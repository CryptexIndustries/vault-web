"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zxing+library@0.21.3";
exports.ids = ["vendor-chunks/@zxing+library@0.21.3"];
exports.modules = {

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// browser\n__exportStar(__webpack_require__(/*! ./browser/BrowserAztecCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserBarcodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserDatamatrixCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserMultiFormatReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserPDF417Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserQRCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/BrowserQRCodeSvgWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/DecodeContinuouslyCallback */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/HTMLCanvasElementLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/HTMLVisualMediaElement */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js\"), exports);\n__exportStar(__webpack_require__(/*! ./browser/VideoInputDevice */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxhQUFhLG1CQUFPLENBQUMsd0tBQWtDO0FBQ3ZELGFBQWEsbUJBQU8sQ0FBQyxvS0FBZ0M7QUFDckQsYUFBYSxtQkFBTyxDQUFDLDhKQUE2QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsa0xBQXVDO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyw0S0FBb0M7QUFDekQsYUFBYSxtQkFBTyxDQUFDLGtLQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsa0tBQStCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyx3S0FBa0M7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLGdMQUFzQztBQUMzRCxhQUFhLG1CQUFPLENBQUMsNExBQTRDO0FBQ2pFLGFBQWEsbUJBQU8sQ0FBQyx3S0FBa0M7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDRKQUE0QiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGJyb3dzZXJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJBenRlY0NvZGVSZWFkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jyb3dzZXIvQnJvd3NlckJhcmNvZGVSZWFkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jyb3dzZXIvQnJvd3NlckNvZGVSZWFkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jyb3dzZXIvQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJNdWx0aUZvcm1hdFJlYWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3Nlci9Ccm93c2VyUERGNDE3UmVhZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJRUkNvZGVSZWFkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jyb3dzZXIvQnJvd3NlclFSQ29kZVN2Z1dyaXRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3Nlci9EZWNvZGVDb250aW51b3VzbHlDYWxsYmFja1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3Nlci9IVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3Nlci9IVE1MVmlzdWFsTWVkaWFFbGVtZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9icm93c2VyL1ZpZGVvSW5wdXREZXZpY2VcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserAztecCodeReader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar AztecReader_1 = __webpack_require__(/*! ../core/aztec/AztecReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js\");\n/**\n * Aztec Code reader to use from browser.\n *\n * @class BrowserAztecCodeReader\n * @extends {BrowserCodeReader}\n */\nvar BrowserAztecCodeReader = /** @class */ (function (_super) {\n    __extends(BrowserAztecCodeReader, _super);\n    /**\n     * Creates an instance of BrowserAztecCodeReader.\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n     *\n     * @memberOf BrowserAztecCodeReader\n     */\n    function BrowserAztecCodeReader(timeBetweenScansMillis) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        return _super.call(this, new AztecReader_1.default(), timeBetweenScansMillis) || this;\n    }\n    return BrowserAztecCodeReader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserAztecCodeReader = BrowserAztecCodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCLDBCQUEwQixtQkFBTyxDQUFDLHNKQUFxQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9icm93c2VyL0Jyb3dzZXJBenRlY0NvZGVSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NlckF6dGVjQ29kZVJlYWRlciA9IHZvaWQgMDtcbnZhciBCcm93c2VyQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vQnJvd3NlckNvZGVSZWFkZXJcIik7XG52YXIgQXp0ZWNSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2F6dGVjL0F6dGVjUmVhZGVyXCIpO1xuLyoqXG4gKiBBenRlYyBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICpcbiAqIEBjbGFzcyBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyXG4gKiBAZXh0ZW5kcyB7QnJvd3NlckNvZGVSZWFkZXJ9XG4gKi9cbnZhciBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcm93c2VyQXp0ZWNDb2RlUmVhZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJBenRlY0NvZGVSZWFkZXIodGltZUJldHdlZW5TY2Fuc01pbGxpcykge1xuICAgICAgICBpZiAodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9PT0gdm9pZCAwKSB7IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDA7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBBenRlY1JlYWRlcl8xLmRlZmF1bHQoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJBenRlY0NvZGVSZWFkZXI7XG59KEJyb3dzZXJDb2RlUmVhZGVyXzEuQnJvd3NlckNvZGVSZWFkZXIpKTtcbmV4cG9ydHMuQnJvd3NlckF6dGVjQ29kZVJlYWRlciA9IEJyb3dzZXJBenRlY0NvZGVSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserBarcodeReader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar MultiFormatOneDReader_1 = __webpack_require__(/*! ../core/oned/MultiFormatOneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js\");\n/**\n * @deprecated Moving to @zxing/browser\n *\n * Barcode reader reader to use from browser.\n */\nvar BrowserBarcodeReader = /** @class */ (function (_super) {\n    __extends(BrowserBarcodeReader, _super);\n    /**\n     * Creates an instance of BrowserBarcodeReader.\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n     * @param {Map<DecodeHintType, any>} hints\n     */\n    function BrowserBarcodeReader(timeBetweenScansMillis, hints) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        return _super.call(this, new MultiFormatOneDReader_1.default(hints), timeBetweenScansMillis, hints) || this;\n    }\n    return BrowserBarcodeReader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserBarcodeReader = BrowserBarcodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyQmFyY29kZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QiwwQkFBMEIsbUJBQU8sQ0FBQyxzSkFBcUI7QUFDdkQsOEJBQThCLG1CQUFPLENBQUMsMktBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2Jyb3dzZXIvQnJvd3NlckJhcmNvZGVSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NlckJhcmNvZGVSZWFkZXIgPSB2b2lkIDA7XG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xudmFyIE11bHRpRm9ybWF0T25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvb25lZC9NdWx0aUZvcm1hdE9uZURSZWFkZXJcIik7XG4vKipcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICpcbiAqIEJhcmNvZGUgcmVhZGVyIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICovXG52YXIgQnJvd3NlckJhcmNvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJCYXJjb2RlUmVhZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckJhcmNvZGVSZWFkZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAqIEBwYXJhbSB7TWFwPERlY29kZUhpbnRUeXBlLCBhbnk+fSBoaW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJCYXJjb2RlUmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMsIGhpbnRzKSB7XG4gICAgICAgIGlmICh0aW1lQmV0d2VlblNjYW5zTWlsbGlzID09PSB2b2lkIDApIHsgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcl8xLmRlZmF1bHQoaGludHMpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzLCBoaW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJCYXJjb2RlUmVhZGVyO1xufShCcm93c2VyQ29kZVJlYWRlcl8xLkJyb3dzZXJDb2RlUmVhZGVyKSk7XG5leHBvcnRzLkJyb3dzZXJCYXJjb2RlUmVhZGVyID0gQnJvd3NlckJhcmNvZGVSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserCodeReader = void 0;\nvar ArgumentException_1 = __webpack_require__(/*! ../core/ArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js\");\nvar BinaryBitmap_1 = __webpack_require__(/*! ../core/BinaryBitmap */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BinaryBitmap.js\");\nvar ChecksumException_1 = __webpack_require__(/*! ../core/ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar HybridBinarizer_1 = __webpack_require__(/*! ../core/common/HybridBinarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js\");\nvar FormatException_1 = __webpack_require__(/*! ../core/FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../core/NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar HTMLCanvasElementLuminanceSource_1 = __webpack_require__(/*! ./HTMLCanvasElementLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js\");\nvar VideoInputDevice_1 = __webpack_require__(/*! ./VideoInputDevice */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js\");\n/**\n * @deprecated Moving to @zxing/browser\n *\n * Base class for browser code reader.\n */\nvar BrowserCodeReader = /** @class */ (function () {\n    /**\n     * Creates an instance of BrowserCodeReader.\n     * @param {Reader} reader The reader instance to decode the barcode\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries\n     *\n     * @memberOf BrowserCodeReader\n     */\n    function BrowserCodeReader(reader, timeBetweenScansMillis, _hints) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        this.reader = reader;\n        this.timeBetweenScansMillis = timeBetweenScansMillis;\n        this._hints = _hints;\n        /**\n         * This will break the loop.\n         */\n        this._stopContinuousDecode = false;\n        /**\n         * This will break the loop.\n         */\n        this._stopAsyncDecode = false;\n        /**\n         * Delay time between decode attempts made by the scanner.\n         */\n        this._timeBetweenDecodingAttempts = 0;\n    }\n    Object.defineProperty(BrowserCodeReader.prototype, \"hasNavigator\", {\n        /**\n         * If navigator is present.\n         */\n        get: function () {\n            return typeof navigator !== 'undefined';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BrowserCodeReader.prototype, \"isMediaDevicesSuported\", {\n        /**\n         * If mediaDevices under navigator is supported.\n         */\n        get: function () {\n            return this.hasNavigator && !!navigator.mediaDevices;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BrowserCodeReader.prototype, \"canEnumerateDevices\", {\n        /**\n         * If enumerateDevices under navigator is supported.\n         */\n        get: function () {\n            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BrowserCodeReader.prototype, \"timeBetweenDecodingAttempts\", {\n        /** Time between two decoding tries in milli seconds. */\n        get: function () {\n            return this._timeBetweenDecodingAttempts;\n        },\n        /**\n         * Change the time span the decoder waits between two decoding tries.\n         *\n         * @param {number} millis Time between two decoding tries in milli seconds.\n         */\n        set: function (millis) {\n            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BrowserCodeReader.prototype, \"hints\", {\n        /**\n         * Sets the hints.\n         */\n        get: function () {\n            return this._hints;\n        },\n        /**\n         * Sets the hints.\n         */\n        set: function (hints) {\n            this._hints = hints || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Lists all the available video input devices.\n     */\n    BrowserCodeReader.prototype.listVideoInputDevices = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;\n            var e_1, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.hasNavigator) {\n                            throw new Error(\"Can't enumerate devices, navigator is not present.\");\n                        }\n                        if (!this.canEnumerateDevices) {\n                            throw new Error(\"Can't enumerate devices, method not supported.\");\n                        }\n                        return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];\n                    case 1:\n                        devices = _b.sent();\n                        videoDevices = [];\n                        try {\n                            for (devices_1 = __values(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {\n                                device = devices_1_1.value;\n                                kind = device.kind === 'video' ? 'videoinput' : device.kind;\n                                if (kind !== 'videoinput') {\n                                    continue;\n                                }\n                                deviceId = device.deviceId || device.id;\n                                label = device.label || \"Video device \" + (videoDevices.length + 1);\n                                groupId = device.groupId;\n                                videoDevice = { deviceId: deviceId, label: label, kind: kind, groupId: groupId };\n                                videoDevices.push(videoDevice);\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return)) _a.call(devices_1);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                        return [2 /*return*/, videoDevices];\n                }\n            });\n        });\n    };\n    /**\n     * Obtain the list of available devices with type 'videoinput'.\n     *\n     * @returns {Promise<VideoInputDevice[]>} an array of available video input devices\n     *\n     * @memberOf BrowserCodeReader\n     *\n     * @deprecated Use `listVideoInputDevices` instead.\n     */\n    BrowserCodeReader.prototype.getVideoInputDevices = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];\n                    case 1:\n                        devices = _a.sent();\n                        return [2 /*return*/, devices.map(function (d) { return new VideoInputDevice_1.VideoInputDevice(d.deviceId, d.label); })];\n                }\n            });\n        });\n    };\n    /**\n     * Let's you find a device using it's Id.\n     */\n    BrowserCodeReader.prototype.findDeviceById = function (deviceId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];\n                    case 1:\n                        devices = _a.sent();\n                        if (!devices) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, devices.find(function (x) { return x.deviceId === deviceId; })];\n                }\n            });\n        });\n    };\n    /**\n     * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.\n     *\n     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     *\n     * @deprecated Use `decodeOnceFromVideoDevice` instead.\n     */\n    BrowserCodeReader.prototype.decodeFromInputVideoDevice = function (deviceId, videoSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.decodeOnceFromVideoDevice(deviceId, videoSource)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.\n     *\n     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeOnceFromVideoDevice = function (deviceId, videoSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var videoConstraints, constraints;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.reset();\n                        if (!deviceId) {\n                            videoConstraints = { facingMode: 'environment' };\n                        }\n                        else {\n                            videoConstraints = { deviceId: { exact: deviceId } };\n                        }\n                        constraints = { video: videoConstraints };\n                        return [4 /*yield*/, this.decodeOnceFromConstraints(constraints, videoSource)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n     *\n     * @param constraints the media stream constraints to get s valid media stream to decode from\n     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeOnceFromConstraints = function (constraints, videoSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stream;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];\n                    case 1:\n                        stream = _a.sent();\n                        return [4 /*yield*/, this.decodeOnceFromStream(stream, videoSource)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n     *\n     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeOnceFromStream = function (stream, videoSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var video, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.reset();\n                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];\n                    case 1:\n                        video = _a.sent();\n                        return [4 /*yield*/, this.decodeOnce(video)];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.\n     *\n     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns {Promise<void>}\n     *\n     * @memberOf BrowserCodeReader\n     *\n     * @deprecated Use `decodeFromVideoDevice` instead.\n     */\n    BrowserCodeReader.prototype.decodeFromInputVideoDeviceContinuously = function (deviceId, videoSource, callbackFn) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.decodeFromVideoDevice(deviceId, videoSource, callbackFn)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.\n     *\n     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns {Promise<void>}\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeFromVideoDevice = function (deviceId, videoSource, callbackFn) {\n        return __awaiter(this, void 0, void 0, function () {\n            var videoConstraints, constraints;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!deviceId) {\n                            videoConstraints = { facingMode: 'environment' };\n                        }\n                        else {\n                            videoConstraints = { deviceId: { exact: deviceId } };\n                        }\n                        constraints = { video: videoConstraints };\n                        return [4 /*yield*/, this.decodeFromConstraints(constraints, videoSource, callbackFn)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n     *\n     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeFromConstraints = function (constraints, videoSource, callbackFn) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stream;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];\n                    case 1:\n                        stream = _a.sent();\n                        return [4 /*yield*/, this.decodeFromStream(stream, videoSource, callbackFn)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n     *\n     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeFromStream = function (stream, videoSource, callbackFn) {\n        return __awaiter(this, void 0, void 0, function () {\n            var video;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.reset();\n                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];\n                    case 1:\n                        video = _a.sent();\n                        return [4 /*yield*/, this.decodeContinuously(video, callbackFn)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Breaks the decoding loop.\n     */\n    BrowserCodeReader.prototype.stopAsyncDecode = function () {\n        this._stopAsyncDecode = true;\n    };\n    /**\n     * Breaks the decoding loop.\n     */\n    BrowserCodeReader.prototype.stopContinuousDecode = function () {\n        this._stopContinuousDecode = true;\n    };\n    /**\n     * Sets the new stream and request a new decoding-with-delay.\n     *\n     * @param stream The stream to be shown in the video element.\n     * @param decodeFn A callback for the decode method.\n     */\n    BrowserCodeReader.prototype.attachStreamToVideo = function (stream, videoSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var videoElement;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        videoElement = this.prepareVideoElement(videoSource);\n                        this.addVideoSource(videoElement, stream);\n                        this.videoElement = videoElement;\n                        this.stream = stream;\n                        return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, videoElement];\n                }\n            });\n        });\n    };\n    /**\n     *\n     * @param videoElement\n     */\n    BrowserCodeReader.prototype.playVideoOnLoadAsync = function (videoElement) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            return _this.playVideoOnLoad(videoElement, function () { return resolve(); });\n        });\n    };\n    /**\n     * Binds listeners and callbacks to the videoElement.\n     *\n     * @param element\n     * @param callbackFn\n     */\n    BrowserCodeReader.prototype.playVideoOnLoad = function (element, callbackFn) {\n        var _this = this;\n        this.videoEndedListener = function () { return _this.stopStreams(); };\n        this.videoCanPlayListener = function () { return _this.tryPlayVideo(element); };\n        element.addEventListener('ended', this.videoEndedListener);\n        element.addEventListener('canplay', this.videoCanPlayListener);\n        element.addEventListener('playing', callbackFn);\n        // if canplay was already fired, we won't know when to play, so just give it a try\n        this.tryPlayVideo(element);\n    };\n    /**\n     * Checks if the given video element is currently playing.\n     */\n    BrowserCodeReader.prototype.isVideoPlaying = function (video) {\n        return (video.currentTime > 0 &&\n            !video.paused &&\n            !video.ended &&\n            video.readyState > 2);\n    };\n    /**\n     * Just tries to play the video and logs any errors.\n     * The play call is only made is the video is not already playing.\n     */\n    BrowserCodeReader.prototype.tryPlayVideo = function (videoElement) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (this.isVideoPlaying(videoElement)) {\n                            console.warn('Trying to play video that is already playing.');\n                            return [2 /*return*/];\n                        }\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, videoElement.play()];\n                    case 2:\n                        _b.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        _a = _b.sent();\n                        console.warn('It was not possible to play the video.');\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Searches and validates a media element.\n     */\n    BrowserCodeReader.prototype.getMediaElement = function (mediaElementId, type) {\n        var mediaElement = document.getElementById(mediaElementId);\n        if (!mediaElement) {\n            throw new ArgumentException_1.default(\"element with id '\" + mediaElementId + \"' not found\");\n        }\n        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {\n            throw new ArgumentException_1.default(\"element with id '\" + mediaElementId + \"' must be an \" + type + \" element\");\n        }\n        return mediaElement;\n    };\n    /**\n     * Decodes the barcode from an image.\n     *\n     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n     * @param {string} [url]\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeFromImage = function (source, url) {\n        if (!source && !url) {\n            throw new ArgumentException_1.default('either imageElement with a src set or an url must be provided');\n        }\n        if (url && !source) {\n            return this.decodeFromImageUrl(url);\n        }\n        return this.decodeFromImageElement(source);\n    };\n    /**\n     * Decodes the barcode from a video.\n     *\n     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n     * @param {string} [url]\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.decodeFromVideo = function (source, url) {\n        if (!source && !url) {\n            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');\n        }\n        if (url && !source) {\n            return this.decodeFromVideoUrl(url);\n        }\n        return this.decodeFromVideoElement(source);\n    };\n    /**\n     * Decodes continuously the barcode from a video.\n     *\n     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n     * @param {string} [url]\n     * @returns {Promise<Result>} The decoding result.\n     *\n     * @memberOf BrowserCodeReader\n     *\n     * @experimental\n     */\n    BrowserCodeReader.prototype.decodeFromVideoContinuously = function (source, url, callbackFn) {\n        if (undefined === source && undefined === url) {\n            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');\n        }\n        if (url && !source) {\n            return this.decodeFromVideoUrlContinuously(url, callbackFn);\n        }\n        return this.decodeFromVideoElementContinuously(source, callbackFn);\n    };\n    /**\n     * Decodes something from an image HTML element.\n     */\n    BrowserCodeReader.prototype.decodeFromImageElement = function (source) {\n        if (!source) {\n            throw new ArgumentException_1.default('An image element must be provided.');\n        }\n        this.reset();\n        var element = this.prepareImageElement(source);\n        this.imageElement = element;\n        var task;\n        if (this.isImageLoaded(element)) {\n            task = this.decodeOnce(element, false, true);\n        }\n        else {\n            task = this._decodeOnLoadImage(element);\n        }\n        return task;\n    };\n    /**\n     * Decodes something from an image HTML element.\n     */\n    BrowserCodeReader.prototype.decodeFromVideoElement = function (source) {\n        var element = this._decodeFromVideoElementSetup(source);\n        return this._decodeOnLoadVideo(element);\n    };\n    /**\n     * Decodes something from an image HTML element.\n     */\n    BrowserCodeReader.prototype.decodeFromVideoElementContinuously = function (source, callbackFn) {\n        var element = this._decodeFromVideoElementSetup(source);\n        return this._decodeOnLoadVideoContinuously(element, callbackFn);\n    };\n    /**\n     * Sets up the video source so it can be decoded when loaded.\n     *\n     * @param source The video source element.\n     */\n    BrowserCodeReader.prototype._decodeFromVideoElementSetup = function (source) {\n        if (!source) {\n            throw new ArgumentException_1.default('A video element must be provided.');\n        }\n        this.reset();\n        var element = this.prepareVideoElement(source);\n        // defines the video element before starts decoding\n        this.videoElement = element;\n        return element;\n    };\n    /**\n     * Decodes an image from a URL.\n     */\n    BrowserCodeReader.prototype.decodeFromImageUrl = function (url) {\n        if (!url) {\n            throw new ArgumentException_1.default('An URL must be provided.');\n        }\n        this.reset();\n        var element = this.prepareImageElement();\n        this.imageElement = element;\n        var decodeTask = this._decodeOnLoadImage(element);\n        element.src = url;\n        return decodeTask;\n    };\n    /**\n     * Decodes an image from a URL.\n     */\n    BrowserCodeReader.prototype.decodeFromVideoUrl = function (url) {\n        if (!url) {\n            throw new ArgumentException_1.default('An URL must be provided.');\n        }\n        this.reset();\n        // creates a new element\n        var element = this.prepareVideoElement();\n        var decodeTask = this.decodeFromVideoElement(element);\n        element.src = url;\n        return decodeTask;\n    };\n    /**\n     * Decodes an image from a URL.\n     *\n     * @experimental\n     */\n    BrowserCodeReader.prototype.decodeFromVideoUrlContinuously = function (url, callbackFn) {\n        if (!url) {\n            throw new ArgumentException_1.default('An URL must be provided.');\n        }\n        this.reset();\n        // creates a new element\n        var element = this.prepareVideoElement();\n        var decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);\n        element.src = url;\n        return decodeTask;\n    };\n    BrowserCodeReader.prototype._decodeOnLoadImage = function (element) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.imageLoadedListener = function () {\n                return _this.decodeOnce(element, false, true).then(resolve, reject);\n            };\n            element.addEventListener('load', _this.imageLoadedListener);\n        });\n    };\n    BrowserCodeReader.prototype._decodeOnLoadVideo = function (videoElement) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: \n                    // plays the video\n                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];\n                    case 1:\n                        // plays the video\n                        _a.sent();\n                        return [4 /*yield*/, this.decodeOnce(videoElement)];\n                    case 2: \n                    // starts decoding after played the video\n                    return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    BrowserCodeReader.prototype._decodeOnLoadVideoContinuously = function (videoElement, callbackFn) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: \n                    // plays the video\n                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];\n                    case 1:\n                        // plays the video\n                        _a.sent();\n                        // starts decoding after played the video\n                        this.decodeContinuously(videoElement, callbackFn);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BrowserCodeReader.prototype.isImageLoaded = function (img) {\n        // During the onload event, IE correctly identifies any images that\n        // weren’t downloaded as not complete. Others should too. Gecko-based\n        // browsers act like NS4 in that they report this incorrectly.\n        if (!img.complete) {\n            return false;\n        }\n        // However, they do have two very useful properties: naturalWidth and\n        // naturalHeight. These give the true size of the image. If it failed\n        // to load, either of these should be zero.\n        if (img.naturalWidth === 0) {\n            return false;\n        }\n        // No other way of checking: assume it’s ok.\n        return true;\n    };\n    BrowserCodeReader.prototype.prepareImageElement = function (imageSource) {\n        var imageElement;\n        if (typeof imageSource === 'undefined') {\n            imageElement = document.createElement('img');\n            imageElement.width = 200;\n            imageElement.height = 200;\n        }\n        if (typeof imageSource === 'string') {\n            imageElement = this.getMediaElement(imageSource, 'img');\n        }\n        if (imageSource instanceof HTMLImageElement) {\n            imageElement = imageSource;\n        }\n        return imageElement;\n    };\n    /**\n     * Sets a HTMLVideoElement for scanning or creates a new one.\n     *\n     * @param videoSource The HTMLVideoElement to be set.\n     */\n    BrowserCodeReader.prototype.prepareVideoElement = function (videoSource) {\n        var videoElement;\n        if (!videoSource && typeof document !== 'undefined') {\n            videoElement = document.createElement('video');\n            videoElement.width = 200;\n            videoElement.height = 200;\n        }\n        if (typeof videoSource === 'string') {\n            videoElement = (this.getMediaElement(videoSource, 'video'));\n        }\n        if (videoSource instanceof HTMLVideoElement) {\n            videoElement = videoSource;\n        }\n        // Needed for iOS 11\n        videoElement.setAttribute('autoplay', 'true');\n        videoElement.setAttribute('muted', 'true');\n        videoElement.setAttribute('playsinline', 'true');\n        return videoElement;\n    };\n    /**\n     * Tries to decode from the video input until it finds some value.\n     */\n    BrowserCodeReader.prototype.decodeOnce = function (element, retryIfNotFound, retryIfChecksumOrFormatError) {\n        var _this = this;\n        if (retryIfNotFound === void 0) { retryIfNotFound = true; }\n        if (retryIfChecksumOrFormatError === void 0) { retryIfChecksumOrFormatError = true; }\n        this._stopAsyncDecode = false;\n        var loop = function (resolve, reject) {\n            if (_this._stopAsyncDecode) {\n                reject(new NotFoundException_1.default('Video stream has ended before any code could be detected.'));\n                _this._stopAsyncDecode = undefined;\n                return;\n            }\n            try {\n                var result = _this.decode(element);\n                resolve(result);\n            }\n            catch (e) {\n                var ifNotFound = retryIfNotFound && e instanceof NotFoundException_1.default;\n                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;\n                var ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;\n                if (ifNotFound || ifChecksumOrFormat) {\n                    // trying again\n                    return setTimeout(loop, _this._timeBetweenDecodingAttempts, resolve, reject);\n                }\n                reject(e);\n            }\n        };\n        return new Promise(function (resolve, reject) { return loop(resolve, reject); });\n    };\n    /**\n     * Continuously decodes from video input.\n     */\n    BrowserCodeReader.prototype.decodeContinuously = function (element, callbackFn) {\n        var _this = this;\n        this._stopContinuousDecode = false;\n        var loop = function () {\n            if (_this._stopContinuousDecode) {\n                _this._stopContinuousDecode = undefined;\n                return;\n            }\n            try {\n                var result = _this.decode(element);\n                callbackFn(result, null);\n                setTimeout(loop, _this.timeBetweenScansMillis);\n            }\n            catch (e) {\n                callbackFn(null, e);\n                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;\n                var isNotFound = e instanceof NotFoundException_1.default;\n                if (isChecksumOrFormatError || isNotFound) {\n                    // trying again\n                    setTimeout(loop, _this._timeBetweenDecodingAttempts);\n                }\n            }\n        };\n        loop();\n    };\n    /**\n     * Gets the BinaryBitmap for ya! (and decodes it)\n     */\n    BrowserCodeReader.prototype.decode = function (element) {\n        // get binary bitmap for decode function\n        var binaryBitmap = this.createBinaryBitmap(element);\n        return this.decodeBitmap(binaryBitmap);\n    };\n    /**\n     * Creates a binaryBitmap based in some image source.\n     *\n     * @param mediaElement HTML element containing drawable image source.\n     */\n    BrowserCodeReader.prototype.createBinaryBitmap = function (mediaElement) {\n        var ctx = this.getCaptureCanvasContext(mediaElement);\n        // doing a scan with inverted colors on the second scan should only happen for video elements\n        var doAutoInvert = false;\n        if (mediaElement instanceof HTMLVideoElement) {\n            this.drawFrameOnCanvas(mediaElement);\n            doAutoInvert = true;\n        }\n        else {\n            this.drawImageOnCanvas(mediaElement);\n        }\n        var canvas = this.getCaptureCanvas(mediaElement);\n        var luminanceSource = new HTMLCanvasElementLuminanceSource_1.HTMLCanvasElementLuminanceSource(canvas, doAutoInvert);\n        var hybridBinarizer = new HybridBinarizer_1.default(luminanceSource);\n        return new BinaryBitmap_1.default(hybridBinarizer);\n    };\n    /**\n     *\n     */\n    BrowserCodeReader.prototype.getCaptureCanvasContext = function (mediaElement) {\n        if (!this.captureCanvasContext) {\n            var elem = this.getCaptureCanvas(mediaElement);\n            var ctx = void 0;\n            try {\n                ctx = elem.getContext('2d', { willReadFrequently: true });\n            }\n            catch (e) {\n                ctx = elem.getContext('2d');\n            }\n            this.captureCanvasContext = ctx;\n        }\n        return this.captureCanvasContext;\n    };\n    /**\n     *\n     */\n    BrowserCodeReader.prototype.getCaptureCanvas = function (mediaElement) {\n        if (!this.captureCanvas) {\n            var elem = this.createCaptureCanvas(mediaElement);\n            this.captureCanvas = elem;\n        }\n        return this.captureCanvas;\n    };\n    /**\n     * Overwriting this allows you to manipulate the next frame in anyway you want before decode.\n     */\n    BrowserCodeReader.prototype.drawFrameOnCanvas = function (srcElement, dimensions, canvasElementContext) {\n        if (dimensions === void 0) { dimensions = {\n            sx: 0,\n            sy: 0,\n            sWidth: srcElement.videoWidth,\n            sHeight: srcElement.videoHeight,\n            dx: 0,\n            dy: 0,\n            dWidth: srcElement.videoWidth,\n            dHeight: srcElement.videoHeight,\n        }; }\n        if (canvasElementContext === void 0) { canvasElementContext = this.captureCanvasContext; }\n        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);\n    };\n    /**\n     * Ovewriting this allows you to manipulate the snapshot image in anyway you want before decode.\n     */\n    BrowserCodeReader.prototype.drawImageOnCanvas = function (srcElement, dimensions, canvasElementContext) {\n        if (dimensions === void 0) { dimensions = {\n            sx: 0,\n            sy: 0,\n            sWidth: srcElement.naturalWidth,\n            sHeight: srcElement.naturalHeight,\n            dx: 0,\n            dy: 0,\n            dWidth: srcElement.naturalWidth,\n            dHeight: srcElement.naturalHeight,\n        }; }\n        if (canvasElementContext === void 0) { canvasElementContext = this.captureCanvasContext; }\n        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);\n    };\n    /**\n     * Call the encapsulated readers decode\n     */\n    BrowserCodeReader.prototype.decodeBitmap = function (binaryBitmap) {\n        return this.reader.decode(binaryBitmap, this._hints);\n    };\n    /**\n     * 🖌 Prepares the canvas for capture and scan frames.\n     */\n    BrowserCodeReader.prototype.createCaptureCanvas = function (mediaElement) {\n        if (typeof document === 'undefined') {\n            this._destroyCaptureCanvas();\n            return null;\n        }\n        var canvasElement = document.createElement('canvas');\n        var width;\n        var height;\n        if (typeof mediaElement !== 'undefined') {\n            if (mediaElement instanceof HTMLVideoElement) {\n                width = mediaElement.videoWidth;\n                height = mediaElement.videoHeight;\n            }\n            else if (mediaElement instanceof HTMLImageElement) {\n                width = mediaElement.naturalWidth || mediaElement.width;\n                height = mediaElement.naturalHeight || mediaElement.height;\n            }\n        }\n        canvasElement.style.width = width + 'px';\n        canvasElement.style.height = height + 'px';\n        canvasElement.width = width;\n        canvasElement.height = height;\n        return canvasElement;\n    };\n    /**\n     * Stops the continuous scan and cleans the stream.\n     */\n    BrowserCodeReader.prototype.stopStreams = function () {\n        if (this.stream) {\n            this.stream.getVideoTracks().forEach(function (t) { return t.stop(); });\n            this.stream = undefined;\n        }\n        if (this._stopAsyncDecode === false) {\n            this.stopAsyncDecode();\n        }\n        if (this._stopContinuousDecode === false) {\n            this.stopContinuousDecode();\n        }\n    };\n    /**\n     * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.\n     *\n     * @memberOf BrowserCodeReader\n     */\n    BrowserCodeReader.prototype.reset = function () {\n        // stops the camera, preview and scan 🔴\n        this.stopStreams();\n        // clean and forget about HTML elements\n        this._destroyVideoElement();\n        this._destroyImageElement();\n        this._destroyCaptureCanvas();\n    };\n    BrowserCodeReader.prototype._destroyVideoElement = function () {\n        if (!this.videoElement) {\n            return;\n        }\n        // first gives freedon to the element 🕊\n        if (typeof this.videoEndedListener !== 'undefined') {\n            this.videoElement.removeEventListener('ended', this.videoEndedListener);\n        }\n        if (typeof this.videoPlayingEventListener !== 'undefined') {\n            this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\n        }\n        if (typeof this.videoCanPlayListener !== 'undefined') {\n            this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);\n        }\n        // then forgets about that element 😢\n        this.cleanVideoSource(this.videoElement);\n        this.videoElement = undefined;\n    };\n    BrowserCodeReader.prototype._destroyImageElement = function () {\n        if (!this.imageElement) {\n            return;\n        }\n        // first gives freedon to the element 🕊\n        if (undefined !== this.imageLoadedListener) {\n            this.imageElement.removeEventListener('load', this.imageLoadedListener);\n        }\n        // then forget about that element 😢\n        this.imageElement.src = undefined;\n        this.imageElement.removeAttribute('src');\n        this.imageElement = undefined;\n    };\n    /**\n     * Cleans canvas references 🖌\n     */\n    BrowserCodeReader.prototype._destroyCaptureCanvas = function () {\n        // then forget about that element 😢\n        this.captureCanvasContext = undefined;\n        this.captureCanvas = undefined;\n    };\n    /**\n     * Defines what the videoElement src will be.\n     *\n     * @param videoElement\n     * @param stream\n     */\n    BrowserCodeReader.prototype.addVideoSource = function (videoElement, stream) {\n        // Older browsers may not have `srcObject`\n        try {\n            // @note Throws Exception if interrupted by a new loaded request\n            videoElement.srcObject = stream;\n        }\n        catch (err) {\n            // @note Avoid using this in new browsers, as it is going away.\n            // @ts-ignore\n            videoElement.src = URL.createObjectURL(stream);\n        }\n    };\n    /**\n     * Unbinds a HTML video src property.\n     *\n     * @param videoElement\n     */\n    BrowserCodeReader.prototype.cleanVideoSource = function (videoElement) {\n        try {\n            videoElement.srcObject = null;\n        }\n        catch (err) {\n            videoElement.src = '';\n        }\n        this.videoElement.removeAttribute('src');\n    };\n    return BrowserCodeReader;\n}());\nexports.BrowserCodeReader = BrowserCodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyQ29kZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLDBCQUEwQixtQkFBTyxDQUFDLHlKQUEyQjtBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQywrSUFBc0I7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMseUpBQTJCO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLG1LQUFnQztBQUNoRSx3QkFBd0IsbUJBQU8sQ0FBQyxxSkFBeUI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMseUpBQTJCO0FBQzdELHlDQUF5QyxtQkFBTyxDQUFDLG9MQUFvQztBQUNyRix5QkFBeUIsbUJBQU8sQ0FBQyxvSkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxtQkFBbUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzRUFBc0U7QUFDL0k7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQ0FBaUM7QUFDM0c7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLHlCQUF5QjtBQUN4QyxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSw4QkFBOEI7QUFDN0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSw4QkFBOEI7QUFDN0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUseUJBQXlCO0FBQ3hDLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSx5QkFBeUI7QUFDeEMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtCQUErQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2Jyb3dzZXIvQnJvd3NlckNvZGVSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyQ29kZVJlYWRlciA9IHZvaWQgMDtcbnZhciBBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgQmluYXJ5Qml0bWFwXzEgPSByZXF1aXJlKFwiLi4vY29yZS9CaW5hcnlCaXRtYXBcIik7XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xudmFyIEh5YnJpZEJpbmFyaXplcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvY29tbW9uL0h5YnJpZEJpbmFyaXplclwiKTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0hUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlXCIpO1xudmFyIFZpZGVvSW5wdXREZXZpY2VfMSA9IHJlcXVpcmUoXCIuL1ZpZGVvSW5wdXREZXZpY2VcIik7XG4vKipcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb3dzZXIgY29kZSByZWFkZXIuXG4gKi9cbnZhciBCcm93c2VyQ29kZVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJDb2RlUmVhZGVyLlxuICAgICAqIEBwYXJhbSB7UmVhZGVyfSByZWFkZXIgVGhlIHJlYWRlciBpbnN0YW5jZSB0byBkZWNvZGUgdGhlIGJhcmNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgc3VjY2Vzc2Z1bCBkZWNvZGUgdHJpZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJDb2RlUmVhZGVyKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcywgX2hpbnRzKSB7XG4gICAgICAgIGlmICh0aW1lQmV0d2VlblNjYW5zTWlsbGlzID09PSB2b2lkIDApIHsgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMDsgfVxuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gdGltZUJldHdlZW5TY2Fuc01pbGxpcztcbiAgICAgICAgdGhpcy5faGludHMgPSBfaGludHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGJyZWFrIHRoZSBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxheSB0aW1lIGJldHdlZW4gZGVjb2RlIGF0dGVtcHRzIG1hZGUgYnkgdGhlIHNjYW5uZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMgPSAwO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLCBcImhhc05hdmlnYXRvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBuYXZpZ2F0b3IgaXMgcHJlc2VudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJpc01lZGlhRGV2aWNlc1N1cG9ydGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG1lZGlhRGV2aWNlcyB1bmRlciBuYXZpZ2F0b3IgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNOYXZpZ2F0b3IgJiYgISFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJjYW5FbnVtZXJhdGVEZXZpY2VzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVudW1lcmF0ZURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuaXNNZWRpYURldmljZXNTdXBvcnRlZCAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJ0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHNcIiwge1xuICAgICAgICAvKiogVGltZSBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcyBpbiBtaWxsaSBzZWNvbmRzLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHRpbWUgc3BhbiB0aGUgZGVjb2RlciB3YWl0cyBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaWxsaXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyA9IG1pbGxpcyA8IDAgPyAwIDogbWlsbGlzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJoaW50c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBoaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoaW50cykge1xuICAgICAgICAgICAgdGhpcy5faGludHMgPSBoaW50cyB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIHRoZSBhdmFpbGFibGUgdmlkZW8gaW5wdXQgZGV2aWNlcy5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUubGlzdFZpZGVvSW5wdXREZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlcywgdmlkZW9EZXZpY2VzLCBkZXZpY2VzXzEsIGRldmljZXNfMV8xLCBkZXZpY2UsIGtpbmQsIGRldmljZUlkLCBsYWJlbCwgZ3JvdXBJZCwgdmlkZW9EZXZpY2U7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNOYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBlbnVtZXJhdGUgZGV2aWNlcywgbmF2aWdhdG9yIGlzIG5vdCBwcmVzZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5FbnVtZXJhdGVEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZW51bWVyYXRlIGRldmljZXMsIG1ldGhvZCBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvRGV2aWNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGRldmljZXNfMSA9IF9fdmFsdWVzKGRldmljZXMpLCBkZXZpY2VzXzFfMSA9IGRldmljZXNfMS5uZXh0KCk7ICFkZXZpY2VzXzFfMS5kb25lOyBkZXZpY2VzXzFfMSA9IGRldmljZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgPSBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvJyA/ICd2aWRlb2lucHV0JyA6IGRldmljZS5raW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZCA9IGRldmljZS5kZXZpY2VJZCB8fCBkZXZpY2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZGV2aWNlLmxhYmVsIHx8IFwiVmlkZW8gZGV2aWNlIFwiICsgKHZpZGVvRGV2aWNlcy5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCA9IGRldmljZS5ncm91cElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0RldmljZSA9IHsgZGV2aWNlSWQ6IGRldmljZUlkLCBsYWJlbDogbGFiZWwsIGtpbmQ6IGtpbmQsIGdyb3VwSWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9EZXZpY2VzLnB1c2godmlkZW9EZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlc18xXzEgJiYgIWRldmljZXNfMV8xLmRvbmUgJiYgKF9hID0gZGV2aWNlc18xLnJldHVybikpIF9hLmNhbGwoZGV2aWNlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZpZGVvRGV2aWNlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT2J0YWluIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBkZXZpY2VzIHdpdGggdHlwZSAndmlkZW9pbnB1dCcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWaWRlb0lucHV0RGV2aWNlW10+fSBhbiBhcnJheSBvZiBhdmFpbGFibGUgdmlkZW8gaW5wdXQgZGV2aWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGxpc3RWaWRlb0lucHV0RGV2aWNlc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZ2V0VmlkZW9JbnB1dERldmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmxpc3RWaWRlb0lucHV0RGV2aWNlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkZXZpY2VzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gbmV3IFZpZGVvSW5wdXREZXZpY2VfMS5WaWRlb0lucHV0RGV2aWNlKGQuZGV2aWNlSWQsIGQubGFiZWwpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGV0J3MgeW91IGZpbmQgYSBkZXZpY2UgdXNpbmcgaXQncyBJZC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZmluZERldmljZUJ5SWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRldmljZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRldmljZXMuZmluZChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQ7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlSWQgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSB2aWRlbyB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlT25jZUZyb21WaWRlb0RldmljZWAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbUlucHV0VmlkZW9EZXZpY2UgPSBmdW5jdGlvbiAoZGV2aWNlSWQsIHZpZGVvU291cmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWQgdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVPbmNlRnJvbVZpZGVvRGV2aWNlID0gZnVuY3Rpb24gKGRldmljZUlkLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50cywgY29uc3RyYWludHM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0geyB2aWRlbzogdmlkZW9Db25zdHJhaW50cyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uc3RyYWludHMgdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZU9uY2VGcm9tQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIHZpZGVvU291cmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZUZyb21TdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW8sIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYXR0YWNoU3RyZWFtVG9WaWRlbyhzdHJlYW0sIHZpZGVvU291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWNvZGVPbmNlKHZpZGVvKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlRnJvbVZpZGVvRGV2aWNlYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZUNvbnRpbnVvdXNseSA9IGZ1bmN0aW9uIChkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb250aW51b3VzbHkgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvRGV2aWNlID0gZnVuY3Rpb24gKGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50cywgY29uc3RyYWludHM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0geyB2aWRlbzogdmlkZW9Db25zdHJhaW50cyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWNvZGVGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IFtjb25zdHJhaW50c10gdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IFtjb25zdHJhaW50c10gdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpZGVvO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZUNvbnRpbnVvdXNseSh2aWRlbywgY2FsbGJhY2tGbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJyZWFrcyB0aGUgZGVjb2RpbmcgbG9vcC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuc3RvcEFzeW5jRGVjb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnJlYWtzIHRoZSBkZWNvZGluZyBsb29wLlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5zdG9wQ29udGludW91c0RlY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbmV3IHN0cmVhbSBhbmQgcmVxdWVzdCBhIG5ldyBkZWNvZGluZy13aXRoLWRlbGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmVhbSBUaGUgc3RyZWFtIHRvIGJlIHNob3duIGluIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBkZWNvZGVGbiBBIGNhbGxiYWNrIGZvciB0aGUgZGVjb2RlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuYXR0YWNoU3RyZWFtVG9WaWRlbyA9IGZ1bmN0aW9uIChzdHJlYW0sIHZpZGVvU291cmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWRlb0VsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQodmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaWRlb1NvdXJjZSh2aWRlb0VsZW1lbnQsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZpZGVvRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLnBsYXlWaWRlb09uTG9hZEFzeW5jID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBsYXlWaWRlb09uTG9hZCh2aWRlb0VsZW1lbnQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmluZHMgbGlzdGVuZXJzIGFuZCBjYWxsYmFja3MgdG8gdGhlIHZpZGVvRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIGNhbGxiYWNrRm5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUucGxheVZpZGVvT25Mb2FkID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdG9wU3RyZWFtcygpOyB9O1xuICAgICAgICB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudHJ5UGxheVZpZGVvKGVsZW1lbnQpOyB9O1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgY2FsbGJhY2tGbik7XG4gICAgICAgIC8vIGlmIGNhbnBsYXkgd2FzIGFscmVhZHkgZmlyZWQsIHdlIHdvbid0IGtub3cgd2hlbiB0byBwbGF5LCBzbyBqdXN0IGdpdmUgaXQgYSB0cnlcbiAgICAgICAgdGhpcy50cnlQbGF5VmlkZW8oZWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmlzVmlkZW9QbGF5aW5nID0gZnVuY3Rpb24gKHZpZGVvKSB7XG4gICAgICAgIHJldHVybiAodmlkZW8uY3VycmVudFRpbWUgPiAwICYmXG4gICAgICAgICAgICAhdmlkZW8ucGF1c2VkICYmXG4gICAgICAgICAgICAhdmlkZW8uZW5kZWQgJiZcbiAgICAgICAgICAgIHZpZGVvLnJlYWR5U3RhdGUgPiAyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEp1c3QgdHJpZXMgdG8gcGxheSB0aGUgdmlkZW8gYW5kIGxvZ3MgYW55IGVycm9ycy5cbiAgICAgKiBUaGUgcGxheSBjYWxsIGlzIG9ubHkgbWFkZSBpcyB0aGUgdmlkZW8gaXMgbm90IGFscmVhZHkgcGxheWluZy5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUudHJ5UGxheVZpZGVvID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWluZyh2aWRlb0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUcnlpbmcgdG8gcGxheSB2aWRlbyB0aGF0IGlzIGFscmVhZHkgcGxheWluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2aWRlb0VsZW1lbnQucGxheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJdCB3YXMgbm90IHBvc3NpYmxlIHRvIHBsYXkgdGhlIHZpZGVvLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGFuZCB2YWxpZGF0ZXMgYSBtZWRpYSBlbGVtZW50LlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5nZXRNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50SWQsIHR5cGUpIHtcbiAgICAgICAgdmFyIG1lZGlhRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1lZGlhRWxlbWVudElkKTtcbiAgICAgICAgaWYgKCFtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoXCJlbGVtZW50IHdpdGggaWQgJ1wiICsgbWVkaWFFbGVtZW50SWQgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KFwiZWxlbWVudCB3aXRoIGlkICdcIiArIG1lZGlhRWxlbWVudElkICsgXCInIG11c3QgYmUgYW4gXCIgKyB0eXBlICsgXCIgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVkaWFFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBbc291cmNlXSBUaGUgaW1hZ2UgZWxlbWVudCB0aGF0IGNhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciB0aGUgZWxlbWVudCBpdHNlbGYuIENhbiBiZSB1bmRlZmluZWQgaW4gd2hpY2ggY2FzZSB0aGUgZGVjb2Rpbmcgd2lsbCBiZSBkb25lIGZyb20gdGhlIGltYWdlVXJsIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21JbWFnZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCkge1xuICAgICAgICBpZiAoIXNvdXJjZSAmJiAhdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdlaXRoZXIgaW1hZ2VFbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VVcmwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gYSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW8gPSBmdW5jdGlvbiAoc291cmNlLCB1cmwpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnRWl0aGVyIGFuIGVsZW1lbnQgd2l0aCBhIHNyYyBzZXQgb3IgYW4gVVJMIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb1VybCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY29kZXMgY29udGludW91c2x5IHRoZSBiYXJjb2RlIGZyb20gYSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW9Db250aW51b3VzbHkgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc291cmNlICYmIHVuZGVmaW5lZCA9PT0gdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdFaXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiBVUkwgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwgJiYgIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShzb3VyY2UsIGNhbGxiYWNrRm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBzb21ldGhpbmcgZnJvbSBhbiBpbWFnZSBIVE1MIGVsZW1lbnQuXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21JbWFnZUVsZW1lbnQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBpbWFnZSBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZUltYWdlRWxlbWVudChzb3VyY2UpO1xuICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHZhciB0YXNrO1xuICAgICAgICBpZiAodGhpcy5pc0ltYWdlTG9hZGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0YXNrID0gdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlT25Mb2FkVmlkZW8oZWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIHNvbWV0aGluZyBmcm9tIGFuIGltYWdlIEhUTUwgZWxlbWVudC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgdmlkZW8gc291cmNlIHNvIGl0IGNhbiBiZSBkZWNvZGVkIHdoZW4gbG9hZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSBUaGUgdmlkZW8gc291cmNlIGVsZW1lbnQuXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBIHZpZGVvIGVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KHNvdXJjZSk7XG4gICAgICAgIC8vIGRlZmluZXMgdGhlIHZpZGVvIGVsZW1lbnQgYmVmb3JlIHN0YXJ0cyBkZWNvZGluZ1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBpbWFnZSBmcm9tIGEgVVJMLlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tSW1hZ2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdmFyIGRlY29kZVRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBpbWFnZSBmcm9tIGEgVVJMLlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW9VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICB2YXIgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBpbWFnZSBmcm9tIGEgVVJMLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW9VcmxDb250aW51b3VzbHkgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICB2YXIgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgIH07XG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVPbkxvYWRJbWFnZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgX3RoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVPbkxvYWRWaWRlbyA9IGZ1bmN0aW9uICh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYXlzIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWNvZGVPbmNlKHZpZGVvRWxlbWVudCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydHMgZGVjb2RpbmcgYWZ0ZXIgcGxheWVkIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5ID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IFxuICAgICAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydHMgZGVjb2RpbmcgYWZ0ZXIgcGxheWVkIHRoZSB2aWRlb1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVDb250aW51b3VzbHkodmlkZW9FbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuaXNJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgLy8gRHVyaW5nIHRoZSBvbmxvYWQgZXZlbnQsIElFIGNvcnJlY3RseSBpZGVudGlmaWVzIGFueSBpbWFnZXMgdGhhdFxuICAgICAgICAvLyB3ZXJlbuKAmXQgZG93bmxvYWRlZCBhcyBub3QgY29tcGxldGUuIE90aGVycyBzaG91bGQgdG9vLiBHZWNrby1iYXNlZFxuICAgICAgICAvLyBicm93c2VycyBhY3QgbGlrZSBOUzQgaW4gdGhhdCB0aGV5IHJlcG9ydCB0aGlzIGluY29ycmVjdGx5LlxuICAgICAgICBpZiAoIWltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZXkgZG8gaGF2ZSB0d28gdmVyeSB1c2VmdWwgcHJvcGVydGllczogbmF0dXJhbFdpZHRoIGFuZFxuICAgICAgICAvLyBuYXR1cmFsSGVpZ2h0LiBUaGVzZSBnaXZlIHRoZSB0cnVlIHNpemUgb2YgdGhlIGltYWdlLiBJZiBpdCBmYWlsZWRcbiAgICAgICAgLy8gdG8gbG9hZCwgZWl0aGVyIG9mIHRoZXNlIHNob3VsZCBiZSB6ZXJvLlxuICAgICAgICBpZiAoaW1nLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG90aGVyIHdheSBvZiBjaGVja2luZzogYXNzdW1lIGl04oCZcyBvay5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUucHJlcGFyZUltYWdlRWxlbWVudCA9IGZ1bmN0aW9uIChpbWFnZVNvdXJjZSkge1xuICAgICAgICB2YXIgaW1hZ2VFbGVtZW50O1xuICAgICAgICBpZiAodHlwZW9mIGltYWdlU291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQud2lkdGggPSAyMDA7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuaGVpZ2h0ID0gMjAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2VTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudChpbWFnZVNvdXJjZSwgJ2ltZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGltYWdlU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZUVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgSFRNTFZpZGVvRWxlbWVudCBmb3Igc2Nhbm5pbmcgb3IgY3JlYXRlcyBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlkZW9Tb3VyY2UgVGhlIEhUTUxWaWRlb0VsZW1lbnQgdG8gYmUgc2V0LlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5wcmVwYXJlVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKHZpZGVvU291cmNlKSB7XG4gICAgICAgIHZhciB2aWRlb0VsZW1lbnQ7XG4gICAgICAgIGlmICghdmlkZW9Tb3VyY2UgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC53aWR0aCA9IDIwMDtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5oZWlnaHQgPSAyMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb1NvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9ICh0aGlzLmdldE1lZGlhRWxlbWVudCh2aWRlb1NvdXJjZSwgJ3ZpZGVvJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb1NvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IHZpZGVvU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZWRlZCBmb3IgaU9TIDExXG4gICAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7XG4gICAgICAgIHJldHVybiB2aWRlb0VsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBkZWNvZGUgZnJvbSB0aGUgdmlkZW8gaW5wdXQgdW50aWwgaXQgZmluZHMgc29tZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZSA9IGZ1bmN0aW9uIChlbGVtZW50LCByZXRyeUlmTm90Rm91bmQsIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJldHJ5SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHJldHJ5SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IgPT09IHZvaWQgMCkgeyByZXRyeUlmQ2hlY2tzdW1PckZvcm1hdEVycm9yID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0b3BBc3luY0RlY29kZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCdWaWRlbyBzdHJlYW0gaGFzIGVuZGVkIGJlZm9yZSBhbnkgY29kZSBjb3VsZCBiZSBkZXRlY3RlZC4nKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0b3BBc3luY0RlY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5kZWNvZGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWZOb3RGb3VuZCA9IHJldHJ5SWZOb3RGb3VuZCAmJiBlIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHZhciBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciA9IGUgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQgfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIGlmQ2hlY2tzdW1PckZvcm1hdCA9IGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yICYmIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGlmTm90Rm91bmQgfHwgaWZDaGVja3N1bU9yRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChsb29wLCBfdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJldHVybiBsb29wKHJlc29sdmUsIHJlamVjdCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IGRlY29kZXMgZnJvbSB2aWRlbyBpbnB1dC5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlQ29udGludW91c2x5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLmRlY29kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZuKHJlc3VsdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wLCBfdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGbihudWxsLCBlKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0IHx8IGUgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHZhciBpc05vdEZvdW5kID0gZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgfHwgaXNOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wLCBfdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEJpbmFyeUJpdG1hcCBmb3IgeWEhIChhbmQgZGVjb2RlcyBpdClcbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZ2V0IGJpbmFyeSBiaXRtYXAgZm9yIGRlY29kZSBmdW5jdGlvblxuICAgICAgICB2YXIgYmluYXJ5Qml0bWFwID0gdGhpcy5jcmVhdGVCaW5hcnlCaXRtYXAoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdG1hcChiaW5hcnlCaXRtYXApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJpbmFyeUJpdG1hcCBiYXNlZCBpbiBzb21lIGltYWdlIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZWRpYUVsZW1lbnQgSFRNTCBlbGVtZW50IGNvbnRhaW5pbmcgZHJhd2FibGUgaW1hZ2Ugc291cmNlLlxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5jcmVhdGVCaW5hcnlCaXRtYXAgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldENhcHR1cmVDYW52YXNDb250ZXh0KG1lZGlhRWxlbWVudCk7XG4gICAgICAgIC8vIGRvaW5nIGEgc2NhbiB3aXRoIGludmVydGVkIGNvbG9ycyBvbiB0aGUgc2Vjb25kIHNjYW4gc2hvdWxkIG9ubHkgaGFwcGVuIGZvciB2aWRlbyBlbGVtZW50c1xuICAgICAgICB2YXIgZG9BdXRvSW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmIChtZWRpYUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdGcmFtZU9uQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICBkb0F1dG9JbnZlcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3SW1hZ2VPbkNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgdmFyIGx1bWluYW5jZVNvdXJjZSA9IG5ldyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZV8xLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcywgZG9BdXRvSW52ZXJ0KTtcbiAgICAgICAgdmFyIGh5YnJpZEJpbmFyaXplciA9IG5ldyBIeWJyaWRCaW5hcml6ZXJfMS5kZWZhdWx0KGx1bWluYW5jZVNvdXJjZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwXzEuZGVmYXVsdChoeWJyaWRCaW5hcml6ZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZ2V0Q2FwdHVyZUNhbnZhc0NvbnRleHQgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBjdHggPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN0eCA9IGVsZW0uZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY3R4ID0gZWxlbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCA9IGN0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmdldENhcHR1cmVDYW52YXMgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5jYXB0dXJlQ2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuY3JlYXRlQ2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gZWxlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYXB0dXJlQ2FudmFzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIG5leHQgZnJhbWUgaW4gYW55d2F5IHlvdSB3YW50IGJlZm9yZSBkZWNvZGUuXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRyYXdGcmFtZU9uQ2FudmFzID0gZnVuY3Rpb24gKHNyY0VsZW1lbnQsIGRpbWVuc2lvbnMsIGNhbnZhc0VsZW1lbnRDb250ZXh0KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb25zID09PSB2b2lkIDApIHsgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHN4OiAwLFxuICAgICAgICAgICAgc3k6IDAsXG4gICAgICAgICAgICBzV2lkdGg6IHNyY0VsZW1lbnQudmlkZW9XaWR0aCxcbiAgICAgICAgICAgIHNIZWlnaHQ6IHNyY0VsZW1lbnQudmlkZW9IZWlnaHQsXG4gICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgZFdpZHRoOiBzcmNFbGVtZW50LnZpZGVvV2lkdGgsXG4gICAgICAgICAgICBkSGVpZ2h0OiBzcmNFbGVtZW50LnZpZGVvSGVpZ2h0LFxuICAgICAgICB9OyB9XG4gICAgICAgIGlmIChjYW52YXNFbGVtZW50Q29udGV4dCA9PT0gdm9pZCAwKSB7IGNhbnZhc0VsZW1lbnRDb250ZXh0ID0gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDsgfVxuICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dC5kcmF3SW1hZ2Uoc3JjRWxlbWVudCwgZGltZW5zaW9ucy5zeCwgZGltZW5zaW9ucy5zeSwgZGltZW5zaW9ucy5zV2lkdGgsIGRpbWVuc2lvbnMuc0hlaWdodCwgZGltZW5zaW9ucy5keCwgZGltZW5zaW9ucy5keSwgZGltZW5zaW9ucy5kV2lkdGgsIGRpbWVuc2lvbnMuZEhlaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmV3cml0aW5nIHRoaXMgYWxsb3dzIHlvdSB0byBtYW5pcHVsYXRlIHRoZSBzbmFwc2hvdCBpbWFnZSBpbiBhbnl3YXkgeW91IHdhbnQgYmVmb3JlIGRlY29kZS5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZHJhd0ltYWdlT25DYW52YXMgPSBmdW5jdGlvbiAoc3JjRWxlbWVudCwgZGltZW5zaW9ucywgY2FudmFzRWxlbWVudENvbnRleHQpIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMgPT09IHZvaWQgMCkgeyBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgc3g6IDAsXG4gICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgIHNXaWR0aDogc3JjRWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICBzSGVpZ2h0OiBzcmNFbGVtZW50Lm5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgZFdpZHRoOiBzcmNFbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgIGRIZWlnaHQ6IHNyY0VsZW1lbnQubmF0dXJhbEhlaWdodCxcbiAgICAgICAgfTsgfVxuICAgICAgICBpZiAoY2FudmFzRWxlbWVudENvbnRleHQgPT09IHZvaWQgMCkgeyBjYW52YXNFbGVtZW50Q29udGV4dCA9IHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQ7IH1cbiAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQuZHJhd0ltYWdlKHNyY0VsZW1lbnQsIGRpbWVuc2lvbnMuc3gsIGRpbWVuc2lvbnMuc3ksIGRpbWVuc2lvbnMuc1dpZHRoLCBkaW1lbnNpb25zLnNIZWlnaHQsIGRpbWVuc2lvbnMuZHgsIGRpbWVuc2lvbnMuZHksIGRpbWVuc2lvbnMuZFdpZHRoLCBkaW1lbnNpb25zLmRIZWlnaHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgZW5jYXBzdWxhdGVkIHJlYWRlcnMgZGVjb2RlXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUJpdG1hcCA9IGZ1bmN0aW9uIChiaW5hcnlCaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZShiaW5hcnlCaXRtYXAsIHRoaXMuX2hpbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIPCflowgUHJlcGFyZXMgdGhlIGNhbnZhcyBmb3IgY2FwdHVyZSBhbmQgc2NhbiBmcmFtZXMuXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmNyZWF0ZUNhcHR1cmVDYW52YXMgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FwdHVyZUNhbnZhcygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICBpZiAodHlwZW9mIG1lZGlhRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChtZWRpYUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQudmlkZW9XaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZWRpYUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IG1lZGlhRWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBtZWRpYUVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgY2FudmFzRWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXNFbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgY29udGludW91cyBzY2FuIGFuZCBjbGVhbnMgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuc3RvcFN0cmVhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnN0b3AoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RvcEFzeW5jRGVjb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wQXN5bmNEZWNvZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BDb250aW51b3VzRGVjb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29kZSByZWFkZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUuIENhbmNlbHMgYW55IG9uZ29pbmcgYmFyY29kZSBzY2FubmluZyBmcm9tIHZpZGVvIG9yIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RvcHMgdGhlIGNhbWVyYSwgcHJldmlldyBhbmQgc2NhbiDwn5S0XG4gICAgICAgIHRoaXMuc3RvcFN0cmVhbXMoKTtcbiAgICAgICAgLy8gY2xlYW4gYW5kIGZvcmdldCBhYm91dCBIVE1MIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveUltYWdlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLl9kZXN0cm95Q2FwdHVyZUNhbnZhcygpO1xuICAgIH07XG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZXN0cm95VmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgZ2l2ZXMgZnJlZWRvbiB0byB0aGUgZWxlbWVudCDwn5WKXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLnZpZGVvUGxheWluZ0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlbiBmb3JnZXRzIGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXG4gICAgICAgIHRoaXMuY2xlYW5WaWRlb1NvdXJjZSh0aGlzLnZpZGVvRWxlbWVudCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZXN0cm95SW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QgZ2l2ZXMgZnJlZWRvbiB0byB0aGUgZWxlbWVudCDwn5WKXG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3JjID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyBjYW52YXMgcmVmZXJlbmNlcyDwn5aMXG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZXN0cm95Q2FwdHVyZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcbiAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IHRoZSB2aWRlb0VsZW1lbnQgc3JjIHdpbGwgYmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICogQHBhcmFtIHN0cmVhbVxuICAgICAqL1xuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5hZGRWaWRlb1NvdXJjZSA9IGZ1bmN0aW9uICh2aWRlb0VsZW1lbnQsIHN0cmVhbSkge1xuICAgICAgICAvLyBPbGRlciBicm93c2VycyBtYXkgbm90IGhhdmUgYHNyY09iamVjdGBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEBub3RlIFRocm93cyBFeGNlcHRpb24gaWYgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZGVkIHJlcXVlc3RcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQG5vdGUgQXZvaWQgdXNpbmcgdGhpcyBpbiBuZXcgYnJvd3NlcnMsIGFzIGl0IGlzIGdvaW5nIGF3YXkuXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIGEgSFRNTCB2aWRlbyBzcmMgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICovXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmNsZWFuVmlkZW9Tb3VyY2UgPSBmdW5jdGlvbiAodmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyQ29kZVJlYWRlcjtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJDb2RlUmVhZGVyID0gQnJvd3NlckNvZGVSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserDatamatrixCodeReader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar DataMatrixReader_1 = __webpack_require__(/*! ../core/datamatrix/DataMatrixReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js\");\n/**\n * @deprecated Moving to @zxing/browser\n *\n * QR Code reader to use from browser.\n */\nvar BrowserDatamatrixCodeReader = /** @class */ (function (_super) {\n    __extends(BrowserDatamatrixCodeReader, _super);\n    /**\n     * Creates an instance of BrowserQRCodeReader.\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n     */\n    function BrowserDatamatrixCodeReader(timeBetweenScansMillis) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        return _super.call(this, new DataMatrixReader_1.default(), timeBetweenScansMillis) || this;\n    }\n    return BrowserDatamatrixCodeReader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsc0pBQXFCO0FBQ3ZELHlCQUF5QixtQkFBTyxDQUFDLDZLQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9icm93c2VyL0Jyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIgPSB2b2lkIDA7XG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xudmFyIERhdGFNYXRyaXhSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2RhdGFtYXRyaXgvRGF0YU1hdHJpeFJlYWRlclwiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKlxuICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAqL1xudmFyIEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlclFSQ29kZVJlYWRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgRGF0YU1hdHJpeFJlYWRlcl8xLmRlZmF1bHQoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlcjtcbn0oQnJvd3NlckNvZGVSZWFkZXJfMS5Ccm93c2VyQ29kZVJlYWRlcikpO1xuZXhwb3J0cy5Ccm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIgPSBCcm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserMultiFormatReader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar MultiFormatReader_1 = __webpack_require__(/*! ../core/MultiFormatReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatReader.js\");\nvar BrowserMultiFormatReader = /** @class */ (function (_super) {\n    __extends(BrowserMultiFormatReader, _super);\n    function BrowserMultiFormatReader(hints, timeBetweenScansMillis) {\n        if (hints === void 0) { hints = null; }\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        var _this = this;\n        var reader = new MultiFormatReader_1.default();\n        reader.setHints(hints);\n        _this = _super.call(this, reader, timeBetweenScansMillis) || this;\n        return _this;\n    }\n    /**\n     * Overwrite decodeBitmap to call decodeWithState, which will pay\n     * attention to the hints set in the constructor function\n     */\n    BrowserMultiFormatReader.prototype.decodeBitmap = function (binaryBitmap) {\n        return this.reader.decodeWithState(binaryBitmap);\n    };\n    return BrowserMultiFormatReader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserMultiFormatReader = BrowserMultiFormatReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyTXVsdGlGb3JtYXRSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsMEJBQTBCLG1CQUFPLENBQUMsc0pBQXFCO0FBQ3ZELDBCQUEwQixtQkFBTyxDQUFDLHlKQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9icm93c2VyL0Jyb3dzZXJNdWx0aUZvcm1hdFJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyTXVsdGlGb3JtYXRSZWFkZXIgPSB2b2lkIDA7XG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xudmFyIE11bHRpRm9ybWF0UmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9NdWx0aUZvcm1hdFJlYWRlclwiKTtcbnZhciBCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXIoaGludHMsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcbiAgICAgICAgaWYgKGhpbnRzID09PSB2b2lkIDApIHsgaGludHMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aW1lQmV0d2VlblNjYW5zTWlsbGlzID09PSB2b2lkIDApIHsgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IE11bHRpRm9ybWF0UmVhZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICByZWFkZXIuc2V0SGludHMoaGludHMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgZGVjb2RlQml0bWFwIHRvIGNhbGwgZGVjb2RlV2l0aFN0YXRlLCB3aGljaCB3aWxsIHBheVxuICAgICAqIGF0dGVudGlvbiB0byB0aGUgaGludHMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAqL1xuICAgIEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlci5wcm90b3R5cGUuZGVjb2RlQml0bWFwID0gZnVuY3Rpb24gKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuZGVjb2RlV2l0aFN0YXRlKGJpbmFyeUJpdG1hcCk7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyO1xufShCcm93c2VyQ29kZVJlYWRlcl8xLkJyb3dzZXJDb2RlUmVhZGVyKSk7XG5leHBvcnRzLkJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlciA9IEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserPDF417Reader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar PDF417Reader_1 = __webpack_require__(/*! ../core/pdf417/PDF417Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js\");\n/**\n * @deprecated Moving to @zxing/browser\n *\n * QR Code reader to use from browser.\n */\nvar BrowserPDF417Reader = /** @class */ (function (_super) {\n    __extends(BrowserPDF417Reader, _super);\n    /**\n     * Creates an instance of BrowserPDF417Reader.\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n     */\n    function BrowserPDF417Reader(timeBetweenScansMillis) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        return _super.call(this, new PDF417Reader_1.default(), timeBetweenScansMillis) || this;\n    }\n    return BrowserPDF417Reader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserPDF417Reader = BrowserPDF417Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUERGNDE3UmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLHNKQUFxQjtBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyw2SkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUERGNDE3UmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJQREY0MTdSZWFkZXIgPSB2b2lkIDA7XG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xudmFyIFBERjQxN1JlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcGRmNDE3L1BERjQxN1JlYWRlclwiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKlxuICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAqL1xudmFyIEJyb3dzZXJQREY0MTdSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJQREY0MTdSZWFkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUERGNDE3UmVhZGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCcm93c2VyUERGNDE3UmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUERGNDE3UmVhZGVyXzEuZGVmYXVsdCgpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlclBERjQxN1JlYWRlcjtcbn0oQnJvd3NlckNvZGVSZWFkZXJfMS5Ccm93c2VyQ29kZVJlYWRlcikpO1xuZXhwb3J0cy5Ccm93c2VyUERGNDE3UmVhZGVyID0gQnJvd3NlclBERjQxN1JlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserQRCodeReader = void 0;\nvar BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js\");\nvar QRCodeReader_1 = __webpack_require__(/*! ../core/qrcode/QRCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js\");\n/**\n * @deprecated Moving to @zxing/browser\n *\n * QR Code reader to use from browser.\n */\nvar BrowserQRCodeReader = /** @class */ (function (_super) {\n    __extends(BrowserQRCodeReader, _super);\n    /**\n     * Creates an instance of BrowserQRCodeReader.\n     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n     */\n    function BrowserQRCodeReader(timeBetweenScansMillis) {\n        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }\n        return _super.call(this, new QRCodeReader_1.default(), timeBetweenScansMillis) || this;\n    }\n    return BrowserQRCodeReader;\n}(BrowserCodeReader_1.BrowserCodeReader));\nexports.BrowserQRCodeReader = BrowserQRCodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUVJDb2RlUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLHNKQUFxQjtBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyw2SkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUVJDb2RlUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJRUkNvZGVSZWFkZXIgPSB2b2lkIDA7XG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xudmFyIFFSQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcXJjb2RlL1FSQ29kZVJlYWRlclwiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKlxuICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAqL1xudmFyIEJyb3dzZXJRUkNvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJRUkNvZGVSZWFkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUVJDb2RlUmVhZGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCcm93c2VyUVJDb2RlUmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUVJDb2RlUmVhZGVyXzEuZGVmYXVsdCgpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlclFSQ29kZVJlYWRlcjtcbn0oQnJvd3NlckNvZGVSZWFkZXJfMS5Ccm93c2VyQ29kZVJlYWRlcikpO1xuZXhwb3J0cy5Ccm93c2VyUVJDb2RlUmVhZGVyID0gQnJvd3NlclFSQ29kZVJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserQRCodeSvgWriter = void 0;\nvar EncodeHintType_1 = __webpack_require__(/*! ../core/EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\nvar Encoder_1 = __webpack_require__(/*! ../core/qrcode/encoder/Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js\");\nvar ErrorCorrectionLevel_1 = __webpack_require__(/*! ../core/qrcode/decoder/ErrorCorrectionLevel */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../core/IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../core/IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\n/**\n * @deprecated Moving to @zxing/browser\n */\nvar BrowserQRCodeSvgWriter = /** @class */ (function () {\n    function BrowserQRCodeSvgWriter() {\n    }\n    /**\n     * Writes and renders a QRCode SVG element.\n     *\n     * @param contents\n     * @param width\n     * @param height\n     * @param hints\n     */\n    BrowserQRCodeSvgWriter.prototype.write = function (contents, width, height, hints) {\n        if (hints === void 0) { hints = null; }\n        if (contents.length === 0) {\n            throw new IllegalArgumentException_1.default('Found empty contents');\n        }\n        // if (format != BarcodeFormat.QR_CODE) {\n        //   throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format)\n        // }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException_1.default('Requested dimensions are too small: ' + width + 'x' + height);\n        }\n        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;\n        var quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;\n        if (hints !== null) {\n            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {\n                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());\n            }\n            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {\n                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);\n            }\n        }\n        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);\n        return this.renderResult(code, width, height, quietZone);\n    };\n    /**\n     * Renders the result and then appends it to the DOM.\n     */\n    BrowserQRCodeSvgWriter.prototype.writeToDom = function (containerElement, contents, width, height, hints) {\n        if (hints === void 0) { hints = null; }\n        if (typeof containerElement === 'string') {\n            containerElement = document.querySelector(containerElement);\n        }\n        var svgElement = this.write(contents, width, height, hints);\n        if (containerElement)\n            containerElement.appendChild(svgElement);\n    };\n    /**\n     * Note that the input matrix uses 0 == white, 1 == black.\n     * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n     */\n    BrowserQRCodeSvgWriter.prototype.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n        var input = code.getMatrix();\n        if (input === null) {\n            throw new IllegalStateException_1.default();\n        }\n        var inputWidth = input.getWidth();\n        var inputHeight = input.getHeight();\n        var qrWidth = inputWidth + (quietZone * 2);\n        var qrHeight = inputHeight + (quietZone * 2);\n        var outputWidth = Math.max(width, qrWidth);\n        var outputHeight = Math.max(height, qrHeight);\n        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n        // handle all the padding from 100x100 (the actual QR) up to 200x160.\n        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n        var svgElement = this.createSVGElement(outputWidth, outputHeight);\n        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the barcode\n            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                if (input.get(inputX, inputY) === 1) {\n                    var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);\n                    svgElement.appendChild(svgRectElement);\n                }\n            }\n        }\n        return svgElement;\n    };\n    /**\n     * Creates a SVG element.\n     *\n     * @param w SVG's width attribute\n     * @param h SVG's height attribute\n     */\n    BrowserQRCodeSvgWriter.prototype.createSVGElement = function (w, h) {\n        var svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');\n        svgElement.setAttributeNS(null, 'height', w.toString());\n        svgElement.setAttributeNS(null, 'width', h.toString());\n        return svgElement;\n    };\n    /**\n     * Creates a SVG rect element.\n     *\n     * @param x Element's x coordinate\n     * @param y Element's y coordinate\n     * @param w Element's width attribute\n     * @param h Element's height attribute\n     */\n    BrowserQRCodeSvgWriter.prototype.createSvgRectElement = function (x, y, w, h) {\n        var rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');\n        rect.setAttributeNS(null, 'x', x.toString());\n        rect.setAttributeNS(null, 'y', y.toString());\n        rect.setAttributeNS(null, 'height', w.toString());\n        rect.setAttributeNS(null, 'width', h.toString());\n        rect.setAttributeNS(null, 'fill', '#000000');\n        return rect;\n    };\n    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;\n    /**\n     * SVG markup NameSpace\n     */\n    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';\n    return BrowserQRCodeSvgWriter;\n}());\nexports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5Qix1QkFBdUIsbUJBQU8sQ0FBQyxtSkFBd0I7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsbUtBQWdDO0FBQ3hELDZCQUE2QixtQkFBTyxDQUFDLDZMQUE2QztBQUNsRixpQ0FBaUMsbUJBQU8sQ0FBQyx1S0FBa0M7QUFDM0UsOEJBQThCLG1CQUFPLENBQUMsaUtBQStCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gdm9pZCAwO1xudmFyIEVuY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vY29yZS9FbmNvZGVIaW50VHlwZVwiKTtcbnZhciBFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9xcmNvZGUvZW5jb2Rlci9FbmNvZGVyXCIpO1xudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi4vY29yZS9xcmNvZGUvZGVjb2Rlci9FcnJvckNvcnJlY3Rpb25MZXZlbFwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKi9cbnZhciBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbmQgcmVuZGVycyBhIFFSQ29kZSBTVkcgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZW50c1xuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHRcbiAgICAgKiBAcGFyYW0gaGludHNcbiAgICAgKi9cbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMpIHtcbiAgICAgICAgaWYgKGhpbnRzID09PSB2b2lkIDApIHsgaGludHMgPSBudWxsOyB9XG4gICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIChmb3JtYXQgIT0gQmFyY29kZUZvcm1hdC5RUl9DT0RFKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkNhbiBvbmx5IGVuY29kZSBRUl9DT0RFLCBidXQgZ290IFwiICsgZm9ybWF0KVxuICAgICAgICAvLyB9XG4gICAgICAgIGlmICh3aWR0aCA8IDAgfHwgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1JlcXVlc3RlZCBkaW1lbnNpb25zIGFyZSB0b28gc21hbGw6ICcgKyB3aWR0aCArICd4JyArIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0Lkw7XG4gICAgICAgIHZhciBxdWlldFpvbmUgPSBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlFVSUVUX1pPTkVfU0laRTtcbiAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT04pKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbF8xLmRlZmF1bHQuZnJvbVN0cmluZyhoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT04pLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5NQVJHSU4pKSB7XG4gICAgICAgICAgICAgICAgcXVpZXRab25lID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuTUFSR0lOKS50b1N0cmluZygpLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGUgPSBFbmNvZGVyXzEuZGVmYXVsdC5lbmNvZGUoY29udGVudHMsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBoaW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWlldFpvbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgcmVzdWx0IGFuZCB0aGVuIGFwcGVuZHMgaXQgdG8gdGhlIERPTS5cbiAgICAgKi9cbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLnByb3RvdHlwZS53cml0ZVRvRG9tID0gZnVuY3Rpb24gKGNvbnRhaW5lckVsZW1lbnQsIGNvbnRlbnRzLCB3aWR0aCwgaGVpZ2h0LCBoaW50cykge1xuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSB0aGlzLndyaXRlKGNvbnRlbnRzLCB3aWR0aCwgaGVpZ2h0LCBoaW50cyk7XG4gICAgICAgIGlmIChjb250YWluZXJFbGVtZW50KVxuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgaW5wdXQgbWF0cml4IHVzZXMgMCA9PSB3aGl0ZSwgMSA9PSBibGFjay5cbiAgICAgKiBUaGUgb3V0cHV0IG1hdHJpeCB1c2VzIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICAgKi9cbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJSZXN1bHQgPSBmdW5jdGlvbiAoY29kZSwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHF1aWV0Wm9uZSAvKmludCovKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRXaWR0aCA9IGlucHV0LmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgcXJXaWR0aCA9IGlucHV0V2lkdGggKyAocXVpZXRab25lICogMik7XG4gICAgICAgIHZhciBxckhlaWdodCA9IGlucHV0SGVpZ2h0ICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICB2YXIgb3V0cHV0V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgcXJXaWR0aCk7XG4gICAgICAgIHZhciBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHFySGVpZ2h0KTtcbiAgICAgICAgdmFyIG11bHRpcGxlID0gTWF0aC5taW4oTWF0aC5mbG9vcihvdXRwdXRXaWR0aCAvIHFyV2lkdGgpLCBNYXRoLmZsb29yKG91dHB1dEhlaWdodCAvIHFySGVpZ2h0KSk7XG4gICAgICAgIC8vIFBhZGRpbmcgaW5jbHVkZXMgYm90aCB0aGUgcXVpZXQgem9uZSBhbmQgdGhlIGV4dHJhIHdoaXRlIHBpeGVscyB0byBhY2NvbW1vZGF0ZSB0aGUgcmVxdWVzdGVkXG4gICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgc2l6ZSBpcyAyMDB4MTYwLCB0aGUgbXVsdGlwbGUgd2lsbCBiZSA0LCBmb3IgYSBRUiBvZiAxMzJ4MTMyLiBUaGVzZSB3aWxsXG4gICAgICAgIC8vIGhhbmRsZSBhbGwgdGhlIHBhZGRpbmcgZnJvbSAxMDB4MTAwICh0aGUgYWN0dWFsIFFSKSB1cCB0byAyMDB4MTYwLlxuICAgICAgICB2YXIgbGVmdFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRXaWR0aCAtIChpbnB1dFdpZHRoICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICB2YXIgdG9wUGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dEhlaWdodCAtIChpbnB1dEhlaWdodCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVNWR0VsZW1lbnQob3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIGlucHV0WSA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRYID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXQoaW5wdXRYLCBpbnB1dFkpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdSZWN0RWxlbWVudCA9IHRoaXMuY3JlYXRlU3ZnUmVjdEVsZW1lbnQob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChzdmdSZWN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFNWRyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHcgU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXG4gICAgICogQHBhcmFtIGggU1ZHJ3MgaGVpZ2h0IGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIucHJvdG90eXBlLmNyZWF0ZVNWR0VsZW1lbnQgPSBmdW5jdGlvbiAodywgaCkge1xuICAgICAgICB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUywgJ3N2ZycpO1xuICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCB3LnRvU3RyaW5nKCkpO1xuICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGgudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFNWRyByZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBFbGVtZW50J3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHkgRWxlbWVudCdzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB3IEVsZW1lbnQncyB3aWR0aCBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gaCBFbGVtZW50J3MgaGVpZ2h0IGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIucHJvdG90eXBlLmNyZWF0ZVN2Z1JlY3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdyZWN0Jyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeS50b1N0cmluZygpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCBoLnRvU3RyaW5nKCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMwMDAwMDAnKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlFVSUVUX1pPTkVfU0laRSA9IDQ7XG4gICAgLyoqXG4gICAgICogU1ZHIG1hcmt1cCBOYW1lU3BhY2VcbiAgICAgKi9cbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgcmV0dXJuIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXI7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9EZWNvZGVDb250aW51b3VzbHlDYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9EZWNvZGVDb250aW51b3VzbHlDYWxsYmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js ***!
  \*******************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HTMLCanvasElementLuminanceSource = void 0;\nvar InvertedLuminanceSource_1 = __webpack_require__(/*! ../core/InvertedLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\");\nvar LuminanceSource_1 = __webpack_require__(/*! ../core/LuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../core/IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * @deprecated Moving to @zxing/browser\n */\nvar HTMLCanvasElementLuminanceSource = /** @class */ (function (_super) {\n    __extends(HTMLCanvasElementLuminanceSource, _super);\n    function HTMLCanvasElementLuminanceSource(canvas, doAutoInvert) {\n        if (doAutoInvert === void 0) { doAutoInvert = false; }\n        var _this = _super.call(this, canvas.width, canvas.height) || this;\n        _this.canvas = canvas;\n        _this.tempCanvasElement = null;\n        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas, doAutoInvert);\n        return _this;\n    }\n    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas, doAutoInvert) {\n        if (doAutoInvert === void 0) { doAutoInvert = false; }\n        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height, doAutoInvert);\n    };\n    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height, doAutoInvert) {\n        if (doAutoInvert === void 0) { doAutoInvert = false; }\n        var grayscaleBuffer = new Uint8ClampedArray(width * height);\n        HTMLCanvasElementLuminanceSource.FRAME_INDEX = !HTMLCanvasElementLuminanceSource.FRAME_INDEX;\n        if (HTMLCanvasElementLuminanceSource.FRAME_INDEX || !doAutoInvert) {\n            for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {\n                var gray = void 0;\n                var alpha = imageBuffer[i + 3];\n                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n                // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n                // barcode image. Force any such pixel to be white:\n                if (alpha === 0) {\n                    gray = 0xFF;\n                }\n                else {\n                    var pixelR = imageBuffer[i];\n                    var pixelG = imageBuffer[i + 1];\n                    var pixelB = imageBuffer[i + 2];\n                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                    // 0x200 >> 10 is 0.5, it implements rounding.\n                    gray = (306 * pixelR +\n                        601 * pixelG +\n                        117 * pixelB +\n                        0x200) >> 10;\n                }\n                grayscaleBuffer[j] = gray;\n            }\n        }\n        else {\n            for (var i = 0, j = 0, length_2 = imageBuffer.length; i < length_2; i += 4, j++) {\n                var gray = void 0;\n                var alpha = imageBuffer[i + 3];\n                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n                // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n                // barcode image. Force any such pixel to be white:\n                if (alpha === 0) {\n                    gray = 0xFF;\n                }\n                else {\n                    var pixelR = imageBuffer[i];\n                    var pixelG = imageBuffer[i + 1];\n                    var pixelB = imageBuffer[i + 2];\n                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                    // 0x200 >> 10 is 0.5, it implements rounding.\n                    gray = (306 * pixelR +\n                        601 * pixelG +\n                        117 * pixelB +\n                        0x200) >> 10;\n                }\n                grayscaleBuffer[j] = 0xFF - gray;\n            }\n        }\n        return grayscaleBuffer;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n        if (y < 0 || y >= this.getHeight()) {\n            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);\n        }\n        var width = this.getWidth();\n        var start = y * width;\n        if (row === null) {\n            row = this.buffer.slice(start, start + width);\n        }\n        else {\n            if (row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            // The underlying raster of image consists of bytes with the luminance values\n            // TODO: can avoid set/slice?\n            row.set(this.buffer.slice(start, start + width));\n        }\n        return row;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {\n        return this.buffer;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {\n        return true;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        _super.prototype.crop.call(this, left, top, width, height);\n        return this;\n    };\n    /**\n     * This is always true, since the image is a gray-scale image.\n     *\n     * @return true\n     */\n    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {\n        return true;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {\n        this.rotate(-90);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {\n        this.rotate(-45);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {\n        if (null === this.tempCanvasElement) {\n            var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n            tempCanvasElement.width = this.canvas.width;\n            tempCanvasElement.height = this.canvas.height;\n            this.tempCanvasElement = tempCanvasElement;\n        }\n        return this.tempCanvasElement;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {\n        var tempCanvasElement = this.getTempCanvasElement();\n        var tempContext = tempCanvasElement.getContext('2d');\n        var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n        // Calculate and set new dimensions for temp canvas\n        var width = this.canvas.width;\n        var height = this.canvas.height;\n        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n        tempCanvasElement.width = newWidth;\n        tempCanvasElement.height = newHeight;\n        // Draw at center of temp canvas to prevent clipping of image data\n        tempContext.translate(newWidth / 2, newHeight / 2);\n        tempContext.rotate(angleRadians);\n        tempContext.drawImage(this.canvas, width / -2, height / -2);\n        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.invert = function () {\n        return new InvertedLuminanceSource_1.default(this);\n    };\n    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n    HTMLCanvasElementLuminanceSource.FRAME_INDEX = true;\n    return HTMLCanvasElementLuminanceSource;\n}(LuminanceSource_1.default));\nexports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9IVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QztBQUN4QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxxS0FBaUM7QUFDekUsd0JBQXdCLG1CQUFPLENBQUMscUpBQXlCO0FBQ3pELGlDQUFpQyxtQkFBTyxDQUFDLHVLQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0NBQXdDIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9icm93c2VyL0hUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlID0gdm9pZCAwO1xudmFyIEludmVydGVkTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi4vY29yZS9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZVwiKTtcbnZhciBMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0x1bWluYW5jZVNvdXJjZVwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKi9cbnZhciBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UoY2FudmFzLCBkb0F1dG9JbnZlcnQpIHtcbiAgICAgICAgaWYgKGRvQXV0b0ludmVydCA9PT0gdm9pZCAwKSB7IGRvQXV0b0ludmVydCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICBfdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcywgZG9BdXRvSW52ZXJ0KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YSA9IGZ1bmN0aW9uIChjYW52YXMsIGRvQXV0b0ludmVydCkge1xuICAgICAgICBpZiAoZG9BdXRvSW52ZXJ0ID09PSB2b2lkIDApIHsgZG9BdXRvSW52ZXJ0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UudG9HcmF5c2NhbGVCdWZmZXIoaW1hZ2VEYXRhLmRhdGEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgZG9BdXRvSW52ZXJ0KTtcbiAgICB9O1xuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLnRvR3JheXNjYWxlQnVmZmVyID0gZnVuY3Rpb24gKGltYWdlQnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBkb0F1dG9JbnZlcnQpIHtcbiAgICAgICAgaWYgKGRvQXV0b0ludmVydCA9PT0gdm9pZCAwKSB7IGRvQXV0b0ludmVydCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBncmF5c2NhbGVCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5GUkFNRV9JTkRFWCA9ICFIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5GUkFNRV9JTkRFWDtcbiAgICAgICAgaWYgKEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkZSQU1FX0lOREVYIHx8ICFkb0F1dG9JbnZlcnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgbGVuZ3RoXzEgPSBpbWFnZUJ1ZmZlci5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSArPSA0LCBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JheSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBpbWFnZUJ1ZmZlcltpICsgM107XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gYmxhY2sgKDAgYWxwaGEsIGFuZCB0aGVuIDAgUkdCKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCwgb2YgY291cnNlIGFzIHRoZSBcIndoaXRlXCIgYXJlYSBpbiBhXG4gICAgICAgICAgICAgICAgLy8gYmFyY29kZSBpbWFnZS4gRm9yY2UgYW55IHN1Y2ggcGl4ZWwgdG8gYmUgd2hpdGU6XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXkgPSAweEZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsUiA9IGltYWdlQnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxHID0gaW1hZ2VCdWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxCID0gaW1hZ2VCdWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyAuMjk5UiArIDAuNTg3RyArIDAuMTE0QiAoWVVWL1lJUSBmb3IgUEFMIGFuZCBOVFNDKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gKDMwNipSKSA+PiAxMCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIFIqMC4yOTksIGFuZCBzbyBvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgICAgICBncmF5ID0gKDMwNiAqIHBpeGVsUiArXG4gICAgICAgICAgICAgICAgICAgICAgICA2MDEgKiBwaXhlbEcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMTE3ICogcGl4ZWxCICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MjAwKSA+PiAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JheXNjYWxlQnVmZmVyW2pdID0gZ3JheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgbGVuZ3RoXzIgPSBpbWFnZUJ1ZmZlci5sZW5ndGg7IGkgPCBsZW5ndGhfMjsgaSArPSA0LCBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JheSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBpbWFnZUJ1ZmZlcltpICsgM107XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gYmxhY2sgKDAgYWxwaGEsIGFuZCB0aGVuIDAgUkdCKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCwgb2YgY291cnNlIGFzIHRoZSBcIndoaXRlXCIgYXJlYSBpbiBhXG4gICAgICAgICAgICAgICAgLy8gYmFyY29kZSBpbWFnZS4gRm9yY2UgYW55IHN1Y2ggcGl4ZWwgdG8gYmUgd2hpdGU6XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXkgPSAweEZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsUiA9IGltYWdlQnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxHID0gaW1hZ2VCdWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxCID0gaW1hZ2VCdWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyAuMjk5UiArIDAuNTg3RyArIDAuMTE0QiAoWVVWL1lJUSBmb3IgUEFMIGFuZCBOVFNDKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gKDMwNipSKSA+PiAxMCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIFIqMC4yOTksIGFuZCBzbyBvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgICAgICBncmF5ID0gKDMwNiAqIHBpeGVsUiArXG4gICAgICAgICAgICAgICAgICAgICAgICA2MDEgKiBwaXhlbEcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMTE3ICogcGl4ZWxCICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MjAwKSA+PiAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JheXNjYWxlQnVmZmVyW2pdID0gMHhGRiAtIGdyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXlzY2FsZUJ1ZmZlcjtcbiAgICB9O1xuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1JlcXVlc3RlZCByb3cgaXMgb3V0c2lkZSB0aGUgaW1hZ2U6ICcgKyB5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBzdGFydCA9IHkgKiB3aWR0aDtcbiAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm93ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgdW5kZXJseWluZyByYXN0ZXIgb2YgaW1hZ2UgY29uc2lzdHMgb2YgYnl0ZXMgd2l0aCB0aGUgbHVtaW5hbmNlIHZhbHVlc1xuICAgICAgICAgICAgLy8gVE9ETzogY2FuIGF2b2lkIHNldC9zbGljZT9cbiAgICAgICAgICAgIHJvdy5zZXQodGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgd2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH07XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH07XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuY3JvcCA9IGZ1bmN0aW9uIChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNyb3AuY2FsbCh0aGlzLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYWx3YXlzIHRydWUsIHNpbmNlIHRoZSBpbWFnZSBpcyBhIGdyYXktc2NhbGUgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRydWVcbiAgICAgKi9cbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm90YXRlKC05MCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUoLTQ1KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGVtcENhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChudWxsID09PSB0aGlzLnRlbXBDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdGVtcENhbnZhc0VsZW1lbnQgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMudGVtcENhbnZhc0VsZW1lbnQgPSB0ZW1wQ2FudmFzRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wQ2FudmFzRWxlbWVudDtcbiAgICB9O1xuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgdmFyIHRlbXBDYW52YXNFbGVtZW50ID0gdGhpcy5nZXRUZW1wQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICB2YXIgdGVtcENvbnRleHQgPSB0ZW1wQ2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgYW5nbGVSYWRpYW5zID0gYW5nbGUgKiBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5ERUdSRUVfVE9fUkFESUFOUztcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBzZXQgbmV3IGRpbWVuc2lvbnMgZm9yIHRlbXAgY2FudmFzXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLmNlaWwoTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiB3aWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogaGVpZ2h0KTtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLnNpbihhbmdsZVJhZGlhbnMpKSAqIHdpZHRoICsgTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiBoZWlnaHQpO1xuICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIC8vIERyYXcgYXQgY2VudGVyIG9mIHRlbXAgY2FudmFzIHRvIHByZXZlbnQgY2xpcHBpbmcgb2YgaW1hZ2UgZGF0YVxuICAgICAgICB0ZW1wQ29udGV4dC50cmFuc2xhdGUobmV3V2lkdGggLyAyLCBuZXdIZWlnaHQgLyAyKTtcbiAgICAgICAgdGVtcENvbnRleHQucm90YXRlKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIHRlbXBDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgd2lkdGggLyAtMiwgaGVpZ2h0IC8gLTIpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKHRlbXBDYW52YXNFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCh0aGlzKTtcbiAgICB9O1xuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkRFR1JFRV9UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5GUkFNRV9JTkRFWCA9IHRydWU7XG4gICAgcmV0dXJuIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlO1xufShMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KSk7XG5leHBvcnRzLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlID0gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9IVE1MVmlzdWFsTWVkaWFFbGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9icm93c2VyL0hUTUxWaXN1YWxNZWRpYUVsZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VideoInputDevice = void 0;\n/**\n * @deprecated Moving to @zxing/browser\n *\n * Video input device metadata containing the id and label of the device if available.\n */\nvar VideoInputDevice = /** @class */ (function () {\n    /**\n     * Creates an instance of VideoInputDevice.\n     *\n     * @param {string} deviceId the video input device id\n     * @param {string} label the label of the device if available\n     */\n    function VideoInputDevice(deviceId, label, groupId) {\n        this.deviceId = deviceId;\n        this.label = label;\n        /** @inheritdoc */\n        this.kind = 'videoinput';\n        this.groupId = groupId || undefined;\n    }\n    /** @inheritdoc */\n    VideoInputDevice.prototype.toJSON = function () {\n        return {\n            kind: this.kind,\n            groupId: this.groupId,\n            deviceId: this.deviceId,\n            label: this.label,\n        };\n    };\n    return VideoInputDevice;\n}());\nexports.VideoInputDevice = VideoInputDevice;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvYnJvd3Nlci9WaWRlb0lucHV0RGV2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0IiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2Jyb3dzZXIvVmlkZW9JbnB1dERldmljZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmlkZW9JbnB1dERldmljZSA9IHZvaWQgMDtcbi8qKlxuICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gKlxuICogVmlkZW8gaW5wdXQgZGV2aWNlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdGhlIGlkIGFuZCBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZS5cbiAqL1xudmFyIFZpZGVvSW5wdXREZXZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBWaWRlb0lucHV0RGV2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIHRoZSB2aWRlbyBpbnB1dCBkZXZpY2UgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgdGhlIGxhYmVsIG9mIHRoZSBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlkZW9JbnB1dERldmljZShkZXZpY2VJZCwgbGFiZWwsIGdyb3VwSWQpIHtcbiAgICAgICAgdGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0aGlzLmtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBWaWRlb0lucHV0RGV2aWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgICBncm91cElkOiB0aGlzLmdyb3VwSWQsXG4gICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFZpZGVvSW5wdXREZXZpY2U7XG59KCkpO1xuZXhwb3J0cy5WaWRlb0lucHV0RGV2aWNlID0gVmlkZW9JbnB1dERldmljZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ArgumentException = /** @class */ (function (_super) {\n    __extends(ArgumentException, _super);\n    function ArgumentException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ArgumentException.kind = 'ArgumentException';\n    return ArgumentException;\n}(Exception_1.default));\nexports[\"default\"] = ArgumentException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Bcmd1bWVudEV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL0FyZ3VtZW50RXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIEFyZ3VtZW50RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmd1bWVudEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmd1bWVudEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0FyZ3VtZW50RXhjZXB0aW9uJztcbiAgICByZXR1cm4gQXJndW1lbnRFeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFyZ3VtZW50RXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ArithmeticException = /** @class */ (function (_super) {\n    __extends(ArithmeticException, _super);\n    function ArithmeticException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ArithmeticException.kind = 'ArithmeticException';\n    return ArithmeticException;\n}(Exception_1.default));\nexports[\"default\"] = ArithmeticException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Bcml0aG1ldGljRXhjZXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsbUlBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvQXJpdGhtZXRpY0V4Y2VwdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gKi9cbnZhciBBcml0aG1ldGljRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcml0aG1ldGljRXhjZXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyaXRobWV0aWNFeGNlcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQXJpdGhtZXRpY0V4Y2VwdGlvbi5raW5kID0gJ0FyaXRobWV0aWNFeGNlcHRpb24nO1xuICAgIHJldHVybiBBcml0aG1ldGljRXhjZXB0aW9uO1xufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcml0aG1ldGljRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IndexOutOfBoundsException_1 = __webpack_require__(/*! ./IndexOutOfBoundsException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ArrayIndexOutOfBoundsException = /** @class */ (function (_super) {\n    __extends(ArrayIndexOutOfBoundsException, _super);\n    function ArrayIndexOutOfBoundsException(index, message) {\n        if (index === void 0) { index = undefined; }\n        if (message === void 0) { message = undefined; }\n        var _this = _super.call(this, message) || this;\n        _this.index = index;\n        _this.message = message;\n        return _this;\n    }\n    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';\n    return ArrayIndexOutOfBoundsException;\n}(IndexOutOfBoundsException_1.default));\nexports[\"default\"] = ArrayIndexOutOfBoundsException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9BcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQyxtS0FBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9BcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gKi9cbnZhciBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0FycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbic7XG4gICAgcmV0dXJuIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtcbn0oSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Direct port to TypeScript of ZXing by Adrian Toșcă\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*namespace com.google.zxing {*/\n/**\n * Enumerates barcode formats known to this package. Please keep alphabetized.\n *\n * @author Sean Owen\n */\nvar BarcodeFormat;\n(function (BarcodeFormat) {\n    /** Aztec 2D barcode format. */\n    BarcodeFormat[BarcodeFormat[\"AZTEC\"] = 0] = \"AZTEC\";\n    /** CODABAR 1D format. */\n    BarcodeFormat[BarcodeFormat[\"CODABAR\"] = 1] = \"CODABAR\";\n    /** Code 39 1D format. */\n    BarcodeFormat[BarcodeFormat[\"CODE_39\"] = 2] = \"CODE_39\";\n    /** Code 93 1D format. */\n    BarcodeFormat[BarcodeFormat[\"CODE_93\"] = 3] = \"CODE_93\";\n    /** Code 128 1D format. */\n    BarcodeFormat[BarcodeFormat[\"CODE_128\"] = 4] = \"CODE_128\";\n    /** Data Matrix 2D barcode format. */\n    BarcodeFormat[BarcodeFormat[\"DATA_MATRIX\"] = 5] = \"DATA_MATRIX\";\n    /** EAN-8 1D format. */\n    BarcodeFormat[BarcodeFormat[\"EAN_8\"] = 6] = \"EAN_8\";\n    /** EAN-13 1D format. */\n    BarcodeFormat[BarcodeFormat[\"EAN_13\"] = 7] = \"EAN_13\";\n    /** ITF (Interleaved Two of Five) 1D format. */\n    BarcodeFormat[BarcodeFormat[\"ITF\"] = 8] = \"ITF\";\n    /** MaxiCode 2D barcode format. */\n    BarcodeFormat[BarcodeFormat[\"MAXICODE\"] = 9] = \"MAXICODE\";\n    /** PDF417 format. */\n    BarcodeFormat[BarcodeFormat[\"PDF_417\"] = 10] = \"PDF_417\";\n    /** QR Code 2D barcode format. */\n    BarcodeFormat[BarcodeFormat[\"QR_CODE\"] = 11] = \"QR_CODE\";\n    /** RSS 14 */\n    BarcodeFormat[BarcodeFormat[\"RSS_14\"] = 12] = \"RSS_14\";\n    /** RSS EXPANDED */\n    BarcodeFormat[BarcodeFormat[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n    /** UPC-A 1D format. */\n    BarcodeFormat[BarcodeFormat[\"UPC_A\"] = 14] = \"UPC_A\";\n    /** UPC-E 1D format. */\n    BarcodeFormat[BarcodeFormat[\"UPC_E\"] = 15] = \"UPC_E\";\n    /** UPC/EAN extension format. Not a stand-alone format. */\n    BarcodeFormat[BarcodeFormat[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n})(BarcodeFormat || (BarcodeFormat = {}));\nexports[\"default\"] = BarcodeFormat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9CYXJjb2RlRm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkMsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvQmFyY29kZUZvcm1hdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBEaXJlY3QgcG9ydCB0byBUeXBlU2NyaXB0IG9mIFpYaW5nIGJ5IEFkcmlhbiBUb8iZY8SDXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbi8qKlxuICogRW51bWVyYXRlcyBiYXJjb2RlIGZvcm1hdHMga25vd24gdG8gdGhpcyBwYWNrYWdlLiBQbGVhc2Uga2VlcCBhbHBoYWJldGl6ZWQuXG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIEJhcmNvZGVGb3JtYXQ7XG4oZnVuY3Rpb24gKEJhcmNvZGVGb3JtYXQpIHtcbiAgICAvKiogQXp0ZWMgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQVpURUNcIl0gPSAwXSA9IFwiQVpURUNcIjtcbiAgICAvKiogQ09EQUJBUiAxRCBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09EQUJBUlwiXSA9IDFdID0gXCJDT0RBQkFSXCI7XG4gICAgLyoqIENvZGUgMzkgMUQgZm9ybWF0LiAqL1xuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkNPREVfMzlcIl0gPSAyXSA9IFwiQ09ERV8zOVwiO1xuICAgIC8qKiBDb2RlIDkzIDFEIGZvcm1hdC4gKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzkzXCJdID0gM10gPSBcIkNPREVfOTNcIjtcbiAgICAvKiogQ29kZSAxMjggMUQgZm9ybWF0LiAqL1xuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkNPREVfMTI4XCJdID0gNF0gPSBcIkNPREVfMTI4XCI7XG4gICAgLyoqIERhdGEgTWF0cml4IDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkRBVEFfTUFUUklYXCJdID0gNV0gPSBcIkRBVEFfTUFUUklYXCI7XG4gICAgLyoqIEVBTi04IDFEIGZvcm1hdC4gKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJFQU5fOFwiXSA9IDZdID0gXCJFQU5fOFwiO1xuICAgIC8qKiBFQU4tMTMgMUQgZm9ybWF0LiAqL1xuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkVBTl8xM1wiXSA9IDddID0gXCJFQU5fMTNcIjtcbiAgICAvKiogSVRGIChJbnRlcmxlYXZlZCBUd28gb2YgRml2ZSkgMUQgZm9ybWF0LiAqL1xuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIklURlwiXSA9IDhdID0gXCJJVEZcIjtcbiAgICAvKiogTWF4aUNvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiTUFYSUNPREVcIl0gPSA5XSA9IFwiTUFYSUNPREVcIjtcbiAgICAvKiogUERGNDE3IGZvcm1hdC4gKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJQREZfNDE3XCJdID0gMTBdID0gXCJQREZfNDE3XCI7XG4gICAgLyoqIFFSIENvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiUVJfQ09ERVwiXSA9IDExXSA9IFwiUVJfQ09ERVwiO1xuICAgIC8qKiBSU1MgMTQgKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfMTRcIl0gPSAxMl0gPSBcIlJTU18xNFwiO1xuICAgIC8qKiBSU1MgRVhQQU5ERUQgKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfRVhQQU5ERURcIl0gPSAxM10gPSBcIlJTU19FWFBBTkRFRFwiO1xuICAgIC8qKiBVUEMtQSAxRCBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0FcIl0gPSAxNF0gPSBcIlVQQ19BXCI7XG4gICAgLyoqIFVQQy1FIDFEIGZvcm1hdC4gKi9cbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcbiAgICAvKiogVVBDL0VBTiBleHRlbnNpb24gZm9ybWF0LiBOb3QgYSBzdGFuZC1hbG9uZSBmb3JtYXQuICovXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSAxNl0gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG59KShCYXJjb2RlRm9ybWF0IHx8IChCYXJjb2RlRm9ybWF0ID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhcmNvZGVGb3JtYXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Binarizer.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Binarizer.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.\n * It allows the algorithm to vary polymorphically, for example allowing a very expensive\n * thresholding technique for servers and a fast one for mobile. It also permits the implementation\n * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar Binarizer = /** @class */ (function () {\n    function Binarizer(source) {\n        this.source = source;\n    }\n    Binarizer.prototype.getLuminanceSource = function () {\n        return this.source;\n    };\n    Binarizer.prototype.getWidth = function () {\n        return this.source.getWidth();\n    };\n    Binarizer.prototype.getHeight = function () {\n        return this.source.getHeight();\n    };\n    return Binarizer;\n}());\nexports[\"default\"] = Binarizer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9CaW5hcml6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvQmluYXJpemVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRoaXMgY2xhc3MgaGllcmFyY2h5IHByb3ZpZGVzIGEgc2V0IG9mIG1ldGhvZHMgdG8gY29udmVydCBsdW1pbmFuY2UgZGF0YSB0byAxIGJpdCBkYXRhLlxuICogSXQgYWxsb3dzIHRoZSBhbGdvcml0aG0gdG8gdmFyeSBwb2x5bW9ycGhpY2FsbHksIGZvciBleGFtcGxlIGFsbG93aW5nIGEgdmVyeSBleHBlbnNpdmVcbiAqIHRocmVzaG9sZGluZyB0ZWNobmlxdWUgZm9yIHNlcnZlcnMgYW5kIGEgZmFzdCBvbmUgZm9yIG1vYmlsZS4gSXQgYWxzbyBwZXJtaXRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICogdG8gdmFyeSwgZS5nLiBhIEpOSSB2ZXJzaW9uIGZvciBBbmRyb2lkIGFuZCBhIEphdmEgZmFsbGJhY2sgdmVyc2lvbiBmb3Igb3RoZXIgcGxhdGZvcm1zLlxuICpcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gKi9cbnZhciBCaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJpemVyKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQmluYXJpemVyLnByb3RvdHlwZS5nZXRMdW1pbmFuY2VTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9O1xuICAgIEJpbmFyaXplci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5nZXRXaWR0aCgpO1xuICAgIH07XG4gICAgQmluYXJpemVyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5nZXRIZWlnaHQoKTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5hcml6ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmluYXJpemVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Binarizer.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BinaryBitmap.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BinaryBitmap.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar BinaryBitmap = /** @class */ (function () {\n    function BinaryBitmap(binarizer) {\n        this.binarizer = binarizer;\n        if (binarizer === null) {\n            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n        }\n    }\n    /**\n     * @return The width of the bitmap.\n     */\n    BinaryBitmap.prototype.getWidth = function () {\n        return this.binarizer.getWidth();\n    };\n    /**\n     * @return The height of the bitmap.\n     */\n    BinaryBitmap.prototype.getHeight = function () {\n        return this.binarizer.getHeight();\n    };\n    /**\n     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n     * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n     *\n     * @param y The row to fetch, which must be in [0, bitmap height)\n     * @param row An optional preallocated array. If null or too small, it will be ignored.\n     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n     * @return The array of bits for this row (true means black).\n     * @throws NotFoundException if row can't be binarized\n     */\n    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {\n        return this.binarizer.getBlackRow(y, row);\n    };\n    /**\n     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n     * fetched using getBlackRow(), so don't mix and match between them.\n     *\n     * @return The 2D array of bits for the image (true means black).\n     * @throws NotFoundException if image can't be binarized to make a matrix\n     */\n    BinaryBitmap.prototype.getBlackMatrix = function () {\n        // The matrix is created on demand the first time it is requested, then cached. There are two\n        // reasons for this:\n        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n        //    1D Reader finds a barcode before the 2D Readers run.\n        // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n        if (this.matrix === null || this.matrix === undefined) {\n            this.matrix = this.binarizer.getBlackMatrix();\n        }\n        return this.matrix;\n    };\n    /**\n     * @return Whether this bitmap can be cropped.\n     */\n    BinaryBitmap.prototype.isCropSupported = function () {\n        return this.binarizer.getLuminanceSource().isCropSupported();\n    };\n    /**\n     * Returns a new object with cropped image data. Implementations may keep a reference to the\n     * original data rather than a copy. Only callable if isCropSupported() is true.\n     *\n     * @param left The left coordinate, which must be in [0,getWidth())\n     * @param top The top coordinate, which must be in [0,getHeight())\n     * @param width The width of the rectangle to crop.\n     * @param height The height of the rectangle to crop.\n     * @return A cropped version of this object.\n     */\n    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * @return Whether this bitmap supports counter-clockwise rotation.\n     */\n    BinaryBitmap.prototype.isRotateSupported = function () {\n        return this.binarizer.getLuminanceSource().isRotateSupported();\n    };\n    /**\n     * Returns a new object with rotated image data by 90 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * Returns a new object with rotated image data by 45 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /*@Override*/\n    BinaryBitmap.prototype.toString = function () {\n        try {\n            return this.getBlackMatrix().toString();\n        }\n        catch (e /*: NotFoundException*/) {\n            return '';\n        }\n    };\n    return BinaryBitmap;\n}());\nexports[\"default\"] = BinaryBitmap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9CaW5hcnlCaXRtYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsaUtBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL0JpbmFyeUJpdG1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIEJpbmFyeUJpdG1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlCaXRtYXAoYmluYXJpemVyKSB7XG4gICAgICAgIHRoaXMuYmluYXJpemVyID0gYmluYXJpemVyO1xuICAgICAgICBpZiAoYmluYXJpemVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQmluYXJpemVyIG11c3QgYmUgbm9uLW51bGwuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIGJpdG1hcC5cbiAgICAgKi9cbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0V2lkdGgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgYml0bWFwLlxuICAgICAqL1xuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBvbmUgcm93IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuIE1heSBhY3R1YWxseSBkbyB0aGUgY29udmVyc2lvbiwgb3IgcmV0dXJuXG4gICAgICogY2FjaGVkIGRhdGEuIENhbGxlcnMgc2hvdWxkIGFzc3VtZSB0aGlzIG1ldGhvZCBpcyBleHBlbnNpdmUgYW5kIGNhbGwgaXQgYXMgc2VsZG9tIGFzIHBvc3NpYmxlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkZWNvZGluZyAxRCBiYXJjb2RlcyBhbmQgbWF5IGNob29zZSB0byBhcHBseSBzaGFycGVuaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byBmZXRjaCwgd2hpY2ggbXVzdCBiZSBpbiBbMCwgYml0bWFwIGhlaWdodClcbiAgICAgKiBAcGFyYW0gcm93IEFuIG9wdGlvbmFsIHByZWFsbG9jYXRlZCBhcnJheS4gSWYgbnVsbCBvciB0b28gc21hbGwsIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiAgICAgICAgICAgIElmIHVzZWQsIHRoZSBCaW5hcml6ZXIgd2lsbCBjYWxsIEJpdEFycmF5LmNsZWFyKCkuIEFsd2F5cyB1c2UgdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBhcnJheSBvZiBiaXRzIGZvciB0aGlzIHJvdyAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiByb3cgY2FuJ3QgYmUgYmluYXJpemVkXG4gICAgICovXG4gICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5nZXRCbGFja1JvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0QmxhY2tSb3coeSwgcm93KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgMkQgYXJyYXkgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQuIEFzIGFib3ZlLCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlXG4gICAgICogYW5kIGRvIG5vdCBjYWxsIGl0IHJlcGVhdGVkbHkuIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkZWNvZGluZyAyRCBiYXJjb2RlcyBhbmQgbWF5IG9yXG4gICAgICogbWF5IG5vdCBhcHBseSBzaGFycGVuaW5nLiBUaGVyZWZvcmUsIGEgcm93IGZyb20gdGhpcyBtYXRyaXggbWF5IG5vdCBiZSBpZGVudGljYWwgdG8gb25lXG4gICAgICogZmV0Y2hlZCB1c2luZyBnZXRCbGFja1JvdygpLCBzbyBkb24ndCBtaXggYW5kIG1hdGNoIGJldHdlZW4gdGhlbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIDJEIGFycmF5IG9mIGJpdHMgZm9yIHRoZSBpbWFnZSAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBjYW4ndCBiZSBiaW5hcml6ZWQgdG8gbWFrZSBhIG1hdHJpeFxuICAgICAqL1xuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuZ2V0QmxhY2tNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBtYXRyaXggaXMgY3JlYXRlZCBvbiBkZW1hbmQgdGhlIGZpcnN0IHRpbWUgaXQgaXMgcmVxdWVzdGVkLCB0aGVuIGNhY2hlZC4gVGhlcmUgYXJlIHR3b1xuICAgICAgICAvLyByZWFzb25zIGZvciB0aGlzOlxuICAgICAgICAvLyAxLiBUaGlzIHdvcmsgd2lsbCBuZXZlciBiZSBkb25lIGlmIHRoZSBjYWxsZXIgb25seSBpbnN0YWxscyAxRCBSZWFkZXIgb2JqZWN0cywgb3IgaWYgYVxuICAgICAgICAvLyAgICAxRCBSZWFkZXIgZmluZHMgYSBiYXJjb2RlIGJlZm9yZSB0aGUgMkQgUmVhZGVycyBydW4uXG4gICAgICAgIC8vIDIuIFRoaXMgd29yayB3aWxsIG9ubHkgYmUgZG9uZSBvbmNlIGV2ZW4gaWYgdGhlIGNhbGxlciBpbnN0YWxscyBtdWx0aXBsZSAyRCBSZWFkZXJzLlxuICAgICAgICBpZiAodGhpcy5tYXRyaXggPT09IG51bGwgfHwgdGhpcy5tYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLmJpbmFyaXplci5nZXRCbGFja01hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBjYW4gYmUgY3JvcHBlZC5cbiAgICAgKi9cbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzQ3JvcFN1cHBvcnRlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB0byBjcm9wLlxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIG5ld1NvdXJjZSA9IHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXAodGhpcy5iaW5hcml6ZXIuY3JlYXRlQmluYXJpemVyKG5ld1NvdXJjZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoaXMgYml0bWFwIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5pc1JvdGF0ZVN1cHBvcnRlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgOTAgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAqXG4gICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCk7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDQ1IGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXAodGhpcy5iaW5hcml6ZXIuY3JlYXRlQmluYXJpemVyKG5ld1NvdXJjZSkpO1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbGFja01hdHJpeCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUgLyo6IE5vdEZvdW5kRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeUJpdG1hcDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCaW5hcnlCaXRtYXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BinaryBitmap.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ChecksumException = /** @class */ (function (_super) {\n    __extends(ChecksumException, _super);\n    function ChecksumException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChecksumException.getChecksumInstance = function () {\n        return new ChecksumException();\n    };\n    ChecksumException.kind = 'ChecksumException';\n    return ChecksumException;\n}(Exception_1.default));\nexports[\"default\"] = ChecksumException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9DaGVja3N1bUV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL0NoZWNrc3VtRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIENoZWNrc3VtRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja3N1bUV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGVja3N1bUV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgfTtcbiAgICBDaGVja3N1bUV4Y2VwdGlvbi5raW5kID0gJ0NoZWNrc3VtRXhjZXB0aW9uJztcbiAgICByZXR1cm4gQ2hlY2tzdW1FeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoZWNrc3VtRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\n/**\n * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n * more quickly or accurately decode it. It is up to implementations to decide what,\n * if anything, to do with the information that is supplied.\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n * @see Reader#decode(BinaryBitmap,java.util.Map)\n */\nvar DecodeHintType;\n(function (DecodeHintType) {\n    /**\n     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n     */\n    DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/\n    /**\n     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/\n    /**\n     * Image is known to be of one of a few possible formats.\n     * Maps to a {@link List} of {@link BarcodeFormat}s.\n     */\n    DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/\n    /**\n     * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/\n    /**\n     * Specifies what character encoding to use when decoding, where applicable (type String)\n     */\n    DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/\n    /**\n     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n     */\n    DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/\n    /**\n     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/\n    /**\n     * Enable extended mode for Code 39 codes. Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"ENABLE_CODE_39_EXTENDED_MODE\"] = 7] = \"ENABLE_CODE_39_EXTENDED_MODE\"; /*(Void.class)*/\n    /**\n     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 8] = \"ASSUME_GS1\"; /*(Void.class)*/\n    /**\n     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 9] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/\n    /**\n     * The caller needs to be notified via callback when a possible {@link ResultPoint}\n     * is found. Maps to a {@link ResultPointCallback}.\n     */\n    DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 10] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/\n    /**\n     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n     * If it is optional to have an extension, do not set this hint. If this is set,\n     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n     * at all.\n     */\n    DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 11] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/\n    // End of enumeration values.\n    /**\n     * Data type the hint is expecting.\n     * Among the possible values the {@link Void} stands out as being used for\n     * hints that do not expect a value to be supplied (flag hints). Such hints\n     * will possibly have their value ignored, or replaced by a\n     * {@link Boolean#TRUE}. Hint suppliers should probably use\n     * {@link Boolean#TRUE} as directed by the actual hint documentation.\n     */\n    // private valueType: Class<?>\n    // DecodeHintType(valueType: Class<?>) {\n    //   this.valueType = valueType\n    // }\n    // public getValueType(): Class<?> {\n    //   return valueType\n    // }\n})(DecodeHintType || (DecodeHintType = {}));\nexports[\"default\"] = DecodeHintType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9EZWNvZGVIaW50VHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxJQUFJLG9CQUFvQjtBQUN0RDtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLGlEQUFpRDtBQUNqRCx1Q0FBdUMsS0FBSyxtQkFBbUI7QUFDL0Q7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLLG1CQUFtQjtBQUMxRTtBQUNBLGlHQUFpRztBQUNqRztBQUNBLHFFQUFxRTtBQUNyRSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekMsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvRGVjb2RlSGludFR5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIHR5cGUgb2YgaGludCB0aGF0IGEgY2FsbGVyIG1heSBwYXNzIHRvIGEgYmFyY29kZSByZWFkZXIgdG8gaGVscCBpdFxuICogbW9yZSBxdWlja2x5IG9yIGFjY3VyYXRlbHkgZGVjb2RlIGl0LiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgdG8gZGVjaWRlIHdoYXQsXG4gKiBpZiBhbnl0aGluZywgdG8gZG8gd2l0aCB0aGUgaW5mb3JtYXRpb24gdGhhdCBpcyBzdXBwbGllZC5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqIEBzZWUgUmVhZGVyI2RlY29kZShCaW5hcnlCaXRtYXAsamF2YS51dGlsLk1hcClcbiAqL1xudmFyIERlY29kZUhpbnRUeXBlO1xuKGZ1bmN0aW9uIChEZWNvZGVIaW50VHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoaW50LiBNYXBzIHRvIGFuIHVuc3BlY2lmaWVkIHtAbGluayBPYmplY3R9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjsgLyooT2JqZWN0LmNsYXNzKSovXG4gICAgLyoqXG4gICAgICogSW1hZ2UgaXMgYSBwdXJlIG1vbm9jaHJvbWUgaW1hZ2Ugb2YgYSBiYXJjb2RlLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUFVSRV9CQVJDT0RFXCJdID0gMV0gPSBcIlBVUkVfQkFSQ09ERVwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgLyoqXG4gICAgICogSW1hZ2UgaXMga25vd24gdG8gYmUgb2Ygb25lIG9mIGEgZmV3IHBvc3NpYmxlIGZvcm1hdHMuXG4gICAgICogTWFwcyB0byBhIHtAbGluayBMaXN0fSBvZiB7QGxpbmsgQmFyY29kZUZvcm1hdH1zLlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUE9TU0lCTEVfRk9STUFUU1wiXSA9IDJdID0gXCJQT1NTSUJMRV9GT1JNQVRTXCI7IC8qKExpc3QuY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBTcGVuZCBtb3JlIHRpbWUgdG8gdHJ5IHRvIGZpbmQgYSBiYXJjb2RlOyBvcHRpbWl6ZSBmb3IgYWNjdXJhY3ksIG5vdCBzcGVlZC5cbiAgICAgKiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87IHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgKi9cbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlRSWV9IQVJERVJcIl0gPSAzXSA9IFwiVFJZX0hBUkRFUlwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVuIGRlY29kaW5nLCB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIFN0cmluZylcbiAgICAgKi9cbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkNIQVJBQ1RFUl9TRVRcIl0gPSA0XSA9IFwiQ0hBUkFDVEVSX1NFVFwiOyAvKihTdHJpbmcuY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBBbGxvd2VkIGxlbmd0aHMgb2YgZW5jb2RlZCBkYXRhIC0tIHJlamVjdCBhbnl0aGluZyBlbHNlLiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fS5cbiAgICAgKi9cbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFMTE9XRURfTEVOR1RIU1wiXSA9IDVdID0gXCJBTExPV0VEX0xFTkdUSFNcIjsgLyooSW50MzJBcnJheS5jbGFzcykqL1xuICAgIC8qKlxuICAgICAqIEFzc3VtZSBDb2RlIDM5IGNvZGVzIGVtcGxveSBhIGNoZWNrIGRpZ2l0LiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVRcIl0gPSA2XSA9IFwiQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVRcIjsgLyooVm9pZC5jbGFzcykqL1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBleHRlbmRlZCBtb2RlIGZvciBDb2RlIDM5IGNvZGVzLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiRU5BQkxFX0NPREVfMzlfRVhURU5ERURfTU9ERVwiXSA9IDddID0gXCJFTkFCTEVfQ09ERV8zOV9FWFRFTkRFRF9NT0RFXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBBc3N1bWUgdGhlIGJhcmNvZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFzIGEgR1MxIGJhcmNvZGUsIGFuZCBtb2RpZnkgYmVoYXZpb3IgYXMgbmVlZGVkLlxuICAgICAqIEZvciBleGFtcGxlIHRoaXMgYWZmZWN0cyBGTkMxIGhhbmRsaW5nIGZvciBDb2RlIDEyOCAoYWthIEdTMS0xMjgpLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQVNTVU1FX0dTMVwiXSA9IDhdID0gXCJBU1NVTUVfR1MxXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgZGlnaXRzIGluIGEgQ29kYWJhciBiYXJjb2RlIGluc3RlYWQgb2Ygc3RyaXBwaW5nIHRoZW0uIFRoZXlcbiAgICAgKiBhcmUgYWxwaGEsIHdoZXJlYXMgdGhlIHJlc3QgYXJlIG51bWVyaWMuIEJ5IGRlZmF1bHQsIHRoZXkgYXJlIHN0cmlwcGVkLCBidXQgdGhpcyBjYXVzZXMgdGhlbVxuICAgICAqIHRvIG5vdCBiZS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOyB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICovXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJSRVRVUk5fQ09EQUJBUl9TVEFSVF9FTkRcIl0gPSA5XSA9IFwiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXCI7IC8qKFZvaWQuY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkIHZpYSBjYWxsYmFjayB3aGVuIGEgcG9zc2libGUge0BsaW5rIFJlc3VsdFBvaW50fVxuICAgICAqIGlzIGZvdW5kLiBNYXBzIHRvIGEge0BsaW5rIFJlc3VsdFBvaW50Q2FsbGJhY2t9LlxuICAgICAqL1xuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIl0gPSAxMF0gPSBcIk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLXCI7IC8qKFJlc3VsdFBvaW50Q2FsbGJhY2suY2xhc3MpKi9cbiAgICAvKipcbiAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuXG4gICAgICogTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0gb2YgdGhlIGFsbG93ZWQgZXh0ZW5zaW9uIGxlbmd0aHMsIGZvciBleGFtcGxlIFsyXSwgWzVdLCBvciBbMiwgNV0uXG4gICAgICogSWYgaXQgaXMgb3B0aW9uYWwgdG8gaGF2ZSBhbiBleHRlbnNpb24sIGRvIG5vdCBzZXQgdGhpcyBoaW50LiBJZiB0aGlzIGlzIHNldCxcbiAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiBhdCBhbGwuXG4gICAgICovXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCJdID0gMTFdID0gXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCI7IC8qKEludDMyQXJyYXkuY2xhc3MpKi9cbiAgICAvLyBFbmQgb2YgZW51bWVyYXRpb24gdmFsdWVzLlxuICAgIC8qKlxuICAgICAqIERhdGEgdHlwZSB0aGUgaGludCBpcyBleHBlY3RpbmcuXG4gICAgICogQW1vbmcgdGhlIHBvc3NpYmxlIHZhbHVlcyB0aGUge0BsaW5rIFZvaWR9IHN0YW5kcyBvdXQgYXMgYmVpbmcgdXNlZCBmb3JcbiAgICAgKiBoaW50cyB0aGF0IGRvIG5vdCBleHBlY3QgYSB2YWx1ZSB0byBiZSBzdXBwbGllZCAoZmxhZyBoaW50cykuIFN1Y2ggaGludHNcbiAgICAgKiB3aWxsIHBvc3NpYmx5IGhhdmUgdGhlaXIgdmFsdWUgaWdub3JlZCwgb3IgcmVwbGFjZWQgYnkgYVxuICAgICAqIHtAbGluayBCb29sZWFuI1RSVUV9LiBIaW50IHN1cHBsaWVycyBzaG91bGQgcHJvYmFibHkgdXNlXG4gICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0gYXMgZGlyZWN0ZWQgYnkgdGhlIGFjdHVhbCBoaW50IGRvY3VtZW50YXRpb24uXG4gICAgICovXG4gICAgLy8gcHJpdmF0ZSB2YWx1ZVR5cGU6IENsYXNzPD8+XG4gICAgLy8gRGVjb2RlSGludFR5cGUodmFsdWVUeXBlOiBDbGFzczw/Pikge1xuICAgIC8vICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGVcbiAgICAvLyB9XG4gICAgLy8gcHVibGljIGdldFZhbHVlVHlwZSgpOiBDbGFzczw/PiB7XG4gICAgLy8gICByZXR1cm4gdmFsdWVUeXBlXG4gICAgLy8gfVxufSkoRGVjb2RlSGludFR5cGUgfHwgKERlY29kZUhpbnRUeXBlID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZUhpbnRUeXBlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\n/**\n * These are a set of hints that you may pass to Writers to specify their behavior.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar EncodeHintType;\n(function (EncodeHintType) {\n    /**\n     * Specifies what degree of error correction to use, for example in QR Codes.\n     * Type depends on the encoder. For example for QR codes it's type\n     * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.\n     * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.\n     * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.\n     * In all cases, it can also be a {@link String} representation of the desired value as well.\n     * Note: an Aztec symbol should have a minimum of 25% EC words.\n     */\n    EncodeHintType[EncodeHintType[\"ERROR_CORRECTION\"] = 0] = \"ERROR_CORRECTION\";\n    /**\n     * Specifies what character encoding to use where applicable (type {@link String})\n     */\n    EncodeHintType[EncodeHintType[\"CHARACTER_SET\"] = 1] = \"CHARACTER_SET\";\n    /**\n     * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})\n     */\n    EncodeHintType[EncodeHintType[\"DATA_MATRIX_SHAPE\"] = 2] = \"DATA_MATRIX_SHAPE\";\n    /**\n     * Specifies whether to use compact mode for Data Matrix (type {@link Boolean}, or \"true\" or \"false\"\n     * {@link String } value).\n     * The compact encoding mode also supports the encoding of characters that are not in the ISO-8859-1\n     * character set via ECIs.\n     * Please note that in that case, the most compact character encoding is chosen for characters in\n     * the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not\n     * support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by\n     * means of the {@link #CHARACTER_SET} encoding hint.\n     * Compact encoding also provides GS1-FNC1 support when {@link #GS1_FORMAT} is selected. In this case\n     * group-separator character (ASCII 29 decimal) can be used to encode the positions of FNC1 codewords\n     * for the purpose of delimiting AIs.\n     * This option and {@link #FORCE_C40} are mutually exclusive.\n     */\n    EncodeHintType[EncodeHintType[\"DATA_MATRIX_COMPACT\"] = 3] = \"DATA_MATRIX_COMPACT\";\n    /**\n     * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n     *\n     * @deprecated use width/height params in\n     * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}\n     */\n    /*@Deprecated*/\n    EncodeHintType[EncodeHintType[\"MIN_SIZE\"] = 4] = \"MIN_SIZE\";\n    /**\n     * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n     *\n     * @deprecated without replacement\n     */\n    /*@Deprecated*/\n    EncodeHintType[EncodeHintType[\"MAX_SIZE\"] = 5] = \"MAX_SIZE\";\n    /**\n     * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary\n     * by format; for example it controls margin before and after the barcode horizontally for\n     * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).\n     */\n    EncodeHintType[EncodeHintType[\"MARGIN\"] = 6] = \"MARGIN\";\n    /**\n     * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or \"true\" or \"false\"\n     * {@link String} value).\n     */\n    EncodeHintType[EncodeHintType[\"PDF417_COMPACT\"] = 7] = \"PDF417_COMPACT\";\n    /**\n     * Specifies what compaction mode to use for PDF417 (type\n     * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its\n     * enum values).\n     */\n    EncodeHintType[EncodeHintType[\"PDF417_COMPACTION\"] = 8] = \"PDF417_COMPACTION\";\n    /**\n     * Specifies the minimum and maximum number of rows and columns for PDF417 (type\n     * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).\n     */\n    EncodeHintType[EncodeHintType[\"PDF417_DIMENSIONS\"] = 9] = \"PDF417_DIMENSIONS\";\n    /**\n     * Specifies the required number of layers for an Aztec code.\n     * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.\n     * 0 indicates to use the minimum number of layers (the default).\n     * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.\n     * (Type {@link Integer}, or {@link String} representation of the integer value).\n     */\n    EncodeHintType[EncodeHintType[\"AZTEC_LAYERS\"] = 10] = \"AZTEC_LAYERS\";\n    /**\n     * Specifies the exact version of QR code to be encoded.\n     * (Type {@link Integer}, or {@link String} representation of the integer value).\n     */\n    EncodeHintType[EncodeHintType[\"QR_VERSION\"] = 11] = \"QR_VERSION\";\n    /**\n     * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or \"true\" or \"false\"\n     * {@link String } value).\n     */\n    EncodeHintType[EncodeHintType[\"GS1_FORMAT\"] = 12] = \"GS1_FORMAT\";\n    /**\n     * Forces C40 encoding for data-matrix (type {@link Boolean}, or \"true\" or \"false\") {@link String } value). This\n     * option and {@link #DATA_MATRIX_COMPACT} are mutually exclusive.\n     */\n    EncodeHintType[EncodeHintType[\"FORCE_C40\"] = 13] = \"FORCE_C40\";\n})(EncodeHintType || (EncodeHintType = {}));\nexports[\"default\"] = EncodeHintType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9FbmNvZGVIaW50VHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFnRjtBQUN4RixnQ0FBZ0MsY0FBYztBQUM5QyxpQ0FBaUMsY0FBYztBQUMvQyx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwREFBMEQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEYsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwrQkFBK0IsY0FBYyxNQUFNLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0UsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBNkQsSUFBSSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUE0RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYyxNQUFNLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWMsTUFBTSxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjO0FBQzdGLFFBQVEsZUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYyx5QkFBeUIsZUFBZTtBQUN4RyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QyxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9FbmNvZGVIaW50VHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbi8qKlxuICogVGhlc2UgYXJlIGEgc2V0IG9mIGhpbnRzIHRoYXQgeW91IG1heSBwYXNzIHRvIFdyaXRlcnMgdG8gc3BlY2lmeSB0aGVpciBiZWhhdmlvci5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICovXG52YXIgRW5jb2RlSGludFR5cGU7XG4oZnVuY3Rpb24gKEVuY29kZUhpbnRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoYXQgZGVncmVlIG9mIGVycm9yIGNvcnJlY3Rpb24gdG8gdXNlLCBmb3IgZXhhbXBsZSBpbiBRUiBDb2Rlcy5cbiAgICAgKiBUeXBlIGRlcGVuZHMgb24gdGhlIGVuY29kZXIuIEZvciBleGFtcGxlIGZvciBRUiBjb2RlcyBpdCdzIHR5cGVcbiAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2Rlci5FcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvckNvcnJlY3Rpb25MZXZlbH0uXG4gICAgICogRm9yIEF6dGVjIGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCByZXByZXNlbnRpbmcgdGhlIG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjb3JyZWN0aW9uIHdvcmRzLlxuICAgICAqIEZvciBQREY0MTcgaXQgaXMgb2YgdHlwZSB7QGxpbmsgSW50ZWdlcn0sIHZhbGlkIHZhbHVlcyBiZWluZyAwIHRvIDguXG4gICAgICogSW4gYWxsIGNhc2VzLCBpdCBjYW4gYWxzbyBiZSBhIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZXNpcmVkIHZhbHVlIGFzIHdlbGwuXG4gICAgICogTm90ZTogYW4gQXp0ZWMgc3ltYm9sIHNob3VsZCBoYXZlIGEgbWluaW11bSBvZiAyNSUgRUMgd29yZHMuXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJFUlJPUl9DT1JSRUNUSU9OXCJdID0gMF0gPSBcIkVSUk9SX0NPUlJFQ1RJT05cIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUge0BsaW5rIFN0cmluZ30pXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gMV0gPSBcIkNIQVJBQ1RFUl9TRVRcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG1hdHJpeCBzaGFwZSBmb3IgRGF0YSBNYXRyaXggKHR5cGUge0BsaW5rIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5lbmNvZGVyLlN5bWJvbFNoYXBlSGludH0pXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJEQVRBX01BVFJJWF9TSEFQRVwiXSA9IDJdID0gXCJEQVRBX01BVFJJWF9TSEFQRVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRvIHVzZSBjb21wYWN0IG1vZGUgZm9yIERhdGEgTWF0cml4ICh0eXBlIHtAbGluayBCb29sZWFufSwgb3IgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4gICAgICoge0BsaW5rIFN0cmluZyB9IHZhbHVlKS5cbiAgICAgKiBUaGUgY29tcGFjdCBlbmNvZGluZyBtb2RlIGFsc28gc3VwcG9ydHMgdGhlIGVuY29kaW5nIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSBJU08tODg1OS0xXG4gICAgICogY2hhcmFjdGVyIHNldCB2aWEgRUNJcy5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGluIHRoYXQgY2FzZSwgdGhlIG1vc3QgY29tcGFjdCBjaGFyYWN0ZXIgZW5jb2RpbmcgaXMgY2hvc2VuIGZvciBjaGFyYWN0ZXJzIGluXG4gICAgICogdGhlIGlucHV0IHRoYXQgYXJlIG5vdCBpbiB0aGUgSVNPLTg4NTktMSBjaGFyYWN0ZXIgc2V0LiBCYXNlZCBvbiBleHBlcmllbmNlLCBzb21lIHNjYW5uZXJzIGRvIG5vdFxuICAgICAqIHN1cHBvcnQgZW5jb2RpbmdzIGxpa2UgY3AtMTI1NiAoQXJhYmljKS4gSW4gc3VjaCBjYXNlcyB0aGUgZW5jb2RpbmcgY2FuIGJlIGZvcmNlZCB0byBVVEYtOCBieVxuICAgICAqIG1lYW5zIG9mIHRoZSB7QGxpbmsgI0NIQVJBQ1RFUl9TRVR9IGVuY29kaW5nIGhpbnQuXG4gICAgICogQ29tcGFjdCBlbmNvZGluZyBhbHNvIHByb3ZpZGVzIEdTMS1GTkMxIHN1cHBvcnQgd2hlbiB7QGxpbmsgI0dTMV9GT1JNQVR9IGlzIHNlbGVjdGVkLiBJbiB0aGlzIGNhc2VcbiAgICAgKiBncm91cC1zZXBhcmF0b3IgY2hhcmFjdGVyIChBU0NJSSAyOSBkZWNpbWFsKSBjYW4gYmUgdXNlZCB0byBlbmNvZGUgdGhlIHBvc2l0aW9ucyBvZiBGTkMxIGNvZGV3b3Jkc1xuICAgICAqIGZvciB0aGUgcHVycG9zZSBvZiBkZWxpbWl0aW5nIEFJcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBhbmQge0BsaW5rICNGT1JDRV9DNDB9IGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJEQVRBX01BVFJJWF9DT01QQUNUXCJdID0gM10gPSBcIkRBVEFfTUFUUklYX0NPTVBBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgYSBtaW5pbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Ugd2lkdGgvaGVpZ2h0IHBhcmFtcyBpblxuICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFdyaXRlciNlbmNvZGUoU3RyaW5nLCBCYXJjb2RlRm9ybWF0LCBpbnQsIGludCl9XG4gICAgICovXG4gICAgLypARGVwcmVjYXRlZCovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNSU5fU0laRVwiXSA9IDRdID0gXCJNSU5fU0laRVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIG1heGltdW0gYmFyY29kZSBzaXplICh0eXBlIHtAbGluayBEaW1lbnNpb259KS4gT25seSBhcHBsaWNhYmxlIHRvIERhdGEgTWF0cml4IG5vdy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHdpdGhvdXQgcmVwbGFjZW1lbnRcbiAgICAgKi9cbiAgICAvKkBEZXByZWNhdGVkKi9cbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1BWF9TSVpFXCJdID0gNV0gPSBcIk1BWF9TSVpFXCI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIG1hcmdpbiwgaW4gcGl4ZWxzLCB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBiYXJjb2RlLiBUaGUgbWVhbmluZyBjYW4gdmFyeVxuICAgICAqIGJ5IGZvcm1hdDsgZm9yIGV4YW1wbGUgaXQgY29udHJvbHMgbWFyZ2luIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGJhcmNvZGUgaG9yaXpvbnRhbGx5IGZvclxuICAgICAqIG1vc3QgMUQgZm9ybWF0cy4gKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNQVJHSU5cIl0gPSA2XSA9IFwiTUFSR0lOXCI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdG8gdXNlIGNvbXBhY3QgbW9kZSBmb3IgUERGNDE3ICh0eXBlIHtAbGluayBCb29sZWFufSwgb3IgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4gICAgICoge0BsaW5rIFN0cmluZ30gdmFsdWUpLlxuICAgICAqL1xuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0NPTVBBQ1RcIl0gPSA3XSA9IFwiUERGNDE3X0NPTVBBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hhdCBjb21wYWN0aW9uIG1vZGUgdG8gdXNlIGZvciBQREY0MTcgKHR5cGVcbiAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5Db21wYWN0aW9uIENvbXBhY3Rpb259IG9yIHtAbGluayBTdHJpbmd9IHZhbHVlIG9mIG9uZSBvZiBpdHNcbiAgICAgKiBlbnVtIHZhbHVlcykuXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVElPTlwiXSA9IDhdID0gXCJQREY0MTdfQ09NUEFDVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBmb3IgUERGNDE3ICh0eXBlXG4gICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmVuY29kZXIuRGltZW5zaW9ucyBEaW1lbnNpb25zfSkuXG4gICAgICovXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfRElNRU5TSU9OU1wiXSA9IDldID0gXCJQREY0MTdfRElNRU5TSU9OU1wiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGxheWVycyBmb3IgYW4gQXp0ZWMgY29kZS5cbiAgICAgKiBBIG5lZ2F0aXZlIG51bWJlciAoLTEsIC0yLCAtMywgLTQpIHNwZWNpZmllcyBhIGNvbXBhY3QgQXp0ZWMgY29kZS5cbiAgICAgKiAwIGluZGljYXRlcyB0byB1c2UgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGxheWVycyAodGhlIGRlZmF1bHQpLlxuICAgICAqIEEgcG9zaXRpdmUgbnVtYmVyICgxLCAyLCAuLiAzMikgc3BlY2lmaWVzIGEgbm9ybWFsIChub24tY29tcGFjdCkgQXp0ZWMgY29kZS5cbiAgICAgKiAoVHlwZSB7QGxpbmsgSW50ZWdlcn0sIG9yIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnRlZ2VyIHZhbHVlKS5cbiAgICAgKi9cbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkFaVEVDX0xBWUVSU1wiXSA9IDEwXSA9IFwiQVpURUNfTEFZRVJTXCI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBleGFjdCB2ZXJzaW9uIG9mIFFSIGNvZGUgdG8gYmUgZW5jb2RlZC5cbiAgICAgKiAoVHlwZSB7QGxpbmsgSW50ZWdlcn0sIG9yIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnRlZ2VyIHZhbHVlKS5cbiAgICAgKi9cbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIlFSX1ZFUlNJT05cIl0gPSAxMV0gPSBcIlFSX1ZFUlNJT05cIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZGF0YSBzaG91bGQgYmUgZW5jb2RlZCB0byB0aGUgR1MxIHN0YW5kYXJkICh0eXBlIHtAbGluayBCb29sZWFufSwgb3IgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4gICAgICoge0BsaW5rIFN0cmluZyB9IHZhbHVlKS5cbiAgICAgKi9cbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkdTMV9GT1JNQVRcIl0gPSAxMl0gPSBcIkdTMV9GT1JNQVRcIjtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgQzQwIGVuY29kaW5nIGZvciBkYXRhLW1hdHJpeCAodHlwZSB7QGxpbmsgQm9vbGVhbn0sIG9yIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIikge0BsaW5rIFN0cmluZyB9IHZhbHVlKS4gVGhpc1xuICAgICAqIG9wdGlvbiBhbmQge0BsaW5rICNEQVRBX01BVFJJWF9DT01QQUNUfSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAqL1xuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiRk9SQ0VfQzQwXCJdID0gMTNdID0gXCJGT1JDRV9DNDBcIjtcbn0pKEVuY29kZUhpbnRUeXBlIHx8IChFbmNvZGVIaW50VHlwZSA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbmNvZGVIaW50VHlwZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ts_custom_error_1 = __webpack_require__(/*! ts-custom-error */ \"(pages-dir-node)/../node_modules/.pnpm/ts-custom-error@3.3.1/node_modules/ts-custom-error/dist/custom-error.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar Exception = /** @class */ (function (_super) {\n    __extends(Exception, _super);\n    /**\n     * Allows Exception to be constructed directly\n     * with some message and prototype definition.\n     */\n    function Exception(message) {\n        if (message === void 0) { message = undefined; }\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        return _this;\n    }\n    Exception.prototype.getKind = function () {\n        var ex = this.constructor;\n        return ex.kind;\n    };\n    /**\n     * It's typed as string so it can be extended and overriden.\n     */\n    Exception.kind = 'Exception';\n    return Exception;\n}(ts_custom_error_1.CustomError));\nexports[\"default\"] = Exception;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9FeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyx1SUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNfY3VzdG9tX2Vycm9yXzEgPSByZXF1aXJlKFwidHMtY3VzdG9tLWVycm9yXCIpO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gKi9cbnZhciBFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgRXhjZXB0aW9uIHRvIGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XG4gICAgICogd2l0aCBzb21lIG1lc3NhZ2UgYW5kIHByb3RvdHlwZSBkZWZpbml0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFeGNlcHRpb24ucHJvdG90eXBlLmdldEtpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBleC5raW5kO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXQncyB0eXBlZCBhcyBzdHJpbmcgc28gaXQgY2FuIGJlIGV4dGVuZGVkIGFuZCBvdmVycmlkZW4uXG4gICAgICovXG4gICAgRXhjZXB0aW9uLmtpbmQgPSAnRXhjZXB0aW9uJztcbiAgICByZXR1cm4gRXhjZXB0aW9uO1xufSh0c19jdXN0b21fZXJyb3JfMS5DdXN0b21FcnJvcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar FormatException = /** @class */ (function (_super) {\n    __extends(FormatException, _super);\n    function FormatException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FormatException.getFormatInstance = function () {\n        return new FormatException();\n    };\n    FormatException.kind = 'FormatException';\n    return FormatException;\n}(Exception_1.default));\nexports[\"default\"] = FormatException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Gb3JtYXRFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtSUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Gb3JtYXRFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgRm9ybWF0RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0RXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICB9O1xuICAgIEZvcm1hdEV4Y2VwdGlvbi5raW5kID0gJ0Zvcm1hdEV4Y2VwdGlvbic7XG4gICAgcmV0dXJuIEZvcm1hdEV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0RXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar IllegalArgumentException = /** @class */ (function (_super) {\n    __extends(IllegalArgumentException, _super);\n    function IllegalArgumentException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IllegalArgumentException.kind = 'IllegalArgumentException';\n    return IllegalArgumentException;\n}(Exception_1.default));\nexports[\"default\"] = IllegalArgumentException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtSUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbic7XG4gICAgcmV0dXJuIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar IllegalStateException = /** @class */ (function (_super) {\n    __extends(IllegalStateException, _super);\n    function IllegalStateException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IllegalStateException.kind = 'IllegalStateException';\n    return IllegalStateException;\n}(Exception_1.default));\nexports[\"default\"] = IllegalStateException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbGxlZ2FsU3RhdGVFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtSUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbGxlZ2FsU3RhdGVFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbGxlZ2FsU3RhdGVFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxTdGF0ZUV4Y2VwdGlvbic7XG4gICAgcmV0dXJuIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSWxsZWdhbFN0YXRlRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar IndexOutOfBoundsException = /** @class */ (function (_super) {\n    __extends(IndexOutOfBoundsException, _super);\n    function IndexOutOfBoundsException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';\n    return IndexOutOfBoundsException;\n}(Exception_1.default));\nexports[\"default\"] = IndexOutOfBoundsException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsbUlBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gKi9cbnZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuICAgIHJldHVybiBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uO1xufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\");\n/*namespace com.google.zxing {*/\n/**\n * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes\n * white and vice versa, and each value becomes (255-value).\n *\n * @author Sean Owen\n */\nvar InvertedLuminanceSource = /** @class */ (function (_super) {\n    __extends(InvertedLuminanceSource, _super);\n    function InvertedLuminanceSource(delegate) {\n        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;\n        _this.delegate = delegate;\n        return _this;\n    }\n    /*@Override*/\n    InvertedLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n        var sourceRow = this.delegate.getRow(y, row);\n        var width = this.getWidth();\n        for (var i = 0; i < width; i++) {\n            sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));\n        }\n        return sourceRow;\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.getMatrix = function () {\n        var matrix = this.delegate.getMatrix();\n        var length = this.getWidth() * this.getHeight();\n        var invertedMatrix = new Uint8ClampedArray(length);\n        for (var i = 0; i < length; i++) {\n            invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));\n        }\n        return invertedMatrix;\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.isCropSupported = function () {\n        return this.delegate.isCropSupported();\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.isRotateSupported = function () {\n        return this.delegate.isRotateSupported();\n    };\n    /**\n     * @return original delegate {@link LuminanceSource} since invert undoes itself\n     */\n    /*@Override*/\n    InvertedLuminanceSource.prototype.invert = function () {\n        return this.delegate;\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.rotateCounterClockwise = function () {\n        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());\n    };\n    /*@Override*/\n    InvertedLuminanceSource.prototype.rotateCounterClockwise45 = function () {\n        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());\n    };\n    return InvertedLuminanceSource;\n}(LuminanceSource_1.default));\nexports[\"default\"] = InvertedLuminanceSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLCtJQUFtQjtBQUNuRCw4QkFBOEI7QUFDOUI7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vTHVtaW5hbmNlU291cmNlXCIpO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbi8qKlxuICogQSB3cmFwcGVyIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHdoaWNoIGludmVydHMgdGhlIGx1bWluYW5jZXMgaXQgcmV0dXJucyAtLSBibGFjayBiZWNvbWVzXG4gKiB3aGl0ZSBhbmQgdmljZSB2ZXJzYSwgYW5kIGVhY2ggdmFsdWUgYmVjb21lcyAoMjU1LXZhbHVlKS5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludmVydGVkTHVtaW5hbmNlU291cmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludmVydGVkTHVtaW5hbmNlU291cmNlKGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlbGVnYXRlLmdldFdpZHRoKCksIGRlbGVnYXRlLmdldEhlaWdodCgpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgIHZhciBzb3VyY2VSb3cgPSB0aGlzLmRlbGVnYXRlLmdldFJvdyh5LCByb3cpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgc291cmNlUm93W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKHNvdXJjZVJvd1tpXSAmIDB4RkYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlUm93O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmRlbGVnYXRlLmdldE1hdHJpeCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIGludmVydGVkTWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludmVydGVkTWF0cml4W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKG1hdHJpeFtpXSAmIDB4RkYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52ZXJ0ZWRNYXRyaXg7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuaXNDcm9wU3VwcG9ydGVkKCk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzUm90YXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5pc1JvdGF0ZVN1cHBvcnRlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBvcmlnaW5hbCBkZWxlZ2F0ZSB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSBzaW5jZSBpbnZlcnQgdW5kb2VzIGl0c2VsZlxuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZTtcbn0oTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar StringBuilder_1 = __webpack_require__(/*! ./util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar UnsupportedOperationException_1 = __webpack_require__(/*! ./UnsupportedOperationException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js\");\n/*namespace com.google.zxing {*/\n/**\n * The purpose of this class hierarchy is to abstract different bitmap implementations across\n * platforms into a standard interface for requesting greyscale luminance values. The interface\n * only provides immutable methods; therefore crop and rotation create copies. This is to ensure\n * that one Reader does not modify the original luminance source and leave it in an unknown state\n * for other Readers in the chain.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar LuminanceSource = /** @class */ (function () {\n    function LuminanceSource(width /*int*/, height /*int*/) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * @return The width of the bitmap.\n     */\n    LuminanceSource.prototype.getWidth = function () {\n        return this.width;\n    };\n    /**\n     * @return The height of the bitmap.\n     */\n    LuminanceSource.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * @return Whether this subclass supports cropping.\n     */\n    LuminanceSource.prototype.isCropSupported = function () {\n        return false;\n    };\n    /**\n     * Returns a new object with cropped image data. Implementations may keep a reference to the\n     * original data rather than a copy. Only callable if isCropSupported() is true.\n     *\n     * @param left The left coordinate, which must be in [0,getWidth())\n     * @param top The top coordinate, which must be in [0,getHeight())\n     * @param width The width of the rectangle to crop.\n     * @param height The height of the rectangle to crop.\n     * @return A cropped version of this object.\n     */\n    LuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        throw new UnsupportedOperationException_1.default('This luminance source does not support cropping.');\n    };\n    /**\n     * @return Whether this subclass supports counter-clockwise rotation.\n     */\n    LuminanceSource.prototype.isRotateSupported = function () {\n        return false;\n    };\n    /**\n     * Returns a new object with rotated image data by 90 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    LuminanceSource.prototype.rotateCounterClockwise = function () {\n        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 90 degrees.');\n    };\n    /**\n     * Returns a new object with rotated image data by 45 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    LuminanceSource.prototype.rotateCounterClockwise45 = function () {\n        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 45 degrees.');\n    };\n    /*@Override*/\n    LuminanceSource.prototype.toString = function () {\n        var row = new Uint8ClampedArray(this.width);\n        var result = new StringBuilder_1.default();\n        for (var y = 0; y < this.height; y++) {\n            var sourceRow = this.getRow(y, row);\n            for (var x = 0; x < this.width; x++) {\n                var luminance = sourceRow[x] & 0xFF;\n                var c = void 0;\n                if (luminance < 0x40) {\n                    c = '#';\n                }\n                else if (luminance < 0x80) {\n                    c = '+';\n                }\n                else if (luminance < 0xC0) {\n                    c = '.';\n                }\n                else {\n                    c = ' ';\n                }\n                result.append(c);\n            }\n            result.append('\\n');\n        }\n        return result.toString();\n    };\n    return LuminanceSource;\n}());\nexports[\"default\"] = LuminanceSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9MdW1pbmFuY2VTb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMscUpBQXNCO0FBQ3BELHNDQUFzQyxtQkFBTyxDQUFDLDJLQUFpQztBQUMvRSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9MdW1pbmFuY2VTb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXCIpO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjbGFzcyBoaWVyYXJjaHkgaXMgdG8gYWJzdHJhY3QgZGlmZmVyZW50IGJpdG1hcCBpbXBsZW1lbnRhdGlvbnMgYWNyb3NzXG4gKiBwbGF0Zm9ybXMgaW50byBhIHN0YW5kYXJkIGludGVyZmFjZSBmb3IgcmVxdWVzdGluZyBncmV5c2NhbGUgbHVtaW5hbmNlIHZhbHVlcy4gVGhlIGludGVyZmFjZVxuICogb25seSBwcm92aWRlcyBpbW11dGFibGUgbWV0aG9kczsgdGhlcmVmb3JlIGNyb3AgYW5kIHJvdGF0aW9uIGNyZWF0ZSBjb3BpZXMuIFRoaXMgaXMgdG8gZW5zdXJlXG4gKiB0aGF0IG9uZSBSZWFkZXIgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBsdW1pbmFuY2Ugc291cmNlIGFuZCBsZWF2ZSBpdCBpbiBhbiB1bmtub3duIHN0YXRlXG4gKiBmb3Igb3RoZXIgUmVhZGVycyBpbiB0aGUgY2hhaW4uXG4gKlxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqL1xudmFyIEx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMdW1pbmFuY2VTb3VyY2Uod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIGJpdG1hcC5cbiAgICAgKi9cbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgYml0bWFwLlxuICAgICAqL1xuICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjcm9wcGluZy5cbiAgICAgKi9cbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB0byBjcm9wLlxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY3JvcHBpbmcuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cbiAgICAgKi9cbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzUm90YXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA5MCBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgOTAgZGVncmVlcy4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDQ1IGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1RoaXMgbHVtaW5hbmNlIHNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IHJvdGF0aW9uIGJ5IDQ1IGRlZ3JlZXMuJyk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLndpZHRoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VSb3cgPSB0aGlzLmdldFJvdyh5LCByb3cpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbHVtaW5hbmNlID0gc291cmNlUm93W3hdICYgMHhGRjtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobHVtaW5hbmNlIDwgMHg0MCkge1xuICAgICAgICAgICAgICAgICAgICBjID0gJyMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsdW1pbmFuY2UgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4QzApIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTHVtaW5hbmNlU291cmNlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEx1bWluYW5jZVNvdXJjZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatReader.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatReader.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecodeHintType_1 = __webpack_require__(/*! ./DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar BarcodeFormat_1 = __webpack_require__(/*! ./BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar QRCodeReader_1 = __webpack_require__(/*! ./qrcode/QRCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js\");\nvar AztecReader_1 = __webpack_require__(/*! ./aztec/AztecReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js\");\nvar MultiFormatOneDReader_1 = __webpack_require__(/*! ./oned/MultiFormatOneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js\");\nvar DataMatrixReader_1 = __webpack_require__(/*! ./datamatrix/DataMatrixReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ./NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar PDF417Reader_1 = __webpack_require__(/*! ./pdf417/PDF417Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js\");\nvar ReaderException_1 = __webpack_require__(/*! ./ReaderException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReaderException.js\");\n/*namespace com.google.zxing {*/\n/**\n * MultiFormatReader is a convenience class and the main entry point into the library for most uses.\n * By default it attempts to decode all barcode formats that the library supports. Optionally, you\n * can provide a hints object to request different behavior, for example only decoding QR codes.\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar MultiFormatReader = /** @class */ (function () {\n    function MultiFormatReader() {\n    }\n    /**\n     * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it\n     * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.\n     * Use setHints() followed by decodeWithState() for continuous scan applications.\n     *\n     * @param image The pixel data to decode\n     * @return The contents of the image\n     *\n     * @throws NotFoundException Any errors which occurred\n     */\n    /*@Override*/\n    // public decode(image: BinaryBitmap): Result {\n    //   setHints(null)\n    //   return decodeInternal(image)\n    // }\n    /**\n     * Decode an image using the hints provided. Does not honor existing state.\n     *\n     * @param image The pixel data to decode\n     * @param hints The hints to use, clearing the previous state.\n     * @return The contents of the image\n     *\n     * @throws NotFoundException Any errors which occurred\n     */\n    /*@Override*/\n    MultiFormatReader.prototype.decode = function (image, hints) {\n        this.setHints(hints);\n        return this.decodeInternal(image);\n    };\n    /**\n     * Decode an image using the state set up by calling setHints() previously. Continuous scan\n     * clients will get a <b>large</b> speed increase by using this instead of decode().\n     *\n     * @param image The pixel data to decode\n     * @return The contents of the image\n     *\n     * @throws NotFoundException Any errors which occurred\n     */\n    MultiFormatReader.prototype.decodeWithState = function (image) {\n        // Make sure to set up the default state so we don't crash\n        if (this.readers === null || this.readers === undefined) {\n            this.setHints(null);\n        }\n        return this.decodeInternal(image);\n    };\n    /**\n     * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls\n     * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This\n     * is important for performance in continuous scan clients.\n     *\n     * @param hints The set of hints to use for subsequent calls to decode(image)\n     */\n    MultiFormatReader.prototype.setHints = function (hints) {\n        this.hints = hints;\n        var tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);\n        /*@SuppressWarnings(\"unchecked\")*/\n        var formats = hints === null || hints === undefined ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\n        var readers = new Array();\n        if (formats !== null && formats !== undefined) {\n            var addOneDReader = formats.some(function (f) {\n                return f === BarcodeFormat_1.default.UPC_A ||\n                    f === BarcodeFormat_1.default.UPC_E ||\n                    f === BarcodeFormat_1.default.EAN_13 ||\n                    f === BarcodeFormat_1.default.EAN_8 ||\n                    f === BarcodeFormat_1.default.CODABAR ||\n                    f === BarcodeFormat_1.default.CODE_39 ||\n                    f === BarcodeFormat_1.default.CODE_93 ||\n                    f === BarcodeFormat_1.default.CODE_128 ||\n                    f === BarcodeFormat_1.default.ITF ||\n                    f === BarcodeFormat_1.default.RSS_14 ||\n                    f === BarcodeFormat_1.default.RSS_EXPANDED;\n            });\n            // Put 1D readers upfront in \"normal\" mode\n            // TYPESCRIPTPORT: TODO: uncomment below as they are ported\n            if (addOneDReader && !tryHarder) {\n                readers.push(new MultiFormatOneDReader_1.default(hints));\n            }\n            if (formats.includes(BarcodeFormat_1.default.QR_CODE)) {\n                readers.push(new QRCodeReader_1.default());\n            }\n            if (formats.includes(BarcodeFormat_1.default.DATA_MATRIX)) {\n                readers.push(new DataMatrixReader_1.default());\n            }\n            if (formats.includes(BarcodeFormat_1.default.AZTEC)) {\n                readers.push(new AztecReader_1.default());\n            }\n            if (formats.includes(BarcodeFormat_1.default.PDF_417)) {\n                readers.push(new PDF417Reader_1.default());\n            }\n            // if (formats.includes(BarcodeFormat.MAXICODE)) {\n            //    readers.push(new MaxiCodeReader())\n            // }\n            // At end in \"try harder\" mode\n            if (addOneDReader && tryHarder) {\n                readers.push(new MultiFormatOneDReader_1.default(hints));\n            }\n        }\n        if (readers.length === 0) {\n            if (!tryHarder) {\n                readers.push(new MultiFormatOneDReader_1.default(hints));\n            }\n            readers.push(new QRCodeReader_1.default());\n            readers.push(new DataMatrixReader_1.default());\n            readers.push(new AztecReader_1.default());\n            readers.push(new PDF417Reader_1.default());\n            // readers.push(new MaxiCodeReader())\n            if (tryHarder) {\n                readers.push(new MultiFormatOneDReader_1.default(hints));\n            }\n        }\n        this.readers = readers; // .toArray(new Reader[readers.size()])\n    };\n    /*@Override*/\n    MultiFormatReader.prototype.reset = function () {\n        var e_1, _a;\n        if (this.readers !== null) {\n            try {\n                for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var reader = _c.value;\n                    reader.reset();\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    };\n    /**\n     * @throws NotFoundException\n     */\n    MultiFormatReader.prototype.decodeInternal = function (image) {\n        var e_2, _a;\n        if (this.readers === null) {\n            throw new ReaderException_1.default('No readers where selected, nothing can be read.');\n        }\n        try {\n            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var reader = _c.value;\n                // Trying to decode with ${reader} reader.\n                try {\n                    return reader.decode(image, this.hints);\n                }\n                catch (ex) {\n                    if (ex instanceof ReaderException_1.default) {\n                        continue;\n                    }\n                    // Bad Exception.\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        throw new NotFoundException_1.default('No MultiFormat Readers were able to detect the code.');\n    };\n    return MultiFormatReader;\n}());\nexports[\"default\"] = MultiFormatReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9NdWx0aUZvcm1hdFJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQyw2SUFBa0I7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsMklBQWlCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLHVKQUF1QjtBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxtSkFBcUI7QUFDakQsOEJBQThCLG1CQUFPLENBQUMscUtBQThCO0FBQ3BFLHlCQUF5QixtQkFBTyxDQUFDLHVLQUErQjtBQUNoRSwwQkFBMEIsbUJBQU8sQ0FBQyxtSkFBcUI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsdUpBQXVCO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLCtJQUFtQjtBQUNuRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL011bHRpRm9ybWF0UmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgUVJDb2RlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9xcmNvZGUvUVJDb2RlUmVhZGVyXCIpO1xudmFyIEF6dGVjUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9henRlYy9BenRlY1JlYWRlclwiKTtcbnZhciBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL29uZWQvTXVsdGlGb3JtYXRPbmVEUmVhZGVyXCIpO1xudmFyIERhdGFNYXRyaXhSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGFtYXRyaXgvRGF0YU1hdHJpeFJlYWRlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgUERGNDE3UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9wZGY0MTcvUERGNDE3UmVhZGVyXCIpO1xudmFyIFJlYWRlckV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vUmVhZGVyRXhjZXB0aW9uXCIpO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbi8qKlxuICogTXVsdGlGb3JtYXRSZWFkZXIgaXMgYSBjb252ZW5pZW5jZSBjbGFzcyBhbmQgdGhlIG1haW4gZW50cnkgcG9pbnQgaW50byB0aGUgbGlicmFyeSBmb3IgbW9zdCB1c2VzLlxuICogQnkgZGVmYXVsdCBpdCBhdHRlbXB0cyB0byBkZWNvZGUgYWxsIGJhcmNvZGUgZm9ybWF0cyB0aGF0IHRoZSBsaWJyYXJ5IHN1cHBvcnRzLiBPcHRpb25hbGx5LCB5b3VcbiAqIGNhbiBwcm92aWRlIGEgaGludHMgb2JqZWN0IHRvIHJlcXVlc3QgZGlmZmVyZW50IGJlaGF2aW9yLCBmb3IgZXhhbXBsZSBvbmx5IGRlY29kaW5nIFFSIGNvZGVzLlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICovXG52YXIgTXVsdGlGb3JtYXRSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlGb3JtYXRSZWFkZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgdmVyc2lvbiBvZiBkZWNvZGUgaG9ub3JzIHRoZSBpbnRlbnQgb2YgUmVhZGVyLmRlY29kZShCaW5hcnlCaXRtYXApIGluIHRoYXQgaXRcbiAgICAgKiBwYXNzZXMgbnVsbCBhcyBhIGhpbnQgdG8gdGhlIGRlY29kZXJzLiBIb3dldmVyLCB0aGF0IG1ha2VzIGl0IGluZWZmaWNpZW50IHRvIGNhbGwgcmVwZWF0ZWRseS5cbiAgICAgKiBVc2Ugc2V0SGludHMoKSBmb2xsb3dlZCBieSBkZWNvZGVXaXRoU3RhdGUoKSBmb3IgY29udGludW91cyBzY2FuIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBCaW5hcnlCaXRtYXApOiBSZXN1bHQge1xuICAgIC8vICAgc2V0SGludHMobnVsbClcbiAgICAvLyAgIHJldHVybiBkZWNvZGVJbnRlcm5hbChpbWFnZSlcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBoaW50cyBwcm92aWRlZC4gRG9lcyBub3QgaG9ub3IgZXhpc3Rpbmcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIGhpbnRzIFRoZSBoaW50cyB0byB1c2UsIGNsZWFyaW5nIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBNdWx0aUZvcm1hdFJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xuICAgICAgICB0aGlzLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW50ZXJuYWwoaW1hZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBzdGF0ZSBzZXQgdXAgYnkgY2FsbGluZyBzZXRIaW50cygpIHByZXZpb3VzbHkuIENvbnRpbnVvdXMgc2NhblxuICAgICAqIGNsaWVudHMgd2lsbCBnZXQgYSA8Yj5sYXJnZTwvYj4gc3BlZWQgaW5jcmVhc2UgYnkgdXNpbmcgdGhpcyBpbnN0ZWFkIG9mIGRlY29kZSgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGltYWdlIFRoZSBwaXhlbCBkYXRhIHRvIGRlY29kZVxuICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxuICAgICAqXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBBbnkgZXJyb3JzIHdoaWNoIG9jY3VycmVkXG4gICAgICovXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLmRlY29kZVdpdGhTdGF0ZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gc2V0IHVwIHRoZSBkZWZhdWx0IHN0YXRlIHNvIHdlIGRvbid0IGNyYXNoXG4gICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwgfHwgdGhpcy5yZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGludHMobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW50ZXJuYWwoaW1hZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyBzdGF0ZSB0byB0aGUgTXVsdGlGb3JtYXRSZWFkZXIuIEJ5IHNldHRpbmcgdGhlIGhpbnRzIG9uY2UsIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIGNhbiByZXVzZSB0aGUgc2FtZSBzZXQgb2YgcmVhZGVycyB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuIFRoaXNcbiAgICAgKiBpcyBpbXBvcnRhbnQgZm9yIHBlcmZvcm1hbmNlIGluIGNvbnRpbnVvdXMgc2NhbiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhpbnRzIFRoZSBzZXQgb2YgaGludHMgdG8gdXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGRlY29kZShpbWFnZSlcbiAgICAgKi9cbiAgICBNdWx0aUZvcm1hdFJlYWRlci5wcm90b3R5cGUuc2V0SGludHMgPSBmdW5jdGlvbiAoaGludHMpIHtcbiAgICAgICAgdGhpcy5oaW50cyA9IGhpbnRzO1xuICAgICAgICB2YXIgdHJ5SGFyZGVyID0gaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuVFJZX0hBUkRFUik7XG4gICAgICAgIC8qQFN1cHByZXNzV2FybmluZ3MoXCJ1bmNoZWNrZWRcIikqL1xuICAgICAgICB2YXIgZm9ybWF0cyA9IGhpbnRzID09PSBudWxsIHx8IGhpbnRzID09PSB1bmRlZmluZWQgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgdmFyIHJlYWRlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgaWYgKGZvcm1hdHMgIT09IG51bGwgJiYgZm9ybWF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYWRkT25lRFJlYWRlciA9IGZvcm1hdHMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5VUENfQSB8fFxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5VUENfRSB8fFxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fMTMgfHxcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzggfHxcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09EQUJBUiB8fFxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzM5IHx8XG4gICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkNPREVfOTMgfHxcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09ERV8xMjggfHxcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuSVRGIHx8XG4gICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlJTU18xNCB8fFxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5SU1NfRVhQQU5ERUQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFB1dCAxRCByZWFkZXJzIHVwZnJvbnQgaW4gXCJub3JtYWxcIiBtb2RlXG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogVE9ETzogdW5jb21tZW50IGJlbG93IGFzIHRoZXkgYXJlIHBvcnRlZFxuICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERSkpIHtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFFSQ29kZVJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5EQVRBX01BVFJJWCkpIHtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IERhdGFNYXRyaXhSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQVpURUMpKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBBenRlY1JlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5QREZfNDE3KSkge1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUERGNDE3UmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuTUFYSUNPREUpKSB7XG4gICAgICAgICAgICAvLyAgICByZWFkZXJzLnB1c2gobmV3IE1heGlDb2RlUmVhZGVyKCkpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBBdCBlbmQgaW4gXCJ0cnkgaGFyZGVyXCIgbW9kZVxuICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMS5kZWZhdWx0KGhpbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBEYXRhTWF0cml4UmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgQXp0ZWNSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgLy8gcmVhZGVycy5wdXNoKG5ldyBNYXhpQ29kZVJlYWRlcigpKVxuICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7IC8vIC50b0FycmF5KG5ldyBSZWFkZXJbcmVhZGVycy5zaXplKCldKVxuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIE11bHRpRm9ybWF0UmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmICh0aGlzLnJlYWRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnJlYWRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICovXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLmRlY29kZUludGVybmFsID0gZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAodGhpcy5yZWFkZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVhZGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gcmVhZGVycyB3aGVyZSBzZWxlY3RlZCwgbm90aGluZyBjYW4gYmUgcmVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnJlYWRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFRyeWluZyB0byBkZWNvZGUgd2l0aCAke3JlYWRlcn0gcmVhZGVyLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZGVjb2RlKGltYWdlLCB0aGlzLmhpbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFJlYWRlckV4Y2VwdGlvbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhZCBFeGNlcHRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gTXVsdGlGb3JtYXQgUmVhZGVycyB3ZXJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjb2RlLicpO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpRm9ybWF0UmVhZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpRm9ybWF0UmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import DataMatrixWriter from './datamatrix/DataMatrixWriter'\n// import CodaBarWriter from './oned/CodaBarWriter'\n// import Code128Writer from './oned/Code128Writer'\n// import Code39Writer from './oned/Code39Writer'\n// import Code93Writer from './oned/Code93Writer'\n// import EAN13Writer from './oned/EAN13Writer'\n// import EAN8Writer from './oned/EAN8Writer'\n// import ITFWriter from './oned/ITFWriter'\n// import UPCAWriter from './oned/UPCAWriter'\n// import UPCEWriter from './oned/UPCEWriter'\n// import PDF417Writer from './pdf417/PDF417Writer'\nvar QRCodeWriter_1 = __webpack_require__(/*! ./qrcode/QRCodeWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js\");\nvar BarcodeFormat_1 = __webpack_require__(/*! ./BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/*import java.util.Map;*/\n/**\n * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat\n * requested and encodes the barcode with the supplied contents.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar MultiFormatWriter = /** @class */ (function () {\n    function MultiFormatWriter() {\n    }\n    /*@Override*/\n    // public encode(contents: string,\n    //                         format: BarcodeFormat,\n    //                         width: number /*int*/,\n    //                         height: number /*int*/): BitMatrix /*throws WriterException */ {\n    //   return encode(contents, format, width, height, null)\n    // }\n    /*@Override*/\n    MultiFormatWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n        var writer;\n        switch (format) {\n            // case BarcodeFormat.EAN_8:\n            //   writer = new EAN8Writer()\n            //   break\n            // case BarcodeFormat.UPC_E:\n            //   writer = new UPCEWriter()\n            //   break\n            // case BarcodeFormat.EAN_13:\n            //   writer = new EAN13Writer()\n            //   break\n            // case BarcodeFormat.UPC_A:\n            //   writer = new UPCAWriter()\n            //   break\n            case BarcodeFormat_1.default.QR_CODE:\n                writer = new QRCodeWriter_1.default();\n                break;\n            // case BarcodeFormat.CODE_39:\n            //   writer = new Code39Writer()\n            //   break\n            // case BarcodeFormat.CODE_93:\n            //   writer = new Code93Writer()\n            //   break\n            // case BarcodeFormat.CODE_128:\n            //   writer = new Code128Writer()\n            //   break\n            // case BarcodeFormat.ITF:\n            //   writer = new ITFWriter()\n            //   break\n            // case BarcodeFormat.PDF_417:\n            //   writer = new PDF417Writer()\n            //   break\n            // case BarcodeFormat.CODABAR:\n            //   writer = new CodaBarWriter()\n            //   break\n            // case BarcodeFormat.DATA_MATRIX:\n            //   writer = new DataMatrixWriter()\n            //   break\n            // case BarcodeFormat.AZTEC:\n            //   writer = new AztecWriter()\n            //   break\n            default:\n                throw new IllegalArgumentException_1.default('No encoder available for format ' + format);\n        }\n        return writer.encode(contents, format, width, height, hints);\n    };\n    return MultiFormatWriter;\n}());\nexports[\"default\"] = MultiFormatWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9NdWx0aUZvcm1hdFdyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsdUpBQXVCO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLDJJQUFpQjtBQUMvQyxpQ0FBaUMsbUJBQU8sQ0FBQyxpS0FBNEI7QUFDckUsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvTXVsdGlGb3JtYXRXcml0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCBEYXRhTWF0cml4V3JpdGVyIGZyb20gJy4vZGF0YW1hdHJpeC9EYXRhTWF0cml4V3JpdGVyJ1xuLy8gaW1wb3J0IENvZGFCYXJXcml0ZXIgZnJvbSAnLi9vbmVkL0NvZGFCYXJXcml0ZXInXG4vLyBpbXBvcnQgQ29kZTEyOFdyaXRlciBmcm9tICcuL29uZWQvQ29kZTEyOFdyaXRlcidcbi8vIGltcG9ydCBDb2RlMzlXcml0ZXIgZnJvbSAnLi9vbmVkL0NvZGUzOVdyaXRlcidcbi8vIGltcG9ydCBDb2RlOTNXcml0ZXIgZnJvbSAnLi9vbmVkL0NvZGU5M1dyaXRlcidcbi8vIGltcG9ydCBFQU4xM1dyaXRlciBmcm9tICcuL29uZWQvRUFOMTNXcml0ZXInXG4vLyBpbXBvcnQgRUFOOFdyaXRlciBmcm9tICcuL29uZWQvRUFOOFdyaXRlcidcbi8vIGltcG9ydCBJVEZXcml0ZXIgZnJvbSAnLi9vbmVkL0lURldyaXRlcidcbi8vIGltcG9ydCBVUENBV3JpdGVyIGZyb20gJy4vb25lZC9VUENBV3JpdGVyJ1xuLy8gaW1wb3J0IFVQQ0VXcml0ZXIgZnJvbSAnLi9vbmVkL1VQQ0VXcml0ZXInXG4vLyBpbXBvcnQgUERGNDE3V3JpdGVyIGZyb20gJy4vcGRmNDE3L1BERjQxN1dyaXRlcidcbnZhciBRUkNvZGVXcml0ZXJfMSA9IHJlcXVpcmUoXCIuL3FyY29kZS9RUkNvZGVXcml0ZXJcIik7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbi8qKlxuICogVGhpcyBpcyBhIGZhY3RvcnkgY2xhc3Mgd2hpY2ggZmluZHMgdGhlIGFwcHJvcHJpYXRlIFdyaXRlciBzdWJjbGFzcyBmb3IgdGhlIEJhcmNvZGVGb3JtYXRcbiAqIHJlcXVlc3RlZCBhbmQgZW5jb2RlcyB0aGUgYmFyY29kZSB3aXRoIHRoZSBzdXBwbGllZCBjb250ZW50cy5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICovXG52YXIgTXVsdGlGb3JtYXRXcml0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlGb3JtYXRXcml0ZXIoKSB7XG4gICAgfVxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICAvLyBwdWJsaWMgZW5jb2RlKGNvbnRlbnRzOiBzdHJpbmcsXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBudW1iZXIgLyppbnQqLyxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bWJlciAvKmludCovKTogQml0TWF0cml4IC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiAqLyB7XG4gICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXG4gICAgLy8gfVxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBNdWx0aUZvcm1hdFdyaXRlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICB2YXIgd3JpdGVyO1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkVBTl84OlxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRUFOOFdyaXRlcigpXG4gICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0U6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBVUENFV3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fMTM6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBFQU4xM1dyaXRlcigpXG4gICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0E6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBVUENBV3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERTpcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSBuZXcgUVJDb2RlV3JpdGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMzk6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RlMzlXcml0ZXIoKVxuICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfOTM6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RlOTNXcml0ZXIoKVxuICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMTI4OlxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTEyOFdyaXRlcigpXG4gICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuSVRGOlxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgSVRGV3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5QREZfNDE3OlxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgUERGNDE3V3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RBQkFSOlxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kYUJhcldyaXRlcigpXG4gICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVg6XG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBEYXRhTWF0cml4V3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5BWlRFQzpcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEF6dGVjV3JpdGVyKClcbiAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05vIGVuY29kZXIgYXZhaWxhYmxlIGZvciBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpRm9ybWF0V3JpdGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpRm9ybWF0V3JpdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar NotFoundException = /** @class */ (function (_super) {\n    __extends(NotFoundException, _super);\n    function NotFoundException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NotFoundException.getNotFoundInstance = function () {\n        return new NotFoundException();\n    };\n    NotFoundException.kind = 'NotFoundException';\n    return NotFoundException;\n}(Exception_1.default));\nexports[\"default\"] = NotFoundException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Ob3RGb3VuZEV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL05vdEZvdW5kRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RGb3VuZEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RGb3VuZEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgfTtcbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5raW5kID0gJ05vdEZvdW5kRXhjZXB0aW9uJztcbiAgICByZXR1cm4gTm90Rm91bmRFeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vdEZvdW5kRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NullPointerException.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NullPointerException.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar NullPointerException = /** @class */ (function (_super) {\n    __extends(NullPointerException, _super);\n    function NullPointerException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NullPointerException.kind = 'NullPointerException';\n    return NullPointerException;\n}(Exception_1.default));\nexports[\"default\"] = NullPointerException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9OdWxsUG9pbnRlckV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL051bGxQb2ludGVyRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIE51bGxQb2ludGVyRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsUG9pbnRlckV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdWxsUG9pbnRlckV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOdWxsUG9pbnRlckV4Y2VwdGlvbi5raW5kID0gJ051bGxQb2ludGVyRXhjZXB0aW9uJztcbiAgICByZXR1cm4gTnVsbFBvaW50ZXJFeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE51bGxQb2ludGVyRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NullPointerException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar OutOfMemoryError = /** @class */ (function (_super) {\n    __extends(OutOfMemoryError, _super);\n    function OutOfMemoryError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return OutOfMemoryError;\n}(Exception_1.default));\nexports[\"default\"] = OutOfMemoryError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9PdXRPZk1lbW9yeUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsbUlBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL091dE9mTWVtb3J5RXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgT3V0T2ZNZW1vcnlFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0T2ZNZW1vcnlFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRPZk1lbW9yeUVycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBPdXRPZk1lbW9yeUVycm9yO1xufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBPdXRPZk1lbW9yeUVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\nvar System_1 = __webpack_require__(/*! ./util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\");\nvar InvertedLuminanceSource_1 = __webpack_require__(/*! ./InvertedLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * This object extends LuminanceSource around an array of YUV data returned from the camera driver,\n * with the option to crop to a rectangle within the full data. This can be used to exclude\n * superfluous pixels around the perimeter and speed up decoding.\n *\n * It works for any pixel format where the Y channel is planar and appears first, including\n * YCbCr_420_SP and YCbCr_422_SP.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar PlanarYUVLuminanceSource = /** @class */ (function (_super) {\n    __extends(PlanarYUVLuminanceSource, _super);\n    function PlanarYUVLuminanceSource(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {\n        var _this = _super.call(this, width, height) || this;\n        _this.yuvData = yuvData;\n        _this.dataWidth = dataWidth;\n        _this.dataHeight = dataHeight;\n        _this.left = left;\n        _this.top = top;\n        if (left + width > dataWidth || top + height > dataHeight) {\n            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');\n        }\n        if (reverseHorizontal) {\n            _this.reverseHorizontal(width, height);\n        }\n        return _this;\n    }\n    /*@Override*/\n    PlanarYUVLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n        if (y < 0 || y >= this.getHeight()) {\n            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);\n        }\n        var width = this.getWidth();\n        if (row === null || row === undefined || row.length < width) {\n            row = new Uint8ClampedArray(width);\n        }\n        var offset = (y + this.top) * this.dataWidth + this.left;\n        System_1.default.arraycopy(this.yuvData, offset, row, 0, width);\n        return row;\n    };\n    /*@Override*/\n    PlanarYUVLuminanceSource.prototype.getMatrix = function () {\n        var width = this.getWidth();\n        var height = this.getHeight();\n        // If the caller asks for the entire underlying image, save the copy and give them the\n        // original data. The docs specifically warn that result.length must be ignored.\n        if (width === this.dataWidth && height === this.dataHeight) {\n            return this.yuvData;\n        }\n        var area = width * height;\n        var matrix = new Uint8ClampedArray(area);\n        var inputOffset = this.top * this.dataWidth + this.left;\n        // If the width matches the full width of the underlying data, perform a single copy.\n        if (width === this.dataWidth) {\n            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, 0, area);\n            return matrix;\n        }\n        // Otherwise copy one cropped row at a time.\n        for (var y = 0; y < height; y++) {\n            var outputOffset = y * width;\n            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);\n            inputOffset += this.dataWidth;\n        }\n        return matrix;\n    };\n    /*@Override*/\n    PlanarYUVLuminanceSource.prototype.isCropSupported = function () {\n        return true;\n    };\n    /*@Override*/\n    PlanarYUVLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);\n    };\n    PlanarYUVLuminanceSource.prototype.renderThumbnail = function () {\n        var width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        var height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        var pixels = new Int32Array(width * height);\n        var yuv = this.yuvData;\n        var inputOffset = this.top * this.dataWidth + this.left;\n        for (var y = 0; y < height; y++) {\n            var outputOffset = y * width;\n            for (var x = 0; x < width; x++) {\n                var grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;\n                pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);\n            }\n            inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        return pixels;\n    };\n    /**\n     * @return width of image from {@link #renderThumbnail()}\n     */\n    PlanarYUVLuminanceSource.prototype.getThumbnailWidth = function () {\n        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n    };\n    /**\n     * @return height of image from {@link #renderThumbnail()}\n     */\n    PlanarYUVLuminanceSource.prototype.getThumbnailHeight = function () {\n        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n    };\n    PlanarYUVLuminanceSource.prototype.reverseHorizontal = function (width /*int*/, height /*int*/) {\n        var yuvData = this.yuvData;\n        for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {\n            var middle = rowStart + width / 2;\n            for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {\n                var temp = yuvData[x1];\n                yuvData[x1] = yuvData[x2];\n                yuvData[x2] = temp;\n            }\n        }\n    };\n    PlanarYUVLuminanceSource.prototype.invert = function () {\n        return new InvertedLuminanceSource_1.default(this);\n    };\n    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;\n    return PlanarYUVLuminanceSource;\n}(LuminanceSource_1.default));\nexports[\"default\"] = PlanarYUVLuminanceSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9QbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHVJQUFlO0FBQ3RDLHdCQUF3QixtQkFBTyxDQUFDLCtJQUFtQjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQywrSkFBMkI7QUFDbkUsaUNBQWlDLG1CQUFPLENBQUMsaUtBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0EsK0RBQStELGFBQWE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9QbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3V0aWwvU3lzdGVtXCIpO1xudmFyIEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vTHVtaW5hbmNlU291cmNlXCIpO1xudmFyIEludmVydGVkTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZVwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qKlxuICogVGhpcyBvYmplY3QgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2UgYXJvdW5kIGFuIGFycmF5IG9mIFlVViBkYXRhIHJldHVybmVkIGZyb20gdGhlIGNhbWVyYSBkcml2ZXIsXG4gKiB3aXRoIHRoZSBvcHRpb24gdG8gY3JvcCB0byBhIHJlY3RhbmdsZSB3aXRoaW4gdGhlIGZ1bGwgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCB0byBleGNsdWRlXG4gKiBzdXBlcmZsdW91cyBwaXhlbHMgYXJvdW5kIHRoZSBwZXJpbWV0ZXIgYW5kIHNwZWVkIHVwIGRlY29kaW5nLlxuICpcbiAqIEl0IHdvcmtzIGZvciBhbnkgcGl4ZWwgZm9ybWF0IHdoZXJlIHRoZSBZIGNoYW5uZWwgaXMgcGxhbmFyIGFuZCBhcHBlYXJzIGZpcnN0LCBpbmNsdWRpbmdcbiAqIFlDYkNyXzQyMF9TUCBhbmQgWUNiQ3JfNDIyX1NQLlxuICpcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gKi9cbnZhciBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UoeXV2RGF0YSwgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHJldmVyc2VIb3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnl1dkRhdGEgPSB5dXZEYXRhO1xuICAgICAgICBfdGhpcy5kYXRhV2lkdGggPSBkYXRhV2lkdGg7XG4gICAgICAgIF90aGlzLmRhdGFIZWlnaHQgPSBkYXRhSGVpZ2h0O1xuICAgICAgICBfdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgX3RoaXMudG9wID0gdG9wO1xuICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gZGF0YVdpZHRoIHx8IHRvcCArIGhlaWdodCA+IGRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdDcm9wIHJlY3RhbmdsZSBkb2VzIG5vdCBmaXQgd2l0aGluIGltYWdlIGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldmVyc2VIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXZlcnNlSG9yaXpvbnRhbCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCByb3cubGVuZ3RoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9ICh5ICsgdGhpcy50b3ApICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgb2Zmc2V0LCByb3csIDAsIHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgZGF0YS4gVGhlIGRvY3Mgc3BlY2lmaWNhbGx5IHdhcm4gdGhhdCByZXN1bHQubGVuZ3RoIG11c3QgYmUgaWdub3JlZC5cbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueXV2RGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZWEpO1xuICAgICAgICB2YXIgaW5wdXRPZmZzZXQgPSB0aGlzLnRvcCAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGgpIHtcbiAgICAgICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgMCwgYXJlYSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBjb3B5IG9uZSBjcm9wcGVkIHJvdyBhdCBhIHRpbWUuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weSh0aGlzLnl1dkRhdGEsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIG91dHB1dE9mZnNldCwgd2lkdGgpO1xuICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlKHRoaXMueXV2RGF0YSwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3AsIHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcbiAgICB9O1xuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucmVuZGVyVGh1bWJuYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgdmFyIHBpeGVscyA9IG5ldyBJbnQzMkFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgdmFyIHl1diA9IHRoaXMueXV2RGF0YTtcbiAgICAgICAgdmFyIGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBncmV5ID0geXV2W2lucHV0T2Zmc2V0ICsgeCAqIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW291dHB1dE9mZnNldCArIHhdID0gMHhGRjAwMDAwMCB8IChncmV5ICogMHgwMDAxMDEwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aCAqIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHdpZHRoIG9mIGltYWdlIGZyb20ge0BsaW5rICNyZW5kZXJUaHVtYm5haWwoKX1cbiAgICAgKi9cbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFRodW1ibmFpbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpIC8gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGhlaWdodCBvZiBpbWFnZSBmcm9tIHtAbGluayAjcmVuZGVyVGh1bWJuYWlsKCl9XG4gICAgICovXG4gICAgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRUaHVtYm5haWxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlaWdodCgpIC8gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1I7XG4gICAgfTtcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJldmVyc2VIb3Jpem9udGFsID0gZnVuY3Rpb24gKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgIHZhciB5dXZEYXRhID0gdGhpcy55dXZEYXRhO1xuICAgICAgICBmb3IgKHZhciB5ID0gMCwgcm93U3RhcnQgPSB0aGlzLnRvcCAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0OyB5IDwgaGVpZ2h0OyB5KyssIHJvd1N0YXJ0ICs9IHRoaXMuZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gcm93U3RhcnQgKyB3aWR0aCAvIDI7XG4gICAgICAgICAgICBmb3IgKHZhciB4MSA9IHJvd1N0YXJ0LCB4MiA9IHJvd1N0YXJ0ICsgd2lkdGggLSAxOyB4MSA8IG1pZGRsZTsgeDErKywgeDItLSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0geXV2RGF0YVt4MV07XG4gICAgICAgICAgICAgICAgeXV2RGF0YVt4MV0gPSB5dXZEYXRhW3gyXTtcbiAgICAgICAgICAgICAgICB5dXZEYXRhW3gyXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCh0aGlzKTtcbiAgICB9O1xuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SID0gMjtcbiAgICByZXR1cm4gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlO1xufShMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\n__webpack_require__(/*! ./InvertedLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\"); // required because of circular dependencies between LuminanceSource and InvertedLuminanceSource\nvar InvertedLuminanceSource_1 = __webpack_require__(/*! ./InvertedLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\");\nvar LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\");\nvar System_1 = __webpack_require__(/*! ./util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * This class is used to help decode images from files which arrive as RGB data from\n * an ARGB pixel array. It does not support rotation.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Betaminos\n */\nvar RGBLuminanceSource = /** @class */ (function (_super) {\n    __extends(RGBLuminanceSource, _super);\n    function RGBLuminanceSource(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {\n        var _this = _super.call(this, width, height) || this;\n        _this.dataWidth = dataWidth;\n        _this.dataHeight = dataHeight;\n        _this.left = left;\n        _this.top = top;\n        if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array\n            var size = width * height;\n            var luminancesUint8Array = new Uint8ClampedArray(size);\n            for (var offset = 0; offset < size; offset++) {\n                var pixel = luminances[offset];\n                var r = (pixel >> 16) & 0xff; // red\n                var g2 = (pixel >> 7) & 0x1fe; // 2 * green\n                var b = pixel & 0xff; // blue\n                // Calculate green-favouring average cheaply\n                luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;\n            }\n            _this.luminances = luminancesUint8Array;\n        }\n        else {\n            _this.luminances = luminances;\n        }\n        if (undefined === dataWidth) {\n            _this.dataWidth = width;\n        }\n        if (undefined === dataHeight) {\n            _this.dataHeight = height;\n        }\n        if (undefined === left) {\n            _this.left = 0;\n        }\n        if (undefined === top) {\n            _this.top = 0;\n        }\n        if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {\n            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');\n        }\n        return _this;\n    }\n    /*@Override*/\n    RGBLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n        if (y < 0 || y >= this.getHeight()) {\n            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);\n        }\n        var width = this.getWidth();\n        if (row === null || row === undefined || row.length < width) {\n            row = new Uint8ClampedArray(width);\n        }\n        var offset = (y + this.top) * this.dataWidth + this.left;\n        System_1.default.arraycopy(this.luminances, offset, row, 0, width);\n        return row;\n    };\n    /*@Override*/\n    RGBLuminanceSource.prototype.getMatrix = function () {\n        var width = this.getWidth();\n        var height = this.getHeight();\n        // If the caller asks for the entire underlying image, save the copy and give them the\n        // original data. The docs specifically warn that result.length must be ignored.\n        if (width === this.dataWidth && height === this.dataHeight) {\n            return this.luminances;\n        }\n        var area = width * height;\n        var matrix = new Uint8ClampedArray(area);\n        var inputOffset = this.top * this.dataWidth + this.left;\n        // If the width matches the full width of the underlying data, perform a single copy.\n        if (width === this.dataWidth) {\n            System_1.default.arraycopy(this.luminances, inputOffset, matrix, 0, area);\n            return matrix;\n        }\n        // Otherwise copy one cropped row at a time.\n        for (var y = 0; y < height; y++) {\n            var outputOffset = y * width;\n            System_1.default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);\n            inputOffset += this.dataWidth;\n        }\n        return matrix;\n    };\n    /*@Override*/\n    RGBLuminanceSource.prototype.isCropSupported = function () {\n        return true;\n    };\n    /*@Override*/\n    RGBLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);\n    };\n    RGBLuminanceSource.prototype.invert = function () {\n        return new InvertedLuminanceSource_1.default(this);\n    };\n    return RGBLuminanceSource;\n}(LuminanceSource_1.default));\nexports[\"default\"] = RGBLuminanceSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SR0JMdW1pbmFuY2VTb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsbUJBQU8sQ0FBQywrSkFBMkIsR0FBRztBQUN0QyxnQ0FBZ0MsbUJBQU8sQ0FBQywrSkFBMkI7QUFDbkUsd0JBQXdCLG1CQUFPLENBQUMsK0lBQW1CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyx1SUFBZTtBQUN0QyxpQ0FBaUMsbUJBQU8sQ0FBQyxpS0FBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBLDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0Msc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvUkdCTHVtaW5hbmNlU291cmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG5yZXF1aXJlKFwiLi9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZVwiKTsgLy8gcmVxdWlyZWQgYmVjYXVzZSBvZiBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBMdW1pbmFuY2VTb3VyY2UgYW5kIEludmVydGVkTHVtaW5hbmNlU291cmNlXG52YXIgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0ludmVydGVkTHVtaW5hbmNlU291cmNlXCIpO1xudmFyIEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vTHVtaW5hbmNlU291cmNlXCIpO1xudmFyIFN5c3RlbV8xID0gcmVxdWlyZShcIi4vdXRpbC9TeXN0ZW1cIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBoZWxwIGRlY29kZSBpbWFnZXMgZnJvbSBmaWxlcyB3aGljaCBhcnJpdmUgYXMgUkdCIGRhdGEgZnJvbVxuICogYW4gQVJHQiBwaXhlbCBhcnJheS4gSXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICogQGF1dGhvciBCZXRhbWlub3NcbiAqL1xudmFyIFJHQkx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUkdCTHVtaW5hbmNlU291cmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJHQkx1bWluYW5jZVNvdXJjZShsdW1pbmFuY2VzLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhV2lkdGggPSBkYXRhV2lkdGg7XG4gICAgICAgIF90aGlzLmRhdGFIZWlnaHQgPSBkYXRhSGVpZ2h0O1xuICAgICAgICBfdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgX3RoaXMudG9wID0gdG9wO1xuICAgICAgICBpZiAobHVtaW5hbmNlcy5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkgeyAvLyBJbnQzMkFycmF5XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgc2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBsdW1pbmFuY2VzW29mZnNldF07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAocGl4ZWwgPj4gMTYpICYgMHhmZjsgLy8gcmVkXG4gICAgICAgICAgICAgICAgdmFyIGcyID0gKHBpeGVsID4+IDcpICYgMHgxZmU7IC8vIDIgKiBncmVlblxuICAgICAgICAgICAgICAgIHZhciBiID0gcGl4ZWwgJiAweGZmOyAvLyBibHVlXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGdyZWVuLWZhdm91cmluZyBhdmVyYWdlIGNoZWFwbHlcbiAgICAgICAgICAgICAgICBsdW1pbmFuY2VzVWludDhBcnJheVtvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChyICsgZzIgKyBiKSAvIDQpICYgMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzVWludDhBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFXaWR0aCkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YVdpZHRoID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBsZWZ0KSB7XG4gICAgICAgICAgICBfdGhpcy5sZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0b3ApIHtcbiAgICAgICAgICAgIF90aGlzLnRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmxlZnQgKyB3aWR0aCA+IF90aGlzLmRhdGFXaWR0aCB8fCBfdGhpcy50b3AgKyBoZWlnaHQgPiBfdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQ3JvcCByZWN0YW5nbGUgZG9lcyBub3QgZml0IHdpdGhpbiBpbWFnZSBkYXRhLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFJHQkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgIGlmICh5IDwgMCB8fCB5ID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdSZXF1ZXN0ZWQgcm93IGlzIG91dHNpZGUgdGhlIGltYWdlOiAnICsgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gKHkgKyB0aGlzLnRvcCkgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBvZmZzZXQsIHJvdywgMCwgd2lkdGgpO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFJHQkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCBkYXRhLiBUaGUgZG9jcyBzcGVjaWZpY2FsbHkgd2FybiB0aGF0IHJlc3VsdC5sZW5ndGggbXVzdCBiZSBpZ25vcmVkLlxuICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJlYSk7XG4gICAgICAgIHZhciBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgIC8vIElmIHRoZSB3aWR0aCBtYXRjaGVzIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEsIHBlcmZvcm0gYSBzaW5nbGUgY29weS5cbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCkge1xuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBpbnB1dE9mZnNldCwgbWF0cml4LCAwLCBhcmVhKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvcHkgb25lIGNyb3BwZWQgcm93IGF0IGEgdGltZS5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRoaXMubHVtaW5hbmNlcywgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XG4gICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFJHQkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBSR0JMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JMdW1pbmFuY2VTb3VyY2UodGhpcy5sdW1pbmFuY2VzLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmRhdGFXaWR0aCwgdGhpcy5kYXRhSGVpZ2h0LCB0aGlzLmxlZnQgKyBsZWZ0LCB0aGlzLnRvcCArIHRvcCk7XG4gICAgfTtcbiAgICBSR0JMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZV8xLmRlZmF1bHQodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUkdCTHVtaW5hbmNlU291cmNlO1xufShMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSR0JMdW1pbmFuY2VTb3VyY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReaderException.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReaderException.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ReaderException = /** @class */ (function (_super) {\n    __extends(ReaderException, _super);\n    function ReaderException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReaderException.kind = 'ReaderException';\n    return ReaderException;\n}(Exception_1.default));\nexports[\"default\"] = ReaderException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZWFkZXJFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtSUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZWFkZXJFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgUmVhZGVyRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkZXJFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZGVyRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlYWRlckV4Y2VwdGlvbi5raW5kID0gJ1JlYWRlckV4Y2VwdGlvbic7XG4gICAgcmV0dXJuIFJlYWRlckV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVhZGVyRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReaderException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReedSolomonException.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReedSolomonException.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar ReedSolomonException = /** @class */ (function (_super) {\n    __extends(ReedSolomonException, _super);\n    function ReedSolomonException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ReedSolomonException.kind = 'ReedSolomonException';\n    return ReedSolomonException;\n}(Exception_1.default));\nexports[\"default\"] = ReedSolomonException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZWVkU29sb21vbkV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL1JlZWRTb2xvbW9uRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIFJlZWRTb2xvbW9uRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWVkU29sb21vbkV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWVkU29sb21vbkV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWVkU29sb21vbkV4Y2VwdGlvbi5raW5kID0gJ1JlZWRTb2xvbW9uRXhjZXB0aW9uJztcbiAgICByZXR1cm4gUmVlZFNvbG9tb25FeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZWRTb2xvbW9uRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReedSolomonException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar System_1 = __webpack_require__(/*! ./util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\n/**\n * <p>Encapsulates the result of decoding a barcode within an image.</p>\n *\n * @author Sean Owen\n */\nvar Result = /** @class */ (function () {\n    // public constructor(private text: string,\n    //               Uint8Array rawBytes,\n    //               ResultPoconst resultPoints: Int32Array,\n    //               BarcodeFormat format) {\n    //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n    // }\n    // public constructor(text: string,\n    //               Uint8Array rawBytes,\n    //               ResultPoconst resultPoints: Int32Array,\n    //               BarcodeFormat format,\n    //               long timestamp) {\n    //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n    //        resultPoints, format, timestamp)\n    // }\n    function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {\n        if (numBits === void 0) { numBits = rawBytes == null ? 0 : 8 * rawBytes.length; }\n        if (timestamp === void 0) { timestamp = System_1.default.currentTimeMillis(); }\n        this.text = text;\n        this.rawBytes = rawBytes;\n        this.numBits = numBits;\n        this.resultPoints = resultPoints;\n        this.format = format;\n        this.timestamp = timestamp;\n        this.text = text;\n        this.rawBytes = rawBytes;\n        if (undefined === numBits || null === numBits) {\n            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;\n        }\n        else {\n            this.numBits = numBits;\n        }\n        this.resultPoints = resultPoints;\n        this.format = format;\n        this.resultMetadata = null;\n        if (undefined === timestamp || null === timestamp) {\n            this.timestamp = System_1.default.currentTimeMillis();\n        }\n        else {\n            this.timestamp = timestamp;\n        }\n    }\n    /**\n     * @return raw text encoded by the barcode\n     */\n    Result.prototype.getText = function () {\n        return this.text;\n    };\n    /**\n     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n     */\n    Result.prototype.getRawBytes = function () {\n        return this.rawBytes;\n    };\n    /**\n     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n     * @since 3.3.0\n     */\n    Result.prototype.getNumBits = function () {\n        return this.numBits;\n    };\n    /**\n     * @return points related to the barcode in the image. These are typically points\n     *         identifying finder patterns or the corners of the barcode. The exact meaning is\n     *         specific to the type of barcode that was decoded.\n     */\n    Result.prototype.getResultPoints = function () {\n        return this.resultPoints;\n    };\n    /**\n     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n     */\n    Result.prototype.getBarcodeFormat = function () {\n        return this.format;\n    };\n    /**\n     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n     *   {@code null}. This contains optional metadata about what was detected about the barcode,\n     *   like orientation.\n     */\n    Result.prototype.getResultMetadata = function () {\n        return this.resultMetadata;\n    };\n    Result.prototype.putMetadata = function (type, value) {\n        if (this.resultMetadata === null) {\n            this.resultMetadata = new Map();\n        }\n        this.resultMetadata.set(type, value);\n    };\n    Result.prototype.putAllMetadata = function (metadata) {\n        if (metadata !== null) {\n            if (this.resultMetadata === null) {\n                this.resultMetadata = metadata;\n            }\n            else {\n                this.resultMetadata = new Map(metadata);\n            }\n        }\n    };\n    Result.prototype.addResultPoints = function (newPoints) {\n        var oldPoints = this.resultPoints;\n        if (oldPoints === null) {\n            this.resultPoints = newPoints;\n        }\n        else if (newPoints !== null && newPoints.length > 0) {\n            var allPoints = new Array(oldPoints.length + newPoints.length);\n            System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n            System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n            this.resultPoints = allPoints;\n        }\n    };\n    Result.prototype.getTimestamp = function () {\n        return this.timestamp;\n    };\n    /*@Override*/\n    Result.prototype.toString = function () {\n        return this.text;\n    };\n    return Result;\n}());\nexports[\"default\"] = Result;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLHVJQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0IsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsU0FBUywwQkFBMEI7QUFDOUQsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvUmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi91dGlsL1N5c3RlbVwiKTtcbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBiYXJjb2RlIHdpdGhpbiBhbiBpbWFnZS48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIFJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSB0ZXh0OiBzdHJpbmcsXG4gICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLFxuICAgIC8vICAgICAgICAgICAgICAgUmVzdWx0UG9jb25zdCByZXN1bHRQb2ludHM6IEludDMyQXJyYXksXG4gICAgLy8gICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0IGZvcm1hdCkge1xuICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKVxuICAgIC8vIH1cbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IodGV4dDogc3RyaW5nLFxuICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcyxcbiAgICAvLyAgICAgICAgICAgICAgIFJlc3VsdFBvY29uc3QgcmVzdWx0UG9pbnRzOiBJbnQzMkFycmF5LFxuICAgIC8vICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCBmb3JtYXQsXG4gICAgLy8gICAgICAgICAgICAgICBsb25nIHRpbWVzdGFtcCkge1xuICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoLFxuICAgIC8vICAgICAgICByZXN1bHRQb2ludHMsIGZvcm1hdCwgdGltZXN0YW1wKVxuICAgIC8vIH1cbiAgICBmdW5jdGlvbiBSZXN1bHQodGV4dCwgcmF3Qnl0ZXMsIG51bUJpdHMsIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IHZvaWQgMCkgeyBudW1CaXRzID0gcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoOyB9XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPT09IHZvaWQgMCkgeyB0aW1lc3RhbXAgPSBTeXN0ZW1fMS5kZWZhdWx0LmN1cnJlbnRUaW1lTWlsbGlzKCk7IH1cbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xuICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IHJlc3VsdFBvaW50cztcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG51bUJpdHMgfHwgbnVsbCA9PT0gbnVtQml0cykge1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gKHJhd0J5dGVzID09PSBudWxsIHx8IHJhd0J5dGVzID09PSB1bmRlZmluZWQpID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRpbWVzdGFtcCB8fCBudWxsID09PSB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gU3lzdGVtXzEuZGVmYXVsdC5jdXJyZW50VGltZU1pbGxpcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiByYXcgdGV4dCBlbmNvZGVkIGJ5IHRoZSBiYXJjb2RlXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiByYXcgYnl0ZXMgZW5jb2RlZCBieSB0aGUgYmFyY29kZSwgaWYgYXBwbGljYWJsZSwgb3RoZXJ3aXNlIHtAY29kZSBudWxsfVxuICAgICAqL1xuICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0UmF3Qnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBob3cgbWFueSBiaXRzIG9mIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0gYXJlIHZhbGlkOyB0eXBpY2FsbHkgOCB0aW1lcyBpdHMgbGVuZ3RoXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXROdW1CaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBwb2ludHMgcmVsYXRlZCB0byB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoZXNlIGFyZSB0eXBpY2FsbHkgcG9pbnRzXG4gICAgICogICAgICAgICBpZGVudGlmeWluZyBmaW5kZXIgcGF0dGVybnMgb3IgdGhlIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUuIFRoZSBleGFjdCBtZWFuaW5nIGlzXG4gICAgICogICAgICAgICBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWQuXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXRSZXN1bHRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0BsaW5rIEJhcmNvZGVGb3JtYXR9IHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIHRoZSBiYXJjb2RlIHRoYXQgd2FzIGRlY29kZWRcbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLmdldEJhcmNvZGVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0BsaW5rIE1hcH0gbWFwcGluZyB7QGxpbmsgUmVzdWx0TWV0YWRhdGFUeXBlfSBrZXlzIHRvIHZhbHVlcy4gTWF5IGJlXG4gICAgICogICB7QGNvZGUgbnVsbH0uIFRoaXMgY29udGFpbnMgb3B0aW9uYWwgbWV0YWRhdGEgYWJvdXQgd2hhdCB3YXMgZGV0ZWN0ZWQgYWJvdXQgdGhlIGJhcmNvZGUsXG4gICAgICogICBsaWtlIG9yaWVudGF0aW9uLlxuICAgICAqL1xuICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0UmVzdWx0TWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdE1ldGFkYXRhO1xuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5wdXRNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRNZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBSZXN1bHQucHJvdG90eXBlLnB1dEFsbE1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0TWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbmV3IE1hcChtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3VsdC5wcm90b3R5cGUuYWRkUmVzdWx0UG9pbnRzID0gZnVuY3Rpb24gKG5ld1BvaW50cykge1xuICAgICAgICB2YXIgb2xkUG9pbnRzID0gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgIGlmIChvbGRQb2ludHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1BvaW50cyAhPT0gbnVsbCAmJiBuZXdQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGFsbFBvaW50cyA9IG5ldyBBcnJheShvbGRQb2ludHMubGVuZ3RoICsgbmV3UG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShvbGRQb2ludHMsIDAsIGFsbFBvaW50cywgMCwgb2xkUG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShuZXdQb2ludHMsIDAsIGFsbFBvaW50cywgb2xkUG9pbnRzLmxlbmd0aCwgbmV3UG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IGFsbFBvaW50cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\n/**\n * Represents some type of metadata about the result of the decoding that the decoder\n * wishes to communicate back to the caller.\n *\n * @author Sean Owen\n */\nvar ResultMetadataType;\n(function (ResultMetadataType) {\n    /**\n     * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.\n     */\n    ResultMetadataType[ResultMetadataType[\"OTHER\"] = 0] = \"OTHER\";\n    /**\n     * Denotes the likely approximate orientation of the barcode in the image. This value\n     * is given as degrees rotated clockwise from the normal, upright orientation.\n     * For example a 1D barcode which was found by reading top-to-bottom would be\n     * said to have orientation \"90\". This key maps to an {@link Integer} whose\n     * value is in the range [0,360).\n     */\n    ResultMetadataType[ResultMetadataType[\"ORIENTATION\"] = 1] = \"ORIENTATION\";\n    /**\n     * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'\n     * which is sometimes used to encode binary data. While {@link Result} makes available\n     * the complete raw bytes in the barcode for these formats, it does not offer the bytes\n     * from the byte segments alone.</p>\n     *\n     * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the\n     * raw bytes in the byte segments in the barcode, in order.</p>\n     */\n    ResultMetadataType[ResultMetadataType[\"BYTE_SEGMENTS\"] = 2] = \"BYTE_SEGMENTS\";\n    /**\n     * Error correction level used, if applicable. The value type depends on the\n     * format, but is typically a String.\n     */\n    ResultMetadataType[ResultMetadataType[\"ERROR_CORRECTION_LEVEL\"] = 3] = \"ERROR_CORRECTION_LEVEL\";\n    /**\n     * For some periodicals, indicates the issue number as an {@link Integer}.\n     */\n    ResultMetadataType[ResultMetadataType[\"ISSUE_NUMBER\"] = 4] = \"ISSUE_NUMBER\";\n    /**\n     * For some products, indicates the suggested retail price in the barcode as a\n     * formatted {@link String}.\n     */\n    ResultMetadataType[ResultMetadataType[\"SUGGESTED_PRICE\"] = 5] = \"SUGGESTED_PRICE\";\n    /**\n     * For some products, the possible country of manufacture as a {@link String} denoting the\n     * ISO country code. Some map to multiple possible countries, like \"US/CA\".\n     */\n    ResultMetadataType[ResultMetadataType[\"POSSIBLE_COUNTRY\"] = 6] = \"POSSIBLE_COUNTRY\";\n    /**\n     * For some products, the extension text\n     */\n    ResultMetadataType[ResultMetadataType[\"UPC_EAN_EXTENSION\"] = 7] = \"UPC_EAN_EXTENSION\";\n    /**\n     * PDF417-specific metadata\n     */\n    ResultMetadataType[ResultMetadataType[\"PDF417_EXTRA_METADATA\"] = 8] = \"PDF417_EXTRA_METADATA\";\n    /**\n     * If the code format supports structured append and the current scanned code is part of one then the\n     * sequence number is given with it.\n     */\n    ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_SEQUENCE\"] = 9] = \"STRUCTURED_APPEND_SEQUENCE\";\n    /**\n     * If the code format supports structured append and the current scanned code is part of one then the\n     * parity is given with it.\n     */\n    ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_PARITY\"] = 10] = \"STRUCTURED_APPEND_PARITY\";\n})(ResultMetadataType || (ResultMetadataType = {}));\nexports[\"default\"] = ResultMetadataType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZXN1bHRNZXRhZGF0YVR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvUmVzdWx0TWV0YWRhdGFUeXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHNvbWUgdHlwZSBvZiBtZXRhZGF0YSBhYm91dCB0aGUgcmVzdWx0IG9mIHRoZSBkZWNvZGluZyB0aGF0IHRoZSBkZWNvZGVyXG4gKiB3aXNoZXMgdG8gY29tbXVuaWNhdGUgYmFjayB0byB0aGUgY2FsbGVyLlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBSZXN1bHRNZXRhZGF0YVR5cGU7XG4oZnVuY3Rpb24gKFJlc3VsdE1ldGFkYXRhVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhZGF0YS4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBEZW5vdGVzIHRoZSBsaWtlbHkgYXBwcm94aW1hdGUgb3JpZW50YXRpb24gb2YgdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLiBUaGlzIHZhbHVlXG4gICAgICogaXMgZ2l2ZW4gYXMgZGVncmVlcyByb3RhdGVkIGNsb2Nrd2lzZSBmcm9tIHRoZSBub3JtYWwsIHVwcmlnaHQgb3JpZW50YXRpb24uXG4gICAgICogRm9yIGV4YW1wbGUgYSAxRCBiYXJjb2RlIHdoaWNoIHdhcyBmb3VuZCBieSByZWFkaW5nIHRvcC10by1ib3R0b20gd291bGQgYmVcbiAgICAgKiBzYWlkIHRvIGhhdmUgb3JpZW50YXRpb24gXCI5MFwiLiBUaGlzIGtleSBtYXBzIHRvIGFuIHtAbGluayBJbnRlZ2VyfSB3aG9zZVxuICAgICAqIHZhbHVlIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLlxuICAgICAqL1xuICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJPUklFTlRBVElPTlwiXSA9IDFdID0gXCJPUklFTlRBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIDxwPjJEIGJhcmNvZGUgZm9ybWF0cyB0eXBpY2FsbHkgZW5jb2RlIHRleHQsIGJ1dCBhbGxvdyBmb3IgYSBzb3J0IG9mICdieXRlIG1vZGUnXG4gICAgICogd2hpY2ggaXMgc29tZXRpbWVzIHVzZWQgdG8gZW5jb2RlIGJpbmFyeSBkYXRhLiBXaGlsZSB7QGxpbmsgUmVzdWx0fSBtYWtlcyBhdmFpbGFibGVcbiAgICAgKiB0aGUgY29tcGxldGUgcmF3IGJ5dGVzIGluIHRoZSBiYXJjb2RlIGZvciB0aGVzZSBmb3JtYXRzLCBpdCBkb2VzIG5vdCBvZmZlciB0aGUgYnl0ZXNcbiAgICAgKiBmcm9tIHRoZSBieXRlIHNlZ21lbnRzIGFsb25lLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgbWFwcyB0byBhIHtAbGluayBqYXZhLnV0aWwuTGlzdH0gb2YgYnl0ZSBhcnJheXMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiByYXcgYnl0ZXMgaW4gdGhlIGJ5dGUgc2VnbWVudHMgaW4gdGhlIGJhcmNvZGUsIGluIG9yZGVyLjwvcD5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiQllURV9TRUdNRU5UU1wiXSA9IDJdID0gXCJCWVRFX1NFR01FTlRTXCI7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29ycmVjdGlvbiBsZXZlbCB1c2VkLCBpZiBhcHBsaWNhYmxlLiBUaGUgdmFsdWUgdHlwZSBkZXBlbmRzIG9uIHRoZVxuICAgICAqIGZvcm1hdCwgYnV0IGlzIHR5cGljYWxseSBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiRVJST1JfQ09SUkVDVElPTl9MRVZFTFwiXSA9IDNdID0gXCJFUlJPUl9DT1JSRUNUSU9OX0xFVkVMXCI7XG4gICAgLyoqXG4gICAgICogRm9yIHNvbWUgcGVyaW9kaWNhbHMsIGluZGljYXRlcyB0aGUgaXNzdWUgbnVtYmVyIGFzIGFuIHtAbGluayBJbnRlZ2VyfS5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiSVNTVUVfTlVNQkVSXCJdID0gNF0gPSBcIklTU1VFX05VTUJFUlwiO1xuICAgIC8qKlxuICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCBpbmRpY2F0ZXMgdGhlIHN1Z2dlc3RlZCByZXRhaWwgcHJpY2UgaW4gdGhlIGJhcmNvZGUgYXMgYVxuICAgICAqIGZvcm1hdHRlZCB7QGxpbmsgU3RyaW5nfS5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1VHR0VTVEVEX1BSSUNFXCJdID0gNV0gPSBcIlNVR0dFU1RFRF9QUklDRVwiO1xuICAgIC8qKlxuICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgcG9zc2libGUgY291bnRyeSBvZiBtYW51ZmFjdHVyZSBhcyBhIHtAbGluayBTdHJpbmd9IGRlbm90aW5nIHRoZVxuICAgICAqIElTTyBjb3VudHJ5IGNvZGUuIFNvbWUgbWFwIHRvIG11bHRpcGxlIHBvc3NpYmxlIGNvdW50cmllcywgbGlrZSBcIlVTL0NBXCIuXG4gICAgICovXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlBPU1NJQkxFX0NPVU5UUllcIl0gPSA2XSA9IFwiUE9TU0lCTEVfQ09VTlRSWVwiO1xuICAgIC8qKlxuICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgZXh0ZW5zaW9uIHRleHRcbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSA3XSA9IFwiVVBDX0VBTl9FWFRFTlNJT05cIjtcbiAgICAvKipcbiAgICAgKiBQREY0MTctc3BlY2lmaWMgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiUERGNDE3X0VYVFJBX01FVEFEQVRBXCJdID0gOF0gPSBcIlBERjQxN19FWFRSQV9NRVRBREFUQVwiO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBjb2RlIGZvcm1hdCBzdXBwb3J0cyBzdHJ1Y3R1cmVkIGFwcGVuZCBhbmQgdGhlIGN1cnJlbnQgc2Nhbm5lZCBjb2RlIGlzIHBhcnQgb2Ygb25lIHRoZW4gdGhlXG4gICAgICogc2VxdWVuY2UgbnVtYmVyIGlzIGdpdmVuIHdpdGggaXQuXG4gICAgICovXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlNUUlVDVFVSRURfQVBQRU5EX1NFUVVFTkNFXCJdID0gOV0gPSBcIlNUUlVDVFVSRURfQVBQRU5EX1NFUVVFTkNFXCI7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcbiAgICAgKiBwYXJpdHkgaXMgZ2l2ZW4gd2l0aCBpdC5cbiAgICAgKi9cbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCJdID0gMTBdID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFlcIjtcbn0pKFJlc3VsdE1ldGFkYXRhVHlwZSB8fCAoUmVzdWx0TWV0YWRhdGFUeXBlID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3VsdE1ldGFkYXRhVHlwZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing {*/\nvar MathUtils_1 = __webpack_require__(/*! ./common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar Float_1 = __webpack_require__(/*! ./util/Float */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Float.js\");\n/**\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n *\n * @author Sean Owen\n */\nvar ResultPoint = /** @class */ (function () {\n    function ResultPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    ResultPoint.prototype.getX = function () {\n        return this.x;\n    };\n    ResultPoint.prototype.getY = function () {\n        return this.y;\n    };\n    /*@Override*/\n    ResultPoint.prototype.equals = function (other) {\n        if (other instanceof ResultPoint) {\n            var otherPoint = other;\n            return this.x === otherPoint.x && this.y === otherPoint.y;\n        }\n        return false;\n    };\n    /*@Override*/\n    ResultPoint.prototype.hashCode = function () {\n        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\n    };\n    /*@Override*/\n    ResultPoint.prototype.toString = function () {\n        return '(' + this.x + ',' + this.y + ')';\n    };\n    /**\n     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n     *\n     * @param patterns array of three {@code ResultPoint} to order\n     */\n    ResultPoint.orderBestPatterns = function (patterns) {\n        // Find distances between pattern centers\n        var zeroOneDistance = this.distance(patterns[0], patterns[1]);\n        var oneTwoDistance = this.distance(patterns[1], patterns[2]);\n        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n        var pointA;\n        var pointB;\n        var pointC;\n        // Assume one closest to other two is B; A and C will just be guesses at first\n        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n            pointB = patterns[0];\n            pointA = patterns[1];\n            pointC = patterns[2];\n        }\n        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n            pointB = patterns[1];\n            pointA = patterns[0];\n            pointC = patterns[2];\n        }\n        else {\n            pointB = patterns[2];\n            pointA = patterns[0];\n            pointC = patterns[1];\n        }\n        // Use cross product to figure out whether A and C are correct or flipped.\n        // This asks whether BC x BA has a positive z component, which is the arrangement\n        // we want for A, B, C. If it's negative, then we've got it flipped around and\n        // should swap A and C.\n        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n            var temp = pointA;\n            pointA = pointC;\n            pointC = temp;\n        }\n        patterns[0] = pointA;\n        patterns[1] = pointB;\n        patterns[2] = pointC;\n    };\n    /**\n     * @param pattern1 first pattern\n     * @param pattern2 second pattern\n     * @return distance between two points\n     */\n    ResultPoint.distance = function (pattern1, pattern2) {\n        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n    };\n    /**\n     * Returns the z component of the cross product between vectors BC and BA.\n     */\n    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\n        var bX = pointB.x;\n        var bY = pointB.y;\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\n    };\n    return ResultPoint;\n}());\nexports[\"default\"] = ResultPoint;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZXN1bHRQb2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsbUtBQTZCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxxSUFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9SZXN1bHRQb2ludC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XG52YXIgRmxvYXRfMSA9IHJlcXVpcmUoXCIuL3V0aWwvRmxvYXRcIik7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXNcbiAqIHdvdWxkIGJlIHRoZSBsb2NhdGlvbiBvZiBhIGZpbmRlciBwYXR0ZXJuIG9yIHRoZSBjb3JuZXIgb2YgdGhlIGJhcmNvZGUsIGZvciBleGFtcGxlLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgUmVzdWx0UG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0UG9pbnQoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9O1xuICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVzdWx0UG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBvdGhlclBvaW50ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlclBvaW50LnggJiYgdGhpcy55ID09PSBvdGhlclBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDMxICogRmxvYXRfMS5kZWZhdWx0LmZsb2F0VG9JbnRCaXRzKHRoaXMueCkgKyBGbG9hdF8xLmRlZmF1bHQuZmxvYXRUb0ludEJpdHModGhpcy55KTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQ1xuICAgICAqIGFuZCBCQyBpcyBsZXNzIHRoYW4gQUMsIGFuZCB0aGUgYW5nbGUgYmV0d2VlbiBCQyBhbmQgQkEgaXMgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXJcbiAgICAgKi9cbiAgICBSZXN1bHRQb2ludC5vcmRlckJlc3RQYXR0ZXJucyA9IGZ1bmN0aW9uIChwYXR0ZXJucykge1xuICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVyc1xuICAgICAgICB2YXIgemVyb09uZURpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pO1xuICAgICAgICB2YXIgb25lVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzFdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgIHZhciB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7XG4gICAgICAgIHZhciBwb2ludEE7XG4gICAgICAgIHZhciBwb2ludEI7XG4gICAgICAgIHZhciBwb2ludEM7XG4gICAgICAgIC8vIEFzc3VtZSBvbmUgY2xvc2VzdCB0byBvdGhlciB0d28gaXMgQjsgQSBhbmQgQyB3aWxsIGp1c3QgYmUgZ3Vlc3NlcyBhdCBmaXJzdFxuICAgICAgICBpZiAob25lVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlICYmIG9uZVR3b0Rpc3RhbmNlID49IHplcm9Ud29EaXN0YW5jZSkge1xuICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XG4gICAgICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHplcm9Ud29EaXN0YW5jZSA+PSBvbmVUd29EaXN0YW5jZSAmJiB6ZXJvVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlKSB7XG4gICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1syXTtcbiAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGNyb3NzIHByb2R1Y3QgdG8gZmlndXJlIG91dCB3aGV0aGVyIEEgYW5kIEMgYXJlIGNvcnJlY3Qgb3IgZmxpcHBlZC5cbiAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XG4gICAgICAgIC8vIHdlIHdhbnQgZm9yIEEsIEIsIEMuIElmIGl0J3MgbmVnYXRpdmUsIHRoZW4gd2UndmUgZ290IGl0IGZsaXBwZWQgYXJvdW5kIGFuZFxuICAgICAgICAvLyBzaG91bGQgc3dhcCBBIGFuZCBDLlxuICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHBvaW50QTtcbiAgICAgICAgICAgIHBvaW50QSA9IHBvaW50QztcbiAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybnNbMF0gPSBwb2ludEE7XG4gICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCO1xuICAgICAgICBwYXR0ZXJuc1syXSA9IHBvaW50QztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXR0ZXJuMSBmaXJzdCBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHBhdHRlcm4yIHNlY29uZCBwYXR0ZXJuXG4gICAgICogQHJldHVybiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICAgKi9cbiAgICBSZXN1bHRQb2ludC5kaXN0YW5jZSA9IGZ1bmN0aW9uIChwYXR0ZXJuMSwgcGF0dGVybjIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UocGF0dGVybjEueCwgcGF0dGVybjEueSwgcGF0dGVybjIueCwgcGF0dGVybjIueSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHZlY3RvcnMgQkMgYW5kIEJBLlxuICAgICAqL1xuICAgIFJlc3VsdFBvaW50LmNyb3NzUHJvZHVjdFogPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIsIHBvaW50Qykge1xuICAgICAgICB2YXIgYlggPSBwb2ludEIueDtcbiAgICAgICAgdmFyIGJZID0gcG9pbnRCLnk7XG4gICAgICAgIHJldHVybiAoKHBvaW50Qy54IC0gYlgpICogKHBvaW50QS55IC0gYlkpKSAtICgocG9pbnRDLnkgLSBiWSkgKiAocG9pbnRBLnggLSBiWCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3VsdFBvaW50O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3VsdFBvaW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar UnsupportedOperationException = /** @class */ (function (_super) {\n    __extends(UnsupportedOperationException, _super);\n    function UnsupportedOperationException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UnsupportedOperationException.kind = 'UnsupportedOperationException';\n    return UnsupportedOperationException;\n}(Exception_1.default));\nexports[\"default\"] = UnsupportedOperationException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLG1JQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAqL1xudmFyIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbi5raW5kID0gJ1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uJztcbiAgICByZXR1cm4gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb247XG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\n/**\n * Custom Error class of type Exception.\n */\nvar WriterException = /** @class */ (function (_super) {\n    __extends(WriterException, _super);\n    function WriterException() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WriterException.kind = 'WriterException';\n    return WriterException;\n}(Exception_1.default));\nexports[\"default\"] = WriterException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Xcml0ZXJFeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtSUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9Xcml0ZXJFeGNlcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICovXG52YXIgV3JpdGVyRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZXJFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVyRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdyaXRlckV4Y2VwdGlvbi5raW5kID0gJ1dyaXRlckV4Y2VwdGlvbic7XG4gICAgcmV0dXJuIFdyaXRlckV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV3JpdGVyRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DetectorResult_1 = __webpack_require__(/*! ../common/DetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js\");\n/**\n * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,\n * like the number of layers and whether it's compact.</p>\n *\n * @author Sean Owen\n */\nvar AztecDetectorResult = /** @class */ (function (_super) {\n    __extends(AztecDetectorResult, _super);\n    function AztecDetectorResult(bits, points, compact, nbDatablocks, nbLayers) {\n        var _this = _super.call(this, bits, points) || this;\n        _this.compact = compact;\n        _this.nbDatablocks = nbDatablocks;\n        _this.nbLayers = nbLayers;\n        return _this;\n    }\n    AztecDetectorResult.prototype.getNbLayers = function () {\n        return this.nbLayers;\n    };\n    AztecDetectorResult.prototype.getNbDatablocks = function () {\n        return this.nbDatablocks;\n    };\n    AztecDetectorResult.prototype.isCompact = function () {\n        return this.compact;\n    };\n    return AztecDetectorResult;\n}(DetectorResult_1.default));\nexports[\"default\"] = AztecDetectorResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9BenRlY0RldGVjdG9yUmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsNEpBQTBCO0FBQ3pEO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9BenRlY0RldGVjdG9yUmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZXRlY3RvclJlc3VsdF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9EZXRlY3RvclJlc3VsdFwiKTtcbi8qKlxuICogPHA+RXh0ZW5kcyB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IHdpdGggbW9yZSBpbmZvcm1hdGlvbiBzcGVjaWZpYyB0byB0aGUgQXp0ZWMgZm9ybWF0LFxuICogbGlrZSB0aGUgbnVtYmVyIG9mIGxheWVycyBhbmQgd2hldGhlciBpdCdzIGNvbXBhY3QuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBBenRlY0RldGVjdG9yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBenRlY0RldGVjdG9yUmVzdWx0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF6dGVjRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzLCBjb21wYWN0LCBuYkRhdGFibG9ja3MsIG5iTGF5ZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJpdHMsIHBvaW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgIF90aGlzLm5iRGF0YWJsb2NrcyA9IG5iRGF0YWJsb2NrcztcbiAgICAgICAgX3RoaXMubmJMYXllcnMgPSBuYkxheWVycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBenRlY0RldGVjdG9yUmVzdWx0LnByb3RvdHlwZS5nZXROYkxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmJMYXllcnM7XG4gICAgfTtcbiAgICBBenRlY0RldGVjdG9yUmVzdWx0LnByb3RvdHlwZS5nZXROYkRhdGFibG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5iRGF0YWJsb2NrcztcbiAgICB9O1xuICAgIEF6dGVjRGV0ZWN0b3JSZXN1bHQucHJvdG90eXBlLmlzQ29tcGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFjdDtcbiAgICB9O1xuICAgIHJldHVybiBBenRlY0RldGVjdG9yUmVzdWx0O1xufShEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF6dGVjRGV0ZWN0b3JSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar System_1 = __webpack_require__(/*! ../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js\");\nvar Detector_1 = __webpack_require__(/*! ./detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js\");\n// import java.util.List;\n// import java.util.Map;\n/**\n * This implementation can detect and decode Aztec codes in an image.\n *\n * @author David Olivier\n */\nvar AztecReader = /** @class */ (function () {\n    function AztecReader() {\n    }\n    /**\n     * Locates and decodes a Data Matrix code in an image.\n     *\n     * @return a String representing the content encoded by the Data Matrix code\n     * @throws NotFoundException if a Data Matrix code cannot be found\n     * @throws FormatException if a Data Matrix code cannot be decoded\n     */\n    AztecReader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var exception = null;\n        var detector = new Detector_1.default(image.getBlackMatrix());\n        var points = null;\n        var decoderResult = null;\n        try {\n            var detectorResult = detector.detectMirror(false);\n            points = detectorResult.getPoints();\n            this.reportFoundResultPoints(hints, points);\n            decoderResult = new Decoder_1.default().decode(detectorResult);\n        }\n        catch (e) {\n            exception = e;\n        }\n        if (decoderResult == null) {\n            try {\n                var detectorResult = detector.detectMirror(true);\n                points = detectorResult.getPoints();\n                this.reportFoundResultPoints(hints, points);\n                decoderResult = new Decoder_1.default().decode(detectorResult);\n            }\n            catch (e) {\n                if (exception != null) {\n                    throw exception;\n                }\n                throw e;\n            }\n        }\n        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat_1.default.AZTEC, System_1.default.currentTimeMillis());\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        return result;\n    };\n    AztecReader.prototype.reportFoundResultPoints = function (hints, points) {\n        if (hints != null) {\n            var rpcb_1 = hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            if (rpcb_1 != null) {\n                points.forEach(function (point, idx, arr) {\n                    rpcb_1.foundPossibleResultPoint(point);\n                });\n            }\n        }\n    };\n    // @Override\n    AztecReader.prototype.reset = function () {\n        // do nothing\n    };\n    return AztecReader;\n}());\nexports[\"default\"] = AztecReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9BenRlY1JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsOEhBQVc7QUFDbEMsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLDhJQUFtQjtBQUNsRCwyQkFBMkIsbUJBQU8sQ0FBQyxzSkFBdUI7QUFDMUQsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxSkFBbUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMseUpBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvQXp0ZWNSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRNZXRhZGF0YVR5cGVcIik7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TeXN0ZW1cIik7XG52YXIgRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9EZWNvZGVyXCIpO1xudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbi8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbi8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBBenRlYyBjb2RlcyBpbiBhbiBpbWFnZS5cbiAqXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAqL1xudmFyIEF6dGVjUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF6dGVjUmVhZGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIERhdGEgTWF0cml4IGNvZGVcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgKi9cbiAgICBBenRlY1JlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBkZXRlY3RvciA9IG5ldyBEZXRlY3Rvcl8xLmRlZmF1bHQoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBudWxsO1xuICAgICAgICB2YXIgZGVjb2RlclJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGV0ZWN0b3JSZXN1bHQgPSBkZXRlY3Rvci5kZXRlY3RNaXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyXzEuZGVmYXVsdCgpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0ZWN0b3JSZXN1bHQgPSBkZXRlY3Rvci5kZXRlY3RNaXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyhoaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJfMS5kZWZhdWx0KCkuZGVjb2RlKGRldGVjdG9yUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgZGVjb2RlclJlc3VsdC5nZXROdW1CaXRzKCksIHBvaW50cywgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQVpURUMsIFN5c3RlbV8xLmRlZmF1bHQuY3VycmVudFRpbWVNaWxsaXMoKSk7XG4gICAgICAgIHZhciBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgaWYgKGVjTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEF6dGVjUmVhZGVyLnByb3RvdHlwZS5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyA9IGZ1bmN0aW9uIChoaW50cywgcG9pbnRzKSB7XG4gICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcnBjYl8xID0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICBpZiAocnBjYl8xICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJwY2JfMS5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBBenRlY1JlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9O1xuICAgIHJldHVybiBBenRlY1JlYWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBenRlY1JlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.aztec;\n// import com.google.zxing.BarcodeFormat;\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\n// import com.google.zxing.EncodeHintType;\nvar EncodeHintType_1 = __webpack_require__(/*! ../EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\n// import com.google.zxing.aztec.encoder.Encoder;\nvar Encoder_1 = __webpack_require__(/*! ./encoder/Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js\");\n// import com.google.zxing.common.BitMatrix;\nvar BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\n// import java.nio.charset.Charset;\nvar Charset_1 = __webpack_require__(/*! ../util/Charset */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js\");\n// import java.nio.charset.StandardCharsets;\nvar StandardCharsets_1 = __webpack_require__(/*! ../util/StandardCharsets */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js\");\n// import java.util.Map;\nvar Integer_1 = __webpack_require__(/*! ../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\n/**\n * Renders an Aztec code as a {@link BitMatrix}.\n */\nvar AztecWriter = /** @class */ (function () {\n    function AztecWriter() {\n    }\n    // @Override\n    AztecWriter.prototype.encode = function (contents, format, width, height) {\n        return this.encodeWithHints(contents, format, width, height, null);\n    };\n    // @Override\n    AztecWriter.prototype.encodeWithHints = function (contents, format, width, height, hints) {\n        var charset = StandardCharsets_1.default.ISO_8859_1;\n        var eccPercent = Encoder_1.default.DEFAULT_EC_PERCENT;\n        var layers = Encoder_1.default.DEFAULT_AZTEC_LAYERS;\n        if (hints != null) {\n            if (hints.has(EncodeHintType_1.default.CHARACTER_SET)) {\n                charset = Charset_1.default.forName(hints.get(EncodeHintType_1.default.CHARACTER_SET).toString());\n            }\n            if (hints.has(EncodeHintType_1.default.ERROR_CORRECTION)) {\n                eccPercent = Integer_1.default.parseInt(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());\n            }\n            if (hints.has(EncodeHintType_1.default.AZTEC_LAYERS)) {\n                layers = Integer_1.default.parseInt(hints.get(EncodeHintType_1.default.AZTEC_LAYERS).toString());\n            }\n        }\n        return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);\n    };\n    AztecWriter.encodeLayers = function (contents, format, width, height, charset, eccPercent, layers) {\n        if (format !== BarcodeFormat_1.default.AZTEC) {\n            throw new IllegalArgumentException_1.default('Can only encode AZTEC, but got ' + format);\n        }\n        var aztec = Encoder_1.default.encode(StringUtils_1.default.getBytes(contents, charset), eccPercent, layers);\n        return AztecWriter.renderResult(aztec, width, height);\n    };\n    AztecWriter.renderResult = function (code, width, height) {\n        var input = code.getMatrix();\n        if (input == null) {\n            throw new IllegalStateException_1.default();\n        }\n        var inputWidth = input.getWidth();\n        var inputHeight = input.getHeight();\n        var outputWidth = Math.max(width, inputWidth);\n        var outputHeight = Math.max(height, inputHeight);\n        var multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);\n        var leftPadding = (outputWidth - (inputWidth * multiple)) / 2;\n        var topPadding = (outputHeight - (inputHeight * multiple)) / 2;\n        var output = new BitMatrix_1.default(outputWidth, outputHeight);\n        for (var inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the barcode\n            for (var inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                if (input.get(inputX, inputY)) {\n                    output.setRegion(outputX, outputY, multiple, multiple);\n                }\n            }\n        }\n        return output;\n    };\n    return AztecWriter;\n}());\nexports[\"default\"] = AztecWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9BenRlY1dyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsOElBQW1CO0FBQ2xEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUpBQW1CO0FBQzNDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsa0pBQXFCO0FBQy9DO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWlCO0FBQ3pDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsNEpBQTBCO0FBQzNEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWlCO0FBQ3pDLDhCQUE4QixtQkFBTyxDQUFDLDRKQUEwQjtBQUNoRSxpQ0FBaUMsbUJBQU8sQ0FBQyxrS0FBNkI7QUFDdEUsb0JBQW9CLG1CQUFPLENBQUMsc0pBQXVCO0FBQ25EO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQSxnRUFBZ0UscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvQXp0ZWNXcml0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcuYXp0ZWM7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5CYXJjb2RlRm9ybWF0O1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuRW5jb2RlSGludFR5cGU7XG52YXIgRW5jb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9FbmNvZGVIaW50VHlwZVwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmF6dGVjLmVuY29kZXIuRW5jb2RlcjtcbnZhciBFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyL0VuY29kZXJcIik7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0TWF0cml4O1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XG4vLyBpbXBvcnQgamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0O1xudmFyIENoYXJzZXRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJzZXRcIik7XG4vLyBpbXBvcnQgamF2YS5uaW8uY2hhcnNldC5TdGFuZGFyZENoYXJzZXRzO1xudmFyIFN0YW5kYXJkQ2hhcnNldHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N0YW5kYXJkQ2hhcnNldHNcIik7XG4vLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbnZhciBJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9JbnRlZ2VyXCIpO1xudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3RyaW5nVXRpbHNcIik7XG4vKipcbiAqIFJlbmRlcnMgYW4gQXp0ZWMgY29kZSBhcyBhIHtAbGluayBCaXRNYXRyaXh9LlxuICovXG52YXIgQXp0ZWNXcml0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXp0ZWNXcml0ZXIoKSB7XG4gICAgfVxuICAgIC8vIEBPdmVycmlkZVxuICAgIEF6dGVjV3JpdGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVXaXRoSGludHMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgbnVsbCk7XG4gICAgfTtcbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBBenRlY1dyaXRlci5wcm90b3R5cGUuZW5jb2RlV2l0aEhpbnRzID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKSB7XG4gICAgICAgIHZhciBjaGFyc2V0ID0gU3RhbmRhcmRDaGFyc2V0c18xLmRlZmF1bHQuSVNPXzg4NTlfMTtcbiAgICAgICAgdmFyIGVjY1BlcmNlbnQgPSBFbmNvZGVyXzEuZGVmYXVsdC5ERUZBVUxUX0VDX1BFUkNFTlQ7XG4gICAgICAgIHZhciBsYXllcnMgPSBFbmNvZGVyXzEuZGVmYXVsdC5ERUZBVUxUX0FaVEVDX0xBWUVSUztcbiAgICAgICAgaWYgKGhpbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IENoYXJzZXRfMS5kZWZhdWx0LmZvck5hbWUoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT04pKSB7XG4gICAgICAgICAgICAgICAgZWNjUGVyY2VudCA9IEludGVnZXJfMS5kZWZhdWx0LnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGludHMuaGFzKEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5BWlRFQ19MQVlFUlMpKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzID0gSW50ZWdlcl8xLmRlZmF1bHQucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5BWlRFQ19MQVlFUlMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBenRlY1dyaXRlci5lbmNvZGVMYXllcnMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgY2hhcnNldCwgZWNjUGVyY2VudCwgbGF5ZXJzKTtcbiAgICB9O1xuICAgIEF6dGVjV3JpdGVyLmVuY29kZUxheWVycyA9IGZ1bmN0aW9uIChjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBjaGFyc2V0LCBlY2NQZXJjZW50LCBsYXllcnMpIHtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQVpURUMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdDYW4gb25seSBlbmNvZGUgQVpURUMsIGJ1dCBnb3QgJyArIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF6dGVjID0gRW5jb2Rlcl8xLmRlZmF1bHQuZW5jb2RlKFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRCeXRlcyhjb250ZW50cywgY2hhcnNldCksIGVjY1BlcmNlbnQsIGxheWVycyk7XG4gICAgICAgIHJldHVybiBBenRlY1dyaXRlci5yZW5kZXJSZXN1bHQoYXp0ZWMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgQXp0ZWNXcml0ZXIucmVuZGVyUmVzdWx0ID0gZnVuY3Rpb24gKGNvZGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGlucHV0V2lkdGgpO1xuICAgICAgICB2YXIgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBpbnB1dEhlaWdodCk7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGgubWluKG91dHB1dFdpZHRoIC8gaW5wdXRXaWR0aCwgb3V0cHV0SGVpZ2h0IC8gaW5wdXRIZWlnaHQpO1xuICAgICAgICB2YXIgbGVmdFBhZGRpbmcgPSAob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyO1xuICAgICAgICB2YXIgdG9wUGFkZGluZyA9IChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMjtcbiAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciBpbnB1dFkgLyppbnQqLyA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRYIC8qaW50Ki8gPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgcmV0dXJuIEF6dGVjV3JpdGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF6dGVjV3JpdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\n// import java.util.Arrays;\nvar Table;\n(function (Table) {\n    Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n    Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n    Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n    Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n    Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n    Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n})(Table || (Table = {}));\n/**\n * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n * the Aztec Code from an image.</p>\n *\n * @author David Olivier\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n    }\n    Decoder.prototype.decode = function (detectorResult) {\n        this.ddata = detectorResult;\n        var matrix = detectorResult.getBits();\n        var rawbits = this.extractBits(matrix);\n        var correctedBits = this.correctBits(rawbits);\n        var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n        var result = Decoder.getEncodedData(correctedBits);\n        var decoderResult = new DecoderResult_1.default(rawBytes, result, null, null);\n        decoderResult.setNumBits(correctedBits.length);\n        return decoderResult;\n    };\n    // This method is used for testing the high-level encoder\n    Decoder.highLevelDecode = function (correctedBits) {\n        return this.getEncodedData(correctedBits);\n    };\n    /**\n     * Gets the string encoded in the aztec code bits\n     *\n     * @return the decoded string\n     */\n    Decoder.getEncodedData = function (correctedBits) {\n        var endIndex = correctedBits.length;\n        var latchTable = Table.UPPER; // table most recently latched to\n        var shiftTable = Table.UPPER; // table to use for the next read\n        var result = '';\n        var index = 0;\n        while (index < endIndex) {\n            if (shiftTable === Table.BINARY) {\n                if (endIndex - index < 5) {\n                    break;\n                }\n                var length_1 = Decoder.readCode(correctedBits, index, 5);\n                index += 5;\n                if (length_1 === 0) {\n                    if (endIndex - index < 11) {\n                        break;\n                    }\n                    length_1 = Decoder.readCode(correctedBits, index, 11) + 31;\n                    index += 11;\n                }\n                for (var charCount = 0; charCount < length_1; charCount++) {\n                    if (endIndex - index < 8) {\n                        index = endIndex; // Force outer loop to exit\n                        break;\n                    }\n                    var code = Decoder.readCode(correctedBits, index, 8);\n                    result += /*(char)*/ StringUtils_1.default.castAsNonUtf8Char(code);\n                    index += 8;\n                }\n                // Go back to whatever mode we had been in\n                shiftTable = latchTable;\n            }\n            else {\n                var size = shiftTable === Table.DIGIT ? 4 : 5;\n                if (endIndex - index < size) {\n                    break;\n                }\n                var code = Decoder.readCode(correctedBits, index, size);\n                index += size;\n                var str = Decoder.getCharacter(shiftTable, code);\n                if (str.startsWith('CTRL_')) {\n                    // Table changes\n                    // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n                    // That's including when that mode is a shift.\n                    // Our test case dlusbs.png for issue #642 exercises that.\n                    latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n                    shiftTable = Decoder.getTable(str.charAt(5));\n                    if (str.charAt(6) === 'L') {\n                        latchTable = shiftTable;\n                    }\n                }\n                else {\n                    result += str;\n                    // Go back to whatever mode we had been in\n                    shiftTable = latchTable;\n                }\n            }\n        }\n        return result;\n    };\n    /**\n     * gets the table corresponding to the char passed\n     */\n    Decoder.getTable = function (t) {\n        switch (t) {\n            case 'L':\n                return Table.LOWER;\n            case 'P':\n                return Table.PUNCT;\n            case 'M':\n                return Table.MIXED;\n            case 'D':\n                return Table.DIGIT;\n            case 'B':\n                return Table.BINARY;\n            case 'U':\n            default:\n                return Table.UPPER;\n        }\n    };\n    /**\n     * Gets the character (or string) corresponding to the passed code in the given table\n     *\n     * @param table the table used\n     * @param code the code of the character\n     */\n    Decoder.getCharacter = function (table, code) {\n        switch (table) {\n            case Table.UPPER:\n                return Decoder.UPPER_TABLE[code];\n            case Table.LOWER:\n                return Decoder.LOWER_TABLE[code];\n            case Table.MIXED:\n                return Decoder.MIXED_TABLE[code];\n            case Table.PUNCT:\n                return Decoder.PUNCT_TABLE[code];\n            case Table.DIGIT:\n                return Decoder.DIGIT_TABLE[code];\n            default:\n                // Should not reach here.\n                throw new IllegalStateException_1.default('Bad table');\n        }\n    };\n    /**\n     * <p>Performs RS error correction on an array of bits.</p>\n     *\n     * @return the corrected array\n     * @throws FormatException if the input contains too many errors\n     */\n    Decoder.prototype.correctBits = function (rawbits) {\n        var gf;\n        var codewordSize;\n        if (this.ddata.getNbLayers() <= 2) {\n            codewordSize = 6;\n            gf = GenericGF_1.default.AZTEC_DATA_6;\n        }\n        else if (this.ddata.getNbLayers() <= 8) {\n            codewordSize = 8;\n            gf = GenericGF_1.default.AZTEC_DATA_8;\n        }\n        else if (this.ddata.getNbLayers() <= 22) {\n            codewordSize = 10;\n            gf = GenericGF_1.default.AZTEC_DATA_10;\n        }\n        else {\n            codewordSize = 12;\n            gf = GenericGF_1.default.AZTEC_DATA_12;\n        }\n        var numDataCodewords = this.ddata.getNbDatablocks();\n        var numCodewords = rawbits.length / codewordSize;\n        if (numCodewords < numDataCodewords) {\n            throw new FormatException_1.default();\n        }\n        var offset = rawbits.length % codewordSize;\n        var dataWords = new Int32Array(numCodewords);\n        for (var i = 0; i < numCodewords; i++, offset += codewordSize) {\n            dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n        }\n        try {\n            var rsDecoder = new ReedSolomonDecoder_1.default(gf);\n            rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n        }\n        catch (ex) {\n            throw new FormatException_1.default(ex);\n        }\n        // Now perform the unstuffing operation.\n        // First, count how many bits are going to be thrown out as stuffing\n        var mask = (1 << codewordSize) - 1;\n        var stuffedBits = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            var dataWord = dataWords[i];\n            if (dataWord === 0 || dataWord === mask) {\n                throw new FormatException_1.default();\n            }\n            else if (dataWord === 1 || dataWord === mask - 1) {\n                stuffedBits++;\n            }\n        }\n        // Now, actually unpack the bits and remove the stuffing\n        var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n        var index = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            var dataWord = dataWords[i];\n            if (dataWord === 1 || dataWord === mask - 1) {\n                // next codewordSize-1 bits are all zeros or all ones\n                correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n                // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n                index += codewordSize - 1;\n            }\n            else {\n                for (var bit = codewordSize - 1; bit >= 0; --bit) {\n                    correctedBits[index++] = (dataWord & (1 << bit)) !== 0;\n                }\n            }\n        }\n        return correctedBits;\n    };\n    /**\n     * Gets the array of bits from an Aztec Code matrix\n     *\n     * @return the array of bits\n     */\n    Decoder.prototype.extractBits = function (matrix) {\n        var compact = this.ddata.isCompact();\n        var layers = this.ddata.getNbLayers();\n        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n        var alignmentMap = new Int32Array(baseMatrixSize);\n        var rawbits = new Array(this.totalBitsInLayer(layers, compact));\n        if (compact) {\n            for (var i = 0; i < alignmentMap.length; i++) {\n                alignmentMap[i] = i;\n            }\n        }\n        else {\n            var matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);\n            var origCenter = baseMatrixSize / 2;\n            var center = Integer_1.default.truncDivision(matrixSize, 2);\n            for (var i = 0; i < origCenter; i++) {\n                var newOffset = i + Integer_1.default.truncDivision(i, 15);\n                alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                alignmentMap[origCenter + i] = center + newOffset + 1;\n            }\n        }\n        for (var i = 0, rowOffset = 0; i < layers; i++) {\n            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n            // The top-left most point of this layer is <low, low> (not including alignment lines)\n            var low = i * 2;\n            // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n            var high = baseMatrixSize - 1 - low;\n            // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n            for (var j = 0; j < rowSize; j++) {\n                var columnOffset = j * 2;\n                for (var k = 0; k < 2; k++) {\n                    // left column\n                    rawbits[rowOffset + columnOffset + k] =\n                        matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n                    // bottom row\n                    rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n                    // right column\n                    rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n                    // top row\n                    rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n                }\n            }\n            rowOffset += rowSize * 8;\n        }\n        return rawbits;\n    };\n    /**\n     * Reads a code of given length and at given index in an array of bits\n     */\n    Decoder.readCode = function (rawbits, startIndex, length) {\n        var res = 0;\n        for (var i = startIndex; i < startIndex + length; i++) {\n            res <<= 1;\n            if (rawbits[i]) {\n                res |= 0x01;\n            }\n        }\n        return res;\n    };\n    /**\n     * Reads a code of length 8 in an array of bits, padding with zeros\n     */\n    Decoder.readByte = function (rawbits, startIndex) {\n        var n = rawbits.length - startIndex;\n        if (n >= 8) {\n            return Decoder.readCode(rawbits, startIndex, 8);\n        }\n        return Decoder.readCode(rawbits, startIndex, n) << (8 - n);\n    };\n    /**\n     * Packs a bit array into bytes, most significant bit first\n     */\n    Decoder.convertBoolArrayToByteArray = function (boolArr) {\n        var byteArr = new Uint8Array((boolArr.length + 7) / 8);\n        for (var i = 0; i < byteArr.length; i++) {\n            byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n        }\n        return byteArr;\n    };\n    Decoder.prototype.totalBitsInLayer = function (layers, compact) {\n        return ((compact ? 88 : 112) + 16 * layers) * layers;\n    };\n    Decoder.UPPER_TABLE = [\n        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.LOWER_TABLE = [\n        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.MIXED_TABLE = [\n        'CTRL_PS', ' ', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07', '\\b', '\\t', '\\n',\n        '\\x0b', '\\f', '\\r', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f', '@', '\\\\', '^', '_',\n        '`', '|', '~', '\\x7f', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'\n    ];\n    Decoder.PUNCT_TABLE = [\n        '', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')',\n        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'\n    ];\n    Decoder.DIGIT_TABLE = [\n        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'\n    ];\n    return Decoder;\n}());\nexports[\"default\"] = Decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9kZWNvZGVyL0RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsNkpBQTRCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDZLQUFvQztBQUM5RCwyQkFBMkIsbUJBQU8sQ0FBQywrTEFBNkM7QUFDaEYsOEJBQThCLG1CQUFPLENBQUMsK0pBQTZCO0FBQ25FLHdCQUF3QixtQkFBTyxDQUFDLG1KQUF1QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsNklBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQ0FBbUMsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2F6dGVjL2RlY29kZXIvRGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERlY29kZXJSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGVjb2RlclJlc3VsdFwiKTtcbnZhciBHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGXCIpO1xudmFyIFJlZWRTb2xvbW9uRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXJcIik7XG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9TdHJpbmdVdGlsc1wiKTtcbnZhciBJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9JbnRlZ2VyXCIpO1xuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG52YXIgVGFibGU7XG4oZnVuY3Rpb24gKFRhYmxlKSB7XG4gICAgVGFibGVbVGFibGVbXCJVUFBFUlwiXSA9IDBdID0gXCJVUFBFUlwiO1xuICAgIFRhYmxlW1RhYmxlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICBUYWJsZVtUYWJsZVtcIk1JWEVEXCJdID0gMl0gPSBcIk1JWEVEXCI7XG4gICAgVGFibGVbVGFibGVbXCJESUdJVFwiXSA9IDNdID0gXCJESUdJVFwiO1xuICAgIFRhYmxlW1RhYmxlW1wiUFVOQ1RcIl0gPSA0XSA9IFwiUFVOQ1RcIjtcbiAgICBUYWJsZVtUYWJsZVtcIkJJTkFSWVwiXSA9IDVdID0gXCJCSU5BUllcIjtcbn0pKFRhYmxlIHx8IChUYWJsZSA9IHt9KSk7XG4vKipcbiAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgQXp0ZWMgQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nXG4gKiB0aGUgQXp0ZWMgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAqXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAqL1xudmFyIERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgICB9XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGRldGVjdG9yUmVzdWx0KSB7XG4gICAgICAgIHRoaXMuZGRhdGEgPSBkZXRlY3RvclJlc3VsdDtcbiAgICAgICAgdmFyIG1hdHJpeCA9IGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKTtcbiAgICAgICAgdmFyIHJhd2JpdHMgPSB0aGlzLmV4dHJhY3RCaXRzKG1hdHJpeCk7XG4gICAgICAgIHZhciBjb3JyZWN0ZWRCaXRzID0gdGhpcy5jb3JyZWN0Qml0cyhyYXdiaXRzKTtcbiAgICAgICAgdmFyIHJhd0J5dGVzID0gRGVjb2Rlci5jb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoY29ycmVjdGVkQml0cyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBEZWNvZGVyLmdldEVuY29kZWREYXRhKGNvcnJlY3RlZEJpdHMpO1xuICAgICAgICB2YXIgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyUmVzdWx0XzEuZGVmYXVsdChyYXdCeXRlcywgcmVzdWx0LCBudWxsLCBudWxsKTtcbiAgICAgICAgZGVjb2RlclJlc3VsdC5zZXROdW1CaXRzKGNvcnJlY3RlZEJpdHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciB0ZXN0aW5nIHRoZSBoaWdoLWxldmVsIGVuY29kZXJcbiAgICBEZWNvZGVyLmhpZ2hMZXZlbERlY29kZSA9IGZ1bmN0aW9uIChjb3JyZWN0ZWRCaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZWREYXRhKGNvcnJlY3RlZEJpdHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RyaW5nIGVuY29kZWQgaW4gdGhlIGF6dGVjIGNvZGUgYml0c1xuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgZGVjb2RlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBEZWNvZGVyLmdldEVuY29kZWREYXRhID0gZnVuY3Rpb24gKGNvcnJlY3RlZEJpdHMpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29ycmVjdGVkQml0cy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXRjaFRhYmxlID0gVGFibGUuVVBQRVI7IC8vIHRhYmxlIG1vc3QgcmVjZW50bHkgbGF0Y2hlZCB0b1xuICAgICAgICB2YXIgc2hpZnRUYWJsZSA9IFRhYmxlLlVQUEVSOyAvLyB0YWJsZSB0byB1c2UgZm9yIHRoZSBuZXh0IHJlYWRcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgaWYgKHNoaWZ0VGFibGUgPT09IFRhYmxlLkJJTkFSWSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgNSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gRGVjb2Rlci5yZWFkQ29kZShjb3JyZWN0ZWRCaXRzLCBpbmRleCwgNSk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IC0gaW5kZXggPCAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoXzEgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCAxMSkgKyAzMTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJDb3VudCA9IDA7IGNoYXJDb3VudCA8IGxlbmd0aF8xOyBjaGFyQ291bnQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXg7IC8vIEZvcmNlIG91dGVyIGxvb3AgdG8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IC8qKGNoYXIpKi8gU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmNhc3RBc05vblV0ZjhDaGFyKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHbyBiYWNrIHRvIHdoYXRldmVyIG1vZGUgd2UgaGFkIGJlZW4gaW5cbiAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gc2hpZnRUYWJsZSA9PT0gVGFibGUuRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gRGVjb2Rlci5yZWFkQ29kZShjb3JyZWN0ZWRCaXRzLCBpbmRleCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gRGVjb2Rlci5nZXRDaGFyYWN0ZXIoc2hpZnRUYWJsZSwgY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCdDVFJMXycpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAyNDc3ODoyMDA4IHByZXNjcmliZXMgZW5kaW5nIGEgc2hpZnQgc2VxdWVuY2UgaW4gdGhlIG1vZGUgZnJvbSB3aGljaCBpdCB3YXMgaW52b2tlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCdzIGluY2x1ZGluZyB3aGVuIHRoYXQgbW9kZSBpcyBhIHNoaWZ0LlxuICAgICAgICAgICAgICAgICAgICAvLyBPdXIgdGVzdCBjYXNlIGRsdXNicy5wbmcgZm9yIGlzc3VlICM2NDIgZXhlcmNpc2VzIHRoYXQuXG4gICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlOyAvLyBMYXRjaCB0aGUgY3VycmVudCBtb2RlLCBzbyBhcyB0byByZXR1cm4gdG8gVXBwZXIgYWZ0ZXIgVS9TIEIvU1xuICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gRGVjb2Rlci5nZXRUYWJsZShzdHIuY2hhckF0KDUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQXQoNikgPT09ICdMJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0Y2hUYWJsZSA9IHNoaWZ0VGFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gd2hhdGV2ZXIgbW9kZSB3ZSBoYWQgYmVlbiBpblxuICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldHMgdGhlIHRhYmxlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXIgcGFzc2VkXG4gICAgICovXG4gICAgRGVjb2Rlci5nZXRUYWJsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkxPV0VSO1xuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlBVTkNUO1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLk1JWEVEO1xuICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkRJR0lUO1xuICAgICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkJJTkFSWTtcbiAgICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuVVBQRVI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciAob3Igc3RyaW5nKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXNzZWQgY29kZSBpbiB0aGUgZ2l2ZW4gdGFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWJsZSB0aGUgdGFibGUgdXNlZFxuICAgICAqIEBwYXJhbSBjb2RlIHRoZSBjb2RlIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBEZWNvZGVyLmdldENoYXJhY3RlciA9IGZ1bmN0aW9uICh0YWJsZSwgY29kZSkge1xuICAgICAgICBzd2l0Y2ggKHRhYmxlKSB7XG4gICAgICAgICAgICBjYXNlIFRhYmxlLlVQUEVSOlxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLlVQUEVSX1RBQkxFW2NvZGVdO1xuICAgICAgICAgICAgY2FzZSBUYWJsZS5MT1dFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5MT1dFUl9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgIGNhc2UgVGFibGUuTUlYRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTUlYRURfVEFCTEVbY29kZV07XG4gICAgICAgICAgICBjYXNlIFRhYmxlLlBVTkNUOlxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLlBVTkNUX1RBQkxFW2NvZGVdO1xuICAgICAgICAgICAgY2FzZSBUYWJsZS5ESUdJVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5ESUdJVF9UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCdCYWQgdGFibGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UGVyZm9ybXMgUlMgZXJyb3IgY29ycmVjdGlvbiBvbiBhbiBhcnJheSBvZiBiaXRzLjwvcD5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIGNvcnJlY3RlZCBhcnJheVxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBjb250YWlucyB0b28gbWFueSBlcnJvcnNcbiAgICAgKi9cbiAgICBEZWNvZGVyLnByb3RvdHlwZS5jb3JyZWN0Qml0cyA9IGZ1bmN0aW9uIChyYXdiaXRzKSB7XG4gICAgICAgIHZhciBnZjtcbiAgICAgICAgdmFyIGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKSA8PSAyKSB7XG4gICAgICAgICAgICBjb2Rld29yZFNpemUgPSA2O1xuICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfNjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCkgPD0gOCkge1xuICAgICAgICAgICAgY29kZXdvcmRTaXplID0gODtcbiAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGXzEuZGVmYXVsdC5BWlRFQ19EQVRBXzg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDIyKSB7XG4gICAgICAgICAgICBjb2Rld29yZFNpemUgPSAxMDtcbiAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGXzEuZGVmYXVsdC5BWlRFQ19EQVRBXzEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXdvcmRTaXplID0gMTI7XG4gICAgICAgICAgICBnZiA9IEdlbmVyaWNHRl8xLmRlZmF1bHQuQVpURUNfREFUQV8xMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IHRoaXMuZGRhdGEuZ2V0TmJEYXRhYmxvY2tzKCk7XG4gICAgICAgIHZhciBudW1Db2Rld29yZHMgPSByYXdiaXRzLmxlbmd0aCAvIGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgaWYgKG51bUNvZGV3b3JkcyA8IG51bURhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IHJhd2JpdHMubGVuZ3RoICUgY29kZXdvcmRTaXplO1xuICAgICAgICB2YXIgZGF0YVdvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKywgb2Zmc2V0ICs9IGNvZGV3b3JkU2l6ZSkge1xuICAgICAgICAgICAgZGF0YVdvcmRzW2ldID0gRGVjb2Rlci5yZWFkQ29kZShyYXdiaXRzLCBvZmZzZXQsIGNvZGV3b3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyXzEuZGVmYXVsdChnZik7XG4gICAgICAgICAgICByc0RlY29kZXIuZGVjb2RlKGRhdGFXb3JkcywgbnVtQ29kZXdvcmRzIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdChleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHBlcmZvcm0gdGhlIHVuc3R1ZmZpbmcgb3BlcmF0aW9uLlxuICAgICAgICAvLyBGaXJzdCwgY291bnQgaG93IG1hbnkgYml0cyBhcmUgZ29pbmcgdG8gYmUgdGhyb3duIG91dCBhcyBzdHVmZmluZ1xuICAgICAgICB2YXIgbWFzayA9ICgxIDw8IGNvZGV3b3JkU2l6ZSkgLSAxO1xuICAgICAgICB2YXIgc3R1ZmZlZEJpdHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xuICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAwIHx8IGRhdGFXb3JkID09PSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93LCBhY3R1YWxseSB1bnBhY2sgdGhlIGJpdHMgYW5kIHJlbW92ZSB0aGUgc3R1ZmZpbmdcbiAgICAgICAgdmFyIGNvcnJlY3RlZEJpdHMgPSBuZXcgQXJyYXkobnVtRGF0YUNvZGV3b3JkcyAqIGNvZGV3b3JkU2l6ZSAtIHN0dWZmZWRCaXRzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhV29yZCA9IGRhdGFXb3Jkc1tpXTtcbiAgICAgICAgICAgIGlmIChkYXRhV29yZCA9PT0gMSB8fCBkYXRhV29yZCA9PT0gbWFzayAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvZGV3b3JkU2l6ZS0xIGJpdHMgYXJlIGFsbCB6ZXJvcyBvciBhbGwgb25lc1xuICAgICAgICAgICAgICAgIGNvcnJlY3RlZEJpdHMuZmlsbChkYXRhV29yZCA+IDEsIGluZGV4LCBpbmRleCArIGNvZGV3b3JkU2l6ZSAtIDEpO1xuICAgICAgICAgICAgICAgIC8vIEFycmF5cy5maWxsKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBpbmRleCArIGNvZGV3b3JkU2l6ZSAtIDEsIGRhdGFXb3JkID4gMSk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gY29kZXdvcmRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJpdCA9IGNvZGV3b3JkU2l6ZSAtIDE7IGJpdCA+PSAwOyAtLWJpdCkge1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRCaXRzW2luZGV4KytdID0gKGRhdGFXb3JkICYgKDEgPDwgYml0KSkgIT09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3JyZWN0ZWRCaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJyYXkgb2YgYml0cyBmcm9tIGFuIEF6dGVjIENvZGUgbWF0cml4XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBiaXRzXG4gICAgICovXG4gICAgRGVjb2Rlci5wcm90b3R5cGUuZXh0cmFjdEJpdHMgPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHZhciBjb21wYWN0ID0gdGhpcy5kZGF0YS5pc0NvbXBhY3QoKTtcbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKTtcbiAgICAgICAgdmFyIGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgIHZhciBhbGlnbm1lbnRNYXAgPSBuZXcgSW50MzJBcnJheShiYXNlTWF0cml4U2l6ZSk7XG4gICAgICAgIHZhciByYXdiaXRzID0gbmV3IEFycmF5KHRoaXMudG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpKTtcbiAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxpZ25tZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24oKEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpIC0gMSksIDE1KTtcbiAgICAgICAgICAgIHZhciBvcmlnQ2VudGVyID0gYmFzZU1hdHJpeFNpemUgLyAyO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSBpICsgSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgLSBpIC0gMV0gPSBjZW50ZXIgLSBuZXdPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyICsgaV0gPSBjZW50ZXIgKyBuZXdPZmZzZXQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCByb3dPZmZzZXQgPSAwOyBpIDwgbGF5ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcbiAgICAgICAgICAgIC8vIFRoZSB0b3AtbGVmdCBtb3N0IHBvaW50IG9mIHRoaXMgbGF5ZXIgaXMgPGxvdywgbG93PiAobm90IGluY2x1ZGluZyBhbGlnbm1lbnQgbGluZXMpXG4gICAgICAgICAgICB2YXIgbG93ID0gaSAqIDI7XG4gICAgICAgICAgICAvLyBUaGUgYm90dG9tLXJpZ2h0IG1vc3QgcG9pbnQgb2YgdGhpcyBsYXllciBpcyA8aGlnaCwgaGlnaD4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxuICAgICAgICAgICAgdmFyIGhpZ2ggPSBiYXNlTWF0cml4U2l6ZSAtIDEgLSBsb3c7XG4gICAgICAgICAgICAvLyBXZSBwdWxsIGJpdHMgZnJvbSB0aGUgdHdvIDIgeCByb3dTaXplIGNvbHVtbnMgYW5kIHR3byByb3dTaXplIHggMiByb3dzXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd1NpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBqICogMjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2xvdyArIGtdLCBhbGlnbm1lbnRNYXBbbG93ICsgal0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgMiAqIHJvd1NpemUgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtsb3cgKyBqXSwgYWxpZ25tZW50TWFwW2hpZ2ggLSBrXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDQgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbaGlnaCAtIGtdLCBhbGlnbm1lbnRNYXBbaGlnaCAtIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9wIHJvd1xuICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDYgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbaGlnaCAtIGpdLCBhbGlnbm1lbnRNYXBbbG93ICsga10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd09mZnNldCArPSByb3dTaXplICogODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3Yml0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgY29kZSBvZiBnaXZlbiBsZW5ndGggYW5kIGF0IGdpdmVuIGluZGV4IGluIGFuIGFycmF5IG9mIGJpdHNcbiAgICAgKi9cbiAgICBEZWNvZGVyLnJlYWRDb2RlID0gZnVuY3Rpb24gKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBzdGFydEluZGV4ICsgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgICAgIGlmIChyYXdiaXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzIHw9IDB4MDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgY29kZSBvZiBsZW5ndGggOCBpbiBhbiBhcnJheSBvZiBiaXRzLCBwYWRkaW5nIHdpdGggemVyb3NcbiAgICAgKi9cbiAgICBEZWNvZGVyLnJlYWRCeXRlID0gZnVuY3Rpb24gKHJhd2JpdHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgdmFyIG4gPSByYXdiaXRzLmxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChuID49IDgpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIG4pIDw8ICg4IC0gbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYWNrcyBhIGJpdCBhcnJheSBpbnRvIGJ5dGVzLCBtb3N0IHNpZ25pZmljYW50IGJpdCBmaXJzdFxuICAgICAqL1xuICAgIERlY29kZXIuY29udmVydEJvb2xBcnJheVRvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKGJvb2xBcnIpIHtcbiAgICAgICAgdmFyIGJ5dGVBcnIgPSBuZXcgVWludDhBcnJheSgoYm9vbEFyci5sZW5ndGggKyA3KSAvIDgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVBcnJbaV0gPSBEZWNvZGVyLnJlYWRCeXRlKGJvb2xBcnIsIDggKiBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycjtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLnRvdGFsQml0c0luTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJzLCBjb21wYWN0KSB7XG4gICAgICAgIHJldHVybiAoKGNvbXBhY3QgPyA4OCA6IDExMikgKyAxNiAqIGxheWVycykgKiBsYXllcnM7XG4gICAgfTtcbiAgICBEZWNvZGVyLlVQUEVSX1RBQkxFID0gW1xuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLFxuICAgICAgICAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdDVFJMX0xMJywgJ0NUUkxfTUwnLCAnQ1RSTF9ETCcsICdDVFJMX0JTJ1xuICAgIF07XG4gICAgRGVjb2Rlci5MT1dFUl9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJyxcbiAgICAgICAgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnQ1RSTF9VUycsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuTUlYRURfVEFCTEUgPSBbXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnXFx4MDEnLCAnXFx4MDInLCAnXFx4MDMnLCAnXFx4MDQnLCAnXFx4MDUnLCAnXFx4MDYnLCAnXFx4MDcnLCAnXFxiJywgJ1xcdCcsICdcXG4nLFxuICAgICAgICAnXFx4MGInLCAnXFxmJywgJ1xccicsICdcXHgxYicsICdcXHgxYycsICdcXHgxZCcsICdcXHgxZScsICdcXHgxZicsICdAJywgJ1xcXFwnLCAnXicsICdfJyxcbiAgICAgICAgJ2AnLCAnfCcsICd+JywgJ1xceDdmJywgJ0NUUkxfTEwnLCAnQ1RSTF9VTCcsICdDVFJMX1BMJywgJ0NUUkxfQlMnXG4gICAgXTtcbiAgICBEZWNvZGVyLlBVTkNUX1RBQkxFID0gW1xuICAgICAgICAnJywgJ1xccicsICdcXHJcXG4nLCAnLiAnLCAnLCAnLCAnOiAnLCAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLFxuICAgICAgICAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnWycsICddJywgJ3snLCAnfScsICdDVFJMX1VMJ1xuICAgIF07XG4gICAgRGVjb2Rlci5ESUdJVF9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJywnLCAnLicsICdDVFJMX1VMJywgJ0NUUkxfVVMnXG4gICAgXTtcbiAgICByZXR1cm4gRGVjb2Rlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Point = void 0;\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar AztecDetectorResult_1 = __webpack_require__(/*! ../AztecDetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js\");\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar WhiteRectangleDetector_1 = __webpack_require__(/*! ../../common/detector/WhiteRectangleDetector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar Point = /** @class */ (function () {\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype.toResultPoint = function () {\n        return new ResultPoint_1.default(this.getX(), this.getY());\n    };\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n    return Point;\n}());\nexports.Point = Point;\n/**\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n * is rotated or skewed, or partially obscured.\n *\n * @author David Olivier\n * @author Frank Yellin\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.EXPECTED_CORNER_BITS = new Int32Array([\n            0xee0,\n            0x1dc,\n            0x83b,\n            0x707,\n        ]);\n        this.image = image;\n    }\n    Detector.prototype.detect = function () {\n        return this.detectMirror(false);\n    };\n    /**\n     * Detects an Aztec Code in an image.\n     *\n     * @param isMirror if true, image is a mirror-image of original\n     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n     * @throws NotFoundException if no Aztec Code can be found\n     */\n    Detector.prototype.detectMirror = function (isMirror) {\n        // 1. Get the center of the aztec matrix\n        var pCenter = this.getMatrixCenter();\n        // 2. Get the center points of the four diagonal points just outside the bull's eye\n        //  [topRight, bottomRight, bottomLeft, topLeft]\n        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n        if (isMirror) {\n            var temp = bullsEyeCorners[0];\n            bullsEyeCorners[0] = bullsEyeCorners[2];\n            bullsEyeCorners[2] = temp;\n        }\n        // 3. Get the size of the matrix and other parameters from the bull's eye\n        this.extractParameters(bullsEyeCorners);\n        // 4. Sample the grid\n        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n        // 5. Get the corners of the matrix.\n        var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n    };\n    /**\n     * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @throws NotFoundException in case of too many errors or invalid parameters\n     */\n    Detector.prototype.extractParameters = function (bullsEyeCorners) {\n        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\n            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n            throw new NotFoundException_1.default();\n        }\n        var length = 2 * this.nbCenterLayers;\n        // Get the bits around the bull's eye\n        var sides = new Int32Array([\n            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n        ]);\n        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n        // orientation marks.\n        // sides[shift] is the row/column that goes from the corner with three\n        // orientation marks to the corner with two.\n        this.shift = this.getRotation(sides, length);\n        // Flatten the parameter bits into a single 28- or 40-bit long\n        var parameterData = 0;\n        for (var i = 0; i < 4; i++) {\n            var side = sides[(this.shift + i) % 4];\n            if (this.compact) {\n                // Each side of the form ..XXXXXXX. where Xs are parameter data\n                parameterData <<= 7;\n                parameterData += (side >> 1) & 0x7F;\n            }\n            else {\n                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                parameterData <<= 10;\n                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\n            }\n        }\n        // Corrects parameter data using RS.  Returns just the data portion\n        // without the error correction.\n        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n        if (this.compact) {\n            // 8 bits:  2 bits layers and 6 bits data blocks\n            this.nbLayers = (correctedData >> 6) + 1;\n            this.nbDataBlocks = (correctedData & 0x3F) + 1;\n        }\n        else {\n            // 16 bits:  5 bits layers and 11 bits data blocks\n            this.nbLayers = (correctedData >> 11) + 1;\n            this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n        }\n    };\n    Detector.prototype.getRotation = function (sides, length) {\n        // In a normal pattern, we expect to See\n        //   **    .*             D       A\n        //   *      *\n        //\n        //   .      *\n        //   ..    ..             C       B\n        //\n        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n        // into a 12-bit integer.  Start with the bit at A\n        var cornerBits = 0;\n        sides.forEach(function (side, idx, arr) {\n            // XX......X where X's are orientation marks\n            var t = ((side >> (length - 2)) << 1) + (side & 1);\n            cornerBits = (cornerBits << 3) + t;\n        });\n        // for (var side in sides) {\n        //     // XX......X where X's are orientation marks\n        //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n        //     cornerBits = (cornerBits << 3) + t;\n        // }\n        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n        // together.  cornerBits is now:\n        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n        // corner. Since the four rotation values have a Hamming distance of 8, we\n        // can easily tolerate two errors.\n        for (var shift = 0; shift < 4; shift++) {\n            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                return shift;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Corrects the parameter bits using Reed-Solomon algorithm.\n     *\n     * @param parameterData parameter bits\n     * @param compact true if this is a compact Aztec code\n     * @throws NotFoundException if the array contains too many errors\n     */\n    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n        var numCodewords;\n        var numDataCodewords;\n        if (compact) {\n            numCodewords = 7;\n            numDataCodewords = 2;\n        }\n        else {\n            numCodewords = 10;\n            numDataCodewords = 4;\n        }\n        var numECCodewords = numCodewords - numDataCodewords;\n        var parameterWords = new Int32Array(numCodewords);\n        for (var i = numCodewords - 1; i >= 0; --i) {\n            parameterWords[i] = parameterData & 0xF;\n            parameterData >>= 4;\n        }\n        try {\n            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n            rsDecoder.decode(parameterWords, numECCodewords);\n        }\n        catch (ignored) {\n            throw new NotFoundException_1.default();\n        }\n        // Toss the error correction.  Just return the data as an integer\n        var result = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            result = (result << 4) + parameterWords[i];\n        }\n        return result;\n    };\n    /**\n     * Finds the corners of a bull-eye centered on the passed point.\n     * This returns the centers of the diagonal points just outside the bull's eye\n     * Returns [topRight, bottomRight, bottomLeft, topLeft]\n     *\n     * @param pCenter Center point\n     * @return The corners of the bull-eye\n     * @throws NotFoundException If no valid bull-eye can be found\n     */\n    Detector.prototype.getBullsEyeCorners = function (pCenter) {\n        var pina = pCenter;\n        var pinb = pCenter;\n        var pinc = pCenter;\n        var pind = pCenter;\n        var color = true;\n        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n            var pouta = this.getFirstDifferent(pina, color, 1, -1);\n            var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n            var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n            var poutd = this.getFirstDifferent(pind, color, -1, -1);\n            // d      a\n            //\n            // c      b\n            if (this.nbCenterLayers > 2) {\n                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                    break;\n                }\n            }\n            pina = pouta;\n            pinb = poutb;\n            pinc = poutc;\n            pind = poutd;\n            color = !color;\n        }\n        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n            throw new NotFoundException_1.default();\n        }\n        this.compact = this.nbCenterLayers === 5;\n        // Expand the square by .5 pixel in each direction so that we're on the border\n        // between the white square and the black square\n        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);\n        // Expand the square so that its corners are the centers of the points\n        // just outside the bull's eye.\n        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n    };\n    /**\n     * Finds a candidate center point of an Aztec code from an image\n     *\n     * @return the center point\n     */\n    Detector.prototype.getMatrixCenter = function () {\n        var pointA;\n        var pointB;\n        var pointC;\n        var pointD;\n        // Get a white rectangle that can be the border of the matrix in center bull's eye or\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case, surely in the bull's eye, we try to expand the rectangle.\n            var cx_1 = this.image.getWidth() / 2;\n            var cy_1 = this.image.getHeight() / 2;\n            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n        }\n        // Compute the center of the rectangle\n        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        // Redetermine the white rectangle starting from previously computed center.\n        // This will ensure that we end up with a white rectangle in center bull's eye\n        // in order to compute a more accurate center.\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case we try to expand the rectangle.\n            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n        }\n        // Recompute the center of the rectangle\n        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        return new Point(cx, cy);\n    };\n    /**\n     * Gets the Aztec code corners from the bull's eye corners and the parameters.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @return the array of aztec code corners\n     */\n    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n    };\n    /**\n     * Creates a BitMatrix by sampling the provided image.\n     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n     * diagonal just outside the bull's eye.\n     */\n    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        var dimension = this.getDimension();\n        var low = dimension / 2 - this.nbCenterLayers;\n        var high = dimension / 2 + this.nbCenterLayers;\n        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n        high, low, // topright\n        high, high, // bottomright\n        low, high, // bottomleft\n        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Samples a line.\n     *\n     * @param p1   start point (inclusive)\n     * @param p2   end point (exclusive)\n     * @param size number of bits\n     * @return the array of bits as an int (first bit is high-order bit of result)\n     */\n    Detector.prototype.sampleLine = function (p1, p2, size) {\n        var result = 0;\n        var d = this.distanceResultPoint(p1, p2);\n        var moduleSize = d / size;\n        var px = p1.getX();\n        var py = p1.getY();\n        var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n        var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n        for (var i = 0; i < size; i++) {\n            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n                result |= 1 << (size - i - 1);\n            }\n        }\n        return result;\n    };\n    /**\n     * @return true if the border of the rectangle passed in parameter is compound of white points only\n     *         or black points only\n     */\n    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n        var corr = 3;\n        p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n        p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n        p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n        p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n        var cInit = this.getColor(p4, p1);\n        if (cInit === 0) {\n            return false;\n        }\n        var c = this.getColor(p1, p2);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p2, p3);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p3, p4);\n        return c === cInit;\n    };\n    /**\n     * Gets the color of a segment\n     *\n     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n     */\n    Detector.prototype.getColor = function (p1, p2) {\n        var d = this.distancePoint(p1, p2);\n        var dx = (p2.getX() - p1.getX()) / d;\n        var dy = (p2.getY() - p1.getY()) / d;\n        var error = 0;\n        var px = p1.getX();\n        var py = p1.getY();\n        var colorModel = this.image.get(p1.getX(), p1.getY());\n        var iMax = Math.ceil(d);\n        for (var i = 0; i < iMax; i++) {\n            px += dx;\n            py += dy;\n            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n                error++;\n            }\n        }\n        var errRatio = error / d;\n        if (errRatio > 0.1 && errRatio < 0.9) {\n            return 0;\n        }\n        return (errRatio <= 0.1) === colorModel ? 1 : -1;\n    };\n    /**\n     * Gets the coordinate of the first point with a different color in the given direction\n     */\n    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n        var x = init.getX() + dx;\n        var y = init.getY() + dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n            y += dy;\n        }\n        x -= dx;\n        y -= dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n        }\n        x -= dx;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            y += dy;\n        }\n        y -= dy;\n        return new Point(x, y);\n    };\n    /**\n     * Expand the square represented by the corner points by pushing out equally in all directions\n     *\n     * @param cornerPoints the corners of the square, which has the bull's eye at its center\n     * @param oldSide the original length of the side of the square in the target bit matrix\n     * @param newSide the new length of the size of the square in the target bit matrix\n     * @return the corners of the expanded square\n     */\n    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n        var ratio = newSide / (2.0 * oldSide);\n        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n        dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        var results = [result0, result1, result2, result3];\n        return results;\n    };\n    Detector.prototype.isValid = function (x, y) {\n        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n    };\n    Detector.prototype.isValidPoint = function (point) {\n        var x = MathUtils_1.default.round(point.getX());\n        var y = MathUtils_1.default.round(point.getY());\n        return this.isValid(x, y);\n    };\n    Detector.prototype.distancePoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.distanceResultPoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.getDimension = function () {\n        if (this.compact) {\n            return 4 * this.nbLayers + 11;\n        }\n        if (this.nbLayers <= 4) {\n            return 4 * this.nbLayers + 15;\n        }\n        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\n    };\n    return Detector;\n}());\nexports[\"default\"] = Detector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9kZXRlY3Rvci9EZXRlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2Isb0JBQW9CLG1CQUFPLENBQUMsMklBQW1CO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLDhKQUF3QjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyx1S0FBaUM7QUFDM0QsK0JBQStCLG1CQUFPLENBQUMsaU1BQThDO0FBQ3JGLGtCQUFrQixtQkFBTyxDQUFDLDZLQUFvQztBQUM5RCwyQkFBMkIsbUJBQU8sQ0FBQywrTEFBNkM7QUFDaEYsMEJBQTBCLG1CQUFPLENBQUMsdUpBQXlCO0FBQzNELDRCQUE0QixtQkFBTyxDQUFDLHlLQUFrQztBQUN0RSxnQkFBZ0IsbUJBQU8sQ0FBQyw2SUFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9kZXRlY3Rvci9EZXRlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2ludCA9IHZvaWQgMDtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIEF6dGVjRGV0ZWN0b3JSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9BenRlY0RldGVjdG9yUmVzdWx0XCIpO1xudmFyIE1hdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XG52YXIgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9XaGl0ZVJlY3RhbmdsZURldGVjdG9yXCIpO1xudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XG52YXIgUmVlZFNvbG9tb25EZWNvZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL1JlZWRTb2xvbW9uRGVjb2RlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIEdyaWRTYW1wbGVySW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZVwiKTtcbnZhciBJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9JbnRlZ2VyXCIpO1xudmFyIFBvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgUG9pbnQucHJvdG90eXBlLnRvUmVzdWx0UG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHRoaXMuZ2V0WCgpLCB0aGlzLmdldFkoKSk7XG4gICAgfTtcbiAgICBQb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9O1xuICAgIFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50O1xufSgpKTtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbi8qKlxuICogRW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhbiBBenRlYyBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBBenRlYyBDb2RlXG4gKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLlxuICpcbiAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICogQGF1dGhvciBGcmFuayBZZWxsaW5cbiAqL1xudmFyIERldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldGVjdG9yKGltYWdlKSB7XG4gICAgICAgIHRoaXMuRVhQRUNURURfQ09STkVSX0JJVFMgPSBuZXcgSW50MzJBcnJheShbXG4gICAgICAgICAgICAweGVlMCxcbiAgICAgICAgICAgIDB4MWRjLFxuICAgICAgICAgICAgMHg4M2IsXG4gICAgICAgICAgICAweDcwNyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0TWlycm9yKGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVjdHMgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc01pcnJvciBpZiB0cnVlLCBpbWFnZSBpcyBhIG1pcnJvci1pbWFnZSBvZiBvcmlnaW5hbFxuICAgICAqIEByZXR1cm4ge0BsaW5rIEF6dGVjRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYW4gQXp0ZWMgQ29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gQXp0ZWMgQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0TWlycm9yID0gZnVuY3Rpb24gKGlzTWlycm9yKSB7XG4gICAgICAgIC8vIDEuIEdldCB0aGUgY2VudGVyIG9mIHRoZSBhenRlYyBtYXRyaXhcbiAgICAgICAgdmFyIHBDZW50ZXIgPSB0aGlzLmdldE1hdHJpeENlbnRlcigpO1xuICAgICAgICAvLyAyLiBHZXQgdGhlIGNlbnRlciBwb2ludHMgb2YgdGhlIGZvdXIgZGlhZ29uYWwgcG9pbnRzIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAvLyAgW3RvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCwgdG9wTGVmdF1cbiAgICAgICAgdmFyIGJ1bGxzRXllQ29ybmVycyA9IHRoaXMuZ2V0QnVsbHNFeWVDb3JuZXJzKHBDZW50ZXIpO1xuICAgICAgICBpZiAoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYnVsbHNFeWVDb3JuZXJzWzBdO1xuICAgICAgICAgICAgYnVsbHNFeWVDb3JuZXJzWzBdID0gYnVsbHNFeWVDb3JuZXJzWzJdO1xuICAgICAgICAgICAgYnVsbHNFeWVDb3JuZXJzWzJdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBHZXQgdGhlIHNpemUgb2YgdGhlIG1hdHJpeCBhbmQgb3RoZXIgcGFyYW1ldGVycyBmcm9tIHRoZSBidWxsJ3MgZXllXG4gICAgICAgIHRoaXMuZXh0cmFjdFBhcmFtZXRlcnMoYnVsbHNFeWVDb3JuZXJzKTtcbiAgICAgICAgLy8gNC4gU2FtcGxlIHRoZSBncmlkXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIGJ1bGxzRXllQ29ybmVyc1t0aGlzLnNoaWZ0ICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDEpICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDIpICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDMpICUgNF0pO1xuICAgICAgICAvLyA1LiBHZXQgdGhlIGNvcm5lcnMgb2YgdGhlIG1hdHJpeC5cbiAgICAgICAgdmFyIGNvcm5lcnMgPSB0aGlzLmdldE1hdHJpeENvcm5lclBvaW50cyhidWxsc0V5ZUNvcm5lcnMpO1xuICAgICAgICByZXR1cm4gbmV3IEF6dGVjRGV0ZWN0b3JSZXN1bHRfMS5kZWZhdWx0KGJpdHMsIGNvcm5lcnMsIHRoaXMuY29tcGFjdCwgdGhpcy5uYkRhdGFCbG9ja3MsIHRoaXMubmJMYXllcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIG51bWJlciBvZiBkYXRhIGxheWVycyBhbmQgZGF0YSBibG9ja3MgZnJvbSB0aGUgbGF5ZXIgYXJvdW5kIHRoZSBidWxsJ3MgZXllLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1bGxzRXllQ29ybmVycyB0aGUgYXJyYXkgb2YgYnVsbCdzIGV5ZSBjb3JuZXJzXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpbiBjYXNlIG9mIHRvbyBtYW55IGVycm9ycyBvciBpbnZhbGlkIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoYnVsbHNFeWVDb3JuZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzBdKSB8fCAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzFdKSB8fFxuICAgICAgICAgICAgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1syXSkgfHwgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1szXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gMiAqIHRoaXMubmJDZW50ZXJMYXllcnM7XG4gICAgICAgIC8vIEdldCB0aGUgYml0cyBhcm91bmQgdGhlIGJ1bGwncyBleWVcbiAgICAgICAgdmFyIHNpZGVzID0gbmV3IEludDMyQXJyYXkoW1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1swXSwgYnVsbHNFeWVDb3JuZXJzWzFdLCBsZW5ndGgpLFxuICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1sxXSwgYnVsbHNFeWVDb3JuZXJzWzJdLCBsZW5ndGgpLFxuICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1syXSwgYnVsbHNFeWVDb3JuZXJzWzNdLCBsZW5ndGgpLFxuICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1szXSwgYnVsbHNFeWVDb3JuZXJzWzBdLCBsZW5ndGgpIC8vIFRvcFxuICAgICAgICBdKTtcbiAgICAgICAgLy8gYnVsbHNFeWVDb3JuZXJzW3NoaWZ0XSBpcyB0aGUgY29ybmVyIG9mIHRoZSBidWxscydleWUgdGhhdCBoYXMgdGhyZWVcbiAgICAgICAgLy8gb3JpZW50YXRpb24gbWFya3MuXG4gICAgICAgIC8vIHNpZGVzW3NoaWZ0XSBpcyB0aGUgcm93L2NvbHVtbiB0aGF0IGdvZXMgZnJvbSB0aGUgY29ybmVyIHdpdGggdGhyZWVcbiAgICAgICAgLy8gb3JpZW50YXRpb24gbWFya3MgdG8gdGhlIGNvcm5lciB3aXRoIHR3by5cbiAgICAgICAgdGhpcy5zaGlmdCA9IHRoaXMuZ2V0Um90YXRpb24oc2lkZXMsIGxlbmd0aCk7XG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIHBhcmFtZXRlciBiaXRzIGludG8gYSBzaW5nbGUgMjgtIG9yIDQwLWJpdCBsb25nXG4gICAgICAgIHZhciBwYXJhbWV0ZXJEYXRhID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaWRlID0gc2lkZXNbKHRoaXMuc2hpZnQgKyBpKSAlIDRdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc2lkZSBvZiB0aGUgZm9ybSAuLlhYWFhYWFguIHdoZXJlIFhzIGFyZSBwYXJhbWV0ZXIgZGF0YVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPDw9IDc7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoc2lkZSA+PiAxKSAmIDB4N0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWC5YWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSA8PD0gMTA7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoKHNpZGUgPj4gMikgJiAoMHgxZiA8PCA1KSkgKyAoKHNpZGUgPj4gMSkgJiAweDFGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb3JyZWN0cyBwYXJhbWV0ZXIgZGF0YSB1c2luZyBSUy4gIFJldHVybnMganVzdCB0aGUgZGF0YSBwb3J0aW9uXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIGVycm9yIGNvcnJlY3Rpb24uXG4gICAgICAgIHZhciBjb3JyZWN0ZWREYXRhID0gdGhpcy5nZXRDb3JyZWN0ZWRQYXJhbWV0ZXJEYXRhKHBhcmFtZXRlckRhdGEsIHRoaXMuY29tcGFjdCk7XG4gICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgIC8vIDggYml0czogIDIgYml0cyBsYXllcnMgYW5kIDYgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IChjb3JyZWN0ZWREYXRhID4+IDYpICsgMTtcbiAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDNGKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAxNiBiaXRzOiAgNSBiaXRzIGxheWVycyBhbmQgMTEgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IChjb3JyZWN0ZWREYXRhID4+IDExKSArIDE7XG4gICAgICAgICAgICB0aGlzLm5iRGF0YUJsb2NrcyA9IChjb3JyZWN0ZWREYXRhICYgMHg3RkYpICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKHNpZGVzLCBsZW5ndGgpIHtcbiAgICAgICAgLy8gSW4gYSBub3JtYWwgcGF0dGVybiwgd2UgZXhwZWN0IHRvIFNlZVxuICAgICAgICAvLyAgICoqICAgIC4qICAgICAgICAgICAgIEQgICAgICAgQVxuICAgICAgICAvLyAgICogICAgICAqXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgLiAgICAgICpcbiAgICAgICAgLy8gICAuLiAgICAuLiAgICAgICAgICAgICBDICAgICAgIEJcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR3JhYiB0aGUgMyBiaXRzIGZyb20gZWFjaCBvZiB0aGUgc2lkZXMgdGhlIGZvcm0gdGhlIGxvY2F0b3IgcGF0dGVybiBhbmQgY29uY2F0ZW5hdGVcbiAgICAgICAgLy8gaW50byBhIDEyLWJpdCBpbnRlZ2VyLiAgU3RhcnQgd2l0aCB0aGUgYml0IGF0IEFcbiAgICAgICAgdmFyIGNvcm5lckJpdHMgPSAwO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlLCBpZHgsIGFycikge1xuICAgICAgICAgICAgLy8gWFguLi4uLi5YIHdoZXJlIFgncyBhcmUgb3JpZW50YXRpb24gbWFya3NcbiAgICAgICAgICAgIHZhciB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xuICAgICAgICAgICAgY29ybmVyQml0cyA9IChjb3JuZXJCaXRzIDw8IDMpICsgdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZvciAodmFyIHNpZGUgaW4gc2lkZXMpIHtcbiAgICAgICAgLy8gICAgIC8vIFhYLi4uLi4uWCB3aGVyZSBYJ3MgYXJlIG9yaWVudGF0aW9uIG1hcmtzXG4gICAgICAgIC8vICAgICB2YXIgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcbiAgICAgICAgLy8gICAgIGNvcm5lckJpdHMgPSAoY29ybmVyQml0cyA8PCAzKSArIHQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gTW92IHRoZSBib3R0b20gYml0IHRvIHRoZSB0b3AsIHNvIHRoYXQgdGhlIHRocmVlIGJpdHMgb2YgdGhlIGxvY2F0b3IgcGF0dGVybiBhdCBBIGFyZVxuICAgICAgICAvLyB0b2dldGhlci4gIGNvcm5lckJpdHMgaXMgbm93OlxuICAgICAgICAvLyAgMyBvcmllbnRhdGlvbiBiaXRzIGF0IEEgfHwgMyBvcmllbnRhdGlvbiBiaXRzIGF0IEIgfHwgLi4uIHx8IDMgb3JpZW50YXRpb24gYml0cyBhdCBEXG4gICAgICAgIGNvcm5lckJpdHMgPSAoKGNvcm5lckJpdHMgJiAxKSA8PCAxMSkgKyAoY29ybmVyQml0cyA+PiAxKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBzaGlmdCBpbmRpY2F0ZXMgd2hpY2ggZWxlbWVudCBvZiBCdWxsc0V5ZUNvcm5lcnNbXSBnb2VzIGludG8gdGhlIHRvcC1sZWZ0XG4gICAgICAgIC8vIGNvcm5lci4gU2luY2UgdGhlIGZvdXIgcm90YXRpb24gdmFsdWVzIGhhdmUgYSBIYW1taW5nIGRpc3RhbmNlIG9mIDgsIHdlXG4gICAgICAgIC8vIGNhbiBlYXNpbHkgdG9sZXJhdGUgdHdvIGVycm9ycy5cbiAgICAgICAgZm9yICh2YXIgc2hpZnQgPSAwOyBzaGlmdCA8IDQ7IHNoaWZ0KyspIHtcbiAgICAgICAgICAgIGlmIChJbnRlZ2VyXzEuZGVmYXVsdC5iaXRDb3VudChjb3JuZXJCaXRzIF4gdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUU1tzaGlmdF0pIDw9IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ycmVjdHMgdGhlIHBhcmFtZXRlciBiaXRzIHVzaW5nIFJlZWQtU29sb21vbiBhbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyRGF0YSBwYXJhbWV0ZXIgYml0c1xuICAgICAqIEBwYXJhbSBjb21wYWN0IHRydWUgaWYgdGhpcyBpcyBhIGNvbXBhY3QgQXp0ZWMgY29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgdGhlIGFycmF5IGNvbnRhaW5zIHRvbyBtYW55IGVycm9yc1xuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRDb3JyZWN0ZWRQYXJhbWV0ZXJEYXRhID0gZnVuY3Rpb24gKHBhcmFtZXRlckRhdGEsIGNvbXBhY3QpIHtcbiAgICAgICAgdmFyIG51bUNvZGV3b3JkcztcbiAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICBudW1Db2Rld29yZHMgPSA3O1xuICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1Db2Rld29yZHMgPSAxMDtcbiAgICAgICAgICAgIG51bURhdGFDb2Rld29yZHMgPSA0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1FQ0NvZGV3b3JkcyA9IG51bUNvZGV3b3JkcyAtIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJXb3JkcyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3Jkcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSBudW1Db2Rld29yZHMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcGFyYW1ldGVyV29yZHNbaV0gPSBwYXJhbWV0ZXJEYXRhICYgMHhGO1xuICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSA+Pj0gNDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXJfMS5kZWZhdWx0KEdlbmVyaWNHRl8xLmRlZmF1bHQuQVpURUNfUEFSQU0pO1xuICAgICAgICAgICAgcnNEZWNvZGVyLmRlY29kZShwYXJhbWV0ZXJXb3JkcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9zcyB0aGUgZXJyb3IgY29ycmVjdGlvbi4gIEp1c3QgcmV0dXJuIHRoZSBkYXRhIGFzIGFuIGludGVnZXJcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDQpICsgcGFyYW1ldGVyV29yZHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb3JuZXJzIG9mIGEgYnVsbC1leWUgY2VudGVyZWQgb24gdGhlIHBhc3NlZCBwb2ludC5cbiAgICAgKiBUaGlzIHJldHVybnMgdGhlIGNlbnRlcnMgb2YgdGhlIGRpYWdvbmFsIHBvaW50cyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWVcbiAgICAgKiBSZXR1cm5zIFt0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQsIHRvcExlZnRdXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcENlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIFRoZSBjb3JuZXJzIG9mIHRoZSBidWxsLWV5ZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gSWYgbm8gdmFsaWQgYnVsbC1leWUgY2FuIGJlIGZvdW5kXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldEJ1bGxzRXllQ29ybmVycyA9IGZ1bmN0aW9uIChwQ2VudGVyKSB7XG4gICAgICAgIHZhciBwaW5hID0gcENlbnRlcjtcbiAgICAgICAgdmFyIHBpbmIgPSBwQ2VudGVyO1xuICAgICAgICB2YXIgcGluYyA9IHBDZW50ZXI7XG4gICAgICAgIHZhciBwaW5kID0gcENlbnRlcjtcbiAgICAgICAgdmFyIGNvbG9yID0gdHJ1ZTtcbiAgICAgICAgZm9yICh0aGlzLm5iQ2VudGVyTGF5ZXJzID0gMTsgdGhpcy5uYkNlbnRlckxheWVycyA8IDk7IHRoaXMubmJDZW50ZXJMYXllcnMrKykge1xuICAgICAgICAgICAgdmFyIHBvdXRhID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5hLCBjb2xvciwgMSwgLTEpO1xuICAgICAgICAgICAgdmFyIHBvdXRiID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5iLCBjb2xvciwgMSwgMSk7XG4gICAgICAgICAgICB2YXIgcG91dGMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmMsIGNvbG9yLCAtMSwgMSk7XG4gICAgICAgICAgICB2YXIgcG91dGQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmQsIGNvbG9yLCAtMSwgLTEpO1xuICAgICAgICAgICAgLy8gZCAgICAgIGFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjICAgICAgYlxuICAgICAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgPiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSAodGhpcy5kaXN0YW5jZVBvaW50KHBvdXRkLCBwb3V0YSkgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKSAvICh0aGlzLmRpc3RhbmNlUG9pbnQocGluZCwgcGluYSkgKiAodGhpcy5uYkNlbnRlckxheWVycyArIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocSA8IDAuNzUgfHwgcSA+IDEuMjUgfHwgIXRoaXMuaXNXaGl0ZU9yQmxhY2tSZWN0YW5nbGUocG91dGEsIHBvdXRiLCBwb3V0YywgcG91dGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpbmEgPSBwb3V0YTtcbiAgICAgICAgICAgIHBpbmIgPSBwb3V0YjtcbiAgICAgICAgICAgIHBpbmMgPSBwb3V0YztcbiAgICAgICAgICAgIHBpbmQgPSBwb3V0ZDtcbiAgICAgICAgICAgIGNvbG9yID0gIWNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5iQ2VudGVyTGF5ZXJzICE9PSA1ICYmIHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBhY3QgPSB0aGlzLm5iQ2VudGVyTGF5ZXJzID09PSA1O1xuICAgICAgICAvLyBFeHBhbmQgdGhlIHNxdWFyZSBieSAuNSBwaXhlbCBpbiBlYWNoIGRpcmVjdGlvbiBzbyB0aGF0IHdlJ3JlIG9uIHRoZSBib3JkZXJcbiAgICAgICAgLy8gYmV0d2VlbiB0aGUgd2hpdGUgc3F1YXJlIGFuZCB0aGUgYmxhY2sgc3F1YXJlXG4gICAgICAgIHZhciBwaW5heCA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocGluYS5nZXRYKCkgKyAwLjUsIHBpbmEuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgdmFyIHBpbmJ4ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwaW5iLmdldFgoKSArIDAuNSwgcGluYi5nZXRZKCkgKyAwLjUpO1xuICAgICAgICB2YXIgcGluY3ggPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHBpbmMuZ2V0WCgpIC0gMC41LCBwaW5jLmdldFkoKSArIDAuNSk7XG4gICAgICAgIHZhciBwaW5keCA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocGluZC5nZXRYKCkgLSAwLjUsIHBpbmQuZ2V0WSgpIC0gMC41KTtcbiAgICAgICAgLy8gRXhwYW5kIHRoZSBzcXVhcmUgc28gdGhhdCBpdHMgY29ybmVycyBhcmUgdGhlIGNlbnRlcnMgb2YgdGhlIHBvaW50c1xuICAgICAgICAvLyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNxdWFyZShbcGluYXgsIHBpbmJ4LCBwaW5jeCwgcGluZHhdLCAyICogdGhpcy5uYkNlbnRlckxheWVycyAtIDMsIDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgY2FuZGlkYXRlIGNlbnRlciBwb2ludCBvZiBhbiBBenRlYyBjb2RlIGZyb20gYW4gaW1hZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIGNlbnRlciBwb2ludFxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRNYXRyaXhDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb2ludEE7XG4gICAgICAgIHZhciBwb2ludEI7XG4gICAgICAgIHZhciBwb2ludEM7XG4gICAgICAgIHZhciBwb2ludEQ7XG4gICAgICAgIC8vIEdldCBhIHdoaXRlIHJlY3RhbmdsZSB0aGF0IGNhbiBiZSB0aGUgYm9yZGVyIG9mIHRoZSBtYXRyaXggaW4gY2VudGVyIGJ1bGwncyBleWUgb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5pbWFnZSkuZGV0ZWN0KCk7XG4gICAgICAgICAgICBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XG4gICAgICAgICAgICBwb2ludEMgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgICAgICBwb2ludEQgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZXhjZXB0aW9uIGNhbiBiZSBpbiBjYXNlIHRoZSBpbml0aWFsIHJlY3RhbmdsZSBpcyB3aGl0ZVxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCBzdXJlbHkgaW4gdGhlIGJ1bGwncyBleWUsIHdlIHRyeSB0byBleHBhbmQgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgIHZhciBjeF8xID0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgIHZhciBjeV8xID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICBwb2ludEEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeF8xICsgNywgY3lfMSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4XzEgKyA3LCBjeV8xICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICBwb2ludEMgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeF8xIC0gNywgY3lfMSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIHBvaW50RCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4XzEgLSA3LCBjeV8xIC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICB2YXIgY3ggPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKChwb2ludEEuZ2V0WCgpICsgcG9pbnRELmdldFgoKSArIHBvaW50Qi5nZXRYKCkgKyBwb2ludEMuZ2V0WCgpKSAvIDQuMCk7XG4gICAgICAgIHZhciBjeSA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoKHBvaW50QS5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkpIC8gNC4wKTtcbiAgICAgICAgLy8gUmVkZXRlcm1pbmUgdGhlIHdoaXRlIHJlY3RhbmdsZSBzdGFydGluZyBmcm9tIHByZXZpb3VzbHkgY29tcHV0ZWQgY2VudGVyLlxuICAgICAgICAvLyBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgd2UgZW5kIHVwIHdpdGggYSB3aGl0ZSByZWN0YW5nbGUgaW4gY2VudGVyIGJ1bGwncyBleWVcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gY29tcHV0ZSBhIG1vcmUgYWNjdXJhdGUgY2VudGVyLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvcm5lclBvaW50cyA9IG5ldyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yXzEuZGVmYXVsdCh0aGlzLmltYWdlLCAxNSwgY3gsIGN5KS5kZXRlY3QoKTtcbiAgICAgICAgICAgIHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcbiAgICAgICAgICAgIHBvaW50QiA9IGNvcm5lclBvaW50c1sxXTtcbiAgICAgICAgICAgIHBvaW50QyA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgIHBvaW50RCA9IGNvcm5lclBvaW50c1szXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBleGNlcHRpb24gY2FuIGJlIGluIGNhc2UgdGhlIGluaXRpYWwgcmVjdGFuZ2xlIGlzIHdoaXRlXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2UgdHJ5IHRvIGV4cGFuZCB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggKyA3LCBjeSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIHBvaW50QyA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4IC0gNywgY3kgKyA3KSwgZmFsc2UsIC0xLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5IC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNvbXB1dGUgdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIGN4ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZCgocG9pbnRBLmdldFgoKSArIHBvaW50RC5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSkgLyA0LjApO1xuICAgICAgICBjeSA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoKHBvaW50QS5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkpIC8gNC4wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChjeCwgY3kpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQXp0ZWMgY29kZSBjb3JuZXJzIGZyb20gdGhlIGJ1bGwncyBleWUgY29ybmVycyBhbmQgdGhlIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcbiAgICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBhenRlYyBjb2RlIGNvcm5lcnNcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0TWF0cml4Q29ybmVyUG9pbnRzID0gZnVuY3Rpb24gKGJ1bGxzRXllQ29ybmVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTcXVhcmUoYnVsbHNFeWVDb3JuZXJzLCAyICogdGhpcy5uYkNlbnRlckxheWVycywgdGhpcy5nZXREaW1lbnNpb24oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQml0TWF0cml4IGJ5IHNhbXBsaW5nIHRoZSBwcm92aWRlZCBpbWFnZS5cbiAgICAgKiB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGFuZCBib3R0b21MZWZ0IGFyZSB0aGUgY2VudGVycyBvZiB0aGUgc3F1YXJlcyBvbiB0aGVcbiAgICAgKiBkaWFnb25hbCBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLnNhbXBsZUdyaWQgPSBmdW5jdGlvbiAoaW1hZ2UsIHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCkge1xuICAgICAgICB2YXIgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2VfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbigpO1xuICAgICAgICB2YXIgbG93ID0gZGltZW5zaW9uIC8gMiAtIHRoaXMubmJDZW50ZXJMYXllcnM7XG4gICAgICAgIHZhciBoaWdoID0gZGltZW5zaW9uIC8gMiArIHRoaXMubmJDZW50ZXJMYXllcnM7XG4gICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCBsb3csIGxvdywgLy8gdG9wbGVmdFxuICAgICAgICBoaWdoLCBsb3csIC8vIHRvcHJpZ2h0XG4gICAgICAgIGhpZ2gsIGhpZ2gsIC8vIGJvdHRvbXJpZ2h0XG4gICAgICAgIGxvdywgaGlnaCwgLy8gYm90dG9tbGVmdFxuICAgICAgICB0b3BMZWZ0LmdldFgoKSwgdG9wTGVmdC5nZXRZKCksIHRvcFJpZ2h0LmdldFgoKSwgdG9wUmlnaHQuZ2V0WSgpLCBib3R0b21SaWdodC5nZXRYKCksIGJvdHRvbVJpZ2h0LmdldFkoKSwgYm90dG9tTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhbXBsZXMgYSBsaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHAxICAgc3RhcnQgcG9pbnQgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0gcDIgICBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0gc2l6ZSBudW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGJpdHMgYXMgYW4gaW50IChmaXJzdCBiaXQgaXMgaGlnaC1vcmRlciBiaXQgb2YgcmVzdWx0KVxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5zYW1wbGVMaW5lID0gZnVuY3Rpb24gKHAxLCBwMiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlUmVzdWx0UG9pbnQocDEsIHAyKTtcbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSBkIC8gc2l6ZTtcbiAgICAgICAgdmFyIHB4ID0gcDEuZ2V0WCgpO1xuICAgICAgICB2YXIgcHkgPSBwMS5nZXRZKCk7XG4gICAgICAgIHZhciBkeCA9IG1vZHVsZVNpemUgKiAocDIuZ2V0WCgpIC0gcDEuZ2V0WCgpKSAvIGQ7XG4gICAgICAgIHZhciBkeSA9IG1vZHVsZVNpemUgKiAocDIuZ2V0WSgpIC0gcDEuZ2V0WSgpKSAvIGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChweCArIGkgKiBkeCksIE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQocHkgKyBpICogZHkpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxIDw8IChzaXplIC0gaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGJvcmRlciBvZiB0aGUgcmVjdGFuZ2xlIHBhc3NlZCBpbiBwYXJhbWV0ZXIgaXMgY29tcG91bmQgb2Ygd2hpdGUgcG9pbnRzIG9ubHlcbiAgICAgKiAgICAgICAgIG9yIGJsYWNrIHBvaW50cyBvbmx5XG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmlzV2hpdGVPckJsYWNrUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIHZhciBjb3JyID0gMztcbiAgICAgICAgcDEgPSBuZXcgUG9pbnQocDEuZ2V0WCgpIC0gY29yciwgcDEuZ2V0WSgpICsgY29ycik7XG4gICAgICAgIHAyID0gbmV3IFBvaW50KHAyLmdldFgoKSAtIGNvcnIsIHAyLmdldFkoKSAtIGNvcnIpO1xuICAgICAgICBwMyA9IG5ldyBQb2ludChwMy5nZXRYKCkgKyBjb3JyLCBwMy5nZXRZKCkgLSBjb3JyKTtcbiAgICAgICAgcDQgPSBuZXcgUG9pbnQocDQuZ2V0WCgpICsgY29yciwgcDQuZ2V0WSgpICsgY29ycik7XG4gICAgICAgIHZhciBjSW5pdCA9IHRoaXMuZ2V0Q29sb3IocDQsIHAxKTtcbiAgICAgICAgaWYgKGNJbml0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmdldENvbG9yKHAxLCBwMik7XG4gICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAyLCBwMyk7XG4gICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAzLCBwNCk7XG4gICAgICAgIHJldHVybiBjID09PSBjSW5pdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbG9yIG9mIGEgc2VnbWVudFxuICAgICAqXG4gICAgICogQHJldHVybiAxIGlmIHNlZ21lbnQgbW9yZSB0aGFuIDkwJSBibGFjaywgLTEgaWYgc2VnbWVudCBpcyBtb3JlIHRoYW4gOTAlIHdoaXRlLCAwIGVsc2VcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZVBvaW50KHAxLCBwMik7XG4gICAgICAgIHZhciBkeCA9IChwMi5nZXRYKCkgLSBwMS5nZXRYKCkpIC8gZDtcbiAgICAgICAgdmFyIGR5ID0gKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xuICAgICAgICB2YXIgZXJyb3IgPSAwO1xuICAgICAgICB2YXIgcHggPSBwMS5nZXRYKCk7XG4gICAgICAgIHZhciBweSA9IHAxLmdldFkoKTtcbiAgICAgICAgdmFyIGNvbG9yTW9kZWwgPSB0aGlzLmltYWdlLmdldChwMS5nZXRYKCksIHAxLmdldFkoKSk7XG4gICAgICAgIHZhciBpTWF4ID0gTWF0aC5jZWlsKGQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgcHggKz0gZHg7XG4gICAgICAgICAgICBweSArPSBkeTtcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLmdldChNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKHB4KSwgTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChweSkpICE9PSBjb2xvck1vZGVsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyUmF0aW8gPSBlcnJvciAvIGQ7XG4gICAgICAgIGlmIChlcnJSYXRpbyA+IDAuMSAmJiBlcnJSYXRpbyA8IDAuOSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlcnJSYXRpbyA8PSAwLjEpID09PSBjb2xvck1vZGVsID8gMSA6IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQgd2l0aCBhIGRpZmZlcmVudCBjb2xvciBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldEZpcnN0RGlmZmVyZW50ID0gZnVuY3Rpb24gKGluaXQsIGNvbG9yLCBkeCwgZHkpIHtcbiAgICAgICAgdmFyIHggPSBpbml0LmdldFgoKSArIGR4O1xuICAgICAgICB2YXIgeSA9IGluaXQuZ2V0WSgpICsgZHk7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgfVxuICAgICAgICB4IC09IGR4O1xuICAgICAgICB5IC09IGR5O1xuICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgfVxuICAgICAgICB4IC09IGR4O1xuICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgfVxuICAgICAgICB5IC09IGR5O1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhwYW5kIHRoZSBzcXVhcmUgcmVwcmVzZW50ZWQgYnkgdGhlIGNvcm5lciBwb2ludHMgYnkgcHVzaGluZyBvdXQgZXF1YWxseSBpbiBhbGwgZGlyZWN0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvcm5lclBvaW50cyB0aGUgY29ybmVycyBvZiB0aGUgc3F1YXJlLCB3aGljaCBoYXMgdGhlIGJ1bGwncyBleWUgYXQgaXRzIGNlbnRlclxuICAgICAqIEBwYXJhbSBvbGRTaWRlIHRoZSBvcmlnaW5hbCBsZW5ndGggb2YgdGhlIHNpZGUgb2YgdGhlIHNxdWFyZSBpbiB0aGUgdGFyZ2V0IGJpdCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbmV3U2lkZSB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgc2l6ZSBvZiB0aGUgc3F1YXJlIGluIHRoZSB0YXJnZXQgYml0IG1hdHJpeFxuICAgICAqIEByZXR1cm4gdGhlIGNvcm5lcnMgb2YgdGhlIGV4cGFuZGVkIHNxdWFyZVxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5leHBhbmRTcXVhcmUgPSBmdW5jdGlvbiAoY29ybmVyUG9pbnRzLCBvbGRTaWRlLCBuZXdTaWRlKSB7XG4gICAgICAgIHZhciByYXRpbyA9IG5ld1NpZGUgLyAoMi4wICogb2xkU2lkZSk7XG4gICAgICAgIHZhciBkeCA9IGNvcm5lclBvaW50c1swXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WCgpO1xuICAgICAgICB2YXIgZHkgPSBjb3JuZXJQb2ludHNbMF0uZ2V0WSgpIC0gY29ybmVyUG9pbnRzWzJdLmdldFkoKTtcbiAgICAgICAgdmFyIGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzBdLmdldFgoKSArIGNvcm5lclBvaW50c1syXS5nZXRYKCkpIC8gMi4wO1xuICAgICAgICB2YXIgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzJdLmdldFkoKSkgLyAyLjA7XG4gICAgICAgIHZhciByZXN1bHQwID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xuICAgICAgICB2YXIgcmVzdWx0MiA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoY2VudGVyeCAtIHJhdGlvICogZHgsIGNlbnRlcnkgLSByYXRpbyAqIGR5KTtcbiAgICAgICAgZHggPSBjb3JuZXJQb2ludHNbMV0uZ2V0WCgpIC0gY29ybmVyUG9pbnRzWzNdLmdldFgoKTtcbiAgICAgICAgZHkgPSBjb3JuZXJQb2ludHNbMV0uZ2V0WSgpIC0gY29ybmVyUG9pbnRzWzNdLmdldFkoKTtcbiAgICAgICAgY2VudGVyeCA9IChjb3JuZXJQb2ludHNbMV0uZ2V0WCgpICsgY29ybmVyUG9pbnRzWzNdLmdldFgoKSkgLyAyLjA7XG4gICAgICAgIGNlbnRlcnkgPSAoY29ybmVyUG9pbnRzWzFdLmdldFkoKSArIGNvcm5lclBvaW50c1szXS5nZXRZKCkpIC8gMi4wO1xuICAgICAgICB2YXIgcmVzdWx0MSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoY2VudGVyeCArIHJhdGlvICogZHgsIGNlbnRlcnkgKyByYXRpbyAqIGR5KTtcbiAgICAgICAgdmFyIHJlc3VsdDMgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGNlbnRlcnggLSByYXRpbyAqIGR4LCBjZW50ZXJ5IC0gcmF0aW8gKiBkeSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPj0gMCAmJiB4IDwgdGhpcy5pbWFnZS5nZXRXaWR0aCgpICYmIHkgPiAwICYmIHkgPCB0aGlzLmltYWdlLmdldEhlaWdodCgpO1xuICAgIH07XG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmlzVmFsaWRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgeCA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQocG9pbnQuZ2V0WCgpKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKHBvaW50LmdldFkoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoeCwgeSk7XG4gICAgfTtcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2VQb2ludCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LmRpc3RhbmNlKGEuZ2V0WCgpLCBhLmdldFkoKSwgYi5nZXRYKCksIGIuZ2V0WSgpKTtcbiAgICB9O1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZVJlc3VsdFBvaW50ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xuICAgIH07XG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmJMYXllcnMgPD0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMTU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMiAqIChJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKCh0aGlzLm5iTGF5ZXJzIC0gNCksIDgpICsgMSkgKyAxNTtcbiAgICB9O1xuICAgIHJldHVybiBEZXRlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZXRlY3RvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Aztec 2D code representation\n *\n * @author Rustam Abdullaev\n */\nvar AztecCode = /** @class */ (function () {\n    function AztecCode() {\n    }\n    /**\n     * @return {@code true} if compact instead of full mode\n     */\n    AztecCode.prototype.isCompact = function () {\n        return this.compact;\n    };\n    AztecCode.prototype.setCompact = function (compact) {\n        this.compact = compact;\n    };\n    /**\n     * @return size in pixels (width and height)\n     */\n    AztecCode.prototype.getSize = function () {\n        return this.size;\n    };\n    AztecCode.prototype.setSize = function (size) {\n        this.size = size;\n    };\n    /**\n     * @return number of levels\n     */\n    AztecCode.prototype.getLayers = function () {\n        return this.layers;\n    };\n    AztecCode.prototype.setLayers = function (layers) {\n        this.layers = layers;\n    };\n    /**\n     * @return number of data codewords\n     */\n    AztecCode.prototype.getCodeWords = function () {\n        return this.codeWords;\n    };\n    AztecCode.prototype.setCodeWords = function (codeWords) {\n        this.codeWords = codeWords;\n    };\n    /**\n     * @return the symbol image\n     */\n    AztecCode.prototype.getMatrix = function () {\n        return this.matrix;\n    };\n    AztecCode.prototype.setMatrix = function (matrix) {\n        this.matrix = matrix;\n    };\n    return AztecCode;\n}());\nexports[\"default\"] = AztecCode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0F6dGVjQ29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2F6dGVjL2VuY29kZXIvQXp0ZWNDb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBenRlYyAyRCBjb2RlIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gKi9cbnZhciBBenRlY0NvZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXp0ZWNDb2RlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiBjb21wYWN0IGluc3RlYWQgb2YgZnVsbCBtb2RlXG4gICAgICovXG4gICAgQXp0ZWNDb2RlLnByb3RvdHlwZS5pc0NvbXBhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3Q7XG4gICAgfTtcbiAgICBBenRlY0NvZGUucHJvdG90eXBlLnNldENvbXBhY3QgPSBmdW5jdGlvbiAoY29tcGFjdCkge1xuICAgICAgICB0aGlzLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBzaXplIGluIHBpeGVscyAod2lkdGggYW5kIGhlaWdodClcbiAgICAgKi9cbiAgICBBenRlY0NvZGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfTtcbiAgICBBenRlY0NvZGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgbGV2ZWxzXG4gICAgICovXG4gICAgQXp0ZWNDb2RlLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICB9O1xuICAgIEF6dGVjQ29kZS5wcm90b3R5cGUuc2V0TGF5ZXJzID0gZnVuY3Rpb24gKGxheWVycykge1xuICAgICAgICB0aGlzLmxheWVycyA9IGxheWVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gICAgICovXG4gICAgQXp0ZWNDb2RlLnByb3RvdHlwZS5nZXRDb2RlV29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVXb3JkcztcbiAgICB9O1xuICAgIEF6dGVjQ29kZS5wcm90b3R5cGUuc2V0Q29kZVdvcmRzID0gZnVuY3Rpb24gKGNvZGVXb3Jkcykge1xuICAgICAgICB0aGlzLmNvZGVXb3JkcyA9IGNvZGVXb3JkcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIHN5bWJvbCBpbWFnZVxuICAgICAqL1xuICAgIEF6dGVjQ29kZS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgfTtcbiAgICBBenRlY0NvZGUucHJvdG90eXBlLnNldE1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgfTtcbiAgICByZXR1cm4gQXp0ZWNDb2RlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF6dGVjQ29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SimpleToken_1 = __webpack_require__(/*! ./SimpleToken */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js\");\nvar BinaryShiftToken = /** @class */ (function (_super) {\n    __extends(BinaryShiftToken, _super);\n    function BinaryShiftToken(previous, binaryShiftStart, binaryShiftByteCount) {\n        var _this = _super.call(this, previous, 0, 0) || this;\n        _this.binaryShiftStart = binaryShiftStart;\n        _this.binaryShiftByteCount = binaryShiftByteCount;\n        return _this;\n    }\n    /**\n     * @Override\n     */\n    BinaryShiftToken.prototype.appendTo = function (bitArray, text) {\n        for (var i = 0; i < this.binaryShiftByteCount; i++) {\n            if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {\n                // We need a header before the first character, and before\n                // character 31 when the total byte code is <= 62\n                bitArray.appendBits(31, 5); // BINARY_SHIFT\n                if (this.binaryShiftByteCount > 62) {\n                    bitArray.appendBits(this.binaryShiftByteCount - 31, 16);\n                }\n                else if (i === 0) {\n                    // 1 <= binaryShiftByteCode <= 62\n                    bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);\n                }\n                else {\n                    // 32 <= binaryShiftCount <= 62 and i == 31\n                    bitArray.appendBits(this.binaryShiftByteCount - 31, 5);\n                }\n            }\n            bitArray.appendBits(text[this.binaryShiftStart + i], 8);\n        }\n    };\n    BinaryShiftToken.prototype.addBinaryShift = function (start, byteCount) {\n        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n        return new BinaryShiftToken(this, start, byteCount);\n    };\n    /**\n     * @Override\n     */\n    BinaryShiftToken.prototype.toString = function () {\n        return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';\n    };\n    return BinaryShiftToken;\n}(SimpleToken_1.default));\nexports[\"default\"] = BinaryShiftToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0JpbmFyeVNoaWZ0VG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxxSkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2F6dGVjL2VuY29kZXIvQmluYXJ5U2hpZnRUb2tlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNpbXBsZVRva2VuXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVUb2tlblwiKTtcbnZhciBCaW5hcnlTaGlmdFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlTaGlmdFRva2VuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmFyeVNoaWZ0VG9rZW4ocHJldmlvdXMsIGJpbmFyeVNoaWZ0U3RhcnQsIGJpbmFyeVNoaWZ0Qnl0ZUNvdW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByZXZpb3VzLCAwLCAwKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ID0gYmluYXJ5U2hpZnRTdGFydDtcbiAgICAgICAgX3RoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAT3ZlcnJpZGVcbiAgICAgKi9cbiAgICBCaW5hcnlTaGlmdFRva2VuLnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uIChiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgKGkgPT09IDMxICYmIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gNjIpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBhIGhlYWRlciBiZWZvcmUgdGhlIGZpcnN0IGNoYXJhY3RlciwgYW5kIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciAzMSB3aGVuIHRoZSB0b3RhbCBieXRlIGNvZGUgaXMgPD0gNjJcbiAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKDMxLCA1KTsgLy8gQklOQVJZX1NISUZUXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgLSAzMSwgMTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDEgPD0gYmluYXJ5U2hpZnRCeXRlQ29kZSA8PSA2MlxuICAgICAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKE1hdGgubWluKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQsIDMxKSwgNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAzMiA8PSBiaW5hcnlTaGlmdENvdW50IDw9IDYyIGFuZCBpID09IDMxXG4gICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDMxLCA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRleHRbdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgaV0sIDgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaW5hcnlTaGlmdFRva2VuLnByb3RvdHlwZS5hZGRCaW5hcnlTaGlmdCA9IGZ1bmN0aW9uIChzdGFydCwgYnl0ZUNvdW50KSB7XG4gICAgICAgIC8vIGludCBiaXRDb3VudCA9IChieXRlQ291bnQgKiA4KSArIChieXRlQ291bnQgPD0gMzEgPyAxMCA6IGJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeVNoaWZ0VG9rZW4odGhpcywgc3RhcnQsIGJ5dGVDb3VudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAT3ZlcnJpZGVcbiAgICAgKi9cbiAgICBCaW5hcnlTaGlmdFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuYmluYXJ5U2hpZnRTdGFydCArICc6OicgKyAodGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDEpICsgJz4nO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeVNoaWZ0VG9rZW47XG59KFNpbXBsZVRva2VuXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmluYXJ5U2hpZnRUb2tlbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CHAR_MAP = exports.static_CHAR_MAP = void 0;\nvar C = __webpack_require__(/*! ./EncoderConstants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js\");\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nfunction static_CHAR_MAP(CHAR_MAP) {\n    var spaceCharCode = StringUtils_1.default.getCharCode(' ');\n    var pointCharCode = StringUtils_1.default.getCharCode('.');\n    var commaCharCode = StringUtils_1.default.getCharCode(',');\n    CHAR_MAP[C.MODE_UPPER][spaceCharCode] = 1;\n    var zUpperCharCode = StringUtils_1.default.getCharCode('Z');\n    var aUpperCharCode = StringUtils_1.default.getCharCode('A');\n    for (var c = aUpperCharCode; c <= zUpperCharCode; c++) {\n        CHAR_MAP[C.MODE_UPPER][c] = c - aUpperCharCode + 2;\n    }\n    CHAR_MAP[C.MODE_LOWER][spaceCharCode] = 1;\n    var zLowerCharCode = StringUtils_1.default.getCharCode('z');\n    var aLowerCharCode = StringUtils_1.default.getCharCode('a');\n    for (var c = aLowerCharCode; c <= zLowerCharCode; c++) {\n        CHAR_MAP[C.MODE_LOWER][c] = c - aLowerCharCode + 2;\n    }\n    CHAR_MAP[C.MODE_DIGIT][spaceCharCode] = 1;\n    var nineCharCode = StringUtils_1.default.getCharCode('9');\n    var zeroCharCode = StringUtils_1.default.getCharCode('0');\n    for (var c = zeroCharCode; c <= nineCharCode; c++) {\n        CHAR_MAP[C.MODE_DIGIT][c] = c - zeroCharCode + 2;\n    }\n    CHAR_MAP[C.MODE_DIGIT][commaCharCode] = 12;\n    CHAR_MAP[C.MODE_DIGIT][pointCharCode] = 13;\n    var mixedTable = [\n        '\\x00',\n        ' ',\n        '\\x01',\n        '\\x02',\n        '\\x03',\n        '\\x04',\n        '\\x05',\n        '\\x06',\n        '\\x07',\n        '\\b',\n        '\\t',\n        '\\n',\n        '\\x0b',\n        '\\f',\n        '\\r',\n        '\\x1b',\n        '\\x1c',\n        '\\x1d',\n        '\\x1e',\n        '\\x1f',\n        '@',\n        '\\\\',\n        '^',\n        '_',\n        '`',\n        '|',\n        '~',\n        '\\x7f'\n    ];\n    for (var i = 0; i < mixedTable.length; i++) {\n        CHAR_MAP[C.MODE_MIXED][StringUtils_1.default.getCharCode(mixedTable[i])] = i;\n    }\n    var punctTable = [\n        '\\x00',\n        '\\r',\n        '\\x00',\n        '\\x00',\n        '\\x00',\n        '\\x00',\n        '!',\n        '\\'',\n        '#',\n        '$',\n        '%',\n        '&',\n        '\\'',\n        '(',\n        ')',\n        '*',\n        '+',\n        ',',\n        '-',\n        '.',\n        '/',\n        ':',\n        ';',\n        '<',\n        '=',\n        '>',\n        '?',\n        '[',\n        ']',\n        '{',\n        '}'\n    ];\n    for (var i = 0; i < punctTable.length; i++) {\n        if (StringUtils_1.default.getCharCode(punctTable[i]) > 0) {\n            CHAR_MAP[C.MODE_PUNCT][StringUtils_1.default.getCharCode(punctTable[i])] = i;\n        }\n    }\n    return CHAR_MAP;\n}\nexports.static_CHAR_MAP = static_CHAR_MAP;\nexports.CHAR_MAP = static_CHAR_MAP(Arrays_1.default.createInt32Array(5, 256));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0NoYXJNYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsdUJBQXVCO0FBQzFDLFFBQVEsbUJBQU8sQ0FBQywrSkFBb0I7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLDJJQUFtQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZ0JBQWdCIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2F6dGVjL2VuY29kZXIvQ2hhck1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hBUl9NQVAgPSBleHBvcnRzLnN0YXRpY19DSEFSX01BUCA9IHZvaWQgMDtcbnZhciBDID0gcmVxdWlyZShcIi4vRW5jb2RlckNvbnN0YW50c1wiKTtcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0FycmF5c1wiKTtcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9TdHJpbmdVdGlsc1wiKTtcbmZ1bmN0aW9uIHN0YXRpY19DSEFSX01BUChDSEFSX01BUCkge1xuICAgIHZhciBzcGFjZUNoYXJDb2RlID0gU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJDb2RlKCcgJyk7XG4gICAgdmFyIHBvaW50Q2hhckNvZGUgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJy4nKTtcbiAgICB2YXIgY29tbWFDaGFyQ29kZSA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnLCcpO1xuICAgIENIQVJfTUFQW0MuTU9ERV9VUFBFUl1bc3BhY2VDaGFyQ29kZV0gPSAxO1xuICAgIHZhciB6VXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnWicpO1xuICAgIHZhciBhVXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnQScpO1xuICAgIGZvciAodmFyIGMgPSBhVXBwZXJDaGFyQ29kZTsgYyA8PSB6VXBwZXJDaGFyQ29kZTsgYysrKSB7XG4gICAgICAgIENIQVJfTUFQW0MuTU9ERV9VUFBFUl1bY10gPSBjIC0gYVVwcGVyQ2hhckNvZGUgKyAyO1xuICAgIH1cbiAgICBDSEFSX01BUFtDLk1PREVfTE9XRVJdW3NwYWNlQ2hhckNvZGVdID0gMTtcbiAgICB2YXIgekxvd2VyQ2hhckNvZGUgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJ3onKTtcbiAgICB2YXIgYUxvd2VyQ2hhckNvZGUgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJ2EnKTtcbiAgICBmb3IgKHZhciBjID0gYUxvd2VyQ2hhckNvZGU7IGMgPD0gekxvd2VyQ2hhckNvZGU7IGMrKykge1xuICAgICAgICBDSEFSX01BUFtDLk1PREVfTE9XRVJdW2NdID0gYyAtIGFMb3dlckNoYXJDb2RlICsgMjtcbiAgICB9XG4gICAgQ0hBUl9NQVBbQy5NT0RFX0RJR0lUXVtzcGFjZUNoYXJDb2RlXSA9IDE7XG4gICAgdmFyIG5pbmVDaGFyQ29kZSA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnOScpO1xuICAgIHZhciB6ZXJvQ2hhckNvZGUgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJzAnKTtcbiAgICBmb3IgKHZhciBjID0gemVyb0NoYXJDb2RlOyBjIDw9IG5pbmVDaGFyQ29kZTsgYysrKSB7XG4gICAgICAgIENIQVJfTUFQW0MuTU9ERV9ESUdJVF1bY10gPSBjIC0gemVyb0NoYXJDb2RlICsgMjtcbiAgICB9XG4gICAgQ0hBUl9NQVBbQy5NT0RFX0RJR0lUXVtjb21tYUNoYXJDb2RlXSA9IDEyO1xuICAgIENIQVJfTUFQW0MuTU9ERV9ESUdJVF1bcG9pbnRDaGFyQ29kZV0gPSAxMztcbiAgICB2YXIgbWl4ZWRUYWJsZSA9IFtcbiAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgJyAnLFxuICAgICAgICAnXFx4MDEnLFxuICAgICAgICAnXFx4MDInLFxuICAgICAgICAnXFx4MDMnLFxuICAgICAgICAnXFx4MDQnLFxuICAgICAgICAnXFx4MDUnLFxuICAgICAgICAnXFx4MDYnLFxuICAgICAgICAnXFx4MDcnLFxuICAgICAgICAnXFxiJyxcbiAgICAgICAgJ1xcdCcsXG4gICAgICAgICdcXG4nLFxuICAgICAgICAnXFx4MGInLFxuICAgICAgICAnXFxmJyxcbiAgICAgICAgJ1xccicsXG4gICAgICAgICdcXHgxYicsXG4gICAgICAgICdcXHgxYycsXG4gICAgICAgICdcXHgxZCcsXG4gICAgICAgICdcXHgxZScsXG4gICAgICAgICdcXHgxZicsXG4gICAgICAgICdAJyxcbiAgICAgICAgJ1xcXFwnLFxuICAgICAgICAnXicsXG4gICAgICAgICdfJyxcbiAgICAgICAgJ2AnLFxuICAgICAgICAnfCcsXG4gICAgICAgICd+JyxcbiAgICAgICAgJ1xceDdmJ1xuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhlZFRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENIQVJfTUFQW0MuTU9ERV9NSVhFRF1bU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJDb2RlKG1peGVkVGFibGVbaV0pXSA9IGk7XG4gICAgfVxuICAgIHZhciBwdW5jdFRhYmxlID0gW1xuICAgICAgICAnXFx4MDAnLFxuICAgICAgICAnXFxyJyxcbiAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgJyEnLFxuICAgICAgICAnXFwnJyxcbiAgICAgICAgJyMnLFxuICAgICAgICAnJCcsXG4gICAgICAgICclJyxcbiAgICAgICAgJyYnLFxuICAgICAgICAnXFwnJyxcbiAgICAgICAgJygnLFxuICAgICAgICAnKScsXG4gICAgICAgICcqJyxcbiAgICAgICAgJysnLFxuICAgICAgICAnLCcsXG4gICAgICAgICctJyxcbiAgICAgICAgJy4nLFxuICAgICAgICAnLycsXG4gICAgICAgICc6JyxcbiAgICAgICAgJzsnLFxuICAgICAgICAnPCcsXG4gICAgICAgICc9JyxcbiAgICAgICAgJz4nLFxuICAgICAgICAnPycsXG4gICAgICAgICdbJyxcbiAgICAgICAgJ10nLFxuICAgICAgICAneycsXG4gICAgICAgICd9J1xuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdW5jdFRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUocHVuY3RUYWJsZVtpXSkgPiAwKSB7XG4gICAgICAgICAgICBDSEFSX01BUFtDLk1PREVfUFVOQ1RdW1N0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZShwdW5jdFRhYmxlW2ldKV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDSEFSX01BUDtcbn1cbmV4cG9ydHMuc3RhdGljX0NIQVJfTUFQID0gc3RhdGljX0NIQVJfTUFQO1xuZXhwb3J0cy5DSEFSX01BUCA9IHN0YXRpY19DSEFSX01BUChBcnJheXNfMS5kZWZhdWx0LmNyZWF0ZUludDMyQXJyYXkoNSwgMjU2KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar AztecCode_1 = __webpack_require__(/*! ./AztecCode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js\");\nvar ReedSolomonEncoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// package com.google.zxing.aztec.encoder;\n// import com.google.zxing.common.BitArray;\n// import com.google.zxing.common.BitMatrix;\n// import com.google.zxing.common.reedsolomon.GenericGF;\n// import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n/**\n * Generates Aztec 2D barcodes.\n *\n * @author Rustam Abdullaev\n */\nvar Encoder = /** @class */ (function () {\n    function Encoder() {\n    }\n    /**\n     * Encodes the given binary content as an Aztec symbol\n     *\n     * @param data input data string\n     * @return Aztec symbol matrix with metadata\n     */\n    Encoder.encodeBytes = function (data) {\n        return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);\n    };\n    /**\n     * Encodes the given binary content as an Aztec symbol\n     *\n     * @param data input data string\n     * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n     *                      a minimum of 23% + 3 words is recommended)\n     * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n     * @return Aztec symbol matrix with metadata\n     */\n    Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {\n        // High-level encode\n        var bits = new HighLevelEncoder_1.default(data).encode();\n        // stuff bits and choose symbol size\n        var eccBits = Integer_1.default.truncDivision((bits.getSize() * minECCPercent), 100) + 11;\n        var totalSizeBits = bits.getSize() + eccBits;\n        var compact;\n        var layers;\n        var totalBitsInLayer;\n        var wordSize;\n        var stuffedBits;\n        if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {\n            compact = userSpecifiedLayers < 0;\n            layers = Math.abs(userSpecifiedLayers);\n            if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {\n                throw new IllegalArgumentException_1.default(StringUtils_1.default.format('Illegal value %s for layers', userSpecifiedLayers));\n            }\n            totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n            wordSize = Encoder.WORD_SIZE[layers];\n            var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n            stuffedBits = Encoder.stuffBits(bits, wordSize);\n            if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n                throw new IllegalArgumentException_1.default('Data to large for user specified layer');\n            }\n            if (compact && stuffedBits.getSize() > wordSize * 64) {\n                // Compact format only allows 64 data words, though C4 can hold more words than that\n                throw new IllegalArgumentException_1.default('Data to large for user specified layer');\n            }\n        }\n        else {\n            wordSize = 0;\n            stuffedBits = null;\n            // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n            // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n            // is the same size, but has more data.\n            for (var i /*int*/ = 0;; i++) {\n                if (i > Encoder.MAX_NB_BITS) {\n                    throw new IllegalArgumentException_1.default('Data too large for an Aztec code');\n                }\n                compact = i <= 3;\n                layers = compact ? i + 1 : i;\n                totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n                if (totalSizeBits > totalBitsInLayer) {\n                    continue;\n                }\n                // [Re]stuff the bits if this is the first opportunity, or if the\n                // wordSize has changed\n                if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {\n                    wordSize = Encoder.WORD_SIZE[layers];\n                    stuffedBits = Encoder.stuffBits(bits, wordSize);\n                }\n                var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                if (compact && stuffedBits.getSize() > wordSize * 64) {\n                    // Compact format only allows 64 data words, though C4 can hold more words than that\n                    continue;\n                }\n                if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n                    break;\n                }\n            }\n        }\n        var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n        // generate mode message\n        var messageSizeInWords = stuffedBits.getSize() / wordSize;\n        var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords);\n        // allocate symbol\n        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n        var alignmentMap = new Int32Array(baseMatrixSize);\n        var matrixSize;\n        if (compact) {\n            // no alignment marks in compact mode, alignmentMap is a no-op\n            matrixSize = baseMatrixSize;\n            for (var i /*int*/ = 0; i < alignmentMap.length; i++) {\n                alignmentMap[i] = i;\n            }\n        }\n        else {\n            matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);\n            var origCenter = Integer_1.default.truncDivision(baseMatrixSize, 2);\n            var center = Integer_1.default.truncDivision(matrixSize, 2);\n            for (var i /*int*/ = 0; i < origCenter; i++) {\n                var newOffset = i + Integer_1.default.truncDivision(i, 15);\n                alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                alignmentMap[origCenter + i] = center + newOffset + 1;\n            }\n        }\n        var matrix = new BitMatrix_1.default(matrixSize);\n        // draw data bits\n        for (var i /*int*/ = 0, rowOffset = 0; i < layers; i++) {\n            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n            for (var j /*int*/ = 0; j < rowSize; j++) {\n                var columnOffset = j * 2;\n                for (var k /*int*/ = 0; k < 2; k++) {\n                    if (messageBits.get(rowOffset + columnOffset + k)) {\n                        matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n                        matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n                    }\n                }\n            }\n            rowOffset += rowSize * 8;\n        }\n        // draw mode message\n        Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n        // draw alignment marks\n        if (compact) {\n            Encoder.drawBullsEye(matrix, Integer_1.default.truncDivision(matrixSize, 2), 5);\n        }\n        else {\n            Encoder.drawBullsEye(matrix, Integer_1.default.truncDivision(matrixSize, 2), 7);\n            for (var i /*int*/ = 0, j = 0; i < Integer_1.default.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n                for (var k /*int*/ = Integer_1.default.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n                    matrix.set(Integer_1.default.truncDivision(matrixSize, 2) - j, k);\n                    matrix.set(Integer_1.default.truncDivision(matrixSize, 2) + j, k);\n                    matrix.set(k, Integer_1.default.truncDivision(matrixSize, 2) - j);\n                    matrix.set(k, Integer_1.default.truncDivision(matrixSize, 2) + j);\n                }\n            }\n        }\n        var aztec = new AztecCode_1.default();\n        aztec.setCompact(compact);\n        aztec.setSize(matrixSize);\n        aztec.setLayers(layers);\n        aztec.setCodeWords(messageSizeInWords);\n        aztec.setMatrix(matrix);\n        return aztec;\n    };\n    Encoder.drawBullsEye = function (matrix, center, size) {\n        for (var i /*int*/ = 0; i < size; i += 2) {\n            for (var j /*int*/ = center - i; j <= center + i; j++) {\n                matrix.set(j, center - i);\n                matrix.set(j, center + i);\n                matrix.set(center - i, j);\n                matrix.set(center + i, j);\n            }\n        }\n        matrix.set(center - size, center - size);\n        matrix.set(center - size + 1, center - size);\n        matrix.set(center - size, center - size + 1);\n        matrix.set(center + size, center - size);\n        matrix.set(center + size, center - size + 1);\n        matrix.set(center + size, center + size - 1);\n    };\n    Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {\n        var modeMessage = new BitArray_1.default();\n        if (compact) {\n            modeMessage.appendBits(layers - 1, 2);\n            modeMessage.appendBits(messageSizeInWords - 1, 6);\n            modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);\n        }\n        else {\n            modeMessage.appendBits(layers - 1, 5);\n            modeMessage.appendBits(messageSizeInWords - 1, 11);\n            modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);\n        }\n        return modeMessage;\n    };\n    Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {\n        var center = Integer_1.default.truncDivision(matrixSize, 2);\n        if (compact) {\n            for (var i /*int*/ = 0; i < 7; i++) {\n                var offset = center - 3 + i;\n                if (modeMessage.get(i)) {\n                    matrix.set(offset, center - 5);\n                }\n                if (modeMessage.get(i + 7)) {\n                    matrix.set(center + 5, offset);\n                }\n                if (modeMessage.get(20 - i)) {\n                    matrix.set(offset, center + 5);\n                }\n                if (modeMessage.get(27 - i)) {\n                    matrix.set(center - 5, offset);\n                }\n            }\n        }\n        else {\n            for (var i /*int*/ = 0; i < 10; i++) {\n                var offset = center - 5 + i + Integer_1.default.truncDivision(i, 5);\n                if (modeMessage.get(i)) {\n                    matrix.set(offset, center - 7);\n                }\n                if (modeMessage.get(i + 10)) {\n                    matrix.set(center + 7, offset);\n                }\n                if (modeMessage.get(29 - i)) {\n                    matrix.set(offset, center + 7);\n                }\n                if (modeMessage.get(39 - i)) {\n                    matrix.set(center - 7, offset);\n                }\n            }\n        }\n    };\n    Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {\n        var e_1, _a;\n        // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n        var messageSizeInWords = bitArray.getSize() / wordSize;\n        var rs = new ReedSolomonEncoder_1.default(Encoder.getGF(wordSize));\n        var totalWords = Integer_1.default.truncDivision(totalBits, wordSize);\n        var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);\n        rs.encode(messageWords, totalWords - messageSizeInWords);\n        var startPad = totalBits % wordSize;\n        var messageBits = new BitArray_1.default();\n        messageBits.appendBits(0, startPad);\n        try {\n            for (var _b = __values(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var messageWord = _c.value /*: int*/;\n                messageBits.appendBits(messageWord, wordSize);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return messageBits;\n    };\n    Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {\n        var message = new Int32Array(totalWords);\n        var i;\n        var n;\n        for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n            var value = 0;\n            for (var j /*int*/ = 0; j < wordSize; j++) {\n                value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;\n            }\n            message[i] = value;\n        }\n        return message;\n    };\n    Encoder.getGF = function (wordSize) {\n        switch (wordSize) {\n            case 4:\n                return GenericGF_1.default.AZTEC_PARAM;\n            case 6:\n                return GenericGF_1.default.AZTEC_DATA_6;\n            case 8:\n                return GenericGF_1.default.AZTEC_DATA_8;\n            case 10:\n                return GenericGF_1.default.AZTEC_DATA_10;\n            case 12:\n                return GenericGF_1.default.AZTEC_DATA_12;\n            default:\n                throw new IllegalArgumentException_1.default('Unsupported word size ' + wordSize);\n        }\n    };\n    Encoder.stuffBits = function (bits, wordSize) {\n        var out = new BitArray_1.default();\n        var n = bits.getSize();\n        var mask = (1 << wordSize) - 2;\n        for (var i /*int*/ = 0; i < n; i += wordSize) {\n            var word = 0;\n            for (var j /*int*/ = 0; j < wordSize; j++) {\n                if (i + j >= n || bits.get(i + j)) {\n                    word |= 1 << (wordSize - 1 - j);\n                }\n            }\n            if ((word & mask) === mask) {\n                out.appendBits(word & mask, wordSize);\n                i--;\n            }\n            else if ((word & mask) === 0) {\n                out.appendBits(word | 1, wordSize);\n                i--;\n            }\n            else {\n                out.appendBits(word, wordSize);\n            }\n        }\n        return out;\n    };\n    Encoder.totalBitsInLayer = function (layers, compact) {\n        return ((compact ? 88 : 112) + 16 * layers) * layers;\n    };\n    Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n    Encoder.DEFAULT_AZTEC_LAYERS = 0;\n    Encoder.MAX_NB_BITS = 32;\n    Encoder.MAX_NB_BITS_COMPACT = 4;\n    Encoder.WORD_SIZE = Int32Array.from([\n        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n        12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n    ]);\n    return Encoder;\n}());\nexports[\"default\"] = Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsbUpBQXVCO0FBQ2hELGlDQUFpQyxtQkFBTyxDQUFDLHFLQUFnQztBQUN6RSxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMscUpBQXdCO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLGlKQUFhO0FBQ3ZDLDJCQUEyQixtQkFBTyxDQUFDLCtMQUE2QztBQUNoRixrQkFBa0IsbUJBQU8sQ0FBQyw2S0FBb0M7QUFDOUQseUJBQXlCLG1CQUFPLENBQUMsK0pBQW9CO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDZJQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQTREO0FBQ3ZHLHlGQUF5RixnQkFBZ0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQyw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0VuY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0QXJyYXlcIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XG52YXIgQXp0ZWNDb2RlXzEgPSByZXF1aXJlKFwiLi9BenRlY0NvZGVcIik7XG52YXIgUmVlZFNvbG9tb25FbmNvZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL1JlZWRTb2xvbW9uRW5jb2RlclwiKTtcbnZhciBHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGXCIpO1xudmFyIEhpZ2hMZXZlbEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0hpZ2hMZXZlbEVuY29kZXJcIik7XG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLmF6dGVjLmVuY29kZXI7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0QXJyYXk7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0TWF0cml4O1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRjtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5SZWVkU29sb21vbkVuY29kZXI7XG4vKipcbiAqIEdlbmVyYXRlcyBBenRlYyAyRCBiYXJjb2Rlcy5cbiAqXG4gKiBAYXV0aG9yIFJ1c3RhbSBBYmR1bGxhZXZcbiAqL1xudmFyIEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBpbnB1dCBkYXRhIHN0cmluZ1xuICAgICAqIEByZXR1cm4gQXp0ZWMgc3ltYm9sIG1hdHJpeCB3aXRoIG1ldGFkYXRhXG4gICAgICovXG4gICAgRW5jb2Rlci5lbmNvZGVCeXRlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBFbmNvZGVyLmVuY29kZShkYXRhLCBFbmNvZGVyLkRFRkFVTFRfRUNfUEVSQ0VOVCwgRW5jb2Rlci5ERUZBVUxUX0FaVEVDX0xBWUVSUyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBiaW5hcnkgY29udGVudCBhcyBhbiBBenRlYyBzeW1ib2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIG1pbkVDQ1BlcmNlbnQgbWluaW1hbCBwZXJjZW50YWdlIG9mIGVycm9yIGNoZWNrIHdvcmRzIChBY2NvcmRpbmcgdG8gSVNPL0lFQyAyNDc3ODoyMDA4LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGEgbWluaW11bSBvZiAyMyUgKyAzIHdvcmRzIGlzIHJlY29tbWVuZGVkKVxuICAgICAqIEBwYXJhbSB1c2VyU3BlY2lmaWVkTGF5ZXJzIGlmIG5vbi16ZXJvLCBhIHVzZXItc3BlY2lmaWVkIHZhbHVlIGZvciB0aGUgbnVtYmVyIG9mIGxheWVyc1xuICAgICAqIEByZXR1cm4gQXp0ZWMgc3ltYm9sIG1hdHJpeCB3aXRoIG1ldGFkYXRhXG4gICAgICovXG4gICAgRW5jb2Rlci5lbmNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgbWluRUNDUGVyY2VudCwgdXNlclNwZWNpZmllZExheWVycykge1xuICAgICAgICAvLyBIaWdoLWxldmVsIGVuY29kZVxuICAgICAgICB2YXIgYml0cyA9IG5ldyBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdChkYXRhKS5lbmNvZGUoKTtcbiAgICAgICAgLy8gc3R1ZmYgYml0cyBhbmQgY2hvb3NlIHN5bWJvbCBzaXplXG4gICAgICAgIHZhciBlY2NCaXRzID0gSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbigoYml0cy5nZXRTaXplKCkgKiBtaW5FQ0NQZXJjZW50KSwgMTAwKSArIDExO1xuICAgICAgICB2YXIgdG90YWxTaXplQml0cyA9IGJpdHMuZ2V0U2l6ZSgpICsgZWNjQml0cztcbiAgICAgICAgdmFyIGNvbXBhY3Q7XG4gICAgICAgIHZhciBsYXllcnM7XG4gICAgICAgIHZhciB0b3RhbEJpdHNJbkxheWVyO1xuICAgICAgICB2YXIgd29yZFNpemU7XG4gICAgICAgIHZhciBzdHVmZmVkQml0cztcbiAgICAgICAgaWYgKHVzZXJTcGVjaWZpZWRMYXllcnMgIT09IEVuY29kZXIuREVGQVVMVF9BWlRFQ19MQVlFUlMpIHtcbiAgICAgICAgICAgIGNvbXBhY3QgPSB1c2VyU3BlY2lmaWVkTGF5ZXJzIDwgMDtcbiAgICAgICAgICAgIGxheWVycyA9IE1hdGguYWJzKHVzZXJTcGVjaWZpZWRMYXllcnMpO1xuICAgICAgICAgICAgaWYgKGxheWVycyA+IChjb21wYWN0ID8gRW5jb2Rlci5NQVhfTkJfQklUU19DT01QQUNUIDogRW5jb2Rlci5NQVhfTkJfQklUUykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdChTdHJpbmdVdGlsc18xLmRlZmF1bHQuZm9ybWF0KCdJbGxlZ2FsIHZhbHVlICVzIGZvciBsYXllcnMnLCB1c2VyU3BlY2lmaWVkTGF5ZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2Rlci50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCk7XG4gICAgICAgICAgICB3b3JkU2l6ZSA9IEVuY29kZXIuV09SRF9TSVpFW2xheWVyc107XG4gICAgICAgICAgICB2YXIgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBFbmNvZGVyLnN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICBpZiAoc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpICsgZWNjQml0cyA+IHVzYWJsZUJpdHNJbkxheWVycykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdEYXRhIHRvIGxhcmdlIGZvciB1c2VyIHNwZWNpZmllZCBsYXllcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpID4gd29yZFNpemUgKiA2NCkge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhY3QgZm9ybWF0IG9ubHkgYWxsb3dzIDY0IGRhdGEgd29yZHMsIHRob3VnaCBDNCBjYW4gaG9sZCBtb3JlIHdvcmRzIHRoYW4gdGhhdFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdEYXRhIHRvIGxhcmdlIGZvciB1c2VyIHNwZWNpZmllZCBsYXllcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29yZFNpemUgPSAwO1xuICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBudWxsO1xuICAgICAgICAgICAgLy8gV2UgbG9vayBhdCB0aGUgcG9zc2libGUgdGFibGUgc2l6ZXMgaW4gdGhlIG9yZGVyIENvbXBhY3QxLCBDb21wYWN0MiwgQ29tcGFjdDMsXG4gICAgICAgICAgICAvLyBDb21wYWN0NCwgTm9ybWFsNCwuLi4gIE5vcm1hbChpKSBmb3IgaSA8IDQgaXNuJ3QgdHlwaWNhbGx5IHVzZWQgc2luY2UgQ29tcGFjdChpKzEpXG4gICAgICAgICAgICAvLyBpcyB0aGUgc2FtZSBzaXplLCBidXQgaGFzIG1vcmUgZGF0YS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IEVuY29kZXIuTUFYX05CX0JJVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RhdGEgdG9vIGxhcmdlIGZvciBhbiBBenRlYyBjb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhY3QgPSBpIDw9IDM7XG4gICAgICAgICAgICAgICAgbGF5ZXJzID0gY29tcGFjdCA/IGkgKyAxIDogaTtcbiAgICAgICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2Rlci50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZUJpdHMgPiB0b3RhbEJpdHNJbkxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBbUmVdc3R1ZmYgdGhlIGJpdHMgaWYgdGhpcyBpcyB0aGUgZmlyc3Qgb3Bwb3J0dW5pdHksIG9yIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHdvcmRTaXplIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKHN0dWZmZWRCaXRzID09IG51bGwgfHwgd29yZFNpemUgIT09IEVuY29kZXIuV09SRF9TSVpFW2xheWVyc10pIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZFNpemUgPSBFbmNvZGVyLldPUkRfU0laRVtsYXllcnNdO1xuICAgICAgICAgICAgICAgICAgICBzdHVmZmVkQml0cyA9IEVuY29kZXIuc3R1ZmZCaXRzKGJpdHMsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHVzYWJsZUJpdHNJbkxheWVycyA9IHRvdGFsQml0c0luTGF5ZXIgLSAodG90YWxCaXRzSW5MYXllciAlIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFjdCAmJiBzdHVmZmVkQml0cy5nZXRTaXplKCkgPiB3b3JkU2l6ZSAqIDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhY3QgZm9ybWF0IG9ubHkgYWxsb3dzIDY0IGRhdGEgd29yZHMsIHRob3VnaCBDNCBjYW4gaG9sZCBtb3JlIHdvcmRzIHRoYW4gdGhhdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0dWZmZWRCaXRzLmdldFNpemUoKSArIGVjY0JpdHMgPD0gdXNhYmxlQml0c0luTGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZUJpdHMgPSBFbmNvZGVyLmdlbmVyYXRlQ2hlY2tXb3JkcyhzdHVmZmVkQml0cywgdG90YWxCaXRzSW5MYXllciwgd29yZFNpemUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBtb2RlIG1lc3NhZ2VcbiAgICAgICAgdmFyIG1lc3NhZ2VTaXplSW5Xb3JkcyA9IHN0dWZmZWRCaXRzLmdldFNpemUoKSAvIHdvcmRTaXplO1xuICAgICAgICB2YXIgbW9kZU1lc3NhZ2UgPSBFbmNvZGVyLmdlbmVyYXRlTW9kZU1lc3NhZ2UoY29tcGFjdCwgbGF5ZXJzLCBtZXNzYWdlU2l6ZUluV29yZHMpO1xuICAgICAgICAvLyBhbGxvY2F0ZSBzeW1ib2xcbiAgICAgICAgdmFyIGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgIHZhciBhbGlnbm1lbnRNYXAgPSBuZXcgSW50MzJBcnJheShiYXNlTWF0cml4U2l6ZSk7XG4gICAgICAgIHZhciBtYXRyaXhTaXplO1xuICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgLy8gbm8gYWxpZ25tZW50IG1hcmtzIGluIGNvbXBhY3QgbW9kZSwgYWxpZ25tZW50TWFwIGlzIGEgbm8tb3BcbiAgICAgICAgICAgIG1hdHJpeFNpemUgPSBiYXNlTWF0cml4U2l6ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBhbGlnbm1lbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbaV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplICsgMSArIDIgKiBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKChJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICB2YXIgb3JpZ0NlbnRlciA9IEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgb3JpZ0NlbnRlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld09mZnNldCA9IGkgKyBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKGksIDE1KTtcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciAtIGkgLSAxXSA9IGNlbnRlciAtIG5ld09mZnNldCAtIDE7XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG1hdHJpeFNpemUpO1xuICAgICAgICAvLyBkcmF3IGRhdGEgYml0c1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwLCByb3dPZmZzZXQgPSAwOyBpIDwgbGF5ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogLyppbnQqLyA9IDA7IGogPCByb3dTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uT2Zmc2V0ID0gaiAqIDI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayAvKmludCovID0gMDsgayA8IDI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUJpdHMuZ2V0KHJvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGFsaWdubWVudE1hcFtpICogMiArIGtdLCBhbGlnbm1lbnRNYXBbaSAqIDIgKyBqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogMiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGFsaWdubWVudE1hcFtpICogMiArIGpdLCBhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGFsaWdubWVudE1hcFtiYXNlTWF0cml4U2l6ZSAtIDEgLSBpICogMiAtIGtdLCBhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGFsaWdubWVudE1hcFtiYXNlTWF0cml4U2l6ZSAtIDEgLSBpICogMiAtIGpdLCBhbGlnbm1lbnRNYXBbaSAqIDIgKyBrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dPZmZzZXQgKz0gcm93U2l6ZSAqIDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhdyBtb2RlIG1lc3NhZ2VcbiAgICAgICAgRW5jb2Rlci5kcmF3TW9kZU1lc3NhZ2UobWF0cml4LCBjb21wYWN0LCBtYXRyaXhTaXplLCBtb2RlTWVzc2FnZSk7XG4gICAgICAgIC8vIGRyYXcgYWxpZ25tZW50IG1hcmtzXG4gICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICBFbmNvZGVyLmRyYXdCdWxsc0V5ZShtYXRyaXgsIEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMiksIDUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRW5jb2Rlci5kcmF3QnVsbHNFeWUobWF0cml4LCBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpLCA3KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDAsIGogPSAwOyBpIDwgSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihiYXNlTWF0cml4U2l6ZSwgMikgLSAxOyBpICs9IDE1LCBqICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayAvKmludCovID0gSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSAmIDE7IGsgPCBtYXRyaXhTaXplOyBrICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpIC0gaiwgayk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSArIGosIGspO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGssIEludGVnZXJfMS5kZWZhdWx0LnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChrLCBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpICsgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhenRlYyA9IG5ldyBBenRlY0NvZGVfMS5kZWZhdWx0KCk7XG4gICAgICAgIGF6dGVjLnNldENvbXBhY3QoY29tcGFjdCk7XG4gICAgICAgIGF6dGVjLnNldFNpemUobWF0cml4U2l6ZSk7XG4gICAgICAgIGF6dGVjLnNldExheWVycyhsYXllcnMpO1xuICAgICAgICBhenRlYy5zZXRDb2RlV29yZHMobWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgYXp0ZWMuc2V0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBhenRlYztcbiAgICB9O1xuICAgIEVuY29kZXIuZHJhd0J1bGxzRXllID0gZnVuY3Rpb24gKG1hdHJpeCwgY2VudGVyLCBzaXplKSB7XG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogLyppbnQqLyA9IGNlbnRlciAtIGk7IGogPD0gY2VudGVyICsgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgLSBpKTtcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGosIGNlbnRlciArIGkpO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gaSwgaik7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUgKyAxLCBjZW50ZXIgLSBzaXplKTtcbiAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplLCBjZW50ZXIgLSBzaXplICsgMSk7XG4gICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyIC0gc2l6ZSArIDEpO1xuICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciArIHNpemUgLSAxKTtcbiAgICB9O1xuICAgIEVuY29kZXIuZ2VuZXJhdGVNb2RlTWVzc2FnZSA9IGZ1bmN0aW9uIChjb21wYWN0LCBsYXllcnMsIG1lc3NhZ2VTaXplSW5Xb3Jkcykge1xuICAgICAgICB2YXIgbW9kZU1lc3NhZ2UgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KCk7XG4gICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKGxheWVycyAtIDEsIDIpO1xuICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhtZXNzYWdlU2l6ZUluV29yZHMgLSAxLCA2KTtcbiAgICAgICAgICAgIG1vZGVNZXNzYWdlID0gRW5jb2Rlci5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDI4LCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVNZXNzYWdlLmFwcGVuZEJpdHMobGF5ZXJzIC0gMSwgNSk7XG4gICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDExKTtcbiAgICAgICAgICAgIG1vZGVNZXNzYWdlID0gRW5jb2Rlci5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDQwLCA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZU1lc3NhZ2U7XG4gICAgfTtcbiAgICBFbmNvZGVyLmRyYXdNb2RlTWVzc2FnZSA9IGZ1bmN0aW9uIChtYXRyaXgsIGNvbXBhY3QsIG1hdHJpeFNpemUsIG1vZGVNZXNzYWdlKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpO1xuICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjZW50ZXIgLSAzICsgaTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgLSA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpICsgNykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyA1LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDIwIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciArIDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDI3IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSA1LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGNlbnRlciAtIDUgKyBpICsgSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihpLCA1KTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgLSA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpICsgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgNywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldCgyOSAtIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgKyA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldCgzOSAtIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gNywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIuZ2VuZXJhdGVDaGVja1dvcmRzID0gZnVuY3Rpb24gKGJpdEFycmF5LCB0b3RhbEJpdHMsIHdvcmRTaXplKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAvLyBiaXRBcnJheSBpcyBndWFyYW50ZWVkIHRvIGJlIGEgbXVsdGlwbGUgb2YgdGhlIHdvcmRTaXplLCBzbyBubyBwYWRkaW5nIG5lZWRlZFxuICAgICAgICB2YXIgbWVzc2FnZVNpemVJbldvcmRzID0gYml0QXJyYXkuZ2V0U2l6ZSgpIC8gd29yZFNpemU7XG4gICAgICAgIHZhciBycyA9IG5ldyBSZWVkU29sb21vbkVuY29kZXJfMS5kZWZhdWx0KEVuY29kZXIuZ2V0R0Yod29yZFNpemUpKTtcbiAgICAgICAgdmFyIHRvdGFsV29yZHMgPSBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKHRvdGFsQml0cywgd29yZFNpemUpO1xuICAgICAgICB2YXIgbWVzc2FnZVdvcmRzID0gRW5jb2Rlci5iaXRzVG9Xb3JkcyhiaXRBcnJheSwgd29yZFNpemUsIHRvdGFsV29yZHMpO1xuICAgICAgICBycy5lbmNvZGUobWVzc2FnZVdvcmRzLCB0b3RhbFdvcmRzIC0gbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgdmFyIHN0YXJ0UGFkID0gdG90YWxCaXRzICUgd29yZFNpemU7XG4gICAgICAgIHZhciBtZXNzYWdlQml0cyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcbiAgICAgICAgbWVzc2FnZUJpdHMuYXBwZW5kQml0cygwLCBzdGFydFBhZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKEFycmF5LmZyb20obWVzc2FnZVdvcmRzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZVdvcmQgPSBfYy52YWx1ZSAvKjogaW50Ki87XG4gICAgICAgICAgICAgICAgbWVzc2FnZUJpdHMuYXBwZW5kQml0cyhtZXNzYWdlV29yZCwgd29yZFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCaXRzO1xuICAgIH07XG4gICAgRW5jb2Rlci5iaXRzVG9Xb3JkcyA9IGZ1bmN0aW9uIChzdHVmZmVkQml0cywgd29yZFNpemUsIHRvdGFsV29yZHMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgSW50MzJBcnJheSh0b3RhbFdvcmRzKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBuO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpIC8gd29yZFNpemU7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqIC8qaW50Ki8gPSAwOyBqIDwgd29yZFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHZhbHVlIHw9IHN0dWZmZWRCaXRzLmdldChpICogd29yZFNpemUgKyBqKSA/ICgxIDw8IHdvcmRTaXplIC0gaiAtIDEpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuICAgIEVuY29kZXIuZ2V0R0YgPSBmdW5jdGlvbiAod29yZFNpemUpIHtcbiAgICAgICAgc3dpdGNoICh3b3JkU2l6ZSkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX1BBUkFNO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGXzEuZGVmYXVsdC5BWlRFQ19EQVRBXzg7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfMTA7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfMTI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdVbnN1cHBvcnRlZCB3b3JkIHNpemUgJyArIHdvcmRTaXplKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5zdHVmZkJpdHMgPSBmdW5jdGlvbiAoYml0cywgd29yZFNpemUpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIG4gPSBiaXRzLmdldFNpemUoKTtcbiAgICAgICAgdmFyIG1hc2sgPSAoMSA8PCB3b3JkU2l6ZSkgLSAyO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbjsgaSArPSB3b3JkU2l6ZSkge1xuICAgICAgICAgICAgdmFyIHdvcmQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiAvKmludCovID0gMDsgaiA8IHdvcmRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSArIGogPj0gbiB8fCBiaXRzLmdldChpICsgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZCB8PSAxIDw8ICh3b3JkU2l6ZSAtIDEgLSBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHdvcmQgJiBtYXNrKSA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgIG91dC5hcHBlbmRCaXRzKHdvcmQgJiBtYXNrLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHdvcmQgJiBtYXNrKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG91dC5hcHBlbmRCaXRzKHdvcmQgfCAxLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCwgd29yZFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBFbmNvZGVyLnRvdGFsQml0c0luTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJzLCBjb21wYWN0KSB7XG4gICAgICAgIHJldHVybiAoKGNvbXBhY3QgPyA4OCA6IDExMikgKyAxNiAqIGxheWVycykgKiBsYXllcnM7XG4gICAgfTtcbiAgICBFbmNvZGVyLkRFRkFVTFRfRUNfUEVSQ0VOVCA9IDMzOyAvLyBkZWZhdWx0IG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjaGVjayB3b3Jkc1xuICAgIEVuY29kZXIuREVGQVVMVF9BWlRFQ19MQVlFUlMgPSAwO1xuICAgIEVuY29kZXIuTUFYX05CX0JJVFMgPSAzMjtcbiAgICBFbmNvZGVyLk1BWF9OQl9CSVRTX0NPTVBBQ1QgPSA0O1xuICAgIEVuY29kZXIuV09SRF9TSVpFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgNCwgNiwgNiwgOCwgOCwgOCwgOCwgOCwgOCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxuICAgICAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMlxuICAgIF0pO1xuICAgIHJldHVybiBFbmNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EMPTY_TOKEN = exports.MODE_PUNCT = exports.MODE_MIXED = exports.MODE_DIGIT = exports.MODE_LOWER = exports.MODE_UPPER = exports.MODE_NAMES = void 0;\nvar SimpleToken_1 = __webpack_require__(/*! ./SimpleToken */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js\");\nexports.MODE_NAMES = [\n    'UPPER',\n    'LOWER',\n    'DIGIT',\n    'MIXED',\n    'PUNCT'\n];\nexports.MODE_UPPER = 0; // 5 bits\nexports.MODE_LOWER = 1; // 5 bits\nexports.MODE_DIGIT = 2; // 4 bits\nexports.MODE_MIXED = 3; // 5 bits\nexports.MODE_PUNCT = 4; // 5 bits\nexports.EMPTY_TOKEN = new SimpleToken_1.default(null, 0, 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0VuY29kZXJDb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ2pKLG9CQUFvQixtQkFBTyxDQUFDLHFKQUFlO0FBQzNDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QixrQkFBa0IsTUFBTTtBQUN4QixrQkFBa0IsTUFBTTtBQUN4QixrQkFBa0IsTUFBTTtBQUN4QixrQkFBa0IsTUFBTTtBQUN4QixtQkFBbUIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvZW5jb2Rlci9FbmNvZGVyQ29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FTVBUWV9UT0tFTiA9IGV4cG9ydHMuTU9ERV9QVU5DVCA9IGV4cG9ydHMuTU9ERV9NSVhFRCA9IGV4cG9ydHMuTU9ERV9ESUdJVCA9IGV4cG9ydHMuTU9ERV9MT1dFUiA9IGV4cG9ydHMuTU9ERV9VUFBFUiA9IGV4cG9ydHMuTU9ERV9OQU1FUyA9IHZvaWQgMDtcbnZhciBTaW1wbGVUb2tlbl8xID0gcmVxdWlyZShcIi4vU2ltcGxlVG9rZW5cIik7XG5leHBvcnRzLk1PREVfTkFNRVMgPSBbXG4gICAgJ1VQUEVSJyxcbiAgICAnTE9XRVInLFxuICAgICdESUdJVCcsXG4gICAgJ01JWEVEJyxcbiAgICAnUFVOQ1QnXG5dO1xuZXhwb3J0cy5NT0RFX1VQUEVSID0gMDsgLy8gNSBiaXRzXG5leHBvcnRzLk1PREVfTE9XRVIgPSAxOyAvLyA1IGJpdHNcbmV4cG9ydHMuTU9ERV9ESUdJVCA9IDI7IC8vIDQgYml0c1xuZXhwb3J0cy5NT0RFX01JWEVEID0gMzsgLy8gNSBiaXRzXG5leHBvcnRzLk1PREVfUFVOQ1QgPSA0OyAvLyA1IGJpdHNcbmV4cG9ydHMuRU1QVFlfVE9LRU4gPSBuZXcgU2ltcGxlVG9rZW5fMS5kZWZhdWx0KG51bGwsIDAsIDApO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import java.util.Collection;\n// import java.util.Collections;\nvar Collections_1 = __webpack_require__(/*! ../../util/Collections */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Collections.js\");\n// import java.util.Comparator;\n// import java.util.Iterator;\n// import java.util.LinkedList;\nvar State_1 = __webpack_require__(/*! ./State */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js\");\nvar C = __webpack_require__(/*! ./EncoderConstants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js\");\nvar CharMap = __webpack_require__(/*! ./CharMap */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js\");\nvar ShiftTable = __webpack_require__(/*! ./ShiftTable */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\n/**\n * This produces nearly optimal encodings of text into the first-level of\n * encoding used by Aztec code.\n *\n * It uses a dynamic algorithm.  For each prefix of the string, it determines\n * a set of encodings that could lead to this prefix.  We repeatedly add a\n * character and generate a new set of optimal encodings until we have read\n * through the entire input.\n *\n * @author Frank Yellin\n * @author Rustam Abdullaev\n */\nvar HighLevelEncoder = /** @class */ (function () {\n    function HighLevelEncoder(text) {\n        this.text = text;\n    }\n    /**\n     * @return text represented by this encoder encoded as a {@link BitArray}\n     */\n    HighLevelEncoder.prototype.encode = function () {\n        var spaceCharCode = StringUtils_1.default.getCharCode(' ');\n        var lineBreakCharCode = StringUtils_1.default.getCharCode('\\n');\n        var states = Collections_1.default.singletonList(State_1.default.INITIAL_STATE);\n        for (var index = 0; index < this.text.length; index++) {\n            var pairCode = void 0;\n            var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n            switch (this.text[index]) {\n                case StringUtils_1.default.getCharCode('\\r'):\n                    pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n                    break;\n                case StringUtils_1.default.getCharCode('.'):\n                    pairCode = nextChar === spaceCharCode ? 3 : 0;\n                    break;\n                case StringUtils_1.default.getCharCode(','):\n                    pairCode = nextChar === spaceCharCode ? 4 : 0;\n                    break;\n                case StringUtils_1.default.getCharCode(':'):\n                    pairCode = nextChar === spaceCharCode ? 5 : 0;\n                    break;\n                default:\n                    pairCode = 0;\n            }\n            if (pairCode > 0) {\n                // We have one of the four special PUNCT pairs.  Treat them specially.\n                // Get a new set of states for the two new characters.\n                states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n                index++;\n            }\n            else {\n                // Get a new set of states for the new character.\n                states = this.updateStateListForChar(states, index);\n            }\n        }\n        // We are left with a set of states.  Find the shortest one.\n        var minState = Collections_1.default.min(states, function (a, b) {\n            return a.getBitCount() - b.getBitCount();\n        });\n        // Convert it to a bit array, and return.\n        return minState.toBitArray(this.text);\n    };\n    // We update a set of states for a new character by updating each state\n    // for the new character, merging the results, and then removing the\n    // non-optimal states.\n    HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {\n        var e_1, _a;\n        var result = [];\n        try {\n            for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {\n                var state = states_1_1.value /*State*/;\n                this.updateStateForChar(state, index, result);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return HighLevelEncoder.simplifyStates(result);\n    };\n    // Return a set of states that represent the possible ways of updating this\n    // state for the next character.  The resulting set of states are added to\n    // the \"result\" list.\n    HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {\n        var ch = (this.text[index] & 0xff);\n        var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;\n        var stateNoBinary = null;\n        for (var mode /*int*/ = 0; mode <= C.MODE_PUNCT; mode++) {\n            var charInMode = CharMap.CHAR_MAP[mode][ch];\n            if (charInMode > 0) {\n                if (stateNoBinary == null) {\n                    // Only create stateNoBinary the first time it's required.\n                    stateNoBinary = state.endBinaryShift(index);\n                }\n                // Try generating the character by latching to its mode\n                if (!charInCurrentTable ||\n                    mode === state.getMode() ||\n                    mode === C.MODE_DIGIT) {\n                    // If the character is in the current table, we don't want to latch to\n                    // any other mode except possibly digit (which uses only 4 bits).  Any\n                    // other latch would be equally successful *after* this character, and\n                    // so wouldn't save any bits.\n                    var latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n                    result.push(latchState);\n                }\n                // Try generating the character by switching to its mode.\n                if (!charInCurrentTable &&\n                    ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {\n                    // It never makes sense to temporarily shift to another mode if the\n                    // character exists in the current mode.  That can never save bits.\n                    var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n                    result.push(shiftState);\n                }\n            }\n        }\n        if (state.getBinaryShiftByteCount() > 0 ||\n            CharMap.CHAR_MAP[state.getMode()][ch] === 0) {\n            // It's never worthwhile to go into binary shift mode if you're not already\n            // in binary shift mode, and the character exists in your current mode.\n            // That can never save bits over just outputting the char in the current mode.\n            var binaryState = state.addBinaryShiftChar(index);\n            result.push(binaryState);\n        }\n    };\n    HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {\n        var e_2, _a;\n        var result = [];\n        try {\n            for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {\n                var state = states_2_1.value /*State*/;\n                this.updateStateForPair(state, index, pairCode, result);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return this.simplifyStates(result);\n    };\n    HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {\n        var stateNoBinary = state.endBinaryShift(index);\n        // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n        result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));\n        if (state.getMode() !== C.MODE_PUNCT) {\n            // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n            // Every state except C.MODE_PUNCT (handled above) can shift\n            result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));\n        }\n        if (pairCode === 3 || pairCode === 4) {\n            // both characters are in DIGITS.  Sometimes better to just add two digits\n            var digitState = stateNoBinary\n                .latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n                .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT\n            result.push(digitState);\n        }\n        if (state.getBinaryShiftByteCount() > 0) {\n            // It only makes sense to do the characters as binary if we're already\n            // in binary mode.\n            var binaryState = state\n                .addBinaryShiftChar(index)\n                .addBinaryShiftChar(index + 1);\n            result.push(binaryState);\n        }\n    };\n    HighLevelEncoder.simplifyStates = function (states) {\n        var e_3, _a, e_4, _b;\n        var result = [];\n        try {\n            for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {\n                var newState = states_3_1.value;\n                var add = true;\n                var _loop_1 = function (oldState) {\n                    if (oldState.isBetterThanOrEqualTo(newState)) {\n                        add = false;\n                        return \"break\";\n                    }\n                    if (newState.isBetterThanOrEqualTo(oldState)) {\n                        // iterator.remove();\n                        result = result.filter(function (x) { return x !== oldState; }); // remove old state\n                    }\n                };\n                try {\n                    for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n                        var oldState = result_1_1.value;\n                        var state_1 = _loop_1(oldState);\n                        if (state_1 === \"break\")\n                            break;\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n                if (add) {\n                    result.push(newState);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return result;\n    };\n    return HighLevelEncoder;\n}());\nexports[\"default\"] = HighLevelEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0hpZ2hMZXZlbEVuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFKQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMseUlBQVM7QUFDL0IsUUFBUSxtQkFBTyxDQUFDLCtKQUFvQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsNklBQVc7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsbUpBQWM7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUpBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixrQkFBa0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0JBQWtCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGtCQUFrQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0JBQXdCLEdBQUc7QUFDekY7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0hpZ2hMZXZlbEVuY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7XG52YXIgQ29sbGVjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0NvbGxlY3Rpb25zXCIpO1xuLy8gaW1wb3J0IGphdmEudXRpbC5Db21wYXJhdG9yO1xuLy8gaW1wb3J0IGphdmEudXRpbC5JdGVyYXRvcjtcbi8vIGltcG9ydCBqYXZhLnV0aWwuTGlua2VkTGlzdDtcbnZhciBTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RhdGVcIik7XG52YXIgQyA9IHJlcXVpcmUoXCIuL0VuY29kZXJDb25zdGFudHNcIik7XG52YXIgQ2hhck1hcCA9IHJlcXVpcmUoXCIuL0NoYXJNYXBcIik7XG52YXIgU2hpZnRUYWJsZSA9IHJlcXVpcmUoXCIuL1NoaWZ0VGFibGVcIik7XG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vU3RyaW5nVXRpbHNcIik7XG4vKipcbiAqIFRoaXMgcHJvZHVjZXMgbmVhcmx5IG9wdGltYWwgZW5jb2RpbmdzIG9mIHRleHQgaW50byB0aGUgZmlyc3QtbGV2ZWwgb2ZcbiAqIGVuY29kaW5nIHVzZWQgYnkgQXp0ZWMgY29kZS5cbiAqXG4gKiBJdCB1c2VzIGEgZHluYW1pYyBhbGdvcml0aG0uICBGb3IgZWFjaCBwcmVmaXggb2YgdGhlIHN0cmluZywgaXQgZGV0ZXJtaW5lc1xuICogYSBzZXQgb2YgZW5jb2RpbmdzIHRoYXQgY291bGQgbGVhZCB0byB0aGlzIHByZWZpeC4gIFdlIHJlcGVhdGVkbHkgYWRkIGFcbiAqIGNoYXJhY3RlciBhbmQgZ2VuZXJhdGUgYSBuZXcgc2V0IG9mIG9wdGltYWwgZW5jb2RpbmdzIHVudGlsIHdlIGhhdmUgcmVhZFxuICogdGhyb3VnaCB0aGUgZW50aXJlIGlucHV0LlxuICpcbiAqIEBhdXRob3IgRnJhbmsgWWVsbGluXG4gKiBAYXV0aG9yIFJ1c3RhbSBBYmR1bGxhZXZcbiAqL1xudmFyIEhpZ2hMZXZlbEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGlnaExldmVsRW5jb2Rlcih0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRlZCBieSB0aGlzIGVuY29kZXIgZW5jb2RlZCBhcyBhIHtAbGluayBCaXRBcnJheX1cbiAgICAgKi9cbiAgICBIaWdoTGV2ZWxFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGFjZUNoYXJDb2RlID0gU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJDb2RlKCcgJyk7XG4gICAgICAgIHZhciBsaW5lQnJlYWtDaGFyQ29kZSA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnXFxuJyk7XG4gICAgICAgIHZhciBzdGF0ZXMgPSBDb2xsZWN0aW9uc18xLmRlZmF1bHQuc2luZ2xldG9uTGlzdChTdGF0ZV8xLmRlZmF1bHQuSU5JVElBTF9TVEFURSk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpckNvZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBpbmRleCArIDEgPCB0aGlzLnRleHQubGVuZ3RoID8gdGhpcy50ZXh0W2luZGV4ICsgMV0gOiAwO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRleHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJ1xccicpOlxuICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBsaW5lQnJlYWtDaGFyQ29kZSA/IDIgOiAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQ29kZSgnLicpOlxuICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBzcGFjZUNoYXJDb2RlID8gMyA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJDb2RlKCcsJyk6XG4gICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IHNwYWNlQ2hhckNvZGUgPyA0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ2V0Q2hhckNvZGUoJzonKTpcbiAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gc3BhY2VDaGFyQ29kZSA/IDUgOiAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpckNvZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBvbmUgb2YgdGhlIGZvdXIgc3BlY2lhbCBQVU5DVCBwYWlycy4gIFRyZWF0IHRoZW0gc3BlY2lhbGx5LlxuICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyBzZXQgb2Ygc3RhdGVzIGZvciB0aGUgdHdvIG5ldyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIHN0YXRlcyA9IEhpZ2hMZXZlbEVuY29kZXIudXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyBzZXQgb2Ygc3RhdGVzIGZvciB0aGUgbmV3IGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICBzdGF0ZXMgPSB0aGlzLnVwZGF0ZVN0YXRlTGlzdEZvckNoYXIoc3RhdGVzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIGxlZnQgd2l0aCBhIHNldCBvZiBzdGF0ZXMuICBGaW5kIHRoZSBzaG9ydGVzdCBvbmUuXG4gICAgICAgIHZhciBtaW5TdGF0ZSA9IENvbGxlY3Rpb25zXzEuZGVmYXVsdC5taW4oc3RhdGVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuZ2V0Qml0Q291bnQoKSAtIGIuZ2V0Qml0Q291bnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbnZlcnQgaXQgdG8gYSBiaXQgYXJyYXksIGFuZCByZXR1cm4uXG4gICAgICAgIHJldHVybiBtaW5TdGF0ZS50b0JpdEFycmF5KHRoaXMudGV4dCk7XG4gICAgfTtcbiAgICAvLyBXZSB1cGRhdGUgYSBzZXQgb2Ygc3RhdGVzIGZvciBhIG5ldyBjaGFyYWN0ZXIgYnkgdXBkYXRpbmcgZWFjaCBzdGF0ZVxuICAgIC8vIGZvciB0aGUgbmV3IGNoYXJhY3RlciwgbWVyZ2luZyB0aGUgcmVzdWx0cywgYW5kIHRoZW4gcmVtb3ZpbmcgdGhlXG4gICAgLy8gbm9uLW9wdGltYWwgc3RhdGVzLlxuICAgIEhpZ2hMZXZlbEVuY29kZXIucHJvdG90eXBlLnVwZGF0ZVN0YXRlTGlzdEZvckNoYXIgPSBmdW5jdGlvbiAoc3RhdGVzLCBpbmRleCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgc3RhdGVzXzEgPSBfX3ZhbHVlcyhzdGF0ZXMpLCBzdGF0ZXNfMV8xID0gc3RhdGVzXzEubmV4dCgpOyAhc3RhdGVzXzFfMS5kb25lOyBzdGF0ZXNfMV8xID0gc3RhdGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVzXzFfMS52YWx1ZSAvKlN0YXRlKi87XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvckNoYXIoc3RhdGUsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVzXzFfMSAmJiAhc3RhdGVzXzFfMS5kb25lICYmIChfYSA9IHN0YXRlc18xLnJldHVybikpIF9hLmNhbGwoc3RhdGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIaWdoTGV2ZWxFbmNvZGVyLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgfTtcbiAgICAvLyBSZXR1cm4gYSBzZXQgb2Ygc3RhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NzaWJsZSB3YXlzIG9mIHVwZGF0aW5nIHRoaXNcbiAgICAvLyBzdGF0ZSBmb3IgdGhlIG5leHQgY2hhcmFjdGVyLiAgVGhlIHJlc3VsdGluZyBzZXQgb2Ygc3RhdGVzIGFyZSBhZGRlZCB0b1xuICAgIC8vIHRoZSBcInJlc3VsdFwiIGxpc3QuXG4gICAgSGlnaExldmVsRW5jb2Rlci5wcm90b3R5cGUudXBkYXRlU3RhdGVGb3JDaGFyID0gZnVuY3Rpb24gKHN0YXRlLCBpbmRleCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBjaCA9ICh0aGlzLnRleHRbaW5kZXhdICYgMHhmZik7XG4gICAgICAgIHZhciBjaGFySW5DdXJyZW50VGFibGUgPSBDaGFyTWFwLkNIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID4gMDtcbiAgICAgICAgdmFyIHN0YXRlTm9CaW5hcnkgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBtb2RlIC8qaW50Ki8gPSAwOyBtb2RlIDw9IEMuTU9ERV9QVU5DVDsgbW9kZSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckluTW9kZSA9IENoYXJNYXAuQ0hBUl9NQVBbbW9kZV1bY2hdO1xuICAgICAgICAgICAgaWYgKGNoYXJJbk1vZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlTm9CaW5hcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBzdGF0ZU5vQmluYXJ5IHRoZSBmaXJzdCB0aW1lIGl0J3MgcmVxdWlyZWQuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTm9CaW5hcnkgPSBzdGF0ZS5lbmRCaW5hcnlTaGlmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZW5lcmF0aW5nIHRoZSBjaGFyYWN0ZXIgYnkgbGF0Y2hpbmcgdG8gaXRzIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoIWNoYXJJbkN1cnJlbnRUYWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlID09PSBzdGF0ZS5nZXRNb2RlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gQy5NT0RFX0RJR0lUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gdGhlIGN1cnJlbnQgdGFibGUsIHdlIGRvbid0IHdhbnQgdG8gbGF0Y2ggdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYW55IG90aGVyIG1vZGUgZXhjZXB0IHBvc3NpYmx5IGRpZ2l0ICh3aGljaCB1c2VzIG9ubHkgNCBiaXRzKS4gIEFueVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBsYXRjaCB3b3VsZCBiZSBlcXVhbGx5IHN1Y2Nlc3NmdWwgKmFmdGVyKiB0aGlzIGNoYXJhY3RlciwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdvdWxkbid0IHNhdmUgYW55IGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXRjaFN0YXRlID0gc3RhdGVOb0JpbmFyeS5sYXRjaEFuZEFwcGVuZChtb2RlLCBjaGFySW5Nb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGF0Y2hTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZW5lcmF0aW5nIHRoZSBjaGFyYWN0ZXIgYnkgc3dpdGNoaW5nIHRvIGl0cyBtb2RlLlxuICAgICAgICAgICAgICAgIGlmICghY2hhckluQ3VycmVudFRhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIFNoaWZ0VGFibGUuU0hJRlRfVEFCTEVbc3RhdGUuZ2V0TW9kZSgpXVttb2RlXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IG5ldmVyIG1ha2VzIHNlbnNlIHRvIHRlbXBvcmFyaWx5IHNoaWZ0IHRvIGFub3RoZXIgbW9kZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGV4aXN0cyBpbiB0aGUgY3VycmVudCBtb2RlLiAgVGhhdCBjYW4gbmV2ZXIgc2F2ZSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZnRTdGF0ZSA9IHN0YXRlTm9CaW5hcnkuc2hpZnRBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNoaWZ0U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDAgfHxcbiAgICAgICAgICAgIENoYXJNYXAuQ0hBUl9NQVBbc3RhdGUuZ2V0TW9kZSgpXVtjaF0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIEl0J3MgbmV2ZXIgd29ydGh3aGlsZSB0byBnbyBpbnRvIGJpbmFyeSBzaGlmdCBtb2RlIGlmIHlvdSdyZSBub3QgYWxyZWFkeVxuICAgICAgICAgICAgLy8gaW4gYmluYXJ5IHNoaWZ0IG1vZGUsIGFuZCB0aGUgY2hhcmFjdGVyIGV4aXN0cyBpbiB5b3VyIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgIC8vIFRoYXQgY2FuIG5ldmVyIHNhdmUgYml0cyBvdmVyIGp1c3Qgb3V0cHV0dGluZyB0aGUgY2hhciBpbiB0aGUgY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgdmFyIGJpbmFyeVN0YXRlID0gc3RhdGUuYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci51cGRhdGVTdGF0ZUxpc3RGb3JQYWlyID0gZnVuY3Rpb24gKHN0YXRlcywgaW5kZXgsIHBhaXJDb2RlKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzdGF0ZXNfMiA9IF9fdmFsdWVzKHN0YXRlcyksIHN0YXRlc18yXzEgPSBzdGF0ZXNfMi5uZXh0KCk7ICFzdGF0ZXNfMl8xLmRvbmU7IHN0YXRlc18yXzEgPSBzdGF0ZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNfMl8xLnZhbHVlIC8qU3RhdGUqLztcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlRm9yUGFpcihzdGF0ZSwgaW5kZXgsIHBhaXJDb2RlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVzXzJfMSAmJiAhc3RhdGVzXzJfMS5kb25lICYmIChfYSA9IHN0YXRlc18yLnJldHVybikpIF9hLmNhbGwoc3RhdGVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLnVwZGF0ZVN0YXRlRm9yUGFpciA9IGZ1bmN0aW9uIChzdGF0ZSwgaW5kZXgsIHBhaXJDb2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIHN0YXRlTm9CaW5hcnkgPSBzdGF0ZS5lbmRCaW5hcnlTaGlmdChpbmRleCk7XG4gICAgICAgIC8vIFBvc3NpYmlsaXR5IDEuICBMYXRjaCB0byBDLk1PREVfUFVOQ1QsIGFuZCB0aGVuIGFwcGVuZCB0aGlzIGNvZGVcbiAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5sYXRjaEFuZEFwcGVuZChDLk1PREVfUFVOQ1QsIHBhaXJDb2RlKSk7XG4gICAgICAgIGlmIChzdGF0ZS5nZXRNb2RlKCkgIT09IEMuTU9ERV9QVU5DVCkge1xuICAgICAgICAgICAgLy8gUG9zc2liaWxpdHkgMi4gIFNoaWZ0IHRvIEMuTU9ERV9QVU5DVCwgYW5kIHRoZW4gYXBwZW5kIHRoaXMgY29kZS5cbiAgICAgICAgICAgIC8vIEV2ZXJ5IHN0YXRlIGV4Y2VwdCBDLk1PREVfUFVOQ1QgKGhhbmRsZWQgYWJvdmUpIGNhbiBzaGlmdFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5zaGlmdEFuZEFwcGVuZChDLk1PREVfUFVOQ1QsIHBhaXJDb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhaXJDb2RlID09PSAzIHx8IHBhaXJDb2RlID09PSA0KSB7XG4gICAgICAgICAgICAvLyBib3RoIGNoYXJhY3RlcnMgYXJlIGluIERJR0lUUy4gIFNvbWV0aW1lcyBiZXR0ZXIgdG8ganVzdCBhZGQgdHdvIGRpZ2l0c1xuICAgICAgICAgICAgdmFyIGRpZ2l0U3RhdGUgPSBzdGF0ZU5vQmluYXJ5XG4gICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKEMuTU9ERV9ESUdJVCwgMTYgLSBwYWlyQ29kZSkgLy8gcGVyaW9kIG9yIGNvbW1hIGluIERJR0lUXG4gICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKEMuTU9ERV9ESUdJVCwgMSk7IC8vIHNwYWNlIGluIERJR0lUXG4gICAgICAgICAgICByZXN1bHQucHVzaChkaWdpdFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gZG8gdGhlIGNoYXJhY3RlcnMgYXMgYmluYXJ5IGlmIHdlJ3JlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGluIGJpbmFyeSBtb2RlLlxuICAgICAgICAgICAgdmFyIGJpbmFyeVN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgICAgICAuYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KVxuICAgICAgICAgICAgICAgIC5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5zaW1wbGlmeVN0YXRlcyA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHN0YXRlc18zID0gX192YWx1ZXMoc3RhdGVzKSwgc3RhdGVzXzNfMSA9IHN0YXRlc18zLm5leHQoKTsgIXN0YXRlc18zXzEuZG9uZTsgc3RhdGVzXzNfMSA9IHN0YXRlc18zLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHN0YXRlc18zXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAob2xkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmlzQmV0dGVyVGhhbk9yRXF1YWxUbyhuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUuaXNCZXR0ZXJUaGFuT3JFcXVhbFRvKG9sZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSBvbGRTdGF0ZTsgfSk7IC8vIHJlbW92ZSBvbGQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzdWx0XzEgPSAoZV80ID0gdm9pZCAwLCBfX3ZhbHVlcyhyZXN1bHQpKSwgcmVzdWx0XzFfMSA9IHJlc3VsdF8xLm5leHQoKTsgIXJlc3VsdF8xXzEuZG9uZTsgcmVzdWx0XzFfMSA9IHJlc3VsdF8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gcmVzdWx0XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShvbGRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzFfMSAmJiAhcmVzdWx0XzFfMS5kb25lICYmIChfYiA9IHJlc3VsdF8xLnJldHVybikpIF9iLmNhbGwocmVzdWx0XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVzXzNfMSAmJiAhc3RhdGVzXzNfMS5kb25lICYmIChfYSA9IHN0YXRlc18zLnJldHVybikpIF9hLmNhbGwoc3RhdGVzXzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSGlnaExldmVsRW5jb2Rlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIaWdoTGV2ZWxFbmNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LATCH_TABLE = void 0;\n// The Latch Table shows, for each pair of Modes, the optimal method for\n// getting from one mode to another.  In the worst possible case, this can\n// be up to 14 bits.  In the best possible case, we are already there!\n// The high half-word of each entry gives the number of bits.\n// The low half-word of each entry are the actual bits necessary to change\nexports.LATCH_TABLE = [\n    Int32Array.from([\n        0,\n        (5 << 16) + 28,\n        (5 << 16) + 30,\n        (5 << 16) + 29,\n        (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (9 << 16) + (30 << 4) + 14,\n        0,\n        (5 << 16) + 30,\n        (5 << 16) + 29,\n        (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (4 << 16) + 14,\n        (9 << 16) + (14 << 5) + 28,\n        0,\n        (9 << 16) + (14 << 5) + 29,\n        (14 << 16) + (14 << 10) + (29 << 5) + 30\n        // DIGIT -> UPPER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (5 << 16) + 29,\n        (5 << 16) + 28,\n        (10 << 16) + (29 << 5) + 30,\n        0,\n        (5 << 16) + 30 // MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (5 << 16) + 31,\n        (10 << 16) + (31 << 5) + 28,\n        (10 << 16) + (31 << 5) + 30,\n        (10 << 16) + (31 << 5) + 29,\n        0\n    ])\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL0xhdGNoVGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvZW5jb2Rlci9MYXRjaFRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MQVRDSF9UQUJMRSA9IHZvaWQgMDtcbi8vIFRoZSBMYXRjaCBUYWJsZSBzaG93cywgZm9yIGVhY2ggcGFpciBvZiBNb2RlcywgdGhlIG9wdGltYWwgbWV0aG9kIGZvclxuLy8gZ2V0dGluZyBmcm9tIG9uZSBtb2RlIHRvIGFub3RoZXIuICBJbiB0aGUgd29yc3QgcG9zc2libGUgY2FzZSwgdGhpcyBjYW5cbi8vIGJlIHVwIHRvIDE0IGJpdHMuICBJbiB0aGUgYmVzdCBwb3NzaWJsZSBjYXNlLCB3ZSBhcmUgYWxyZWFkeSB0aGVyZSFcbi8vIFRoZSBoaWdoIGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cy5cbi8vIFRoZSBsb3cgaGFsZi13b3JkIG9mIGVhY2ggZW50cnkgYXJlIHRoZSBhY3R1YWwgYml0cyBuZWNlc3NhcnkgdG8gY2hhbmdlXG5leHBvcnRzLkxBVENIX1RBQkxFID0gW1xuICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDAsXG4gICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAoNSA8PCAxNikgKyAzMCxcbiAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCAvLyBVUFBFUiAtPiBNSVhFRCAtPiBQVU5DVFxuICAgIF0pLFxuICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICg5IDw8IDE2KSArICgzMCA8PCA0KSArIDE0LFxuICAgICAgICAwLFxuICAgICAgICAoNSA8PCAxNikgKyAzMCxcbiAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCAvLyBMT1dFUiAtPiBNSVhFRCAtPiBQVU5DVFxuICAgIF0pLFxuICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICg0IDw8IDE2KSArIDE0LFxuICAgICAgICAoOSA8PCAxNikgKyAoMTQgPDwgNSkgKyAyOCxcbiAgICAgICAgMCxcbiAgICAgICAgKDkgPDwgMTYpICsgKDE0IDw8IDUpICsgMjksXG4gICAgICAgICgxNCA8PCAxNikgKyAoMTQgPDwgMTApICsgKDI5IDw8IDUpICsgMzBcbiAgICAgICAgLy8gRElHSVQgLT4gVVBQRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICBdKSxcbiAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgKDUgPDwgMTYpICsgMjgsXG4gICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCxcbiAgICAgICAgMCxcbiAgICAgICAgKDUgPDwgMTYpICsgMzAgLy8gTUlYRUQgLT4gUFVOQ1RcbiAgICBdKSxcbiAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAoNSA8PCAxNikgKyAzMSxcbiAgICAgICAgKDEwIDw8IDE2KSArICgzMSA8PCA1KSArIDI4LFxuICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMzAsXG4gICAgICAgICgxMCA8PCAxNikgKyAoMzEgPDwgNSkgKyAyOSxcbiAgICAgICAgMFxuICAgIF0pXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHIFT_TABLE = exports.static_SHIFT_TABLE = void 0;\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar C = __webpack_require__(/*! ./EncoderConstants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js\");\nfunction static_SHIFT_TABLE(SHIFT_TABLE) {\n    var e_1, _a;\n    try {\n        for (var SHIFT_TABLE_1 = __values(SHIFT_TABLE), SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next(); !SHIFT_TABLE_1_1.done; SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next()) {\n            var table = SHIFT_TABLE_1_1.value /*Int32Array*/;\n            Arrays_1.default.fill(table, -1);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (SHIFT_TABLE_1_1 && !SHIFT_TABLE_1_1.done && (_a = SHIFT_TABLE_1.return)) _a.call(SHIFT_TABLE_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    SHIFT_TABLE[C.MODE_UPPER][C.MODE_PUNCT] = 0;\n    SHIFT_TABLE[C.MODE_LOWER][C.MODE_PUNCT] = 0;\n    SHIFT_TABLE[C.MODE_LOWER][C.MODE_UPPER] = 28;\n    SHIFT_TABLE[C.MODE_MIXED][C.MODE_PUNCT] = 0;\n    SHIFT_TABLE[C.MODE_DIGIT][C.MODE_PUNCT] = 0;\n    SHIFT_TABLE[C.MODE_DIGIT][C.MODE_UPPER] = 15;\n    return SHIFT_TABLE;\n}\nexports.static_SHIFT_TABLE = static_SHIFT_TABLE;\nexports.SHIFT_TABLE = static_SHIFT_TABLE(Arrays_1.default.createInt32Array(6, 6)); // mode shift codes, per table\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1NoaWZ0VGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsMEJBQTBCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQywySUFBbUI7QUFDMUMsUUFBUSxtQkFBTyxDQUFDLCtKQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csdUJBQXVCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLG1CQUFtQixnRUFBZ0UiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvZW5jb2Rlci9TaGlmdFRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSElGVF9UQUJMRSA9IGV4cG9ydHMuc3RhdGljX1NISUZUX1RBQkxFID0gdm9pZCAwO1xudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvQXJyYXlzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi9FbmNvZGVyQ29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gc3RhdGljX1NISUZUX1RBQkxFKFNISUZUX1RBQkxFKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgU0hJRlRfVEFCTEVfMSA9IF9fdmFsdWVzKFNISUZUX1RBQkxFKSwgU0hJRlRfVEFCTEVfMV8xID0gU0hJRlRfVEFCTEVfMS5uZXh0KCk7ICFTSElGVF9UQUJMRV8xXzEuZG9uZTsgU0hJRlRfVEFCTEVfMV8xID0gU0hJRlRfVEFCTEVfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IFNISUZUX1RBQkxFXzFfMS52YWx1ZSAvKkludDMyQXJyYXkqLztcbiAgICAgICAgICAgIEFycmF5c18xLmRlZmF1bHQuZmlsbCh0YWJsZSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoU0hJRlRfVEFCTEVfMV8xICYmICFTSElGVF9UQUJMRV8xXzEuZG9uZSAmJiAoX2EgPSBTSElGVF9UQUJMRV8xLnJldHVybikpIF9hLmNhbGwoU0hJRlRfVEFCTEVfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICBTSElGVF9UQUJMRVtDLk1PREVfVVBQRVJdW0MuTU9ERV9QVU5DVF0gPSAwO1xuICAgIFNISUZUX1RBQkxFW0MuTU9ERV9MT1dFUl1bQy5NT0RFX1BVTkNUXSA9IDA7XG4gICAgU0hJRlRfVEFCTEVbQy5NT0RFX0xPV0VSXVtDLk1PREVfVVBQRVJdID0gMjg7XG4gICAgU0hJRlRfVEFCTEVbQy5NT0RFX01JWEVEXVtDLk1PREVfUFVOQ1RdID0gMDtcbiAgICBTSElGVF9UQUJMRVtDLk1PREVfRElHSVRdW0MuTU9ERV9QVU5DVF0gPSAwO1xuICAgIFNISUZUX1RBQkxFW0MuTU9ERV9ESUdJVF1bQy5NT0RFX1VQUEVSXSA9IDE1O1xuICAgIHJldHVybiBTSElGVF9UQUJMRTtcbn1cbmV4cG9ydHMuc3RhdGljX1NISUZUX1RBQkxFID0gc3RhdGljX1NISUZUX1RBQkxFO1xuZXhwb3J0cy5TSElGVF9UQUJMRSA9IHN0YXRpY19TSElGVF9UQUJMRShBcnJheXNfMS5kZWZhdWx0LmNyZWF0ZUludDMyQXJyYXkoNiwgNikpOyAvLyBtb2RlIHNoaWZ0IGNvZGVzLCBwZXIgdGFibGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Token_1 = __webpack_require__(/*! ./Token */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar SimpleToken = /** @class */ (function (_super) {\n    __extends(SimpleToken, _super);\n    function SimpleToken(previous, value, bitCount) {\n        var _this = _super.call(this, previous) || this;\n        _this.value = value;\n        _this.bitCount = bitCount;\n        return _this;\n    }\n    /**\n     * @Override\n     */\n    SimpleToken.prototype.appendTo = function (bitArray, text) {\n        bitArray.appendBits(this.value, this.bitCount);\n    };\n    SimpleToken.prototype.add = function (value, bitCount) {\n        return new SimpleToken(this, value, bitCount);\n    };\n    SimpleToken.prototype.addBinaryShift = function (start, byteCount) {\n        // no-op can't binary shift a simple token\n        console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');\n        return new SimpleToken(this, start, byteCount);\n    };\n    /**\n     * @Override\n     */\n    SimpleToken.prototype.toString = function () {\n        var value = this.value & ((1 << this.bitCount) - 1);\n        value |= 1 << this.bitCount;\n        return '<' + Integer_1.default.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';\n    };\n    return SimpleToken;\n}(Token_1.default));\nexports[\"default\"] = SimpleToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1NpbXBsZVRva2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLHlJQUFTO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDZJQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1NpbXBsZVRva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVG9rZW5fMSA9IHJlcXVpcmUoXCIuL1Rva2VuXCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XG52YXIgU2ltcGxlVG9rZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbXBsZVRva2VuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVRva2VuKHByZXZpb3VzLCB2YWx1ZSwgYml0Q291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJldmlvdXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLmJpdENvdW50ID0gYml0Q291bnQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQE92ZXJyaWRlXG4gICAgICovXG4gICAgU2ltcGxlVG9rZW4ucHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24gKGJpdEFycmF5LCB0ZXh0KSB7XG4gICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy52YWx1ZSwgdGhpcy5iaXRDb3VudCk7XG4gICAgfTtcbiAgICBTaW1wbGVUb2tlbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBiaXRDb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgfTtcbiAgICBTaW1wbGVUb2tlbi5wcm90b3R5cGUuYWRkQmluYXJ5U2hpZnQgPSBmdW5jdGlvbiAoc3RhcnQsIGJ5dGVDb3VudCkge1xuICAgICAgICAvLyBuby1vcCBjYW4ndCBiaW5hcnkgc2hpZnQgYSBzaW1wbGUgdG9rZW5cbiAgICAgICAgY29uc29sZS53YXJuKCdhZGRCaW5hcnlTaGlmdCBvbiBTaW1wbGVUb2tlbiwgdGhpcyBzaW1wbHkgcmV0dXJucyBhIGNvcHkgb2YgdGhpcyB0b2tlbicpO1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQE92ZXJyaWRlXG4gICAgICovXG4gICAgU2ltcGxlVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlICYgKCgxIDw8IHRoaXMuYml0Q291bnQpIC0gMSk7XG4gICAgICAgIHZhbHVlIHw9IDEgPDwgdGhpcy5iaXRDb3VudDtcbiAgICAgICAgcmV0dXJuICc8JyArIEludGVnZXJfMS5kZWZhdWx0LnRvQmluYXJ5U3RyaW5nKHZhbHVlIHwgKDEgPDwgdGhpcy5iaXRDb3VudCkpLnN1YnN0cmluZygxKSArICc+JztcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVUb2tlbjtcbn0oVG9rZW5fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaW1wbGVUb2tlbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.aztec.encoder;\n// import java.util.Deque;\n// import java.util.LinkedList;\n// import com.google.zxing.common.BitArray;\nvar BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar TokenHelpers = __webpack_require__(/*! ./TokenHelpers */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js\");\nvar C = __webpack_require__(/*! ./EncoderConstants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js\");\nvar LatchTable = __webpack_require__(/*! ./LatchTable */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js\");\nvar ShiftTable = __webpack_require__(/*! ./ShiftTable */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\n/**\n * State represents all information about a sequence necessary to generate the current output.\n * Note that a state is immutable.\n */\nvar State = /** @class */ (function () {\n    function State(token, mode, binaryBytes, bitCount) {\n        this.token = token;\n        this.mode = mode;\n        this.binaryShiftByteCount = binaryBytes;\n        this.bitCount = bitCount;\n        // Make sure we match the token\n        // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n        //    (binaryShiftByteCount === 0 ? 0 :\n        //     binaryShiftByteCount <= 31 ? 10 :\n        //     binaryShiftByteCount <= 62 ? 20 : 21);\n        // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n    }\n    State.prototype.getMode = function () {\n        return this.mode;\n    };\n    State.prototype.getToken = function () {\n        return this.token;\n    };\n    State.prototype.getBinaryShiftByteCount = function () {\n        return this.binaryShiftByteCount;\n    };\n    State.prototype.getBitCount = function () {\n        return this.bitCount;\n    };\n    // Create a new state representing this state with a latch to a (not\n    // necessary different) mode, and then a code.\n    State.prototype.latchAndAppend = function (mode, value) {\n        // assert binaryShiftByteCount === 0;\n        var bitCount = this.bitCount;\n        var token = this.token;\n        if (mode !== this.mode) {\n            var latch = LatchTable.LATCH_TABLE[this.mode][mode];\n            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n            bitCount += latch >> 16;\n        }\n        var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;\n        token = TokenHelpers.add(token, value, latchModeBitCount);\n        return new State(token, mode, 0, bitCount + latchModeBitCount);\n    };\n    // Create a new state representing this state, with a temporary shift\n    // to a different mode to output a single value.\n    State.prototype.shiftAndAppend = function (mode, value) {\n        // assert binaryShiftByteCount === 0 && this.mode !== mode;\n        var token = this.token;\n        var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5;\n        // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n        token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n        token = TokenHelpers.add(token, value, 5);\n        return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n    };\n    // Create a new state representing this state, but an additional character\n    // output in Binary Shift mode.\n    State.prototype.addBinaryShiftChar = function (index) {\n        var token = this.token;\n        var mode = this.mode;\n        var bitCount = this.bitCount;\n        if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {\n            // assert binaryShiftByteCount === 0;\n            var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];\n            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n            bitCount += latch >> 16;\n            mode = C.MODE_UPPER;\n        }\n        var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31\n            ? 18\n            : this.binaryShiftByteCount === 62\n                ? 9\n                : 8;\n        var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n        if (result.binaryShiftByteCount === 2047 + 31) {\n            // The string is as long as it's allowed to be.  We should end it.\n            result = result.endBinaryShift(index + 1);\n        }\n        return result;\n    };\n    // Create the state identical to this one, but we are no longer in\n    // Binary Shift mode.\n    State.prototype.endBinaryShift = function (index) {\n        if (this.binaryShiftByteCount === 0) {\n            return this;\n        }\n        var token = this.token;\n        token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n        // assert token.getTotalBitCount() === this.bitCount;\n        return new State(token, this.mode, 0, this.bitCount);\n    };\n    // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n    // state under all possible circumstances.\n    State.prototype.isBetterThanOrEqualTo = function (other) {\n        var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);\n        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n            // add additional B/S encoding cost of other, if any\n            newModeBitCount +=\n                State.calculateBinaryShiftCost(other) -\n                    State.calculateBinaryShiftCost(this);\n        }\n        else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&\n            other.binaryShiftByteCount > 0) {\n            // maximum possible additional cost (it: h)\n            newModeBitCount += 10;\n        }\n        return newModeBitCount <= other.bitCount;\n    };\n    State.prototype.toBitArray = function (text) {\n        var e_1, _a;\n        // Reverse the tokens, so that they are in the order that they should\n        // be output\n        var symbols = [];\n        for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n            symbols.unshift(token);\n        }\n        var bitArray = new BitArray_1.default();\n        try {\n            // Add each token to the result.\n            for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n                var symbol = symbols_1_1.value;\n                symbol.appendTo(bitArray, text);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // assert bitArray.getSize() === this.bitCount;\n        return bitArray;\n    };\n    /**\n     * @Override\n     */\n    State.prototype.toString = function () {\n        return StringUtils_1.default.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n    };\n    State.calculateBinaryShiftCost = function (state) {\n        if (state.binaryShiftByteCount > 62) {\n            return 21; // B/S with extended length\n        }\n        if (state.binaryShiftByteCount > 31) {\n            return 20; // two B/S\n        }\n        if (state.binaryShiftByteCount > 0) {\n            return 10; // one B/S\n        }\n        return 0;\n    };\n    State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);\n    return State;\n}());\nexports[\"default\"] = State;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1N0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsbUpBQXVCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLHVKQUFnQjtBQUMzQyxRQUFRLG1CQUFPLENBQUMsK0pBQW9CO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1KQUFjO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG1KQUFjO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG1CQUFtQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1N0YXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcuYXp0ZWMuZW5jb2Rlcjtcbi8vIGltcG9ydCBqYXZhLnV0aWwuRGVxdWU7XG4vLyBpbXBvcnQgamF2YS51dGlsLkxpbmtlZExpc3Q7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0QXJyYXk7XG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0QXJyYXlcIik7XG52YXIgVG9rZW5IZWxwZXJzID0gcmVxdWlyZShcIi4vVG9rZW5IZWxwZXJzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi9FbmNvZGVyQ29uc3RhbnRzXCIpO1xudmFyIExhdGNoVGFibGUgPSByZXF1aXJlKFwiLi9MYXRjaFRhYmxlXCIpO1xudmFyIFNoaWZ0VGFibGUgPSByZXF1aXJlKFwiLi9TaGlmdFRhYmxlXCIpO1xudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xuLyoqXG4gKiBTdGF0ZSByZXByZXNlbnRzIGFsbCBpbmZvcm1hdGlvbiBhYm91dCBhIHNlcXVlbmNlIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aGUgY3VycmVudCBvdXRwdXQuXG4gKiBOb3RlIHRoYXQgYSBzdGF0ZSBpcyBpbW11dGFibGUuXG4gKi9cbnZhciBTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZSh0b2tlbiwgbW9kZSwgYmluYXJ5Qnl0ZXMsIGJpdENvdW50KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9IGJpbmFyeUJ5dGVzO1xuICAgICAgICB0aGlzLmJpdENvdW50ID0gYml0Q291bnQ7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBtYXRjaCB0aGUgdG9rZW5cbiAgICAgICAgLy8gaW50IGJpbmFyeVNoaWZ0Qml0Q291bnQgPSAoYmluYXJ5U2hpZnRCeXRlQ291bnQgKiA4KSArXG4gICAgICAgIC8vICAgIChiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCA/IDAgOlxuICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gMzEgPyAxMCA6XG4gICAgICAgIC8vICAgICBiaW5hcnlTaGlmdEJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICAvLyBhc3NlcnQgdGhpcy5iaXRDb3VudCA9PT0gdG9rZW4uZ2V0VG90YWxCaXRDb3VudCgpICsgYmluYXJ5U2hpZnRCaXRDb3VudDtcbiAgICB9XG4gICAgU3RhdGUucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuO1xuICAgIH07XG4gICAgU3RhdGUucHJvdG90eXBlLmdldEJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICB9O1xuICAgIFN0YXRlLnByb3RvdHlwZS5nZXRCaXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0Q291bnQ7XG4gICAgfTtcbiAgICAvLyBDcmVhdGUgYSBuZXcgc3RhdGUgcmVwcmVzZW50aW5nIHRoaXMgc3RhdGUgd2l0aCBhIGxhdGNoIHRvIGEgKG5vdFxuICAgIC8vIG5lY2Vzc2FyeSBkaWZmZXJlbnQpIG1vZGUsIGFuZCB0aGVuIGEgY29kZS5cbiAgICBTdGF0ZS5wcm90b3R5cGUubGF0Y2hBbmRBcHBlbmQgPSBmdW5jdGlvbiAobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gYXNzZXJ0IGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwO1xuICAgICAgICB2YXIgYml0Q291bnQgPSB0aGlzLmJpdENvdW50O1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICBpZiAobW9kZSAhPT0gdGhpcy5tb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGF0Y2ggPSBMYXRjaFRhYmxlLkxBVENIX1RBQkxFW3RoaXMubW9kZV1bbW9kZV07XG4gICAgICAgICAgICB0b2tlbiA9IFRva2VuSGVscGVycy5hZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICBiaXRDb3VudCArPSBsYXRjaCA+PiAxNjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF0Y2hNb2RlQml0Q291bnQgPSBtb2RlID09PSBDLk1PREVfRElHSVQgPyA0IDogNTtcbiAgICAgICAgdG9rZW4gPSBUb2tlbkhlbHBlcnMuYWRkKHRva2VuLCB2YWx1ZSwgbGF0Y2hNb2RlQml0Q291bnQpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlKHRva2VuLCBtb2RlLCAwLCBiaXRDb3VudCArIGxhdGNoTW9kZUJpdENvdW50KTtcbiAgICB9O1xuICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgd2l0aCBhIHRlbXBvcmFyeSBzaGlmdFxuICAgIC8vIHRvIGEgZGlmZmVyZW50IG1vZGUgdG8gb3V0cHV0IGEgc2luZ2xlIHZhbHVlLlxuICAgIFN0YXRlLnByb3RvdHlwZS5zaGlmdEFuZEFwcGVuZCA9IGZ1bmN0aW9uIChtb2RlLCB2YWx1ZSkge1xuICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDAgJiYgdGhpcy5tb2RlICE9PSBtb2RlO1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICB2YXIgdGhpc01vZGVCaXRDb3VudCA9IHRoaXMubW9kZSA9PT0gQy5NT0RFX0RJR0lUID8gNCA6IDU7XG4gICAgICAgIC8vIFNoaWZ0cyBleGlzdCBvbmx5IHRvIFVQUEVSIGFuZCBQVU5DVCwgYm90aCB3aXRoIHRva2VucyBzaXplIDUuXG4gICAgICAgIHRva2VuID0gVG9rZW5IZWxwZXJzLmFkZCh0b2tlbiwgU2hpZnRUYWJsZS5TSElGVF9UQUJMRVt0aGlzLm1vZGVdW21vZGVdLCB0aGlzTW9kZUJpdENvdW50KTtcbiAgICAgICAgdG9rZW4gPSBUb2tlbkhlbHBlcnMuYWRkKHRva2VuLCB2YWx1ZSwgNSk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIHRoaXMubW9kZSwgMCwgdGhpcy5iaXRDb3VudCArIHRoaXNNb2RlQml0Q291bnQgKyA1KTtcbiAgICB9O1xuICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgYnV0IGFuIGFkZGl0aW9uYWwgY2hhcmFjdGVyXG4gICAgLy8gb3V0cHV0IGluIEJpbmFyeSBTaGlmdCBtb2RlLlxuICAgIFN0YXRlLnByb3RvdHlwZS5hZGRCaW5hcnlTaGlmdENoYXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIHZhciBiaXRDb3VudCA9IHRoaXMuYml0Q291bnQ7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEMuTU9ERV9QVU5DVCB8fCB0aGlzLm1vZGUgPT09IEMuTU9ERV9ESUdJVCkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0IGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwO1xuICAgICAgICAgICAgdmFyIGxhdGNoID0gTGF0Y2hUYWJsZS5MQVRDSF9UQUJMRVttb2RlXVtDLk1PREVfVVBQRVJdO1xuICAgICAgICAgICAgdG9rZW4gPSBUb2tlbkhlbHBlcnMuYWRkKHRva2VuLCBsYXRjaCAmIDB4ZmZmZiwgbGF0Y2ggPj4gMTYpO1xuICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICBtb2RlID0gQy5NT0RFX1VQUEVSO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWx0YUJpdENvdW50ID0gdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCB8fCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAzMVxuICAgICAgICAgICAgPyAxOFxuICAgICAgICAgICAgOiB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSA2MlxuICAgICAgICAgICAgICAgID8gOVxuICAgICAgICAgICAgICAgIDogODtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdGF0ZSh0b2tlbiwgbW9kZSwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCArIDEsIGJpdENvdW50ICsgZGVsdGFCaXRDb3VudCk7XG4gICAgICAgIGlmIChyZXN1bHQuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDIwNDcgKyAzMSkge1xuICAgICAgICAgICAgLy8gVGhlIHN0cmluZyBpcyBhcyBsb25nIGFzIGl0J3MgYWxsb3dlZCB0byBiZS4gIFdlIHNob3VsZCBlbmQgaXQuXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZW5kQmluYXJ5U2hpZnQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3ZSBhcmUgbm8gbG9uZ2VyIGluXG4gICAgLy8gQmluYXJ5IFNoaWZ0IG1vZGUuXG4gICAgU3RhdGUucHJvdG90eXBlLmVuZEJpbmFyeVNoaWZ0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICB0b2tlbiA9IFRva2VuSGVscGVycy5hZGRCaW5hcnlTaGlmdCh0b2tlbiwgaW5kZXggLSB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICAgICAgLy8gYXNzZXJ0IHRva2VuLmdldFRvdGFsQml0Q291bnQoKSA9PT0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh0b2tlbiwgdGhpcy5tb2RlLCAwLCB0aGlzLmJpdENvdW50KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBcInRoaXNcIiBzdGF0ZSBpcyBiZXR0ZXIgKGVxdWFsOiBvcikgdG8gYmUgaW4gdGhhbiBcInRoYXRcIlxuICAgIC8vIHN0YXRlIHVuZGVyIGFsbCBwb3NzaWJsZSBjaXJjdW1zdGFuY2VzLlxuICAgIFN0YXRlLnByb3RvdHlwZS5pc0JldHRlclRoYW5PckVxdWFsVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIG5ld01vZGVCaXRDb3VudCA9IHRoaXMuYml0Q291bnQgKyAoTGF0Y2hUYWJsZS5MQVRDSF9UQUJMRVt0aGlzLm1vZGVdW290aGVyLm1vZGVdID4+IDE2KTtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPCBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gYWRkIGFkZGl0aW9uYWwgQi9TIGVuY29kaW5nIGNvc3Qgb2Ygb3RoZXIsIGlmIGFueVxuICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9XG4gICAgICAgICAgICAgICAgU3RhdGUuY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KG90aGVyKSAtXG4gICAgICAgICAgICAgICAgICAgIFN0YXRlLmNhbGN1bGF0ZUJpbmFyeVNoaWZ0Q29zdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQgJiZcbiAgICAgICAgICAgIG90aGVyLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gbWF4aW11bSBwb3NzaWJsZSBhZGRpdGlvbmFsIGNvc3QgKGl0OiBoKVxuICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNb2RlQml0Q291bnQgPD0gb3RoZXIuYml0Q291bnQ7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUudG9CaXRBcnJheSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAvLyBSZXZlcnNlIHRoZSB0b2tlbnMsIHNvIHRoYXQgdGhleSBhcmUgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGRcbiAgICAgICAgLy8gYmUgb3V0cHV0XG4gICAgICAgIHZhciBzeW1ib2xzID0gW107XG4gICAgICAgIGZvciAodmFyIHRva2VuID0gdGhpcy5lbmRCaW5hcnlTaGlmdCh0ZXh0Lmxlbmd0aCkudG9rZW47IHRva2VuICE9PSBudWxsOyB0b2tlbiA9IHRva2VuLmdldFByZXZpb3VzKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbHMudW5zaGlmdCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdEFycmF5ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQWRkIGVhY2ggdG9rZW4gdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIGZvciAodmFyIHN5bWJvbHNfMSA9IF9fdmFsdWVzKHN5bWJvbHMpLCBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCk7ICFzeW1ib2xzXzFfMS5kb25lOyBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFwcGVuZFRvKGJpdEFycmF5LCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbHNfMV8xICYmICFzeW1ib2xzXzFfMS5kb25lICYmIChfYSA9IHN5bWJvbHNfMS5yZXR1cm4pKSBfYS5jYWxsKHN5bWJvbHNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzZXJ0IGJpdEFycmF5LmdldFNpemUoKSA9PT0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgcmV0dXJuIGJpdEFycmF5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQE92ZXJyaWRlXG4gICAgICovXG4gICAgU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmZvcm1hdCgnJXMgYml0cz0lZCBieXRlcz0lZCcsIEMuTU9ERV9OQU1FU1t0aGlzLm1vZGVdLCB0aGlzLmJpdENvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICB9O1xuICAgIFN0YXRlLmNhbGN1bGF0ZUJpbmFyeVNoaWZ0Q29zdCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgcmV0dXJuIDIxOyAvLyBCL1Mgd2l0aCBleHRlbmRlZCBsZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiAzMSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwOyAvLyB0d28gQi9TXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEwOyAvLyBvbmUgQi9TXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTdGF0ZS5JTklUSUFMX1NUQVRFID0gbmV3IFN0YXRlKEMuRU1QVFlfVE9LRU4sIEMuTU9ERV9VUFBFUiwgMCwgMCk7XG4gICAgcmV0dXJuIFN0YXRlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Token = /** @class */ (function () {\n    function Token(previous) {\n        this.previous = previous;\n    }\n    Token.prototype.getPrevious = function () {\n        return this.previous;\n    };\n    return Token;\n}());\nexports[\"default\"] = Token;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1Rva2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvYXp0ZWMvZW5jb2Rlci9Ub2tlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUb2tlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbihwcmV2aW91cykge1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgfVxuICAgIFRva2VuLnByb3RvdHlwZS5nZXRQcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXM7XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.add = exports.addBinaryShift = void 0;\nvar SimpleToken_1 = __webpack_require__(/*! ./SimpleToken */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js\");\nvar BinaryShiftToken_1 = __webpack_require__(/*! ./BinaryShiftToken */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js\");\nfunction addBinaryShift(token, start, byteCount) {\n    // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n    return new BinaryShiftToken_1.default(token, start, byteCount);\n}\nexports.addBinaryShift = addBinaryShift;\nfunction add(token, value, bitCount) {\n    return new SimpleToken_1.default(token, value, bitCount);\n}\nexports.add = add;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9henRlYy9lbmNvZGVyL1Rva2VuSGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsc0JBQXNCO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLHFKQUFlO0FBQzNDLHlCQUF5QixtQkFBTyxDQUFDLCtKQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxXQUFXIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2F6dGVjL2VuY29kZXIvVG9rZW5IZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLmFkZEJpbmFyeVNoaWZ0ID0gdm9pZCAwO1xudmFyIFNpbXBsZVRva2VuXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVUb2tlblwiKTtcbnZhciBCaW5hcnlTaGlmdFRva2VuXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlTaGlmdFRva2VuXCIpO1xuZnVuY3Rpb24gYWRkQmluYXJ5U2hpZnQodG9rZW4sIHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAvLyBpbnQgYml0Q291bnQgPSAoYnl0ZUNvdW50ICogOCkgKyAoYnl0ZUNvdW50IDw9IDMxID8gMTAgOiBieXRlQ291bnQgPD0gNjIgPyAyMCA6IDIxKTtcbiAgICByZXR1cm4gbmV3IEJpbmFyeVNoaWZ0VG9rZW5fMS5kZWZhdWx0KHRva2VuLCBzdGFydCwgYnl0ZUNvdW50KTtcbn1cbmV4cG9ydHMuYWRkQmluYXJ5U2hpZnQgPSBhZGRCaW5hcnlTaGlmdDtcbmZ1bmN0aW9uIGFkZCh0b2tlbiwgdmFsdWUsIGJpdENvdW50KSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVUb2tlbl8xLmRlZmF1bHQodG9rZW4sIHZhbHVlLCBiaXRDb3VudCk7XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar Arrays_1 = __webpack_require__(/*! ../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar Integer_1 = __webpack_require__(/*! ../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar System_1 = __webpack_require__(/*! ../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\n/**\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n *\n * @author Sean Owen\n */\nvar BitArray /*implements Cloneable*/ = /** @class */ (function () {\n    // public constructor() {\n    //   this.size = 0\n    //   this.bits = new Int32Array(1)\n    // }\n    // public constructor(size?: number /*int*/) {\n    //   if (undefined === size) {\n    //     this.size = 0\n    //   } else {\n    //     this.size = size\n    //   }\n    //   this.bits = this.makeArray(size)\n    // }\n    // For testing only\n    function BitArray(size /*int*/, bits) {\n        if (undefined === size) {\n            this.size = 0;\n            this.bits = new Int32Array(1);\n        }\n        else {\n            this.size = size;\n            if (undefined === bits || null === bits) {\n                this.bits = BitArray.makeArray(size);\n            }\n            else {\n                this.bits = bits;\n            }\n        }\n    }\n    BitArray.prototype.getSize = function () {\n        return this.size;\n    };\n    BitArray.prototype.getSizeInBytes = function () {\n        return Math.floor((this.size + 7) / 8);\n    };\n    BitArray.prototype.ensureCapacity = function (size /*int*/) {\n        if (size > this.bits.length * 32) {\n            var newBits = BitArray.makeArray(size);\n            System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n            this.bits = newBits;\n        }\n    };\n    /**\n     * @param i bit to get\n     * @return true iff bit i is set\n     */\n    BitArray.prototype.get = function (i /*int*/) {\n        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;\n    };\n    /**\n     * Sets bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.set = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n    };\n    /**\n     * Flips bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.flip = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n    };\n    /**\n     * @param from first bit to check\n     * @return index of first bit that is set, starting from the given index, or size if none are set\n     *  at or beyond this given index\n     * @see #getNextUnset(int)\n     */\n    BitArray.prototype.getNextSet = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * @param from index to start looking for unset bit\n     * @return index of next unset bit, or {@code size} if none are unset until the end\n     * @see #getNextSet(int)\n     */\n    BitArray.prototype.getNextUnset = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = ~bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = ~bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * Sets a block of 32 bits, starting at bit i.\n     *\n     * @param i first bit to set\n     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n     * corresponds to bit i, the next-least-significant to i+1, and so on.\n     */\n    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {\n        this.bits[Math.floor(i / 32)] = newBits;\n    };\n    /**\n     * Sets a range of bits.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     */\n    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return;\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit);\n            bits[i] |= mask;\n        }\n    };\n    /**\n     * Clears all bits (sets to false).\n     */\n    BitArray.prototype.clear = function () {\n        var max = this.bits.length;\n        var bits = this.bits;\n        for (var i = 0; i < max; i++) {\n            bits[i] = 0;\n        }\n    };\n    /**\n     * Efficient method to check if a range of bits is set, or not set.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n     * @return true iff all bits are set or not set in range, according to value argument\n     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n     */\n    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return true; // empty range matches\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n            // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n            if ((bits[i] & mask) !== (value ? mask : 0)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    BitArray.prototype.appendBit = function (bit) {\n        this.ensureCapacity(this.size + 1);\n        if (bit) {\n            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n        }\n        this.size++;\n    };\n    /**\n     * Appends the least-significant bits, from value, in order from most-significant to\n     * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n     * 0, 1, 1, 1, 1, 0 in that order.\n     *\n     * @param value {@code int} containing bits to append\n     * @param numBits bits from value to append\n     */\n    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {\n        if (numBits < 0 || numBits > 32) {\n            throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');\n        }\n        this.ensureCapacity(this.size + numBits);\n        // const appendBit = this.appendBit;\n        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);\n        }\n    };\n    BitArray.prototype.appendBitArray = function (other) {\n        var otherSize = other.size;\n        this.ensureCapacity(this.size + otherSize);\n        // const appendBit = this.appendBit;\n        for (var i = 0; i < otherSize; i++) {\n            this.appendBit(other.get(i));\n        }\n    };\n    BitArray.prototype.xor = function (other) {\n        if (this.size !== other.size) {\n            throw new IllegalArgumentException_1.default('Sizes don\\'t match');\n        }\n        var bits = this.bits;\n        for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n            // The last int could be incomplete (i.e. not have 32 bits in\n            // it) but there is no problem since 0 XOR 0 == 0.\n            bits[i] ^= other.bits[i];\n        }\n    };\n    /**\n     *\n     * @param bitOffset first bit to start writing\n     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n     *  of the internal representation, which is exposed by {@link #getBitArray()}\n     * @param offset position in array to start writing\n     * @param numBytes how many bytes to write\n     */\n    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n        for (var i = 0; i < numBytes; i++) {\n            var theByte = 0;\n            for (var j = 0; j < 8; j++) {\n                if (this.get(bitOffset)) {\n                    theByte |= 1 << (7 - j);\n                }\n                bitOffset++;\n            }\n            array[offset + i] = /*(byte)*/ theByte;\n        }\n    };\n    /**\n     * @return underlying array of ints. The first element holds the first 32 bits, and the least\n     *         significant bit is bit 0.\n     */\n    BitArray.prototype.getBitArray = function () {\n        return this.bits;\n    };\n    /**\n     * Reverses all bits in the array.\n     */\n    BitArray.prototype.reverse = function () {\n        var newBits = new Int32Array(this.bits.length);\n        // reverse all int's first\n        var len = Math.floor((this.size - 1) / 32);\n        var oldBitsLen = len + 1;\n        var bits = this.bits;\n        for (var i = 0; i < oldBitsLen; i++) {\n            var x = bits[i];\n            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n            newBits[len - i] = /*(int)*/ x;\n        }\n        // now correct the int's if the bit size isn't a multiple of 32\n        if (this.size !== oldBitsLen * 32) {\n            var leftOffset = oldBitsLen * 32 - this.size;\n            var currentInt = newBits[0] >>> leftOffset;\n            for (var i = 1; i < oldBitsLen; i++) {\n                var nextInt = newBits[i];\n                currentInt |= nextInt << (32 - leftOffset);\n                newBits[i - 1] = currentInt;\n                currentInt = nextInt >>> leftOffset;\n            }\n            newBits[oldBitsLen - 1] = currentInt;\n        }\n        this.bits = newBits;\n    };\n    BitArray.makeArray = function (size /*int*/) {\n        return new Int32Array(Math.floor((size + 31) / 32));\n    };\n    /*@Override*/\n    BitArray.prototype.equals = function (o) {\n        if (!(o instanceof BitArray)) {\n            return false;\n        }\n        var other = o;\n        return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.hashCode = function () {\n        return 31 * this.size + Arrays_1.default.hashCode(this.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.toString = function () {\n        var result = '';\n        for (var i = 0, size = this.size; i < size; i++) {\n            if ((i & 0x07) === 0) {\n                result += ' ';\n            }\n            result += this.get(i) ? 'X' : '.';\n        }\n        return result;\n    };\n    /*@Override*/\n    BitArray.prototype.clone = function () {\n        return new BitArray(this.size, this.bits.slice());\n    };\n    /**\n     * converts to boolean array.\n     */\n    BitArray.prototype.toArray = function () {\n        var result = [];\n        for (var i = 0, size = this.size; i < size; i++) {\n            result.push(this.get(i));\n        }\n        return result;\n    };\n    return BitArray;\n}());\nexports[\"default\"] = BitArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vQml0QXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLDBCQUEwQjtBQUMxQixpQ0FBaUMsbUJBQU8sQ0FBQyxrS0FBNkI7QUFDdEUsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwSUFBaUI7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2NvbW1vbi9CaXRBcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlzOyovXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJyYXlzXCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0ludGVnZXJcIik7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TeXN0ZW1cIik7XG4vKipcbiAqIDxwPkEgc2ltcGxlLCBmYXN0IGFycmF5IG9mIGJpdHMsIHJlcHJlc2VudGVkIGNvbXBhY3RseSBieSBhbiBhcnJheSBvZiBpbnRzIGludGVybmFsbHkuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBCaXRBcnJheSAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vICAgdGhpcy5zaXplID0gMFxuICAgIC8vICAgdGhpcy5iaXRzID0gbmV3IEludDMyQXJyYXkoMSlcbiAgICAvLyB9XG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHNpemU/OiBudW1iZXIgLyppbnQqLykge1xuICAgIC8vICAgaWYgKHVuZGVmaW5lZCA9PT0gc2l6ZSkge1xuICAgIC8vICAgICB0aGlzLnNpemUgPSAwXG4gICAgLy8gICB9IGVsc2Uge1xuICAgIC8vICAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgLy8gICB9XG4gICAgLy8gICB0aGlzLmJpdHMgPSB0aGlzLm1ha2VBcnJheShzaXplKVxuICAgIC8vIH1cbiAgICAvLyBGb3IgdGVzdGluZyBvbmx5XG4gICAgZnVuY3Rpb24gQml0QXJyYXkoc2l6ZSAvKmludCovLCBiaXRzKSB7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBCaXRBcnJheS5tYWtlQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG4gICAgQml0QXJyYXkucHJvdG90eXBlLmdldFNpemVJbkJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5zaXplICsgNykgLyA4KTtcbiAgICB9O1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmJpdHMubGVuZ3RoICogMzIpIHtcbiAgICAgICAgICAgIHZhciBuZXdCaXRzID0gQml0QXJyYXkubWFrZUFycmF5KHNpemUpO1xuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5iaXRzLCAwLCBuZXdCaXRzLCAwLCB0aGlzLmJpdHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpIGJpdCB0byBnZXRcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGJpdCBpIGlzIHNldFxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSAvKmludCovKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gJiAoMSA8PCAoaSAmIDB4MUYpKSkgIT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGJpdCBpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSAvKmludCovKSB7XG4gICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIHw9IDEgPDwgKGkgJiAweDFGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZsaXBzIGJpdCBpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgYml0IHRvIHNldFxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gKGkgLyppbnQqLykge1xuICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSBePSAxIDw8IChpICYgMHgxRik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZnJvbSBmaXJzdCBiaXQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIGluZGV4IG9mIGZpcnN0IGJpdCB0aGF0IGlzIHNldCwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXgsIG9yIHNpemUgaWYgbm9uZSBhcmUgc2V0XG4gICAgICogIGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4XG4gICAgICogQHNlZSAjZ2V0TmV4dFVuc2V0KGludClcbiAgICAgKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0TmV4dFNldCA9IGZ1bmN0aW9uIChmcm9tIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICB2YXIgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcbiAgICAgICAgdmFyIGN1cnJlbnRCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Qml0cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IChiaXRzT2Zmc2V0ICogMzIpICsgSW50ZWdlcl8xLmRlZmF1bHQubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZyb20gaW5kZXggdG8gc3RhcnQgbG9va2luZyBmb3IgdW5zZXQgYml0XG4gICAgICogQHJldHVybiBpbmRleCBvZiBuZXh0IHVuc2V0IGJpdCwgb3Ige0Bjb2RlIHNpemV9IGlmIG5vbmUgYXJlIHVuc2V0IHVudGlsIHRoZSBlbmRcbiAgICAgKiBAc2VlICNnZXROZXh0U2V0KGludClcbiAgICAgKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0TmV4dFVuc2V0ID0gZnVuY3Rpb24gKGZyb20gLyppbnQqLykge1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKGZyb20gPj0gc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgIHZhciBiaXRzT2Zmc2V0ID0gTWF0aC5mbG9vcihmcm9tIC8gMzIpO1xuICAgICAgICB2YXIgY3VycmVudEJpdHMgPSB+Yml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYml0cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Qml0cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXJfMS5kZWZhdWx0Lm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPiBzaXplID8gc2l6ZSA6IHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBibG9jayBvZiAzMiBiaXRzLCBzdGFydGluZyBhdCBiaXQgaS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIGZpcnN0IGJpdCB0byBzZXRcbiAgICAgKiBAcGFyYW0gbmV3Qml0cyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBuZXh0IDMyIGJpdHMuIE5vdGUgYWdhaW4gdGhhdCB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0XG4gICAgICogY29ycmVzcG9uZHMgdG8gYml0IGksIHRoZSBuZXh0LWxlYXN0LXNpZ25pZmljYW50IHRvIGkrMSwgYW5kIHNvIG9uLlxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5zZXRCdWxrID0gZnVuY3Rpb24gKGkgLyppbnQqLywgbmV3Qml0cyAvKmludCovKSB7XG4gICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildID0gbmV3Qml0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSByYW5nZSBvZiBiaXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICogQHBhcmFtIGVuZCBlbmQgb2YgcmFuZ2UsIGV4Y2x1c2l2ZVxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCAvKmludCovLCBlbmQgLyppbnQqLykge1xuICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgICAgIHZhciBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XG4gICAgICAgIHZhciBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7XG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RCaXQgPSBpID4gZmlyc3RJbnQgPyAwIDogc3RhcnQgJiAweDFGO1xuICAgICAgICAgICAgdmFyIGxhc3RCaXQgPSBpIDwgbGFzdEludCA/IDMxIDogZW5kICYgMHgxRjtcbiAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmVcbiAgICAgICAgICAgIHZhciBtYXNrID0gKDIgPDwgbGFzdEJpdCkgLSAoMSA8PCBmaXJzdEJpdCk7XG4gICAgICAgICAgICBiaXRzW2ldIHw9IG1hc2s7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICovXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5iaXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgIGJpdHNbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnQgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcmFuZ2Ugb2YgYml0cyBpcyBzZXQsIG9yIG5vdCBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgb2YgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlXG4gICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUsIGNoZWNrcyB0aGF0IGJpdHMgaW4gcmFuZ2UgYXJlIHNldCwgb3RoZXJ3aXNlIGNoZWNrcyB0aGF0IHRoZXkgYXJlIG5vdCBzZXRcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nIHRvIHZhbHVlIGFyZ3VtZW50XG4gICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydCBvciB0aGUgcmFuZ2UgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUuaXNSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCAvKmludCovLCBlbmQgLyppbnQqLywgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSByYW5nZSBtYXRjaGVzXG4gICAgICAgIH1cbiAgICAgICAgZW5kLS07IC8vIHdpbGwgYmUgZWFzaWVyIHRvIHRyZWF0IHRoaXMgYXMgdGhlIGxhc3QgYWN0dWFsbHkgc2V0IGJpdCAtLSBpbmNsdXNpdmVcbiAgICAgICAgdmFyIGZpcnN0SW50ID0gTWF0aC5mbG9vcihzdGFydCAvIDMyKTtcbiAgICAgICAgdmFyIGxhc3RJbnQgPSBNYXRoLmZsb29yKGVuZCAvIDMyKTtcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSBmaXJzdEludDsgaSA8PSBsYXN0SW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XG4gICAgICAgICAgICB2YXIgbGFzdEJpdCA9IGkgPCBsYXN0SW50ID8gMzEgOiBlbmQgJiAweDFGO1xuICAgICAgICAgICAgLy8gT25lcyBmcm9tIGZpcnN0Qml0IHRvIGxhc3RCaXQsIGluY2x1c2l2ZVxuICAgICAgICAgICAgdmFyIG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KSAmIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogJiAweEZGRkZGRkZGIGFkZGVkIHRvIGRpc2NhcmQgYW55dGhpbmcgYWZ0ZXIgMzIgYml0cywgYXMgRVMgaGFzIDUzIGJpdHNcbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiB3ZSdyZSBsb29raW5nIGZvciAxcyBhbmQgdGhlIG1hc2tlZCBiaXRzW2ldIGlzbid0IGFsbCAxcyAoaXM6IHRoYXQsXG4gICAgICAgICAgICAvLyBlcXVhbHMgdGhlIG1hc2ssIG9yIHdlJ3JlIGxvb2tpbmcgZm9yIDBzIGFuZCB0aGUgbWFza2VkIHBvcnRpb24gaXMgbm90IGFsbCAwc1xuICAgICAgICAgICAgaWYgKChiaXRzW2ldICYgbWFzaykgIT09ICh2YWx1ZSA/IG1hc2sgOiAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5hcHBlbmRCaXQgPSBmdW5jdGlvbiAoYml0KSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgMSk7XG4gICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKHRoaXMuc2l6ZSAvIDMyKV0gfD0gMSA8PCAodGhpcy5zaXplICYgMHgxRik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRzLCBmcm9tIHZhbHVlLCBpbiBvcmRlciBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG9cbiAgICAgKiBsZWFzdC1zaWduaWZpY2FudC4gRm9yIGV4YW1wbGUsIGFwcGVuZGluZyA2IGJpdHMgZnJvbSAweDAwMDAwMUUgd2lsbCBhcHBlbmQgdGhlIGJpdHNcbiAgICAgKiAwLCAxLCAxLCAxLCAxLCAwIGluIHRoYXQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUge0Bjb2RlIGludH0gY29udGFpbmluZyBiaXRzIHRvIGFwcGVuZFxuICAgICAqIEBwYXJhbSBudW1CaXRzIGJpdHMgZnJvbSB2YWx1ZSB0byBhcHBlbmRcbiAgICAgKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUuYXBwZW5kQml0cyA9IGZ1bmN0aW9uICh2YWx1ZSAvKmludCovLCBudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKG51bUJpdHMgPCAwIHx8IG51bUJpdHMgPiAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ051bSBiaXRzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAzMicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgbnVtQml0cyk7XG4gICAgICAgIC8vIGNvbnN0IGFwcGVuZEJpdCA9IHRoaXMuYXBwZW5kQml0O1xuICAgICAgICBmb3IgKHZhciBudW1CaXRzTGVmdCA9IG51bUJpdHM7IG51bUJpdHNMZWZ0ID4gMDsgbnVtQml0c0xlZnQtLSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQoKCh2YWx1ZSA+PiAobnVtQml0c0xlZnQgLSAxKSkgJiAweDAxKSA9PT0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5hcHBlbmRCaXRBcnJheSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgb3RoZXJTaXplID0gb3RoZXIuc2l6ZTtcbiAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemUgKyBvdGhlclNpemUpO1xuICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclNpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQob3RoZXIuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQml0QXJyYXkucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnU2l6ZXMgZG9uXFwndCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBiaXRzLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGludCBjb3VsZCBiZSBpbmNvbXBsZXRlIChpLmUuIG5vdCBoYXZlIDMyIGJpdHMgaW5cbiAgICAgICAgICAgIC8vIGl0KSBidXQgdGhlcmUgaXMgbm8gcHJvYmxlbSBzaW5jZSAwIFhPUiAwID09IDAuXG4gICAgICAgICAgICBiaXRzW2ldIF49IG90aGVyLmJpdHNbaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJpdE9mZnNldCBmaXJzdCBiaXQgdG8gc3RhcnQgd3JpdGluZ1xuICAgICAqIEBwYXJhbSBhcnJheSBhcnJheSB0byB3cml0ZSBpbnRvLiBCeXRlcyBhcmUgd3JpdHRlbiBtb3N0LXNpZ25pZmljYW50IGJ5dGUgZmlyc3QuIFRoaXMgaXMgdGhlIG9wcG9zaXRlXG4gICAgICogIG9mIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgd2hpY2ggaXMgZXhwb3NlZCBieSB7QGxpbmsgI2dldEJpdEFycmF5KCl9XG4gICAgICogQHBhcmFtIG9mZnNldCBwb3NpdGlvbiBpbiBhcnJheSB0byBzdGFydCB3cml0aW5nXG4gICAgICogQHBhcmFtIG51bUJ5dGVzIGhvdyBtYW55IGJ5dGVzIHRvIHdyaXRlXG4gICAgICovXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiAoYml0T2Zmc2V0IC8qaW50Ki8sIGFycmF5LCBvZmZzZXQgLyppbnQqLywgbnVtQnl0ZXMgLyppbnQqLykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aGVCeXRlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGJpdE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlQnl0ZSB8PSAxIDw8ICg3IC0gaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpdE9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSAvKihieXRlKSovIHRoZUJ5dGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdW5kZXJseWluZyBhcnJheSBvZiBpbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBob2xkcyB0aGUgZmlyc3QgMzIgYml0cywgYW5kIHRoZSBsZWFzdFxuICAgICAqICAgICAgICAgc2lnbmlmaWNhbnQgYml0IGlzIGJpdCAwLlxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXRCaXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGFsbCBiaXRzIGluIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0JpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJpdHMubGVuZ3RoKTtcbiAgICAgICAgLy8gcmV2ZXJzZSBhbGwgaW50J3MgZmlyc3RcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguZmxvb3IoKHRoaXMuc2l6ZSAtIDEpIC8gMzIpO1xuICAgICAgICB2YXIgb2xkQml0c0xlbiA9IGxlbiArIDE7XG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZEJpdHNMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBiaXRzW2ldO1xuICAgICAgICAgICAgeCA9ICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpIHwgKCh4ICYgMHg1NTU1NTU1NSkgPDwgMSk7XG4gICAgICAgICAgICB4ID0gKCh4ID4+IDIpICYgMHgzMzMzMzMzMykgfCAoKHggJiAweDMzMzMzMzMzKSA8PCAyKTtcbiAgICAgICAgICAgIHggPSAoKHggPj4gNCkgJiAweDBmMGYwZjBmKSB8ICgoeCAmIDB4MGYwZjBmMGYpIDw8IDQpO1xuICAgICAgICAgICAgeCA9ICgoeCA+PiA4KSAmIDB4MDBmZjAwZmYpIHwgKCh4ICYgMHgwMGZmMDBmZikgPDwgOCk7XG4gICAgICAgICAgICB4ID0gKCh4ID4+IDE2KSAmIDB4MDAwMGZmZmYpIHwgKCh4ICYgMHgwMDAwZmZmZikgPDwgMTYpO1xuICAgICAgICAgICAgbmV3Qml0c1tsZW4gLSBpXSA9IC8qKGludCkqLyB4O1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBjb3JyZWN0IHRoZSBpbnQncyBpZiB0aGUgYml0IHNpemUgaXNuJ3QgYSBtdWx0aXBsZSBvZiAzMlxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvbGRCaXRzTGVuICogMzIpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gb2xkQml0c0xlbiAqIDMyIC0gdGhpcy5zaXplO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbnQgPSBuZXdCaXRzWzBdID4+PiBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvbGRCaXRzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEludCA9IG5ld0JpdHNbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudEludCB8PSBuZXh0SW50IDw8ICgzMiAtIGxlZnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIG5ld0JpdHNbaSAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ID0gbmV4dEludCA+Pj4gbGVmdE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0JpdHNbb2xkQml0c0xlbiAtIDFdID0gY3VycmVudEludDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpdHMgPSBuZXdCaXRzO1xuICAgIH07XG4gICAgQml0QXJyYXkubWFrZUFycmF5ID0gZnVuY3Rpb24gKHNpemUgLyppbnQqLykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoTWF0aC5mbG9vcigoc2l6ZSArIDMxKSAvIDMyKSk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCaXRBcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBvdGhlci5zaXplICYmIEFycmF5c18xLmRlZmF1bHQuZXF1YWxzKHRoaXMuYml0cywgb3RoZXIuYml0cyk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMzEgKiB0aGlzLnNpemUgKyBBcnJheXNfMS5kZWZhdWx0Lmhhc2hDb2RlKHRoaXMuYml0cyk7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzaXplID0gdGhpcy5zaXplOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGkgJiAweDA3KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXQoaSkgPyAnWCcgOiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBCaXRBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQml0QXJyYXkodGhpcy5zaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyB0byBib29sZWFuIGFycmF5LlxuICAgICAqL1xuICAgIEJpdEFycmF5LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzaXplID0gdGhpcy5zaXplOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdldChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBCaXRBcnJheTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCaXRBcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nvar BitArray_1 = __webpack_require__(/*! ./BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar System_1 = __webpack_require__(/*! ../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar Arrays_1 = __webpack_require__(/*! ../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n * module, x is the column position, and y is the row position. The ordering is always x, y.\n * The origin is at the top-left.</p>\n *\n * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n * efficiently.</p>\n *\n * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar BitMatrix /*implements Cloneable*/ = /** @class */ (function () {\n    /**\n     * Creates an empty square {@link BitMatrix}.\n     *\n     * @param dimension height and width\n     */\n    // public constructor(dimension: number /*int*/) {\n    //   this(dimension, dimension)\n    // }\n    /**\n     * Creates an empty {@link BitMatrix}.\n     *\n     * @param width bit matrix width\n     * @param height bit matrix height\n     */\n    // public constructor(width: number /*int*/, height: number /*int*/) {\n    //   if (width < 1 || height < 1) {\n    //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n    //   }\n    //   this.width = width\n    //   this.height = height\n    //   this.rowSize = (width + 31) / 32\n    //   bits = new int[rowSize * height];\n    // }\n    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {\n        this.width = width;\n        this.height = height;\n        this.rowSize = rowSize;\n        this.bits = bits;\n        if (undefined === height || null === height) {\n            height = width;\n        }\n        this.height = height;\n        if (width < 1 || height < 1) {\n            throw new IllegalArgumentException_1.default('Both dimensions must be greater than 0');\n        }\n        if (undefined === rowSize || null === rowSize) {\n            rowSize = Math.floor((width + 31) / 32);\n        }\n        this.rowSize = rowSize;\n        if (undefined === bits || null === bits) {\n            this.bits = new Int32Array(this.rowSize * this.height);\n        }\n    }\n    /**\n     * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n     *\n     * @function parse\n     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n     * @return {@link BitMatrix} representation of image\n     */\n    BitMatrix.parseFromBooleanArray = function (image) {\n        var height = image.length;\n        var width = image[0].length;\n        var bits = new BitMatrix(width, height);\n        for (var i = 0; i < height; i++) {\n            var imageI = image[i];\n            for (var j = 0; j < width; j++) {\n                if (imageI[j]) {\n                    bits.set(j, i);\n                }\n            }\n        }\n        return bits;\n    };\n    /**\n     *\n     * @function parse\n     * @param stringRepresentation\n     * @param setString\n     * @param unsetString\n     */\n    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {\n        if (stringRepresentation === null) {\n            throw new IllegalArgumentException_1.default('stringRepresentation cannot be null');\n        }\n        var bits = new Array(stringRepresentation.length);\n        var bitsPos = 0;\n        var rowStartPos = 0;\n        var rowLength = -1;\n        var nRows = 0;\n        var pos = 0;\n        while (pos < stringRepresentation.length) {\n            if (stringRepresentation.charAt(pos) === '\\n' ||\n                stringRepresentation.charAt(pos) === '\\r') {\n                if (bitsPos > rowStartPos) {\n                    if (rowLength === -1) {\n                        rowLength = bitsPos - rowStartPos;\n                    }\n                    else if (bitsPos - rowStartPos !== rowLength) {\n                        throw new IllegalArgumentException_1.default('row lengths do not match');\n                    }\n                    rowStartPos = bitsPos;\n                    nRows++;\n                }\n                pos++;\n            }\n            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n                pos += setString.length;\n                bits[bitsPos] = true;\n                bitsPos++;\n            }\n            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n                pos += unsetString.length;\n                bits[bitsPos] = false;\n                bitsPos++;\n            }\n            else {\n                throw new IllegalArgumentException_1.default('illegal character encountered: ' + stringRepresentation.substring(pos));\n            }\n        }\n        // no EOL at end?\n        if (bitsPos > rowStartPos) {\n            if (rowLength === -1) {\n                rowLength = bitsPos - rowStartPos;\n            }\n            else if (bitsPos - rowStartPos !== rowLength) {\n                throw new IllegalArgumentException_1.default('row lengths do not match');\n            }\n            nRows++;\n        }\n        var matrix = new BitMatrix(rowLength, nRows);\n        for (var i = 0; i < bitsPos; i++) {\n            if (bits[i]) {\n                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n            }\n        }\n        return matrix;\n    };\n    /**\n     * <p>Gets the requested bit, where true means black.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     * @return value of given bit in matrix\n     */\n    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;\n    };\n    /**\n     * <p>Sets the given bit to true.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     */\n    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;\n    };\n    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);\n    };\n    /**\n     * <p>Flips the given bit.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     */\n    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n    };\n    /**\n     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n     * mask bit is set.\n     *\n     * @param mask XOR mask\n     */\n    BitMatrix.prototype.xor = function (mask) {\n        if (this.width !== mask.getWidth() || this.height !== mask.getHeight()\n            || this.rowSize !== mask.getRowSize()) {\n            throw new IllegalArgumentException_1.default('input matrix dimensions do not match');\n        }\n        var rowArray = new BitArray_1.default(Math.floor(this.width / 32) + 1);\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        for (var y = 0, height = this.height; y < height; y++) {\n            var offset = y * rowSize;\n            var row = mask.getRow(y, rowArray).getBitArray();\n            for (var x = 0; x < rowSize; x++) {\n                bits[offset + x] ^= row[x];\n            }\n        }\n    };\n    /**\n     * Clears all bits (sets to false).\n     */\n    BitMatrix.prototype.clear = function () {\n        var bits = this.bits;\n        var max = bits.length;\n        for (var i = 0; i < max; i++) {\n            bits[i] = 0;\n        }\n    };\n    /**\n     * <p>Sets a square region of the bit matrix to true.</p>\n     *\n     * @param left The horizontal position to begin at (inclusive)\n     * @param top The vertical position to begin at (inclusive)\n     * @param width The width of the region\n     * @param height The height of the region\n     */\n    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        if (top < 0 || left < 0) {\n            throw new IllegalArgumentException_1.default('Left and top must be nonnegative');\n        }\n        if (height < 1 || width < 1) {\n            throw new IllegalArgumentException_1.default('Height and width must be at least 1');\n        }\n        var right = left + width;\n        var bottom = top + height;\n        if (bottom > this.height || right > this.width) {\n            throw new IllegalArgumentException_1.default('The region must fit inside the matrix');\n        }\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        for (var y = top; y < bottom; y++) {\n            var offset = y * rowSize;\n            for (var x = left; x < right; x++) {\n                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n            }\n        }\n    };\n    /**\n     * A fast method to retrieve one row of data from the matrix as a BitArray.\n     *\n     * @param y The row to retrieve\n     * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n     * @return The resulting BitArray - this reference should always be used even when passing\n     *         your own row\n     */\n    BitMatrix.prototype.getRow = function (y /*int*/, row) {\n        if (row === null || row === undefined || row.getSize() < this.width) {\n            row = new BitArray_1.default(this.width);\n        }\n        else {\n            row.clear();\n        }\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var offset = y * rowSize;\n        for (var x = 0; x < rowSize; x++) {\n            row.setBulk(x * 32, bits[offset + x]);\n        }\n        return row;\n    };\n    /**\n     * @param y row to set\n     * @param row {@link BitArray} to copy from\n     */\n    BitMatrix.prototype.setRow = function (y /*int*/, row) {\n        System_1.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n    };\n    /**\n     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n     */\n    BitMatrix.prototype.rotate180 = function () {\n        var width = this.getWidth();\n        var height = this.getHeight();\n        var topRow = new BitArray_1.default(width);\n        var bottomRow = new BitArray_1.default(width);\n        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {\n            topRow = this.getRow(i, topRow);\n            bottomRow = this.getRow(height - 1 - i, bottomRow);\n            topRow.reverse();\n            bottomRow.reverse();\n            this.setRow(i, bottomRow);\n            this.setRow(height - 1 - i, topRow);\n        }\n    };\n    /**\n     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n     *\n     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n     */\n    BitMatrix.prototype.getEnclosingRectangle = function () {\n        var width = this.width;\n        var height = this.height;\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var left = width;\n        var top = height;\n        var right = -1;\n        var bottom = -1;\n        for (var y = 0; y < height; y++) {\n            for (var x32 = 0; x32 < rowSize; x32++) {\n                var theBits = bits[y * rowSize + x32];\n                if (theBits !== 0) {\n                    if (y < top) {\n                        top = y;\n                    }\n                    if (y > bottom) {\n                        bottom = y;\n                    }\n                    if (x32 * 32 < left) {\n                        var bit = 0;\n                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                            bit++;\n                        }\n                        if ((x32 * 32 + bit) < left) {\n                            left = x32 * 32 + bit;\n                        }\n                    }\n                    if (x32 * 32 + 31 > right) {\n                        var bit = 31;\n                        while ((theBits >>> bit) === 0) {\n                            bit--;\n                        }\n                        if ((x32 * 32 + bit) > right) {\n                            right = x32 * 32 + bit;\n                        }\n                    }\n                }\n            }\n        }\n        if (right < left || bottom < top) {\n            return null;\n        }\n        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);\n    };\n    /**\n     * This is useful in detecting a corner of a 'pure' barcode.\n     *\n     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n     */\n    BitMatrix.prototype.getTopLeftOnBit = function () {\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var bitsOffset = 0;\n        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {\n            bitsOffset++;\n        }\n        if (bitsOffset === bits.length) {\n            return null;\n        }\n        var y = bitsOffset / rowSize;\n        var x = (bitsOffset % rowSize) * 32;\n        var theBits = bits[bitsOffset];\n        var bit = 0;\n        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n            bit++;\n        }\n        x += bit;\n        return Int32Array.from([x, y]);\n    };\n    BitMatrix.prototype.getBottomRightOnBit = function () {\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var bitsOffset = bits.length - 1;\n        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {\n            bitsOffset--;\n        }\n        if (bitsOffset < 0) {\n            return null;\n        }\n        var y = Math.floor(bitsOffset / rowSize);\n        var x = Math.floor(bitsOffset % rowSize) * 32;\n        var theBits = bits[bitsOffset];\n        var bit = 31;\n        while ((theBits >>> bit) === 0) {\n            bit--;\n        }\n        x += bit;\n        return Int32Array.from([x, y]);\n    };\n    /**\n     * @return The width of the matrix\n     */\n    BitMatrix.prototype.getWidth = function () {\n        return this.width;\n    };\n    /**\n     * @return The height of the matrix\n     */\n    BitMatrix.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * @return The row size of the matrix\n     */\n    BitMatrix.prototype.getRowSize = function () {\n        return this.rowSize;\n    };\n    /*@Override*/\n    BitMatrix.prototype.equals = function (o) {\n        if (!(o instanceof BitMatrix)) {\n            return false;\n        }\n        var other = o;\n        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&\n            Arrays_1.default.equals(this.bits, other.bits);\n    };\n    /*@Override*/\n    BitMatrix.prototype.hashCode = function () {\n        var hash = this.width;\n        hash = 31 * hash + this.width;\n        hash = 31 * hash + this.height;\n        hash = 31 * hash + this.rowSize;\n        hash = 31 * hash + Arrays_1.default.hashCode(this.bits);\n        return hash;\n    };\n    /**\n     * @return string representation using \"X\" for set and \" \" for unset bits\n     */\n    /*@Override*/\n    // public toString(): string {\n    //   return toString(\": \"X, \"  \")\n    // }\n    /**\n     * @param setString representation of a set bit\n     * @param unsetString representation of an unset bit\n     * @return string representation of entire matrix utilizing given strings\n     */\n    // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n    //   return this.buildToString(setString, unsetString, \"\\n\")\n    // }\n    /**\n     * @param setString representation of a set bit\n     * @param unsetString representation of an unset bit\n     * @param lineSeparator newline character in string representation\n     * @return string representation of entire matrix utilizing given strings and line separator\n     * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n     */\n    // @Deprecated\n    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {\n        if (setString === void 0) { setString = 'X '; }\n        if (unsetString === void 0) { unsetString = '  '; }\n        if (lineSeparator === void 0) { lineSeparator = '\\n'; }\n        return this.buildToString(setString, unsetString, lineSeparator);\n    };\n    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {\n        var result = new StringBuilder_1.default();\n        // result.append(lineSeparator);\n        for (var y = 0, height = this.height; y < height; y++) {\n            for (var x = 0, width = this.width; x < width; x++) {\n                result.append(this.get(x, y) ? setString : unsetString);\n            }\n            result.append(lineSeparator);\n        }\n        return result.toString();\n    };\n    /*@Override*/\n    BitMatrix.prototype.clone = function () {\n        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n    };\n    return BitMatrix;\n}());\nexports[\"default\"] = BitMatrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vQml0TWF0cml4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQztBQUNyQywwQkFBMEI7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsd0lBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMsd0lBQWdCO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLHNKQUF1QjtBQUNyRCxpQ0FBaUMsbUJBQU8sQ0FBQyxrS0FBNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFELGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0JpdE1hdHJpeC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlzOyovXG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuL0JpdEFycmF5XCIpO1xudmFyIFN5c3RlbV8xID0gcmVxdWlyZShcIi4uL3V0aWwvU3lzdGVtXCIpO1xudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJyYXlzXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xuLyoqXG4gKiA8cD5SZXByZXNlbnRzIGEgMkQgbWF0cml4IG9mIGJpdHMuIEluIGZ1bmN0aW9uIGFyZ3VtZW50cyBiZWxvdywgYW5kIHRocm91Z2hvdXQgdGhlIGNvbW1vblxuICogbW9kdWxlLCB4IGlzIHRoZSBjb2x1bW4gcG9zaXRpb24sIGFuZCB5IGlzIHRoZSByb3cgcG9zaXRpb24uIFRoZSBvcmRlcmluZyBpcyBhbHdheXMgeCwgeS5cbiAqIFRoZSBvcmlnaW4gaXMgYXQgdGhlIHRvcC1sZWZ0LjwvcD5cbiAqXG4gKiA8cD5JbnRlcm5hbGx5IHRoZSBiaXRzIGFyZSByZXByZXNlbnRlZCBpbiBhIDEtRCBhcnJheSBvZiAzMi1iaXQgaW50cy4gSG93ZXZlciwgZWFjaCByb3cgYmVnaW5zXG4gKiB3aXRoIGEgbmV3IGludC4gVGhpcyBpcyBkb25lIGludGVudGlvbmFsbHkgc28gdGhhdCB3ZSBjYW4gY29weSBvdXQgYSByb3cgaW50byBhIEJpdEFycmF5IHZlcnlcbiAqIGVmZmljaWVudGx5LjwvcD5cbiAqXG4gKiA8cD5UaGUgb3JkZXJpbmcgb2YgYml0cyBpcyByb3ctbWFqb3IuIFdpdGhpbiBlYWNoIGludCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgYXJlIHVzZWQgZmlyc3QsXG4gKiBtZWFuaW5nIHRoZXkgcmVwcmVzZW50IGxvd2VyIHggdmFsdWVzLiBUaGlzIGlzIGNvbXBhdGlibGUgd2l0aCBCaXRBcnJheSdzIGltcGxlbWVudGF0aW9uLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqL1xudmFyIEJpdE1hdHJpeCAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBzcXVhcmUge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGhlaWdodCBhbmQgd2lkdGhcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoZGltZW5zaW9uOiBudW1iZXIgLyppbnQqLykge1xuICAgIC8vICAgdGhpcyhkaW1lbnNpb24sIGRpbWVuc2lvbilcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSB7QGxpbmsgQml0TWF0cml4fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aCBiaXQgbWF0cml4IHdpZHRoXG4gICAgICogQHBhcmFtIGhlaWdodCBiaXQgbWF0cml4IGhlaWdodFxuICAgICAqL1xuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAvLyAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkge1xuICAgIC8vICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIilcbiAgICAvLyAgIH1cbiAgICAvLyAgIHRoaXMud2lkdGggPSB3aWR0aFxuICAgIC8vICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAvLyAgIHRoaXMucm93U2l6ZSA9ICh3aWR0aCArIDMxKSAvIDMyXG4gICAgLy8gICBiaXRzID0gbmV3IGludFtyb3dTaXplICogaGVpZ2h0XTtcbiAgICAvLyB9XG4gICAgZnVuY3Rpb24gQml0TWF0cml4KHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCByb3dTaXplIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gaGVpZ2h0IHx8IG51bGwgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0JvdGggZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcm93U2l6ZSB8fCBudWxsID09PSByb3dTaXplKSB7XG4gICAgICAgICAgICByb3dTaXplID0gTWF0aC5mbG9vcigod2lkdGggKyAzMSkgLyAzMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJvd1NpemUgKiB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJwcmV0cyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0sIHdoZXJlIFwidHJ1ZVwiIG1lYW5zIGFuIFwib25cIiBiaXQuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgKiBAcGFyYW0gaW1hZ2UgYml0cyBvZiB0aGUgaW1hZ2UsIGFzIGEgcm93LW1ham9yIDJEIGFycmF5LiBFbGVtZW50cyBhcmUgYXJyYXlzIHJlcHJlc2VudGluZyByb3dzXG4gICAgICogQHJldHVybiB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRhdGlvbiBvZiBpbWFnZVxuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wYXJzZUZyb21Cb29sZWFuQXJyYXkgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmxlbmd0aDtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2VbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbWFnZUkgPSBpbWFnZVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZUlbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoaiwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gcGFyc2VcbiAgICAgKiBAcGFyYW0gc3RyaW5nUmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0gc2V0U3RyaW5nXG4gICAgICogQHBhcmFtIHVuc2V0U3RyaW5nXG4gICAgICovXG4gICAgQml0TWF0cml4LnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdSZXByZXNlbnRhdGlvbiwgc2V0U3RyaW5nLCB1bnNldFN0cmluZykge1xuICAgICAgICBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdzdHJpbmdSZXByZXNlbnRhdGlvbiBjYW5ub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzID0gbmV3IEFycmF5KHN0cmluZ1JlcHJlc2VudGF0aW9uLmxlbmd0aCk7XG4gICAgICAgIHZhciBiaXRzUG9zID0gMDtcbiAgICAgICAgdmFyIHJvd1N0YXJ0UG9zID0gMDtcbiAgICAgICAgdmFyIHJvd0xlbmd0aCA9IC0xO1xuICAgICAgICB2YXIgblJvd3MgPSAwO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHN0cmluZ1JlcHJlc2VudGF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGlmIChiaXRzUG9zID4gcm93U3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ3JvdyBsZW5ndGhzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvd1N0YXJ0UG9zID0gYml0c1BvcztcbiAgICAgICAgICAgICAgICAgICAgblJvd3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zLCBwb3MgKyBzZXRTdHJpbmcubGVuZ3RoKSA9PT0gc2V0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IHNldFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYml0c1BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgdW5zZXRTdHJpbmcubGVuZ3RoKSA9PT0gdW5zZXRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBwb3MgKz0gdW5zZXRTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJpdHNbYml0c1Bvc10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBiaXRzUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnaWxsZWdhbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQ6ICcgKyBzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gRU9MIGF0IGVuZD9cbiAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xuICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByb3dMZW5ndGggPSBiaXRzUG9zIC0gcm93U3RhcnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdyb3cgbGVuZ3RocyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5Sb3dzKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgocm93TGVuZ3RoLCBuUm93cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0c1BvczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYml0c1tpXSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoTWF0aC5mbG9vcihpICUgcm93TGVuZ3RoKSwgTWF0aC5mbG9vcihpIC8gcm93TGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkdldHMgdGhlIHJlcXVlc3RlZCBiaXQsIHdoZXJlIHRydWUgbWVhbnMgYmxhY2suPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcbiAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdylcbiAgICAgKiBAcmV0dXJuIHZhbHVlIG9mIGdpdmVuIGJpdCBpbiBtYXRyaXhcbiAgICAgKi9cbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgcmV0dXJuICgodGhpcy5iaXRzW29mZnNldF0gPj4+ICh4ICYgMHgxZikpICYgMSkgIT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5TZXRzIHRoZSBnaXZlbiBiaXQgdG8gdHJ1ZS48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKVxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICB0aGlzLmJpdHNbb2Zmc2V0XSB8PSAoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkY7XG4gICAgfTtcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICB0aGlzLmJpdHNbb2Zmc2V0XSAmPSB+KCgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5GbGlwcyB0aGUgZ2l2ZW4gYml0LjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICogQHBhcmFtIHkgVGhlIHZlcnRpY2FsIGNvbXBvbmVudCAoaS5lLiB3aGljaCByb3cpXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xuICAgICAgICB0aGlzLmJpdHNbb2Zmc2V0XSBePSAoKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZS1vciAoWE9SKTogRmxpcCB0aGUgYml0IGluIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gaWYgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBtYXNrIGJpdCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFzayBYT1IgbWFza1xuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG1hc2spIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IG1hc2suZ2V0V2lkdGgoKSB8fCB0aGlzLmhlaWdodCAhPT0gbWFzay5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfHwgdGhpcy5yb3dTaXplICE9PSBtYXNrLmdldFJvd1NpemUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2lucHV0IG1hdHJpeCBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dBcnJheSA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMzIpICsgMSk7XG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgICAgIHZhciByb3cgPSBtYXNrLmdldFJvdyh5LCByb3dBcnJheSkuZ2V0Qml0QXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcm93U2l6ZTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyB4XSBePSByb3dbeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgIHZhciBtYXggPSBiaXRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgYml0c1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPlNldHMgYSBzcXVhcmUgcmVnaW9uIG9mIHRoZSBiaXQgbWF0cml4IHRvIHRydWUuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGhvcml6b250YWwgcG9zaXRpb24gdG8gYmVnaW4gYXQgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0gdG9wIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlZ2lvblxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHRvcCA8IDAgfHwgbGVmdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdMZWZ0IGFuZCB0b3AgbXVzdCBiZSBub25uZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCAxIHx8IHdpZHRoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0hlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBhdCBsZWFzdCAxJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgICBpZiAoYm90dG9tID4gdGhpcy5oZWlnaHQgfHwgcmlnaHQgPiB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnVGhlIHJlZ2lvbiBtdXN0IGZpdCBpbnNpZGUgdGhlIG1hdHJpeCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgZm9yICh2YXIgeSA9IHRvcDsgeSA8IGJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gbGVmdDsgeCA8IHJpZ2h0OyB4KyspIHtcbiAgICAgICAgICAgICAgICBiaXRzW29mZnNldCArIE1hdGguZmxvb3IoeCAvIDMyKV0gfD0gKCgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZmFzdCBtZXRob2QgdG8gcmV0cmlldmUgb25lIHJvdyBvZiBkYXRhIGZyb20gdGhlIG1hdHJpeCBhcyBhIEJpdEFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byByZXRyaWV2ZVxuICAgICAqIEBwYXJhbSByb3cgQW4gb3B0aW9uYWwgY2FsbGVyLWFsbG9jYXRlZCBCaXRBcnJheSwgd2lsbCBiZSBhbGxvY2F0ZWQgaWYgbnVsbCBvciB0b28gc21hbGxcbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQml0QXJyYXkgLSB0aGlzIHJlZmVyZW5jZSBzaG91bGQgYWx3YXlzIGJlIHVzZWQgZXZlbiB3aGVuIHBhc3NpbmdcbiAgICAgKiAgICAgICAgIHlvdXIgb3duIHJvd1xuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93LmdldFNpemUoKSA8IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQodGhpcy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3cuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogcm93U2l6ZTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByb3dTaXplOyB4KyspIHtcbiAgICAgICAgICAgIHJvdy5zZXRCdWxrKHggKiAzMiwgYml0c1tvZmZzZXQgKyB4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB5IHJvdyB0byBzZXRcbiAgICAgKiBAcGFyYW0gcm93IHtAbGluayBCaXRBcnJheX0gdG8gY29weSBmcm9tXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkocm93LmdldEJpdEFycmF5KCksIDAsIHRoaXMuYml0cywgeSAqIHRoaXMucm93U2l6ZSwgdGhpcy5yb3dTaXplKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gdG8gcmVwcmVzZW50IHRoZSBzYW1lIGJ1dCByb3RhdGVkIDE4MCBkZWdyZWVzXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5yb3RhdGUxODAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciB0b3BSb3cgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KHdpZHRoKTtcbiAgICAgICAgdmFyIGJvdHRvbVJvdyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQod2lkdGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBNYXRoLmZsb29yKChoZWlnaHQgKyAxKSAvIDIpOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAgICAgdG9wUm93ID0gdGhpcy5nZXRSb3coaSwgdG9wUm93KTtcbiAgICAgICAgICAgIGJvdHRvbVJvdyA9IHRoaXMuZ2V0Um93KGhlaWdodCAtIDEgLSBpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgdG9wUm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIGJvdHRvbVJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFJvdyhpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgdGhpcy5zZXRSb3coaGVpZ2h0IC0gMSAtIGksIHRvcFJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyB0aGUgZW5jbG9zaW5nIHJlY3RhbmdsZSBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QGNvZGUgbGVmdCx0b3Asd2lkdGgsaGVpZ2h0fSBlbmNsb3NpbmcgcmVjdGFuZ2xlIG9mIGFsbCAxIGJpdHMsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRFbmNsb3NpbmdSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICB2YXIgbGVmdCA9IHdpZHRoO1xuICAgICAgICB2YXIgdG9wID0gaGVpZ2h0O1xuICAgICAgICB2YXIgcmlnaHQgPSAtMTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IC0xO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4MzIgPSAwOyB4MzIgPCByb3dTaXplOyB4MzIrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVCaXRzID0gYml0c1t5ICogcm93U2l6ZSArIHgzMl07XG4gICAgICAgICAgICAgICAgaWYgKHRoZUJpdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiBib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHgzMiAqIDMyIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSB4MzIgKiAzMiArIGJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeDMyICogMzIgKyAzMSA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gMzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDMyICogMzIgKyBiaXQpID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHgzMiAqIDMyICsgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IGxlZnQgfHwgYm90dG9tIDwgdG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFtsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCArIDEsIGJvdHRvbSAtIHRvcCArIDFdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyBhIGNvcm5lciBvZiBhICdwdXJlJyBiYXJjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QGNvZGUgeCx5fSBjb29yZGluYXRlIG9mIHRvcC1sZWZ0LW1vc3QgMSBiaXQsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICovXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRUb3BMZWZ0T25CaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgdmFyIGJpdHNPZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAoYml0c09mZnNldCA8IGJpdHMubGVuZ3RoICYmIGJpdHNbYml0c09mZnNldF0gPT09IDApIHtcbiAgICAgICAgICAgIGJpdHNPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0c09mZnNldCA9PT0gYml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gYml0c09mZnNldCAvIHJvd1NpemU7XG4gICAgICAgIHZhciB4ID0gKGJpdHNPZmZzZXQgJSByb3dTaXplKSAqIDMyO1xuICAgICAgICB2YXIgdGhlQml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgIHZhciBiaXQgPSAwO1xuICAgICAgICB3aGlsZSAoKCh0aGVCaXRzIDw8ICgzMSAtIGJpdCkpICYgMHhGRkZGRkZGRikgPT09IDApIHtcbiAgICAgICAgICAgIGJpdCsrO1xuICAgICAgICB9XG4gICAgICAgIHggKz0gYml0O1xuICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFt4LCB5XSk7XG4gICAgfTtcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldEJvdHRvbVJpZ2h0T25CaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgdmFyIGJpdHNPZmZzZXQgPSBiaXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0ID49IDAgJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xuICAgICAgICAgICAgYml0c09mZnNldC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGJpdHNPZmZzZXQgLyByb3dTaXplKTtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGJpdHNPZmZzZXQgJSByb3dTaXplKSAqIDMyO1xuICAgICAgICB2YXIgdGhlQml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgIHZhciBiaXQgPSAzMTtcbiAgICAgICAgd2hpbGUgKCh0aGVCaXRzID4+PiBiaXQpID09PSAwKSB7XG4gICAgICAgICAgICBiaXQtLTtcbiAgICAgICAgfVxuICAgICAgICB4ICs9IGJpdDtcbiAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbeCwgeV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIG1hdHJpeFxuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBtYXRyaXhcbiAgICAgKi9cbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgcm93IHNpemUgb2YgdGhlIG1hdHJpeFxuICAgICAqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0Um93U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93U2l6ZTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCaXRNYXRyaXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyID0gbztcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQgJiYgdGhpcy5yb3dTaXplID09PSBvdGhlci5yb3dTaXplICYmXG4gICAgICAgICAgICBBcnJheXNfMS5kZWZhdWx0LmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpO1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNoID0gdGhpcy53aWR0aDtcbiAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMud2lkdGg7XG4gICAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyB0aGlzLmhlaWdodDtcbiAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMucm93U2l6ZTtcbiAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIEFycmF5c18xLmRlZmF1bHQuaGFzaENvZGUodGhpcy5iaXRzKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2luZyBcIlhcIiBmb3Igc2V0IGFuZCBcIiBcIiBmb3IgdW5zZXQgYml0c1xuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICAvLyBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAvLyAgIHJldHVybiB0b1N0cmluZyhcIjogXCJYLCBcIiAgXCIpXG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XG4gICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdFxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVudGlyZSBtYXRyaXggdXRpbGl6aW5nIGdpdmVuIHN0cmluZ3NcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgdG9TdHJpbmcoc2V0U3RyaW5nOiBzdHJpbmcgPSBcIlggXCIsIHVuc2V0U3RyaW5nOiBzdHJpbmcgPSBcIiAgXCIpOiBzdHJpbmcge1xuICAgIC8vICAgcmV0dXJuIHRoaXMuYnVpbGRUb1N0cmluZyhzZXRTdHJpbmcsIHVuc2V0U3RyaW5nLCBcIlxcblwiKVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc2V0IGJpdFxuICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcbiAgICAgKiBAcGFyYW0gbGluZVNlcGFyYXRvciBuZXdsaW5lIGNoYXJhY3RlciBpbiBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbnRpcmUgbWF0cml4IHV0aWxpemluZyBnaXZlbiBzdHJpbmdzIGFuZCBsaW5lIHNlcGFyYXRvclxuICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rICN0b1N0cmluZyhTdHJpbmcsU3RyaW5nKX0gb25seSwgd2hpY2ggdXNlcyBcXG4gbGluZSBzZXBhcmF0b3IgYWx3YXlzXG4gICAgICovXG4gICAgLy8gQERlcHJlY2F0ZWRcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKHNldFN0cmluZyA9PT0gdm9pZCAwKSB7IHNldFN0cmluZyA9ICdYICc7IH1cbiAgICAgICAgaWYgKHVuc2V0U3RyaW5nID09PSB2b2lkIDApIHsgdW5zZXRTdHJpbmcgPSAnICAnOyB9XG4gICAgICAgIGlmIChsaW5lU2VwYXJhdG9yID09PSB2b2lkIDApIHsgbGluZVNlcGFyYXRvciA9ICdcXG4nOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcik7XG4gICAgfTtcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmJ1aWxkVG9TdHJpbmcgPSBmdW5jdGlvbiAoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8vIHJlc3VsdC5hcHBlbmQobGluZVNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5nZXQoeCwgeSkgPyBzZXRTdHJpbmcgOiB1bnNldFN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpdE1hdHJpeCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yb3dTaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQml0TWF0cml4O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdE1hdHJpeDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n * number of bits read is not often a multiple of 8.</p>\n *\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n * it passed in, in which case all bets are off.</p>\n *\n * @author Sean Owen\n */\nvar BitSource = /** @class */ (function () {\n    /**\n     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n     * Bits are read within a byte from most-significant to least-significant bit.\n     */\n    function BitSource(bytes) {\n        this.bytes = bytes;\n        this.byteOffset = 0;\n        this.bitOffset = 0;\n    }\n    /**\n     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getBitOffset = function () {\n        return this.bitOffset;\n    };\n    /**\n     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getByteOffset = function () {\n        return this.byteOffset;\n    };\n    /**\n     * @param numBits number of bits to read\n     * @return int representing the bits read. The bits will appear as the least-significant\n     *         bits of the int\n     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n     */\n    BitSource.prototype.readBits = function (numBits /*int*/) {\n        if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n            throw new IllegalArgumentException_1.default('' + numBits);\n        }\n        var result = 0;\n        var bitOffset = this.bitOffset;\n        var byteOffset = this.byteOffset;\n        var bytes = this.bytes;\n        // First, read remainder from current byte\n        if (bitOffset > 0) {\n            var bitsLeft = 8 - bitOffset;\n            var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n            var bitsToNotRead = bitsLeft - toRead;\n            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\n            result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n            numBits -= toRead;\n            bitOffset += toRead;\n            if (bitOffset === 8) {\n                bitOffset = 0;\n                byteOffset++;\n            }\n        }\n        // Next read whole bytes\n        if (numBits > 0) {\n            while (numBits >= 8) {\n                result = (result << 8) | (bytes[byteOffset] & 0xFF);\n                byteOffset++;\n                numBits -= 8;\n            }\n            // Finally read a partial byte\n            if (numBits > 0) {\n                var bitsToNotRead = 8 - numBits;\n                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\n                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\n                bitOffset += numBits;\n            }\n        }\n        this.bitOffset = bitOffset;\n        this.byteOffset = byteOffset;\n        return result;\n    };\n    /**\n     * @return number of bits that can be read successfully\n     */\n    BitSource.prototype.available = function () {\n        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n    };\n    return BitSource;\n}());\nexports[\"default\"] = BitSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vQml0U291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQztBQUNyQyxpQ0FBaUMsbUJBQU8sQ0FBQyxrS0FBNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixxQkFBcUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixxQkFBcUI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0JpdFNvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xuLyoqXG4gKiA8cD5UaGlzIHByb3ZpZGVzIGFuIGVhc3kgYWJzdHJhY3Rpb24gdG8gcmVhZCBiaXRzIGF0IGEgdGltZSBmcm9tIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHdoZXJlIHRoZVxuICogbnVtYmVyIG9mIGJpdHMgcmVhZCBpcyBub3Qgb2Z0ZW4gYSBtdWx0aXBsZSBvZiA4LjwvcD5cbiAqXG4gKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50IC0tIHVubGVzcyB0aGUgY2FsbGVyIG1vZGlmaWVzIHRoZSBieXRlcyBhcnJheVxuICogaXQgcGFzc2VkIGluLCBpbiB3aGljaCBjYXNlIGFsbCBiZXRzIGFyZSBvZmYuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBCaXRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGZyb20gd2hpY2ggdGhpcyB3aWxsIHJlYWQgYml0cy4gQml0cyB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgZmlyc3QgYnl0ZSBmaXJzdC5cbiAgICAgKiBCaXRzIGFyZSByZWFkIHdpdGhpbiBhIGJ5dGUgZnJvbSBtb3N0LXNpZ25pZmljYW50IHRvIGxlYXN0LXNpZ25pZmljYW50IGJpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaXRTb3VyY2UoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmJpdE9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBiaXQgaW4gY3VycmVudCBieXRlIHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAqL1xuICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuZ2V0Qml0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRPZmZzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYnl0ZSBpbiBpbnB1dCBieXRlIGFycmF5IHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxuICAgICAqL1xuICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuZ2V0Qnl0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJuIGludCByZXByZXNlbnRpbmcgdGhlIGJpdHMgcmVhZC4gVGhlIGJpdHMgd2lsbCBhcHBlYXIgYXMgdGhlIGxlYXN0LXNpZ25pZmljYW50XG4gICAgICogICAgICAgICBiaXRzIG9mIHRoZSBpbnRcbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBudW1CaXRzIGlzbid0IGluIFsxLDMyXSBvciBtb3JlIHRoYW4gaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgQml0U291cmNlLnByb3RvdHlwZS5yZWFkQml0cyA9IGZ1bmN0aW9uIChudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKG51bUJpdHMgPCAxIHx8IG51bUJpdHMgPiAzMiB8fCBudW1CaXRzID4gdGhpcy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJycgKyBudW1CaXRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgdmFyIGJpdE9mZnNldCA9IHRoaXMuYml0T2Zmc2V0O1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IHRoaXMuYnl0ZU9mZnNldDtcbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcztcbiAgICAgICAgLy8gRmlyc3QsIHJlYWQgcmVtYWluZGVyIGZyb20gY3VycmVudCBieXRlXG4gICAgICAgIGlmIChiaXRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYml0c0xlZnQgPSA4IC0gYml0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHRvUmVhZCA9IG51bUJpdHMgPCBiaXRzTGVmdCA/IG51bUJpdHMgOiBiaXRzTGVmdDtcbiAgICAgICAgICAgIHZhciBiaXRzVG9Ob3RSZWFkID0gYml0c0xlZnQgLSB0b1JlYWQ7XG4gICAgICAgICAgICB2YXIgbWFzayA9ICgweEZGID4+ICg4IC0gdG9SZWFkKSkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgIHJlc3VsdCA9IChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgICAgICBudW1CaXRzIC09IHRvUmVhZDtcbiAgICAgICAgICAgIGJpdE9mZnNldCArPSB0b1JlYWQ7XG4gICAgICAgICAgICBpZiAoYml0T2Zmc2V0ID09PSA4KSB7XG4gICAgICAgICAgICAgICAgYml0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCByZWFkIHdob2xlIGJ5dGVzXG4gICAgICAgIGlmIChudW1CaXRzID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKG51bUJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgfCAoYnl0ZXNbYnl0ZU9mZnNldF0gJiAweEZGKTtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgbnVtQml0cyAtPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSByZWFkIGEgcGFydGlhbCBieXRlXG4gICAgICAgICAgICBpZiAobnVtQml0cyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzO1xuICAgICAgICAgICAgICAgIHZhciBtYXNrID0gKDB4RkYgPj4gYml0c1RvTm90UmVhZCkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IG51bUJpdHMpIHwgKChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQpO1xuICAgICAgICAgICAgICAgIGJpdE9mZnNldCArPSBudW1CaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYml0T2Zmc2V0ID0gYml0T2Zmc2V0O1xuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBiZSByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuYXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gOCAqICh0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMuYnl0ZU9mZnNldCkgLSB0aGlzLmJpdE9mZnNldDtcbiAgICB9O1xuICAgIHJldHVybiBCaXRTb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQml0U291cmNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CharacterSetValueIdentifiers = void 0;\n/*namespace com.google.zxing.common {*/\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n/*import java.util.HashMap;*/\n/*import java.util.Map;*/\nvar CharacterSetValueIdentifiers;\n(function (CharacterSetValueIdentifiers) {\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp437\"] = 0] = \"Cp437\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_1\"] = 1] = \"ISO8859_1\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_2\"] = 2] = \"ISO8859_2\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_3\"] = 3] = \"ISO8859_3\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_4\"] = 4] = \"ISO8859_4\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_5\"] = 5] = \"ISO8859_5\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_6\"] = 6] = \"ISO8859_6\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_7\"] = 7] = \"ISO8859_7\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_8\"] = 8] = \"ISO8859_8\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_9\"] = 9] = \"ISO8859_9\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_10\"] = 10] = \"ISO8859_10\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_11\"] = 11] = \"ISO8859_11\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_13\"] = 12] = \"ISO8859_13\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_14\"] = 13] = \"ISO8859_14\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_15\"] = 14] = \"ISO8859_15\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_16\"] = 15] = \"ISO8859_16\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"SJIS\"] = 16] = \"SJIS\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1250\"] = 17] = \"Cp1250\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1251\"] = 18] = \"Cp1251\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1252\"] = 19] = \"Cp1252\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1256\"] = 20] = \"Cp1256\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UnicodeBigUnmarked\"] = 21] = \"UnicodeBigUnmarked\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UTF8\"] = 22] = \"UTF8\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ASCII\"] = 23] = \"ASCII\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Big5\"] = 24] = \"Big5\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"GB18030\"] = 25] = \"GB18030\";\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"EUC_KR\"] = 26] = \"EUC_KR\";\n})(CharacterSetValueIdentifiers = exports.CharacterSetValueIdentifiers || (exports.CharacterSetValueIdentifiers = {}));\n/**\n * Encapsulates a Character Set ECI, according to \"Extended Channel Interpretations\" 5.3.1.1\n * of ISO 18004.\n *\n * @author Sean Owen\n */\nvar CharacterSetECI = /** @class */ (function () {\n    function CharacterSetECI(valueIdentifier, valuesParam, name) {\n        var e_1, _a;\n        var otherEncodingNames = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            otherEncodingNames[_i - 3] = arguments[_i];\n        }\n        this.valueIdentifier = valueIdentifier;\n        this.name = name;\n        if (typeof valuesParam === 'number') {\n            this.values = Int32Array.from([valuesParam]);\n        }\n        else {\n            this.values = valuesParam;\n        }\n        this.otherEncodingNames = otherEncodingNames;\n        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);\n        CharacterSetECI.NAME_TO_ECI.set(name, this);\n        var values = this.values;\n        for (var i = 0, length_1 = values.length; i !== length_1; i++) {\n            var v = values[i];\n            CharacterSetECI.VALUES_TO_ECI.set(v, this);\n        }\n        try {\n            for (var otherEncodingNames_1 = __values(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {\n                var otherName = otherEncodingNames_1_1.value;\n                CharacterSetECI.NAME_TO_ECI.set(otherName, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return)) _a.call(otherEncodingNames_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    // CharacterSetECI(value: number /*int*/) {\n    //   this(new Int32Array {value})\n    // }\n    // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {\n    //   this.values = new Int32Array {value}\n    //   this.otherEncodingNames = otherEncodingNames\n    // }\n    // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {\n    //   this.values = values\n    //   this.otherEncodingNames = otherEncodingNames\n    // }\n    CharacterSetECI.prototype.getValueIdentifier = function () {\n        return this.valueIdentifier;\n    };\n    CharacterSetECI.prototype.getName = function () {\n        return this.name;\n    };\n    CharacterSetECI.prototype.getValue = function () {\n        return this.values[0];\n    };\n    /**\n     * @param value character set ECI value\n     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but\n     *   unsupported\n     * @throws FormatException if ECI value is invalid\n     */\n    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {\n        if (value < 0 || value >= 900) {\n            throw new FormatException_1.default('incorect value');\n        }\n        var characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);\n        if (undefined === characterSet) {\n            throw new FormatException_1.default('incorect value');\n        }\n        return characterSet;\n    };\n    /**\n     * @param name character set ECI encoding name\n     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal\n     *   but unsupported\n     */\n    CharacterSetECI.getCharacterSetECIByName = function (name) {\n        var characterSet = CharacterSetECI.NAME_TO_ECI.get(name);\n        if (undefined === characterSet) {\n            throw new FormatException_1.default('incorect value');\n        }\n        return characterSet;\n    };\n    CharacterSetECI.prototype.equals = function (o) {\n        if (!(o instanceof CharacterSetECI)) {\n            return false;\n        }\n        var other = o;\n        return this.getName() === other.getName();\n    };\n    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();\n    CharacterSetECI.VALUES_TO_ECI = new Map();\n    CharacterSetECI.NAME_TO_ECI = new Map();\n    // Enum name is a Java encoding valid for java.lang and java.io\n    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java\n    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)\n    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default\n    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');\n    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');\n    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');\n    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');\n    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');\n    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');\n    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');\n    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');\n    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');\n    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');\n    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');\n    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');\n    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');\n    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');\n    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');\n    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');\n    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');\n    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');\n    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');\n    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');\n    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');\n    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');\n    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');\n    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');\n    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');\n    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');\n    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');\n    return CharacterSetECI;\n}());\nexports[\"default\"] = CharacterSetECI;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsZ0pBQW9CO0FBQ3BELDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFLG9DQUFvQyxLQUFLO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSw4QkFBOEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHZvaWQgMDtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbi8qaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwOyovXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG52YXIgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycztcbihmdW5jdGlvbiAoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycykge1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwNDM3XCJdID0gMF0gPSBcIkNwNDM3XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xXCJdID0gMV0gPSBcIklTTzg4NTlfMVwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMlwiXSA9IDJdID0gXCJJU084ODU5XzJcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzNcIl0gPSAzXSA9IFwiSVNPODg1OV8zXCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV80XCJdID0gNF0gPSBcIklTTzg4NTlfNFwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfNVwiXSA9IDVdID0gXCJJU084ODU5XzVcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzZcIl0gPSA2XSA9IFwiSVNPODg1OV82XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV83XCJdID0gN10gPSBcIklTTzg4NTlfN1wiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfOFwiXSA9IDhdID0gXCJJU084ODU5XzhcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzlcIl0gPSA5XSA9IFwiSVNPODg1OV85XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xMFwiXSA9IDEwXSA9IFwiSVNPODg1OV8xMFwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTFcIl0gPSAxMV0gPSBcIklTTzg4NTlfMTFcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzEzXCJdID0gMTJdID0gXCJJU084ODU5XzEzXCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNFwiXSA9IDEzXSA9IFwiSVNPODg1OV8xNFwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTVcIl0gPSAxNF0gPSBcIklTTzg4NTlfMTVcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzE2XCJdID0gMTVdID0gXCJJU084ODU5XzE2XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiU0pJU1wiXSA9IDE2XSA9IFwiU0pJU1wiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MFwiXSA9IDE3XSA9IFwiQ3AxMjUwXCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUxXCJdID0gMThdID0gXCJDcDEyNTFcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJDcDEyNTJcIl0gPSAxOV0gPSBcIkNwMTI1MlwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1NlwiXSA9IDIwXSA9IFwiQ3AxMjU2XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiVW5pY29kZUJpZ1VubWFya2VkXCJdID0gMjFdID0gXCJVbmljb2RlQmlnVW5tYXJrZWRcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJVVEY4XCJdID0gMjJdID0gXCJVVEY4XCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQVNDSUlcIl0gPSAyM10gPSBcIkFTQ0lJXCI7XG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQmlnNVwiXSA9IDI0XSA9IFwiQmlnNVwiO1xuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkdCMTgwMzBcIl0gPSAyNV0gPSBcIkdCMTgwMzBcIjtcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJFVUNfS1JcIl0gPSAyNl0gPSBcIkVVQ19LUlwiO1xufSkoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IGV4cG9ydHMuQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyB8fCAoZXhwb3J0cy5DaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzID0ge30pKTtcbi8qKlxuICogRW5jYXBzdWxhdGVzIGEgQ2hhcmFjdGVyIFNldCBFQ0ksIGFjY29yZGluZyB0byBcIkV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25zXCIgNS4zLjEuMVxuICogb2YgSVNPIDE4MDA0LlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBDaGFyYWN0ZXJTZXRFQ0kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlSWRlbnRpZmllciwgdmFsdWVzUGFyYW0sIG5hbWUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBvdGhlckVuY29kaW5nTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG90aGVyRW5jb2RpbmdOYW1lc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlSWRlbnRpZmllciA9IHZhbHVlSWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNQYXJhbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gSW50MzJBcnJheS5mcm9tKFt2YWx1ZXNQYXJhbV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lcztcbiAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJLnNldCh2YWx1ZUlkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG5hbWUsIHRoaXMpO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuc2V0KHYsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvdGhlckVuY29kaW5nTmFtZXNfMSA9IF9fdmFsdWVzKG90aGVyRW5jb2RpbmdOYW1lcyksIG90aGVyRW5jb2RpbmdOYW1lc18xXzEgPSBvdGhlckVuY29kaW5nTmFtZXNfMS5uZXh0KCk7ICFvdGhlckVuY29kaW5nTmFtZXNfMV8xLmRvbmU7IG90aGVyRW5jb2RpbmdOYW1lc18xXzEgPSBvdGhlckVuY29kaW5nTmFtZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJOYW1lID0gb3RoZXJFbmNvZGluZ05hbWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG90aGVyTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvdGhlckVuY29kaW5nTmFtZXNfMV8xICYmICFvdGhlckVuY29kaW5nTmFtZXNfMV8xLmRvbmUgJiYgKF9hID0gb3RoZXJFbmNvZGluZ05hbWVzXzEucmV0dXJuKSkgX2EuY2FsbChvdGhlckVuY29kaW5nTmFtZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlOiBudW1iZXIgLyppbnQqLykge1xuICAgIC8vICAgdGhpcyhuZXcgSW50MzJBcnJheSB7dmFsdWV9KVxuICAgIC8vIH1cbiAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovLCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgLy8gICB0aGlzLnZhbHVlcyA9IG5ldyBJbnQzMkFycmF5IHt2YWx1ZX1cbiAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXG4gICAgLy8gfVxuICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZXM6IEludDMyQXJyYXksIFN0cmluZy4uLiBvdGhlckVuY29kaW5nTmFtZXMpIHtcbiAgICAvLyAgIHRoaXMudmFsdWVzID0gdmFsdWVzXG4gICAgLy8gICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lc1xuICAgIC8vIH1cbiAgICBDaGFyYWN0ZXJTZXRFQ0kucHJvdG90eXBlLmdldFZhbHVlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJZGVudGlmaWVyO1xuICAgIH07XG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH07XG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlIGNoYXJhY3RlciBzZXQgRUNJIHZhbHVlXG4gICAgICogQHJldHVybiB7QGNvZGUgQ2hhcmFjdGVyU2V0RUNJfSByZXByZXNlbnRpbmcgRUNJIG9mIGdpdmVuIHZhbHVlLCBvciBudWxsIGlmIGl0IGlzIGxlZ2FsIGJ1dFxuICAgICAqICAgdW5zdXBwb3J0ZWRcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBFQ0kgdmFsdWUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA5MDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyYWN0ZXJTZXQgPSBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSS5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmFtZSBjaGFyYWN0ZXIgc2V0IEVDSSBlbmNvZGluZyBuYW1lXG4gICAgICogQHJldHVybiBDaGFyYWN0ZXJTZXRFQ0kgcmVwcmVzZW50aW5nIEVDSSBmb3IgY2hhcmFjdGVyIGVuY29kaW5nLCBvciBudWxsIGlmIGl0IGlzIGxlZ2FsXG4gICAgICogICBidXQgdW5zdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSS5nZXQobmFtZSk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2luY29yZWN0IHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlclNldDtcbiAgICB9O1xuICAgIENoYXJhY3RlclNldEVDSS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIENoYXJhY3RlclNldEVDSSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYW1lKCkgPT09IG90aGVyLmdldE5hbWUoKTtcbiAgICB9O1xuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kgPSBuZXcgTWFwKCk7XG4gICAgLy8gRW51bSBuYW1lIGlzIGEgSmF2YSBlbmNvZGluZyB2YWxpZCBmb3IgamF2YS5sYW5nIGFuZCBqYXZhLmlvXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdGhlIG1haW4gbGFiZWwgZm9yIElTTyBhcyB0aGUgVGV4dEVuY29kZXIgZGlkIG5vdCByZWNvZ25pemVkIHRoZW0gaW4gdGhlIGZvcm0gZnJvbSBqYXZhXG4gICAgLy8gKGVnIElTTzg4NTlfMSBtdXN0IGJlIElTTzg4NTkxIG9yIElTTzg4NTktMSBvciBJU08tODg1OS0xKVxuICAgIC8vIGxhdGVyIG9uOiB3ZWxsLCBleGNlcHQgMTYgd2ljaCBkb2VzIG5vdCB3b3JrIHdpdGggSVNPODg1OTE2IHNvIHVzZWQgSVNPLTg4NTktMSBmb3JtIGZvciBkZWZhdWx0XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwNDM3ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwNDM3LCBJbnQzMkFycmF5LmZyb20oWzAsIDJdKSwgJ0NwNDM3Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEsIEludDMyQXJyYXkuZnJvbShbMSwgM10pLCAnSVNPLTg4NTktMScsICdJU084ODU5MScsICdJU084ODU5XzEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8yID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMiwgNCwgJ0lTTy04ODU5LTInLCAnSVNPODg1OTInLCAnSVNPODg1OV8yJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzMsIDUsICdJU08tODg1OS0zJywgJ0lTTzg4NTkzJywgJ0lTTzg4NTlfMycpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV80LCA2LCAnSVNPLTg4NTktNCcsICdJU084ODU5NCcsICdJU084ODU5XzQnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV81ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNSwgNywgJ0lTTy04ODU5LTUnLCAnSVNPODg1OTUnLCAnSVNPODg1OV81Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzYsIDgsICdJU08tODg1OS02JywgJ0lTTzg4NTk2JywgJ0lTTzg4NTlfNicpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV83LCA5LCAnSVNPLTg4NTktNycsICdJU084ODU5NycsICdJU084ODU5XzcnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV84ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfOCwgMTAsICdJU08tODg1OS04JywgJ0lTTzg4NTk4JywgJ0lTTzg4NTlfOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzkgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV85LCAxMSwgJ0lTTy04ODU5LTknLCAnSVNPODg1OTknLCAnSVNPODg1OV85Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMCwgMTIsICdJU08tODg1OS0xMCcsICdJU084ODU5MTAnLCAnSVNPODg1OV8xMCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzExID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTEsIDEzLCAnSVNPLTg4NTktMTEnLCAnSVNPODg1OTExJywgJ0lTTzg4NTlfMTEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEzLCAxNSwgJ0lTTy04ODU5LTEzJywgJ0lTTzg4NTkxMycsICdJU084ODU5XzEzJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNCwgMTYsICdJU08tODg1OS0xNCcsICdJU084ODU5MTQnLCAnSVNPODg1OV8xNCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTUsIDE3LCAnSVNPLTg4NTktMTUnLCAnSVNPODg1OTE1JywgJ0lTTzg4NTlfMTUnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE2LCAxOCwgJ0lTTy04ODU5LTE2JywgJ0lTTzg4NTkxNicsICdJU084ODU5XzE2Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlNKSVMgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuU0pJUywgMjAsICdTSklTJywgJ1NoaWZ0X0pJUycpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUwLCAyMSwgJ0NwMTI1MCcsICd3aW5kb3dzLTEyNTAnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUxID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MSwgMjIsICdDcDEyNTEnLCAnd2luZG93cy0xMjUxJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTIsIDIzLCAnQ3AxMjUyJywgJ3dpbmRvd3MtMTI1MicpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjU2LCAyNCwgJ0NwMTI1NicsICd3aW5kb3dzLTEyNTYnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVuaWNvZGVCaWdVbm1hcmtlZCwgMjUsICdVbmljb2RlQmlnVW5tYXJrZWQnLCAnVVRGLTE2QkUnLCAnVW5pY29kZUJpZycpO1xuICAgIENoYXJhY3RlclNldEVDSS5VVEY4ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVURjgsIDI2LCAnVVRGOCcsICdVVEYtOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5BU0NJSSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5BU0NJSSwgSW50MzJBcnJheS5mcm9tKFsyNywgMTcwXSksICdBU0NJSScsICdVUy1BU0NJSScpO1xuICAgIENoYXJhY3RlclNldEVDSS5CaWc1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkJpZzUsIDI4LCAnQmlnNScpO1xuICAgIENoYXJhY3RlclNldEVDSS5HQjE4MDMwID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkdCMTgwMzAsIDI5LCAnR0IxODAzMCcsICdHQjIzMTInLCAnRVVDX0NOJywgJ0dCSycpO1xuICAgIENoYXJhY3RlclNldEVDSS5FVUNfS1IgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuRVVDX0tSLCAzMCwgJ0VVQ19LUicsICdFVUMtS1InKTtcbiAgICByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXJhY3RlclNldEVDSTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\n/*import java.util.List;*/\n/**\n * <p>Encapsulates the result of decoding a matrix of bits. This typically\n * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n * as well as a String interpretation of those bytes, if applicable.</p>\n *\n * @author Sean Owen\n */\nvar DecoderResult = /** @class */ (function () {\n    // public constructor(rawBytes: Uint8Array,\n    //                      text: string,\n    //                      List<Uint8Array> byteSegments,\n    //                      String ecLevel) {\n    //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n    // }\n    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {\n        if (structuredAppendSequenceNumber === void 0) { structuredAppendSequenceNumber = -1; }\n        if (structuredAppendParity === void 0) { structuredAppendParity = -1; }\n        this.rawBytes = rawBytes;\n        this.text = text;\n        this.byteSegments = byteSegments;\n        this.ecLevel = ecLevel;\n        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n        this.structuredAppendParity = structuredAppendParity;\n        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;\n    }\n    /**\n     * @return raw bytes representing the result, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getRawBytes = function () {\n        return this.rawBytes;\n    };\n    /**\n     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n     * @since 3.3.0\n     */\n    DecoderResult.prototype.getNumBits = function () {\n        return this.numBits;\n    };\n    /**\n     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n     * @since 3.3.0\n     */\n    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {\n        this.numBits = numBits;\n    };\n    /**\n     * @return text representation of the result\n     */\n    DecoderResult.prototype.getText = function () {\n        return this.text;\n    };\n    /**\n     * @return list of byte segments in the result, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getByteSegments = function () {\n        return this.byteSegments;\n    };\n    /**\n     * @return name of error correction level used, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getECLevel = function () {\n        return this.ecLevel;\n    };\n    /**\n     * @return number of errors corrected, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getErrorsCorrected = function () {\n        return this.errorsCorrected;\n    };\n    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {\n        this.errorsCorrected = errorsCorrected;\n    };\n    /**\n     * @return number of erasures corrected, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getErasures = function () {\n        return this.erasures;\n    };\n    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {\n        this.erasures = erasures;\n    };\n    /**\n     * @return arbitrary additional metadata\n     */\n    DecoderResult.prototype.getOther = function () {\n        return this.other;\n    };\n    DecoderResult.prototype.setOther = function (other) {\n        this.other = other;\n    };\n    DecoderResult.prototype.hasStructuredAppend = function () {\n        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n    };\n    DecoderResult.prototype.getStructuredAppendParity = function () {\n        return this.structuredAppendParity;\n    };\n    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {\n        return this.structuredAppendSequenceNumber;\n    };\n    return DecoderResult;\n}());\nexports[\"default\"] = DecoderResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vRGVjb2RlclJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUM7QUFDckMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0IsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vRGVjb2RlclJlc3VsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4vKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHJlc3VsdCBvZiBkZWNvZGluZyBhIG1hdHJpeCBvZiBiaXRzLiBUaGlzIHR5cGljYWxseVxuICogYXBwbGllcyB0byAyRCBiYXJjb2RlIGZvcm1hdHMuIEZvciBub3cgaXQgY29udGFpbnMgdGhlIHJhdyBieXRlcyBvYnRhaW5lZCxcbiAqIGFzIHdlbGwgYXMgYSBTdHJpbmcgaW50ZXJwcmV0YXRpb24gb2YgdGhvc2UgYnl0ZXMsIGlmIGFwcGxpY2FibGUuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBEZWNvZGVyUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihyYXdCeXRlczogVWludDhBcnJheSxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdHJpbmcsXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgTGlzdDxVaW50OEFycmF5PiBieXRlU2VnbWVudHMsXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgU3RyaW5nIGVjTGV2ZWwpIHtcbiAgICAvLyAgIHRoaXMocmF3Qnl0ZXMsIHRleHQsIGJ5dGVTZWdtZW50cywgZWNMZXZlbCwgLTEsIC0xKVxuICAgIC8vIH1cbiAgICBmdW5jdGlvbiBEZWNvZGVyUmVzdWx0KHJhd0J5dGVzLCB0ZXh0LCBieXRlU2VnbWVudHMsIGVjTGV2ZWwsIHN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciwgc3RydWN0dXJlZEFwcGVuZFBhcml0eSkge1xuICAgICAgICBpZiAoc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID09PSB2b2lkIDApIHsgc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gLTE7IH1cbiAgICAgICAgaWYgKHN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPT09IHZvaWQgMCkgeyBzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID0gLTE7IH1cbiAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmJ5dGVTZWdtZW50cyA9IGJ5dGVTZWdtZW50cztcbiAgICAgICAgdGhpcy5lY0xldmVsID0gZWNMZXZlbDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IHN0cnVjdHVyZWRBcHBlbmRQYXJpdHk7XG4gICAgICAgIHRoaXMubnVtQml0cyA9IChyYXdCeXRlcyA9PT0gdW5kZWZpbmVkIHx8IHJhd0J5dGVzID09PSBudWxsKSA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0UmF3Qnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBob3cgbWFueSBiaXRzIG9mIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0gYXJlIHZhbGlkOyB0eXBpY2FsbHkgOCB0aW1lcyBpdHMgbGVuZ3RoXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICovXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0TnVtQml0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1CaXRzIG92ZXJyaWRlcyB0aGUgbnVtYmVyIG9mIGJpdHMgdGhhdCBhcmUgdmFsaWQgaW4ge0BsaW5rICNnZXRSYXdCeXRlcygpfVxuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqL1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLnNldE51bUJpdHMgPSBmdW5jdGlvbiAobnVtQml0cyAvKmludCovKSB7XG4gICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGxpc3Qgb2YgYnl0ZSBzZWdtZW50cyBpbiB0aGUgcmVzdWx0LCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRCeXRlU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVTZWdtZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbmFtZSBvZiBlcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldEVDTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcnJvcnMgY29ycmVjdGVkLCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRFcnJvcnNDb3JyZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yc0NvcnJlY3RlZDtcbiAgICB9O1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLnNldEVycm9yc0NvcnJlY3RlZCA9IGZ1bmN0aW9uIChlcnJvcnNDb3JyZWN0ZWQgLypJbnRlZ2VyKi8pIHtcbiAgICAgICAgdGhpcy5lcnJvcnNDb3JyZWN0ZWQgPSBlcnJvcnNDb3JyZWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcmFzdXJlcyBjb3JyZWN0ZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldEVyYXN1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcmFzdXJlcztcbiAgICB9O1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLnNldEVyYXN1cmVzID0gZnVuY3Rpb24gKGVyYXN1cmVzIC8qSW50ZWdlciovKSB7XG4gICAgICAgIHRoaXMuZXJhc3VyZXMgPSBlcmFzdXJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYXJiaXRyYXJ5IGFkZGl0aW9uYWwgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRPdGhlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3RoZXI7XG4gICAgfTtcbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5zZXRPdGhlciA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgfTtcbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5oYXNTdHJ1Y3R1cmVkQXBwZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID49IDAgJiYgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPj0gMDtcbiAgICB9O1xuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldFN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHk7XG4gICAgfTtcbiAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRTdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcjtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVyUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZXJSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\nvar GridSampler_1 = __webpack_require__(/*! ./GridSampler */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSampler.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar PerspectiveTransform_1 = __webpack_require__(/*! ./PerspectiveTransform */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * @author Sean Owen\n */\nvar DefaultGridSampler = /** @class */ (function (_super) {\n    __extends(DefaultGridSampler, _super);\n    function DefaultGridSampler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /*@Override*/\n    DefaultGridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {\n        var transform = PerspectiveTransform_1.default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);\n    };\n    /*@Override*/\n    DefaultGridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) {\n        if (dimensionX <= 0 || dimensionY <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        var bits = new BitMatrix_1.default(dimensionX, dimensionY);\n        var points = new Float32Array(2 * dimensionX);\n        for (var y = 0; y < dimensionY; y++) {\n            var max = points.length;\n            var iValue = y + 0.5;\n            for (var x = 0; x < max; x += 2) {\n                points[x] = (x / 2) + 0.5;\n                points[x + 1] = iValue;\n            }\n            transform.transformPoints(points);\n            // Quick check to see if points transformed to something inside the image\n            // sufficient to check the endpoints\n            GridSampler_1.default.checkAndNudgePoints(image, points);\n            try {\n                for (var x = 0; x < max; x += 2) {\n                    if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {\n                        // Black(-ish) pixel\n                        bits.set(x / 2, y);\n                    }\n                }\n            }\n            catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {\n                // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n                // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n                // whose endpoints are in bounds, but others are not. There is probably some mathematical\n                // way to detect this about the transformation that I don't know yet.\n                // This results in an ugly runtime exception despite our clever checks above -- can't have\n                // that. We could check each point's coordinates but that feels duplicative. We settle for\n                // catching and wrapping ArrayIndexOutOfBoundsException.\n                throw new NotFoundException_1.default();\n            }\n        }\n        return bits;\n    };\n    return DefaultGridSampler;\n}(GridSampler_1.default));\nexports[\"default\"] = DefaultGridSampler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vRGVmYXVsdEdyaWRTYW1wbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLDhJQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDBJQUFhO0FBQ3ZDLDZCQUE2QixtQkFBTyxDQUFDLGdLQUF3QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2NvbW1vbi9EZWZhdWx0R3JpZFNhbXBsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG52YXIgR3JpZFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL0dyaWRTYW1wbGVyXCIpO1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4vQml0TWF0cml4XCIpO1xudmFyIFBlcnNwZWN0aXZlVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9QZXJzcGVjdGl2ZVRyYW5zZm9ybVwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgRGVmYXVsdEdyaWRTYW1wbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZhdWx0R3JpZFNhbXBsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEdyaWRTYW1wbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBEZWZhdWx0R3JpZFNhbXBsZXIucHJvdG90eXBlLnNhbXBsZUdyaWQgPSBmdW5jdGlvbiAoaW1hZ2UsIGRpbWVuc2lvblggLyppbnQqLywgZGltZW5zaW9uWSAvKmludCovLCBwMVRvWCAvKmZsb2F0Ki8sIHAxVG9ZIC8qZmxvYXQqLywgcDJUb1ggLypmbG9hdCovLCBwMlRvWSAvKmZsb2F0Ki8sIHAzVG9YIC8qZmxvYXQqLywgcDNUb1kgLypmbG9hdCovLCBwNFRvWCAvKmZsb2F0Ki8sIHA0VG9ZIC8qZmxvYXQqLywgcDFGcm9tWCAvKmZsb2F0Ki8sIHAxRnJvbVkgLypmbG9hdCovLCBwMkZyb21YIC8qZmxvYXQqLywgcDJGcm9tWSAvKmZsb2F0Ki8sIHAzRnJvbVggLypmbG9hdCovLCBwM0Zyb21ZIC8qZmxvYXQqLywgcDRGcm9tWCAvKmZsb2F0Ki8sIHA0RnJvbVkgLypmbG9hdCovKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xLmRlZmF1bHQucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgdHJhbnNmb3JtKTtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBEZWZhdWx0R3JpZFNhbXBsZXIucHJvdG90eXBlLnNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtID0gZnVuY3Rpb24gKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgdHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChkaW1lbnNpb25YIDw9IDAgfHwgZGltZW5zaW9uWSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdHMgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChkaW1lbnNpb25YLCBkaW1lbnNpb25ZKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGRpbWVuc2lvblgpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGRpbWVuc2lvblk7IHkrKykge1xuICAgICAgICAgICAgdmFyIG1heCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaVZhbHVlID0geSArIDAuNTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbeF0gPSAoeCAvIDIpICsgMC41O1xuICAgICAgICAgICAgICAgIHBvaW50c1t4ICsgMV0gPSBpVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtUG9pbnRzKHBvaW50cyk7XG4gICAgICAgICAgICAvLyBRdWljayBjaGVjayB0byBzZWUgaWYgcG9pbnRzIHRyYW5zZm9ybWVkIHRvIHNvbWV0aGluZyBpbnNpZGUgdGhlIGltYWdlXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRvIGNoZWNrIHRoZSBlbmRwb2ludHNcbiAgICAgICAgICAgIEdyaWRTYW1wbGVyXzEuZGVmYXVsdC5jaGVja0FuZE51ZGdlUG9pbnRzKGltYWdlLCBwb2ludHMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoTWF0aC5mbG9vcihwb2ludHNbeF0pLCBNYXRoLmZsb29yKHBvaW50c1t4ICsgMV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2soLWlzaCkgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHggLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChhaW9vYmUgLyo6IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmZWVscyB3cm9uZywgYnV0LCBzb21ldGltZXMgaWYgdGhlIGZpbmRlciBwYXR0ZXJucyBhcmUgbWlzaWRlbnRpZmllZCwgdGhlIHJlc3VsdGluZ1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBnZXRzIFwidHdpc3RlZFwiIHN1Y2ggdGhhdCBpdCBtYXBzIGEgc3RyYWlnaHQgbGluZSBvZiBwb2ludHMgdG8gYSBzZXQgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gd2hvc2UgZW5kcG9pbnRzIGFyZSBpbiBib3VuZHMsIGJ1dCBvdGhlcnMgYXJlIG5vdC4gVGhlcmUgaXMgcHJvYmFibHkgc29tZSBtYXRoZW1hdGljYWxcbiAgICAgICAgICAgICAgICAvLyB3YXkgdG8gZGV0ZWN0IHRoaXMgYWJvdXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgSSBkb24ndCBrbm93IHlldC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gYW4gdWdseSBydW50aW1lIGV4Y2VwdGlvbiBkZXNwaXRlIG91ciBjbGV2ZXIgY2hlY2tzIGFib3ZlIC0tIGNhbid0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyB0aGF0LiBXZSBjb3VsZCBjaGVjayBlYWNoIHBvaW50J3MgY29vcmRpbmF0ZXMgYnV0IHRoYXQgZmVlbHMgZHVwbGljYXRpdmUuIFdlIHNldHRsZSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjYXRjaGluZyBhbmQgd3JhcHBpbmcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0R3JpZFNhbXBsZXI7XG59KEdyaWRTYW1wbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmYXVsdEdyaWRTYW1wbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw\n * matrix of black/white pixels corresponding to the barcode, and possibly points of interest\n * in the image, like the location of finder patterns or corners of the barcode in the image.</p>\n *\n * @author Sean Owen\n */\nvar DetectorResult = /** @class */ (function () {\n    function DetectorResult(bits, points) {\n        this.bits = bits;\n        this.points = points;\n    }\n    DetectorResult.prototype.getBits = function () {\n        return this.bits;\n    };\n    DetectorResult.prototype.getPoints = function () {\n        return this.points;\n    };\n    return DetectorResult;\n}());\nexports[\"default\"] = DetectorResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vRGV0ZWN0b3JSZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0RldGVjdG9yUmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRldGVjdGluZyBhIGJhcmNvZGUgaW4gYW4gaW1hZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIHJhd1xuICogbWF0cml4IG9mIGJsYWNrL3doaXRlIHBpeGVscyBjb3JyZXNwb25kaW5nIHRvIHRoZSBiYXJjb2RlLCBhbmQgcG9zc2libHkgcG9pbnRzIG9mIGludGVyZXN0XG4gKiBpbiB0aGUgaW1hZ2UsIGxpa2UgdGhlIGxvY2F0aW9uIG9mIGZpbmRlciBwYXR0ZXJucyBvciBjb3JuZXJzIG9mIHRoZSBiYXJjb2RlIGluIHRoZSBpbWFnZS48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIERldGVjdG9yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldGVjdG9yUmVzdWx0KGJpdHMsIHBvaW50cykge1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB9XG4gICAgRGV0ZWN0b3JSZXN1bHQucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgfTtcbiAgICBEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgfTtcbiAgICByZXR1cm4gRGV0ZWN0b3JSZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0b3JSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Set of CharsetEncoders for a given input string\n *\n * Invariants:\n * - The list contains only encoders from CharacterSetECI (list is shorter then the list of encoders available on\n *   the platform for which ECI values are defined).\n * - The list contains encoders at least one encoder for every character in the input.\n * - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded\n *       by it.\n * - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the\n *   UTF-8 encoder and the UTF-16BE encoder.\n *\n * @author Alex Geller\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ECIEncoderSet = void 0;\nvar Charset_1 = __webpack_require__(/*! ../util/Charset */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js\");\nvar StandardCharsets_1 = __webpack_require__(/*! ../util/StandardCharsets */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\nvar StringUtils_1 = __webpack_require__(/*! ./StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar CharsetEncoder = /** @class */ (function () {\n    function CharsetEncoder(charset) {\n        this.charset = charset;\n        this.name = charset.name;\n    }\n    CharsetEncoder.prototype.canEncode = function (c) {\n        try {\n            return StringEncoding_1.default.encode(c, this.charset) != null;\n        }\n        catch (ex) {\n            return false;\n        }\n    };\n    return CharsetEncoder;\n}());\nvar ECIEncoderSet = /** @class */ (function () {\n    /**\n     * Constructs an encoder set\n     *\n     * @param stringToEncode the string that needs to be encoded\n     * @param priorityCharset The preferred {@link Charset} or null.\n     * @param fnc1 fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar\n     * code. When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().\n     */\n    function ECIEncoderSet(stringToEncode, priorityCharset, fnc1) {\n        var e_1, _a, e_2, _b, e_3, _c;\n        this.ENCODERS = [\n            'IBM437',\n            'ISO-8859-2',\n            'ISO-8859-3',\n            'ISO-8859-4',\n            'ISO-8859-5',\n            'ISO-8859-6',\n            'ISO-8859-7',\n            'ISO-8859-8',\n            'ISO-8859-9',\n            'ISO-8859-10',\n            'ISO-8859-11',\n            'ISO-8859-13',\n            'ISO-8859-14',\n            'ISO-8859-15',\n            'ISO-8859-16',\n            'windows-1250',\n            'windows-1251',\n            'windows-1252',\n            'windows-1256',\n            'Shift_JIS',\n        ].map(function (name) { return new CharsetEncoder(Charset_1.default.forName(name)); });\n        this.encoders = [];\n        var neededEncoders = [];\n        // we always need the ISO-8859-1 encoder. It is the default encoding\n        neededEncoders.push(new CharsetEncoder(StandardCharsets_1.default.ISO_8859_1));\n        var needUnicodeEncoder = priorityCharset != null && priorityCharset.name.startsWith('UTF');\n        // Walk over the input string and see if all characters can be encoded with the list of encoders\n        for (var i = 0; i < stringToEncode.length; i++) {\n            var canEncode = false;\n            try {\n                for (var neededEncoders_1 = (e_1 = void 0, __values(neededEncoders)), neededEncoders_1_1 = neededEncoders_1.next(); !neededEncoders_1_1.done; neededEncoders_1_1 = neededEncoders_1.next()) {\n                    var encoder = neededEncoders_1_1.value;\n                    var singleCharacter = stringToEncode.charAt(i);\n                    var c = singleCharacter.charCodeAt(0);\n                    if (c === fnc1 || encoder.canEncode(singleCharacter)) {\n                        canEncode = true;\n                        break;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (neededEncoders_1_1 && !neededEncoders_1_1.done && (_a = neededEncoders_1.return)) _a.call(neededEncoders_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (!canEncode) {\n                try {\n                    // for the character at position i we don't yet have an encoder in the list\n                    for (var _d = (e_2 = void 0, __values(this.ENCODERS)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var encoder = _e.value;\n                        if (encoder.canEncode(stringToEncode.charAt(i))) {\n                            // Good, we found an encoder that can encode the character. We add him to the list and continue scanning\n                            // the input\n                            neededEncoders.push(encoder);\n                            canEncode = true;\n                            break;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (!canEncode) {\n                // The character is not encodeable by any of the single byte encoders so we remember that we will need a\n                // Unicode encoder.\n                needUnicodeEncoder = true;\n            }\n        }\n        if (neededEncoders.length === 1 && !needUnicodeEncoder) {\n            // the entire input can be encoded by the ISO-8859-1 encoder\n            this.encoders = [neededEncoders[0]];\n        }\n        else {\n            // we need more than one single byte encoder or we need a Unicode encoder.\n            // In this case we append a UTF-8 and UTF-16 encoder to the list\n            this.encoders = [];\n            var index = 0;\n            try {\n                for (var neededEncoders_2 = __values(neededEncoders), neededEncoders_2_1 = neededEncoders_2.next(); !neededEncoders_2_1.done; neededEncoders_2_1 = neededEncoders_2.next()) {\n                    var encoder = neededEncoders_2_1.value;\n                    this.encoders[index++] = encoder;\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (neededEncoders_2_1 && !neededEncoders_2_1.done && (_c = neededEncoders_2.return)) _c.call(neededEncoders_2);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            // this.encoders[index] = new CharsetEncoder(StandardCharsets.UTF_8);\n            // this.encoders[index + 1] = new CharsetEncoder(StandardCharsets.UTF_16BE);\n        }\n        // Compute priorityEncoderIndex by looking up priorityCharset in encoders\n        var priorityEncoderIndexValue = -1;\n        if (priorityCharset != null) {\n            for (var i = 0; i < this.encoders.length; i++) {\n                if (this.encoders[i] != null &&\n                    priorityCharset.name === this.encoders[i].name) {\n                    priorityEncoderIndexValue = i;\n                    break;\n                }\n            }\n        }\n        this.priorityEncoderIndex = priorityEncoderIndexValue;\n        // invariants\n        // if(this?.encoders?.[0].name !== StandardCharsets.ISO_8859_1)){\n        // throw new Error(\"ISO-8859-1 must be the first encoder\");\n        // }\n    }\n    ECIEncoderSet.prototype.length = function () {\n        return this.encoders.length;\n    };\n    ECIEncoderSet.prototype.getCharsetName = function (index) {\n        if (!(index < this.length())) {\n            throw new Error('index must be less than length');\n        }\n        return this.encoders[index].name;\n    };\n    ECIEncoderSet.prototype.getCharset = function (index) {\n        if (!(index < this.length())) {\n            throw new Error('index must be less than length');\n        }\n        return this.encoders[index].charset;\n    };\n    ECIEncoderSet.prototype.getECIValue = function (encoderIndex) {\n        return this.encoders[encoderIndex].charset.getValueIdentifier();\n    };\n    /*\n     *  returns -1 if no priority charset was defined\n     */\n    ECIEncoderSet.prototype.getPriorityEncoderIndex = function () {\n        return this.priorityEncoderIndex;\n    };\n    ECIEncoderSet.prototype.canEncode = function (c, encoderIndex) {\n        if (!(encoderIndex < this.length())) {\n            throw new Error('index must be less than length');\n        }\n        return true;\n    };\n    ECIEncoderSet.prototype.encode = function (c, encoderIndex) {\n        if (!(encoderIndex < this.length())) {\n            throw new Error('index must be less than length');\n        }\n        return StringEncoding_1.default.encode(StringUtils_1.default.getCharAt(c), this.encoders[encoderIndex].name);\n    };\n    return ECIEncoderSet;\n}());\nexports.ECIEncoderSet = ECIEncoderSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vRUNJRW5jb2RlclNldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGdCQUFnQixtQkFBTyxDQUFDLDBJQUFpQjtBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyw0SkFBMEI7QUFDM0QsdUJBQXVCLG1CQUFPLENBQUMsd0pBQXdCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLDhJQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLG9JQUFvSSwwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsVUFBVTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCwwQkFBMEI7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0VDSUVuY29kZXJTZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFNldCBvZiBDaGFyc2V0RW5jb2RlcnMgZm9yIGEgZ2l2ZW4gaW5wdXQgc3RyaW5nXG4gKlxuICogSW52YXJpYW50czpcbiAqIC0gVGhlIGxpc3QgY29udGFpbnMgb25seSBlbmNvZGVycyBmcm9tIENoYXJhY3RlclNldEVDSSAobGlzdCBpcyBzaG9ydGVyIHRoZW4gdGhlIGxpc3Qgb2YgZW5jb2RlcnMgYXZhaWxhYmxlIG9uXG4gKiAgIHRoZSBwbGF0Zm9ybSBmb3Igd2hpY2ggRUNJIHZhbHVlcyBhcmUgZGVmaW5lZCkuXG4gKiAtIFRoZSBsaXN0IGNvbnRhaW5zIGVuY29kZXJzIGF0IGxlYXN0IG9uZSBlbmNvZGVyIGZvciBldmVyeSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LlxuICogLSBUaGUgZmlyc3QgZW5jb2RlciBpbiB0aGUgbGlzdCBpcyBhbHdheXMgdGhlIElTTy04ODU5LTEgZW5jb2RlciBldmVuIG9mIG5vIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgY2FuIGJlIGVuY29kZWRcbiAqICAgICAgIGJ5IGl0LlxuICogLSBJZiB0aGUgaW5wdXQgY29udGFpbnMgYSBjaGFyYWN0ZXIgdGhhdCBpcyBub3QgaW4gSVNPLTg4NTktMSB0aGVuIHRoZSBsYXN0IHR3byBlbnRyaWVzIGluIHRoZSBsaXN0IHdpbGwgYmUgdGhlXG4gKiAgIFVURi04IGVuY29kZXIgYW5kIHRoZSBVVEYtMTZCRSBlbmNvZGVyLlxuICpcbiAqIEBhdXRob3IgQWxleCBHZWxsZXJcbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FQ0lFbmNvZGVyU2V0ID0gdm9pZCAwO1xudmFyIENoYXJzZXRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJzZXRcIik7XG52YXIgU3RhbmRhcmRDaGFyc2V0c18xID0gcmVxdWlyZShcIi4uL3V0aWwvU3RhbmRhcmRDaGFyc2V0c1wiKTtcbnZhciBTdHJpbmdFbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL3V0aWwvU3RyaW5nRW5jb2RpbmdcIik7XG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ1V0aWxzXCIpO1xudmFyIENoYXJzZXRFbmNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJzZXRFbmNvZGVyKGNoYXJzZXQpIHtcbiAgICAgICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbiAgICAgICAgdGhpcy5uYW1lID0gY2hhcnNldC5uYW1lO1xuICAgIH1cbiAgICBDaGFyc2V0RW5jb2Rlci5wcm90b3R5cGUuY2FuRW5jb2RlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZW5jb2RlKGMsIHRoaXMuY2hhcnNldCkgIT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENoYXJzZXRFbmNvZGVyO1xufSgpKTtcbnZhciBFQ0lFbmNvZGVyU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gZW5jb2RlciBzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmdUb0VuY29kZSB0aGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZFxuICAgICAqIEBwYXJhbSBwcmlvcml0eUNoYXJzZXQgVGhlIHByZWZlcnJlZCB7QGxpbmsgQ2hhcnNldH0gb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gZm5jMSBmbmMxIGRlbm90ZXMgdGhlIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdGhhdCByZXByZXNlbnRzIHRoZSBGTkMxIGNoYXJhY3RlciBvciAtMSBmb3IgYSBub24tR1MxIGJhclxuICAgICAqIGNvZGUuIFdoZW4gc3BlY2lmaWVkLCBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yIHRvIHBhc3MgaXQgYXMgYXJndW1lbnQgdG8gdGhlIG1ldGhvZHMgY2FuRW5jb2RlKCkgb3IgZW5jb2RlKCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRUNJRW5jb2RlclNldChzdHJpbmdUb0VuY29kZSwgcHJpb3JpdHlDaGFyc2V0LCBmbmMxKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jO1xuICAgICAgICB0aGlzLkVOQ09ERVJTID0gW1xuICAgICAgICAgICAgJ0lCTTQzNycsXG4gICAgICAgICAgICAnSVNPLTg4NTktMicsXG4gICAgICAgICAgICAnSVNPLTg4NTktMycsXG4gICAgICAgICAgICAnSVNPLTg4NTktNCcsXG4gICAgICAgICAgICAnSVNPLTg4NTktNScsXG4gICAgICAgICAgICAnSVNPLTg4NTktNicsXG4gICAgICAgICAgICAnSVNPLTg4NTktNycsXG4gICAgICAgICAgICAnSVNPLTg4NTktOCcsXG4gICAgICAgICAgICAnSVNPLTg4NTktOScsXG4gICAgICAgICAgICAnSVNPLTg4NTktMTAnLFxuICAgICAgICAgICAgJ0lTTy04ODU5LTExJyxcbiAgICAgICAgICAgICdJU08tODg1OS0xMycsXG4gICAgICAgICAgICAnSVNPLTg4NTktMTQnLFxuICAgICAgICAgICAgJ0lTTy04ODU5LTE1JyxcbiAgICAgICAgICAgICdJU08tODg1OS0xNicsXG4gICAgICAgICAgICAnd2luZG93cy0xMjUwJyxcbiAgICAgICAgICAgICd3aW5kb3dzLTEyNTEnLFxuICAgICAgICAgICAgJ3dpbmRvd3MtMTI1MicsXG4gICAgICAgICAgICAnd2luZG93cy0xMjU2JyxcbiAgICAgICAgICAgICdTaGlmdF9KSVMnLFxuICAgICAgICBdLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV3IENoYXJzZXRFbmNvZGVyKENoYXJzZXRfMS5kZWZhdWx0LmZvck5hbWUobmFtZSkpOyB9KTtcbiAgICAgICAgdGhpcy5lbmNvZGVycyA9IFtdO1xuICAgICAgICB2YXIgbmVlZGVkRW5jb2RlcnMgPSBbXTtcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgdGhlIElTTy04ODU5LTEgZW5jb2Rlci4gSXQgaXMgdGhlIGRlZmF1bHQgZW5jb2RpbmdcbiAgICAgICAgbmVlZGVkRW5jb2RlcnMucHVzaChuZXcgQ2hhcnNldEVuY29kZXIoU3RhbmRhcmRDaGFyc2V0c18xLmRlZmF1bHQuSVNPXzg4NTlfMSkpO1xuICAgICAgICB2YXIgbmVlZFVuaWNvZGVFbmNvZGVyID0gcHJpb3JpdHlDaGFyc2V0ICE9IG51bGwgJiYgcHJpb3JpdHlDaGFyc2V0Lm5hbWUuc3RhcnRzV2l0aCgnVVRGJyk7XG4gICAgICAgIC8vIFdhbGsgb3ZlciB0aGUgaW5wdXQgc3RyaW5nIGFuZCBzZWUgaWYgYWxsIGNoYXJhY3RlcnMgY2FuIGJlIGVuY29kZWQgd2l0aCB0aGUgbGlzdCBvZiBlbmNvZGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1RvRW5jb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FuRW5jb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5lZWRlZEVuY29kZXJzXzEgPSAoZV8xID0gdm9pZCAwLCBfX3ZhbHVlcyhuZWVkZWRFbmNvZGVycykpLCBuZWVkZWRFbmNvZGVyc18xXzEgPSBuZWVkZWRFbmNvZGVyc18xLm5leHQoKTsgIW5lZWRlZEVuY29kZXJzXzFfMS5kb25lOyBuZWVkZWRFbmNvZGVyc18xXzEgPSBuZWVkZWRFbmNvZGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlciA9IG5lZWRlZEVuY29kZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpbmdsZUNoYXJhY3RlciA9IHN0cmluZ1RvRW5jb2RlLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBzaW5nbGVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGZuYzEgfHwgZW5jb2Rlci5jYW5FbmNvZGUoc2luZ2xlQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuRW5jb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkZWRFbmNvZGVyc18xXzEgJiYgIW5lZWRlZEVuY29kZXJzXzFfMS5kb25lICYmIChfYSA9IG5lZWRlZEVuY29kZXJzXzEucmV0dXJuKSkgX2EuY2FsbChuZWVkZWRFbmNvZGVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW5FbmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBpIHdlIGRvbid0IHlldCBoYXZlIGFuIGVuY29kZXIgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyh0aGlzLkVOQ09ERVJTKSksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVyID0gX2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlci5jYW5FbmNvZGUoc3RyaW5nVG9FbmNvZGUuY2hhckF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2QsIHdlIGZvdW5kIGFuIGVuY29kZXIgdGhhdCBjYW4gZW5jb2RlIHRoZSBjaGFyYWN0ZXIuIFdlIGFkZCBoaW0gdG8gdGhlIGxpc3QgYW5kIGNvbnRpbnVlIHNjYW5uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGVkRW5jb2RlcnMucHVzaChlbmNvZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5FbmNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9iID0gX2QucmV0dXJuKSkgX2IuY2FsbChfZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuRW5jb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBpcyBub3QgZW5jb2RlYWJsZSBieSBhbnkgb2YgdGhlIHNpbmdsZSBieXRlIGVuY29kZXJzIHNvIHdlIHJlbWVtYmVyIHRoYXQgd2Ugd2lsbCBuZWVkIGFcbiAgICAgICAgICAgICAgICAvLyBVbmljb2RlIGVuY29kZXIuXG4gICAgICAgICAgICAgICAgbmVlZFVuaWNvZGVFbmNvZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZGVkRW5jb2RlcnMubGVuZ3RoID09PSAxICYmICFuZWVkVW5pY29kZUVuY29kZXIpIHtcbiAgICAgICAgICAgIC8vIHRoZSBlbnRpcmUgaW5wdXQgY2FuIGJlIGVuY29kZWQgYnkgdGhlIElTTy04ODU5LTEgZW5jb2RlclxuICAgICAgICAgICAgdGhpcy5lbmNvZGVycyA9IFtuZWVkZWRFbmNvZGVyc1swXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIG1vcmUgdGhhbiBvbmUgc2luZ2xlIGJ5dGUgZW5jb2RlciBvciB3ZSBuZWVkIGEgVW5pY29kZSBlbmNvZGVyLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGFwcGVuZCBhIFVURi04IGFuZCBVVEYtMTYgZW5jb2RlciB0byB0aGUgbGlzdFxuICAgICAgICAgICAgdGhpcy5lbmNvZGVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmVlZGVkRW5jb2RlcnNfMiA9IF9fdmFsdWVzKG5lZWRlZEVuY29kZXJzKSwgbmVlZGVkRW5jb2RlcnNfMl8xID0gbmVlZGVkRW5jb2RlcnNfMi5uZXh0KCk7ICFuZWVkZWRFbmNvZGVyc18yXzEuZG9uZTsgbmVlZGVkRW5jb2RlcnNfMl8xID0gbmVlZGVkRW5jb2RlcnNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZXIgPSBuZWVkZWRFbmNvZGVyc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlcnNbaW5kZXgrK10gPSBlbmNvZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZGVkRW5jb2RlcnNfMl8xICYmICFuZWVkZWRFbmNvZGVyc18yXzEuZG9uZSAmJiAoX2MgPSBuZWVkZWRFbmNvZGVyc18yLnJldHVybikpIF9jLmNhbGwobmVlZGVkRW5jb2RlcnNfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMuZW5jb2RlcnNbaW5kZXhdID0gbmV3IENoYXJzZXRFbmNvZGVyKFN0YW5kYXJkQ2hhcnNldHMuVVRGXzgpO1xuICAgICAgICAgICAgLy8gdGhpcy5lbmNvZGVyc1tpbmRleCArIDFdID0gbmV3IENoYXJzZXRFbmNvZGVyKFN0YW5kYXJkQ2hhcnNldHMuVVRGXzE2QkUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgcHJpb3JpdHlFbmNvZGVySW5kZXggYnkgbG9va2luZyB1cCBwcmlvcml0eUNoYXJzZXQgaW4gZW5jb2RlcnNcbiAgICAgICAgdmFyIHByaW9yaXR5RW5jb2RlckluZGV4VmFsdWUgPSAtMTtcbiAgICAgICAgaWYgKHByaW9yaXR5Q2hhcnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW5jb2RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmNvZGVyc1tpXSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5Q2hhcnNldC5uYW1lID09PSB0aGlzLmVuY29kZXJzW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlFbmNvZGVySW5kZXhWYWx1ZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW9yaXR5RW5jb2RlckluZGV4ID0gcHJpb3JpdHlFbmNvZGVySW5kZXhWYWx1ZTtcbiAgICAgICAgLy8gaW52YXJpYW50c1xuICAgICAgICAvLyBpZih0aGlzPy5lbmNvZGVycz8uWzBdLm5hbWUgIT09IFN0YW5kYXJkQ2hhcnNldHMuSVNPXzg4NTlfMSkpe1xuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJJU08tODg1OS0xIG11c3QgYmUgdGhlIGZpcnN0IGVuY29kZXJcIik7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgRUNJRW5jb2RlclNldC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVycy5sZW5ndGg7XG4gICAgfTtcbiAgICBFQ0lFbmNvZGVyU2V0LnByb3RvdHlwZS5nZXRDaGFyc2V0TmFtZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoIShpbmRleCA8IHRoaXMubGVuZ3RoKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IG11c3QgYmUgbGVzcyB0aGFuIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXJzW2luZGV4XS5uYW1lO1xuICAgIH07XG4gICAgRUNJRW5jb2RlclNldC5wcm90b3R5cGUuZ2V0Q2hhcnNldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoIShpbmRleCA8IHRoaXMubGVuZ3RoKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IG11c3QgYmUgbGVzcyB0aGFuIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXJzW2luZGV4XS5jaGFyc2V0O1xuICAgIH07XG4gICAgRUNJRW5jb2RlclNldC5wcm90b3R5cGUuZ2V0RUNJVmFsdWUgPSBmdW5jdGlvbiAoZW5jb2RlckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXJzW2VuY29kZXJJbmRleF0uY2hhcnNldC5nZXRWYWx1ZUlkZW50aWZpZXIoKTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogIHJldHVybnMgLTEgaWYgbm8gcHJpb3JpdHkgY2hhcnNldCB3YXMgZGVmaW5lZFxuICAgICAqL1xuICAgIEVDSUVuY29kZXJTZXQucHJvdG90eXBlLmdldFByaW9yaXR5RW5jb2RlckluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eUVuY29kZXJJbmRleDtcbiAgICB9O1xuICAgIEVDSUVuY29kZXJTZXQucHJvdG90eXBlLmNhbkVuY29kZSA9IGZ1bmN0aW9uIChjLCBlbmNvZGVySW5kZXgpIHtcbiAgICAgICAgaWYgKCEoZW5jb2RlckluZGV4IDwgdGhpcy5sZW5ndGgoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5kZXggbXVzdCBiZSBsZXNzIHRoYW4gbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFQ0lFbmNvZGVyU2V0LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoYywgZW5jb2RlckluZGV4KSB7XG4gICAgICAgIGlmICghKGVuY29kZXJJbmRleCA8IHRoaXMubGVuZ3RoKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IG11c3QgYmUgbGVzcyB0aGFuIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZW5jb2RlKFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQXQoYyksIHRoaXMuZW5jb2RlcnNbZW5jb2RlckluZGV4XS5uYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBFQ0lFbmNvZGVyU2V0O1xufSgpKTtcbmV4cG9ydHMuRUNJRW5jb2RlclNldCA9IEVDSUVuY29kZXJTZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js":
/*!***************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js ***!
  \***************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\nvar Binarizer_1 = __webpack_require__(/*! ../Binarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Binarizer.js\");\nvar BitArray_1 = __webpack_require__(/*! ./BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar GlobalHistogramBinarizer = /** @class */ (function (_super) {\n    __extends(GlobalHistogramBinarizer, _super);\n    function GlobalHistogramBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.luminances = GlobalHistogramBinarizer.EMPTY;\n        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        return _this;\n    }\n    // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        if (row === undefined || row === null || row.getSize() < width) {\n            row = new BitArray_1.default(width);\n        }\n        else {\n            row.clear();\n        }\n        this.initArrays(width);\n        var localLuminances = source.getRow(y, this.luminances);\n        var localBuckets = this.buckets;\n        for (var x = 0; x < width; x++) {\n            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        if (width < 3) {\n            // Special case for very small images\n            for (var x = 0; x < width; x++) {\n                if ((localLuminances[x] & 0xff) < blackPoint) {\n                    row.set(x);\n                }\n            }\n        }\n        else {\n            var left = localLuminances[0] & 0xff;\n            var center = localLuminances[1] & 0xff;\n            for (var x = 1; x < width - 1; x++) {\n                var right = localLuminances[x + 1] & 0xff;\n                // A simple -1 4 -1 box filter with a weight of 2.\n                if (((center * 4) - left - right) / 2 < blackPoint) {\n                    row.set(x);\n                }\n                left = center;\n                center = right;\n            }\n        }\n        return row;\n    };\n    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        var matrix = new BitMatrix_1.default(width, height);\n        // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n        // more robust on the blackbox tests than sampling a diagonal as we used to do.\n        this.initArrays(width);\n        var localBuckets = this.buckets;\n        for (var y = 1; y < 5; y++) {\n            var row = Math.floor((height * y) / 5);\n            var localLuminances_1 = source.getRow(row, this.luminances);\n            var right = Math.floor((width * 4) / 5);\n            for (var x = Math.floor(width / 5); x < right; x++) {\n                var pixel = localLuminances_1[x] & 0xff;\n                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        // We delay reading the entire image luminance until the black point estimation succeeds.\n        // Although we end up reading four rows twice, it is consistent with our motto of\n        // \"fail quickly\" which is necessary for continuous scanning.\n        var localLuminances = source.getMatrix();\n        for (var y = 0; y < height; y++) {\n            var offset = y * width;\n            for (var x = 0; x < width; x++) {\n                var pixel = localLuminances[offset + x] & 0xff;\n                if (pixel < blackPoint) {\n                    matrix.set(x, y);\n                }\n            }\n        }\n        return matrix;\n    };\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n        return new GlobalHistogramBinarizer(source);\n    };\n    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\n        if (this.luminances.length < luminanceSize) {\n            this.luminances = new Uint8ClampedArray(luminanceSize);\n        }\n        var buckets = this.buckets;\n        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n            buckets[x] = 0;\n        }\n    };\n    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n        // Find the tallest peak in the histogram.\n        var numBuckets = buckets.length;\n        var maxBucketCount = 0;\n        var firstPeak = 0;\n        var firstPeakSize = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            if (buckets[x] > firstPeakSize) {\n                firstPeak = x;\n                firstPeakSize = buckets[x];\n            }\n            if (buckets[x] > maxBucketCount) {\n                maxBucketCount = buckets[x];\n            }\n        }\n        // Find the second-tallest peak which is somewhat far from the tallest peak.\n        var secondPeak = 0;\n        var secondPeakScore = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            var distanceToBiggest = x - firstPeak;\n            // Encourage more distant second peaks by multiplying by square of distance.\n            var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n            if (score > secondPeakScore) {\n                secondPeak = x;\n                secondPeakScore = score;\n            }\n        }\n        // Make sure firstPeak corresponds to the black peak.\n        if (firstPeak > secondPeak) {\n            var temp = firstPeak;\n            firstPeak = secondPeak;\n            secondPeak = temp;\n        }\n        // If there is too little contrast in the image to pick a meaningful black point, throw rather\n        // than waste time trying to decode the image, and risk false positives.\n        if (secondPeak - firstPeak <= numBuckets / 16) {\n            throw new NotFoundException_1.default();\n        }\n        // Find a valley between them that is low and closer to the white peak.\n        var bestValley = secondPeak - 1;\n        var bestValleyScore = -1;\n        for (var x = secondPeak - 1; x > firstPeak; x--) {\n            var fromFirst = x - firstPeak;\n            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n            if (score > bestValleyScore) {\n                bestValley = x;\n                bestValleyScore = score;\n            }\n        }\n        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n    };\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n    return GlobalHistogramBinarizer;\n}(Binarizer_1.default));\nexports[\"default\"] = GlobalHistogramBinarizer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG9JQUFjO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLHdJQUFZO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLDBJQUFhO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xudmFyIEJpbmFyaXplcl8xID0gcmVxdWlyZShcIi4uL0JpbmFyaXplclwiKTtcbnZhciBCaXRBcnJheV8xID0gcmVxdWlyZShcIi4vQml0QXJyYXlcIik7XG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi9CaXRNYXRyaXhcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbi8qKlxuICogVGhpcyBCaW5hcml6ZXIgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgb2xkIFpYaW5nIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guIEl0IGlzIHN1aXRhYmxlXG4gKiBmb3IgbG93LWVuZCBtb2JpbGUgZGV2aWNlcyB3aGljaCBkb24ndCBoYXZlIGVub3VnaCBDUFUgb3IgbWVtb3J5IHRvIHVzZSBhIGxvY2FsIHRocmVzaG9sZGluZ1xuICogYWxnb3JpdGhtLiBIb3dldmVyLCBiZWNhdXNlIGl0IHBpY2tzIGEgZ2xvYmFsIGJsYWNrIHBvaW50LCBpdCBjYW5ub3QgaGFuZGxlIGRpZmZpY3VsdCBzaGFkb3dzXG4gKiBhbmQgZ3JhZGllbnRzLlxuICpcbiAqIEZhc3RlciBtb2JpbGUgZGV2aWNlcyBhbmQgYWxsIGRlc2t0b3AgYXBwbGljYXRpb25zIHNob3VsZCBwcm9iYWJseSB1c2UgSHlicmlkQmluYXJpemVyIGluc3RlYWQuXG4gKlxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNvdXJjZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubHVtaW5hbmNlcyA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5FTVBUWTtcbiAgICAgICAgX3RoaXMuYnVja2V0cyA9IG5ldyBJbnQzMkFycmF5KEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gQXBwbGllcyBzaW1wbGUgc2hhcnBlbmluZyB0byB0aGUgcm93IGRhdGEgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBvZiB0aGUgMUQgUmVhZGVycy5cbiAgICAvKkBPdmVycmlkZSovXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5nZXRCbGFja1JvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IG51bGwgfHwgcm93LmdldFNpemUoKSA8IHdpZHRoKSB7XG4gICAgICAgICAgICByb3cgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvdy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEFycmF5cyh3aWR0aCk7XG4gICAgICAgIHZhciBsb2NhbEx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0Um93KHksIHRoaXMubHVtaW5hbmNlcyk7XG4gICAgICAgIHZhciBsb2NhbEJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgbG9jYWxCdWNrZXRzWyhsb2NhbEx1bWluYW5jZXNbeF0gJiAweGZmKSA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibGFja1BvaW50ID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludChsb2NhbEJ1Y2tldHMpO1xuICAgICAgICBpZiAod2lkdGggPCAzKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHZlcnkgc21hbGwgaW1hZ2VzXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmYpIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG9jYWxMdW1pbmFuY2VzWzBdICYgMHhmZjtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBsb2NhbEx1bWluYW5jZXNbMV0gJiAweGZmO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB3aWR0aCAtIDE7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGxvY2FsTHVtaW5hbmNlc1t4ICsgMV0gJiAweGZmO1xuICAgICAgICAgICAgICAgIC8vIEEgc2ltcGxlIC0xIDQgLTEgYm94IGZpbHRlciB3aXRoIGEgd2VpZ2h0IG9mIDIuXG4gICAgICAgICAgICAgICAgaWYgKCgoY2VudGVyICogNCkgLSBsZWZ0IC0gcmlnaHQpIC8gMiA8IGJsYWNrUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnNldCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH07XG4gICAgLy8gRG9lcyBub3Qgc2hhcnBlbiB0aGUgZGF0YSwgYXMgdGhpcyBjYWxsIGlzIGludGVuZGVkIHRvIG9ubHkgYmUgdXNlZCBieSAyRCBSZWFkZXJzLlxuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIucHJvdG90eXBlLmdldEJsYWNrTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gUXVpY2tseSBjYWxjdWxhdGVzIHRoZSBoaXN0b2dyYW0gYnkgc2FtcGxpbmcgZm91ciByb3dzIGZyb20gdGhlIGltYWdlLiBUaGlzIHByb3ZlZCB0byBiZVxuICAgICAgICAvLyBtb3JlIHJvYnVzdCBvbiB0aGUgYmxhY2tib3ggdGVzdHMgdGhhbiBzYW1wbGluZyBhIGRpYWdvbmFsIGFzIHdlIHVzZWQgdG8gZG8uXG4gICAgICAgIHRoaXMuaW5pdEFycmF5cyh3aWR0aCk7XG4gICAgICAgIHZhciBsb2NhbEJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XG4gICAgICAgIGZvciAodmFyIHkgPSAxOyB5IDwgNTsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcigoaGVpZ2h0ICogeSkgLyA1KTtcbiAgICAgICAgICAgIHZhciBsb2NhbEx1bWluYW5jZXNfMSA9IHNvdXJjZS5nZXRSb3cocm93LCB0aGlzLmx1bWluYW5jZXMpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5mbG9vcigod2lkdGggKiA0KSAvIDUpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IE1hdGguZmxvb3Iod2lkdGggLyA1KTsgeCA8IHJpZ2h0OyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBsb2NhbEx1bWluYW5jZXNfMVt4XSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgbG9jYWxCdWNrZXRzW3BpeGVsID4+IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlRdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG4gICAgICAgIC8vIFdlIGRlbGF5IHJlYWRpbmcgdGhlIGVudGlyZSBpbWFnZSBsdW1pbmFuY2UgdW50aWwgdGhlIGJsYWNrIHBvaW50IGVzdGltYXRpb24gc3VjY2VlZHMuXG4gICAgICAgIC8vIEFsdGhvdWdoIHdlIGVuZCB1cCByZWFkaW5nIGZvdXIgcm93cyB0d2ljZSwgaXQgaXMgY29uc2lzdGVudCB3aXRoIG91ciBtb3R0byBvZlxuICAgICAgICAvLyBcImZhaWwgcXVpY2tseVwiIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgY29udGludW91cyBzY2FubmluZy5cbiAgICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGxvY2FsTHVtaW5hbmNlc1tvZmZzZXQgKyB4XSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5wcm90b3R5cGUuY3JlYXRlQmluYXJpemVyID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcihzb3VyY2UpO1xuICAgIH07XG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5pbml0QXJyYXlzID0gZnVuY3Rpb24gKGx1bWluYW5jZVNpemUgLyppbnQqLykge1xuICAgICAgICBpZiAodGhpcy5sdW1pbmFuY2VzLmxlbmd0aCA8IGx1bWluYW5jZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubHVtaW5hbmNlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsdW1pbmFuY2VTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVja2V0cyA9IHRoaXMuYnVja2V0cztcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFM7IHgrKykge1xuICAgICAgICAgICAgYnVja2V0c1t4XSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5lc3RpbWF0ZUJsYWNrUG9pbnQgPSBmdW5jdGlvbiAoYnVja2V0cykge1xuICAgICAgICAvLyBGaW5kIHRoZSB0YWxsZXN0IHBlYWsgaW4gdGhlIGhpc3RvZ3JhbS5cbiAgICAgICAgdmFyIG51bUJ1Y2tldHMgPSBidWNrZXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heEJ1Y2tldENvdW50ID0gMDtcbiAgICAgICAgdmFyIGZpcnN0UGVhayA9IDA7XG4gICAgICAgIHZhciBmaXJzdFBlYWtTaXplID0gMDtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBudW1CdWNrZXRzOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChidWNrZXRzW3hdID4gZmlyc3RQZWFrU2l6ZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UGVhayA9IHg7XG4gICAgICAgICAgICAgICAgZmlyc3RQZWFrU2l6ZSA9IGJ1Y2tldHNbeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVja2V0c1t4XSA+IG1heEJ1Y2tldENvdW50KSB7XG4gICAgICAgICAgICAgICAgbWF4QnVja2V0Q291bnQgPSBidWNrZXRzW3hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIHNlY29uZC10YWxsZXN0IHBlYWsgd2hpY2ggaXMgc29tZXdoYXQgZmFyIGZyb20gdGhlIHRhbGxlc3QgcGVhay5cbiAgICAgICAgdmFyIHNlY29uZFBlYWsgPSAwO1xuICAgICAgICB2YXIgc2Vjb25kUGVha1Njb3JlID0gMDtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBudW1CdWNrZXRzOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVRvQmlnZ2VzdCA9IHggLSBmaXJzdFBlYWs7XG4gICAgICAgICAgICAvLyBFbmNvdXJhZ2UgbW9yZSBkaXN0YW50IHNlY29uZCBwZWFrcyBieSBtdWx0aXBseWluZyBieSBzcXVhcmUgb2YgZGlzdGFuY2UuXG4gICAgICAgICAgICB2YXIgc2NvcmUgPSBidWNrZXRzW3hdICogZGlzdGFuY2VUb0JpZ2dlc3QgKiBkaXN0YW5jZVRvQmlnZ2VzdDtcbiAgICAgICAgICAgIGlmIChzY29yZSA+IHNlY29uZFBlYWtTY29yZSkge1xuICAgICAgICAgICAgICAgIHNlY29uZFBlYWsgPSB4O1xuICAgICAgICAgICAgICAgIHNlY29uZFBlYWtTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBmaXJzdFBlYWsgY29ycmVzcG9uZHMgdG8gdGhlIGJsYWNrIHBlYWsuXG4gICAgICAgIGlmIChmaXJzdFBlYWsgPiBzZWNvbmRQZWFrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZpcnN0UGVhaztcbiAgICAgICAgICAgIGZpcnN0UGVhayA9IHNlY29uZFBlYWs7XG4gICAgICAgICAgICBzZWNvbmRQZWFrID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyB0b28gbGl0dGxlIGNvbnRyYXN0IGluIHRoZSBpbWFnZSB0byBwaWNrIGEgbWVhbmluZ2Z1bCBibGFjayBwb2ludCwgdGhyb3cgcmF0aGVyXG4gICAgICAgIC8vIHRoYW4gd2FzdGUgdGltZSB0cnlpbmcgdG8gZGVjb2RlIHRoZSBpbWFnZSwgYW5kIHJpc2sgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICBpZiAoc2Vjb25kUGVhayAtIGZpcnN0UGVhayA8PSBudW1CdWNrZXRzIC8gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIGEgdmFsbGV5IGJldHdlZW4gdGhlbSB0aGF0IGlzIGxvdyBhbmQgY2xvc2VyIHRvIHRoZSB3aGl0ZSBwZWFrLlxuICAgICAgICB2YXIgYmVzdFZhbGxleSA9IHNlY29uZFBlYWsgLSAxO1xuICAgICAgICB2YXIgYmVzdFZhbGxleVNjb3JlID0gLTE7XG4gICAgICAgIGZvciAodmFyIHggPSBzZWNvbmRQZWFrIC0gMTsgeCA+IGZpcnN0UGVhazsgeC0tKSB7XG4gICAgICAgICAgICB2YXIgZnJvbUZpcnN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgICAgIHZhciBzY29yZSA9IGZyb21GaXJzdCAqIGZyb21GaXJzdCAqIChzZWNvbmRQZWFrIC0geCkgKiAobWF4QnVja2V0Q291bnQgLSBidWNrZXRzW3hdKTtcbiAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RWYWxsZXlTY29yZSkge1xuICAgICAgICAgICAgICAgIGJlc3RWYWxsZXkgPSB4O1xuICAgICAgICAgICAgICAgIGJlc3RWYWxsZXlTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0VmFsbGV5IDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQ7XG4gICAgfTtcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JJVFMgPSA1O1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQgPSA4IC0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUyA9IDEgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5FTVBUWSA9IFVpbnQ4Q2xhbXBlZEFycmF5LmZyb20oWzBdKTtcbiAgICByZXR1cm4gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyO1xufShCaW5hcml6ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSampler.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSampler.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * Implementations of this class can, given locations of finder patterns for a QR code in an\n * image, sample the right points in the image to reconstruct the QR code, accounting for\n * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\n * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\n * Imaging library, but which may not be available in other environments such as J2ME, and vice\n * versa.\n *\n * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\n * with an instance of a class which implements this interface.\n *\n * @author Sean Owen\n */\nvar GridSampler = /** @class */ (function () {\n    function GridSampler() {\n    }\n    /**\n     * <p>Checks a set of points that have been transformed to sample points on an image against\n     * the image's dimensions to see if the point are even within the image.</p>\n     *\n     * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\n     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\n     * patterns in an image where the QR Code runs all the way to the image border.</p>\n     *\n     * <p>For efficiency, the method will check points from either end of the line until one is found\n     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\n     *\n     * @param image image into which the points should map\n     * @param points actual points in x1,y1,...,xn,yn form\n     * @throws NotFoundException if an endpoint is lies outside the image boundaries\n     */\n    GridSampler.checkAndNudgePoints = function (image, points) {\n        var width = image.getWidth();\n        var height = image.getHeight();\n        // Check and nudge points from start until we see some that are OK:\n        var nudged = true;\n        for (var offset = 0; offset < points.length && nudged; offset += 2) {\n            var x = Math.floor(points[offset]);\n            var y = Math.floor(points[offset + 1]);\n            if (x < -1 || x > width || y < -1 || y > height) {\n                throw new NotFoundException_1.default();\n            }\n            nudged = false;\n            if (x === -1) {\n                points[offset] = 0.0;\n                nudged = true;\n            }\n            else if (x === width) {\n                points[offset] = width - 1;\n                nudged = true;\n            }\n            if (y === -1) {\n                points[offset + 1] = 0.0;\n                nudged = true;\n            }\n            else if (y === height) {\n                points[offset + 1] = height - 1;\n                nudged = true;\n            }\n        }\n        // Check and nudge points from end:\n        nudged = true;\n        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n            var x = Math.floor(points[offset]);\n            var y = Math.floor(points[offset + 1]);\n            if (x < -1 || x > width || y < -1 || y > height) {\n                throw new NotFoundException_1.default();\n            }\n            nudged = false;\n            if (x === -1) {\n                points[offset] = 0.0;\n                nudged = true;\n            }\n            else if (x === width) {\n                points[offset] = width - 1;\n                nudged = true;\n            }\n            if (y === -1) {\n                points[offset + 1] = 0.0;\n                nudged = true;\n            }\n            else if (y === height) {\n                points[offset + 1] = height - 1;\n                nudged = true;\n            }\n        }\n    };\n    return GridSampler;\n}());\nexports[\"default\"] = GridSampler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vR3JpZFNhbXBsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0dyaWRTYW1wbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbi8qKlxuICogSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgY2xhc3MgY2FuLCBnaXZlbiBsb2NhdGlvbnMgb2YgZmluZGVyIHBhdHRlcm5zIGZvciBhIFFSIGNvZGUgaW4gYW5cbiAqIGltYWdlLCBzYW1wbGUgdGhlIHJpZ2h0IHBvaW50cyBpbiB0aGUgaW1hZ2UgdG8gcmVjb25zdHJ1Y3QgdGhlIFFSIGNvZGUsIGFjY291bnRpbmcgZm9yXG4gKiBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBJdCBpcyBhYnN0cmFjdGVkIHNpbmNlIGl0IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGFuZCBzaG91bGQgYmUgYWxsb3dlZFxuICogdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgcGxhdGZvcm0tc3BlY2lmaWMgb3B0aW1pemVkIGltcGxlbWVudGF0aW9ucywgbGlrZSBTdW4ncyBKYXZhIEFkdmFuY2VkXG4gKiBJbWFnaW5nIGxpYnJhcnksIGJ1dCB3aGljaCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBvdGhlciBlbnZpcm9ubWVudHMgc3VjaCBhcyBKMk1FLCBhbmQgdmljZVxuICogdmVyc2EuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZWQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgY2FsbGluZyB7QGxpbmsgI3NldEdyaWRTYW1wbGVyKEdyaWRTYW1wbGVyKX1cbiAqIHdpdGggYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBHcmlkU2FtcGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkU2FtcGxlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+Q2hlY2tzIGEgc2V0IG9mIHBvaW50cyB0aGF0IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCB0byBzYW1wbGUgcG9pbnRzIG9uIGFuIGltYWdlIGFnYWluc3RcbiAgICAgKiB0aGUgaW1hZ2UncyBkaW1lbnNpb25zIHRvIHNlZSBpZiB0aGUgcG9pbnQgYXJlIGV2ZW4gd2l0aGluIHRoZSBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIG1ldGhvZCB3aWxsIGFjdHVhbGx5IFwibnVkZ2VcIiB0aGUgZW5kcG9pbnRzIGJhY2sgb250byB0aGUgaW1hZ2UgaWYgdGhleSBhcmUgZm91bmQgdG8gYmVcbiAgICAgKiBiYXJlbHkgKGxlc3MgdGhhbiAxIHBpeGVsKSBvZmYgdGhlIGltYWdlLiBUaGlzIGFjY291bnRzIGZvciBpbXBlcmZlY3QgZGV0ZWN0aW9uIG9mIGZpbmRlclxuICAgICAqIHBhdHRlcm5zIGluIGFuIGltYWdlIHdoZXJlIHRoZSBRUiBDb2RlIHJ1bnMgYWxsIHRoZSB3YXkgdG8gdGhlIGltYWdlIGJvcmRlci48L3A+XG4gICAgICpcbiAgICAgKiA8cD5Gb3IgZWZmaWNpZW5jeSwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIHBvaW50cyBmcm9tIGVpdGhlciBlbmQgb2YgdGhlIGxpbmUgdW50aWwgb25lIGlzIGZvdW5kXG4gICAgICogdG8gYmUgd2l0aGluIHRoZSBpbWFnZS4gQmVjYXVzZSB0aGUgc2V0IG9mIHBvaW50cyBhcmUgYXNzdW1lZCB0byBiZSBsaW5lYXIsIHRoaXMgaXMgdmFsaWQuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIGltYWdlIGltYWdlIGludG8gd2hpY2ggdGhlIHBvaW50cyBzaG91bGQgbWFwXG4gICAgICogQHBhcmFtIHBvaW50cyBhY3R1YWwgcG9pbnRzIGluIHgxLHkxLC4uLix4bix5biBmb3JtXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiBlbmRwb2ludCBpcyBsaWVzIG91dHNpZGUgdGhlIGltYWdlIGJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBHcmlkU2FtcGxlci5jaGVja0FuZE51ZGdlUG9pbnRzID0gZnVuY3Rpb24gKGltYWdlLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gc3RhcnQgdW50aWwgd2Ugc2VlIHNvbWUgdGhhdCBhcmUgT0s6XG4gICAgICAgIHZhciBudWRnZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IDAuMDtcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSBoZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIGVuZDpcbiAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gcG9pbnRzLmxlbmd0aCAtIDI7IG9mZnNldCA+PSAwICYmIG51ZGdlZDsgb2Zmc2V0IC09IDIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IDAuMDtcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSBoZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHcmlkU2FtcGxlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHcmlkU2FtcGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSampler.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DefaultGridSampler_1 = __webpack_require__(/*! ./DefaultGridSampler */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js\");\nvar GridSamplerInstance = /** @class */ (function () {\n    function GridSamplerInstance() {\n    }\n    /**\n     * Sets the implementation of GridSampler used by the library. One global\n     * instance is stored, which may sound problematic. But, the implementation provided\n     * ought to be appropriate for the entire platform, and all uses of this library\n     * in the whole lifetime of the JVM. For instance, an Android activity can swap in\n     * an implementation that takes advantage of native platform libraries.\n     *\n     * @param newGridSampler The platform-specific object to install.\n     */\n    GridSamplerInstance.setGridSampler = function (newGridSampler) {\n        GridSamplerInstance.gridSampler = newGridSampler;\n    };\n    /**\n     * @return the current implementation of GridSampler\n     */\n    GridSamplerInstance.getInstance = function () {\n        return GridSamplerInstance.gridSampler;\n    };\n    GridSamplerInstance.gridSampler = new DefaultGridSampler_1.default();\n    return GridSamplerInstance;\n}());\nexports[\"default\"] = GridSamplerInstance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyw0SkFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWZhdWx0R3JpZFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHRHcmlkU2FtcGxlclwiKTtcbnZhciBHcmlkU2FtcGxlckluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyaWRTYW1wbGVySW5zdGFuY2UoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyIHVzZWQgYnkgdGhlIGxpYnJhcnkuIE9uZSBnbG9iYWxcbiAgICAgKiBpbnN0YW5jZSBpcyBzdG9yZWQsIHdoaWNoIG1heSBzb3VuZCBwcm9ibGVtYXRpYy4gQnV0LCB0aGUgaW1wbGVtZW50YXRpb24gcHJvdmlkZWRcbiAgICAgKiBvdWdodCB0byBiZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGVudGlyZSBwbGF0Zm9ybSwgYW5kIGFsbCB1c2VzIG9mIHRoaXMgbGlicmFyeVxuICAgICAqIGluIHRoZSB3aG9sZSBsaWZldGltZSBvZiB0aGUgSlZNLiBGb3IgaW5zdGFuY2UsIGFuIEFuZHJvaWQgYWN0aXZpdHkgY2FuIHN3YXAgaW5cbiAgICAgKiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IHRha2VzIGFkdmFudGFnZSBvZiBuYXRpdmUgcGxhdGZvcm0gbGlicmFyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0dyaWRTYW1wbGVyIFRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBvYmplY3QgdG8gaW5zdGFsbC5cbiAgICAgKi9cbiAgICBHcmlkU2FtcGxlckluc3RhbmNlLnNldEdyaWRTYW1wbGVyID0gZnVuY3Rpb24gKG5ld0dyaWRTYW1wbGVyKSB7XG4gICAgICAgIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXIgPSBuZXdHcmlkU2FtcGxlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgR3JpZFNhbXBsZXJcbiAgICAgKi9cbiAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlcjtcbiAgICB9O1xuICAgIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXIgPSBuZXcgRGVmYXVsdEdyaWRTYW1wbGVyXzEuZGVmYXVsdCgpO1xuICAgIHJldHVybiBHcmlkU2FtcGxlckluc3RhbmNlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEdyaWRTYW1wbGVySW5zdGFuY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar GlobalHistogramBinarizer_1 = __webpack_require__(/*! ./GlobalHistogramBinarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar HybridBinarizer = /** @class */ (function (_super) {\n    __extends(HybridBinarizer, _super);\n    function HybridBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.matrix = null;\n        return _this;\n    }\n    /**\n     * Calculates the final BitMatrix once for all requests. This could be called once from the\n     * constructor instead, but there are some advantages to doing it lazily, such as making\n     * profiling easier, and not doing heavy lifting when callers don't expect it.\n     */\n    /*@Override*/\n    HybridBinarizer.prototype.getBlackMatrix = function () {\n        if (this.matrix !== null) {\n            return this.matrix;\n        }\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n            var luminances = source.getMatrix();\n            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subWidth++;\n            }\n            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subHeight++;\n            }\n            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n            var newMatrix = new BitMatrix_1.default(width, height);\n            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n            this.matrix = newMatrix;\n        }\n        else {\n            // If the image is too small, fall back to the global histogram approach.\n            this.matrix = _super.prototype.getBlackMatrix.call(this);\n        }\n        return this.matrix;\n    };\n    /*@Override*/\n    HybridBinarizer.prototype.createBinarizer = function (source) {\n        return new HybridBinarizer(source);\n    };\n    /**\n     * For each block in the image, calculate the average black point using a 5x5 grid\n     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n     * on the last pixels in the row/column which are also used in the previous block).\n     */\n    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        for (var y = 0; y < subHeight; y++) {\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                var sum = 0;\n                for (var z = -2; z <= 2; z++) {\n                    var blackRow = blackPoints[top_1 + z];\n                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                }\n                var average = sum / 25;\n                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n            }\n        }\n    };\n    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\n        return value < min ? min : value > max ? max : value;\n    };\n    /**\n     * Applies a single threshold to a block of pixels.\n     */\n    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                if ((luminances[offset + x] & 0xFF) <= threshold) {\n                    matrix.set(xoffset + x, yoffset + y);\n                }\n            }\n        }\n    };\n    /**\n     * Calculates a single black point for each block of pixels and saves it away.\n     * See the following thread for a discussion of this algorithm:\n     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n     */\n    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        // tslint:disable-next-line:whitespace\n        var blackPoints = new Array(subHeight); // subWidth\n        for (var y = 0; y < subHeight; y++) {\n            blackPoints[y] = new Int32Array(subWidth);\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var sum = 0;\n                var min = 0xFF;\n                var max = 0;\n                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                        var pixel = luminances[offset + xx] & 0xFF;\n                        sum += pixel;\n                        // still looking for good contrast\n                        if (pixel < min) {\n                            min = pixel;\n                        }\n                        if (pixel > max) {\n                            max = pixel;\n                        }\n                    }\n                    // short-circuit min/max tests once dynamic range is met\n                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // finish the rest of the rows quickly\n                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                                sum += luminances[offset + xx] & 0xFF;\n                            }\n                        }\n                    }\n                }\n                // The default estimate is the average of the values in the block.\n                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\n                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                    // If variation within the block is low, assume this is a block with only light or only\n                    // dark pixels. In that case we do not want to use the average, as it would divide this\n                    // low contrast area into black and white pixels, essentially creating data out of noise.\n                    //\n                    // The default assumption is that the block is light/background. Since no estimate for\n                    // the level of dark pixels exists locally, use half the min for the block.\n                    average = min / 2;\n                    if (y > 0 && x > 0) {\n                        // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                        // the pixels in this block to the previously calculated black points. This is based on\n                        // the fact that dark barcode symbology is always surrounded by some amount of light\n                        // background for which reasonable black point estimates were made. The bp estimated at\n                        // the boundaries is used for the interior.\n                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\n                        if (min < averageNeighborBlackPoint) {\n                            average = averageNeighborBlackPoint;\n                        }\n                    }\n                }\n                blackPoints[y][x] = average;\n            }\n        }\n        return blackPoints;\n    };\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n    return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default));\nexports[\"default\"] = HybridBinarizer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vSHlicmlkQmluYXJpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsd0tBQTRCO0FBQ3JFLGtCQUFrQixtQkFBTyxDQUFDLDBJQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0YsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUNBQWlDO0FBQ3RHLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGLDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL0h5YnJpZEJpbmFyaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEgPSByZXF1aXJlKFwiLi9HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJcIik7XG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi9CaXRNYXRyaXhcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0sIHdoaWNoIHdoaWxlIHNsb3dlciB0aGFuIHRoZVxuICogR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCBpcyBmYWlybHkgZWZmaWNpZW50IGZvciB3aGF0IGl0IGRvZXMuIEl0IGlzIGRlc2lnbmVkIGZvclxuICogaGlnaCBmcmVxdWVuY3kgaW1hZ2VzIG9mIGJhcmNvZGVzIHdpdGggYmxhY2sgZGF0YSBvbiB3aGl0ZSBiYWNrZ3JvdW5kcy4gRm9yIHRoaXMgYXBwbGljYXRpb24sXG4gKiBpdCBkb2VzIGEgbXVjaCBiZXR0ZXIgam9iIHRoYW4gYSBnbG9iYWwgYmxhY2twb2ludCB3aXRoIHNldmVyZSBzaGFkb3dzIGFuZCBncmFkaWVudHMuXG4gKiBIb3dldmVyIGl0IHRlbmRzIHRvIHByb2R1Y2UgYXJ0aWZhY3RzIG9uIGxvd2VyIGZyZXF1ZW5jeSBpbWFnZXMgYW5kIGlzIHRoZXJlZm9yZSBub3RcbiAqIGEgZ29vZCBnZW5lcmFsIHB1cnBvc2UgYmluYXJpemVyIGZvciB1c2VzIG91dHNpZGUgWlhpbmcuXG4gKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgdXNpbmcgdGhlIG9sZGVyIGhpc3RvZ3JhbSBhcHByb2FjaCBmb3IgMUQgcmVhZGVycyxcbiAqIGFuZCB0aGUgbmV3ZXIgbG9jYWwgYXBwcm9hY2ggZm9yIDJEIHJlYWRlcnMuIDFEIGRlY29kaW5nIHVzaW5nIGEgcGVyLXJvdyBoaXN0b2dyYW0gaXMgYWxyZWFkeVxuICogaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHkgZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsXG4gKiBidXQgZm9yIG5vdyBpdCB3YXMgbm90IGEgd2luIHRvIHVzZSBsb2NhbCBibG9ja3MgZm9yIDFELlxuICpcbiAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzIGZvciBsaWJyYXJ5IHVzZXJzLlxuICpcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gKi9cbnZhciBIeWJyaWRCaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh5YnJpZEJpbmFyaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIeWJyaWRCaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNvdXJjZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWF0cml4ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmaW5hbCBCaXRNYXRyaXggb25jZSBmb3IgYWxsIHJlcXVlc3RzLiBUaGlzIGNvdWxkIGJlIGNhbGxlZCBvbmNlIGZyb20gdGhlXG4gICAgICogY29uc3RydWN0b3IgaW5zdGVhZCwgYnV0IHRoZXJlIGFyZSBzb21lIGFkdmFudGFnZXMgdG8gZG9pbmcgaXQgbGF6aWx5LCBzdWNoIGFzIG1ha2luZ1xuICAgICAqIHByb2ZpbGluZyBlYXNpZXIsIGFuZCBub3QgZG9pbmcgaGVhdnkgbGlmdGluZyB3aGVuIGNhbGxlcnMgZG9uJ3QgZXhwZWN0IGl0LlxuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBIeWJyaWRCaW5hcml6ZXIucHJvdG90eXBlLmdldEJsYWNrTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXRyaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGlmICh3aWR0aCA+PSBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gJiYgaGVpZ2h0ID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTikge1xuICAgICAgICAgICAgdmFyIGx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICB2YXIgc3ViV2lkdGggPSB3aWR0aCA+PiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgIGlmICgod2lkdGggJiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN1YldpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ViSGVpZ2h0ID0gaGVpZ2h0ID4+IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgaWYgKChoZWlnaHQgJiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN1YkhlaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJsYWNrUG9pbnRzID0gSHlicmlkQmluYXJpemVyLmNhbGN1bGF0ZUJsYWNrUG9pbnRzKGx1bWluYW5jZXMsIHN1YldpZHRoLCBzdWJIZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgSHlicmlkQmluYXJpemVyLmNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrKGx1bWluYW5jZXMsIHN1YldpZHRoLCBzdWJIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIGJsYWNrUG9pbnRzLCBuZXdNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBuZXdNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgdG9vIHNtYWxsLCBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guXG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IF9zdXBlci5wcm90b3R5cGUuZ2V0QmxhY2tNYXRyaXguY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgSHlicmlkQmluYXJpemVyLnByb3RvdHlwZS5jcmVhdGVCaW5hcml6ZXIgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHlicmlkQmluYXJpemVyKHNvdXJjZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGUgaW1hZ2UsIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSBibGFjayBwb2ludCB1c2luZyBhIDV4NSBncmlkXG4gICAgICogb2YgdGhlIGJsb2NrcyBhcm91bmQgaXQuIEFsc28gaGFuZGxlcyB0aGUgY29ybmVyIGNhc2VzIChmcmFjdGlvbmFsIGJsb2NrcyBhcmUgY29tcHV0ZWQgYmFzZWRcbiAgICAgKiBvbiB0aGUgbGFzdCBwaXhlbHMgaW4gdGhlIHJvdy9jb2x1bW4gd2hpY2ggYXJlIGFsc28gdXNlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2spLlxuICAgICAqL1xuICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayA9IGZ1bmN0aW9uIChsdW1pbmFuY2VzLCBzdWJXaWR0aCAvKmludCovLCBzdWJIZWlnaHQgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGJsYWNrUG9pbnRzLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIG1heFlPZmZzZXQgPSBoZWlnaHQgLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgdmFyIG1heFhPZmZzZXQgPSB3aWR0aCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHN1YkhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3BfMSA9IEh5YnJpZEJpbmFyaXplci5jYXAoeSwgMiwgc3ViSGVpZ2h0IC0gMyk7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKHhvZmZzZXQgPiBtYXhYT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IEh5YnJpZEJpbmFyaXplci5jYXAoeCwgMiwgc3ViV2lkdGggLSAzKTtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gLTI7IHogPD0gMjsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibGFja1JvdyA9IGJsYWNrUG9pbnRzW3RvcF8xICsgel07XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBibGFja1Jvd1tsZWZ0IC0gMl0gKyBibGFja1Jvd1tsZWZ0IC0gMV0gKyBibGFja1Jvd1tsZWZ0XSArIGJsYWNrUm93W2xlZnQgKyAxXSArIGJsYWNrUm93W2xlZnQgKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGF2ZXJhZ2UgPSBzdW0gLyAyNTtcbiAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIudGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCwgeW9mZnNldCwgYXZlcmFnZSwgd2lkdGgsIG1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh5YnJpZEJpbmFyaXplci5jYXAgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLywgbWluIC8qaW50Ki8sIG1heCAvKmludCovKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgc2luZ2xlIHRocmVzaG9sZCB0byBhIGJsb2NrIG9mIHBpeGVscy5cbiAgICAgKi9cbiAgICBIeWJyaWRCaW5hcml6ZXIudGhyZXNob2xkQmxvY2sgPSBmdW5jdGlvbiAobHVtaW5hbmNlcywgeG9mZnNldCAvKmludCovLCB5b2Zmc2V0IC8qaW50Ki8sIHRocmVzaG9sZCAvKmludCovLCBzdHJpZGUgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBvZmZzZXQgPSB5b2Zmc2V0ICogc3RyaWRlICsgeG9mZnNldDsgeSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5KyssIG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhcmlzb24gbmVlZHMgdG8gYmUgPD0gc28gdGhhdCBibGFjayA9PSAwIHBpeGVscyBhcmUgYmxhY2sgZXZlbiBpZiB0aGUgdGhyZXNob2xkIGlzIDAuXG4gICAgICAgICAgICAgICAgaWYgKChsdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhGRikgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoeG9mZnNldCArIHgsIHlvZmZzZXQgKyB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYSBzaW5nbGUgYmxhY2sgcG9pbnQgZm9yIGVhY2ggYmxvY2sgb2YgcGl4ZWxzIGFuZCBzYXZlcyBpdCBhd2F5LlxuICAgICAqIFNlZSB0aGUgZm9sbG93aW5nIHRocmVhZCBmb3IgYSBkaXNjdXNzaW9uIG9mIHRoaXMgYWxnb3JpdGhtOlxuICAgICAqICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvenhpbmcvYnJvd3NlX3RocmVhZC90aHJlYWQvZDA2ZWZhMmMzNWE3ZGRjMFxuICAgICAqL1xuICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVCbGFja1BvaW50cyA9IGZ1bmN0aW9uIChsdW1pbmFuY2VzLCBzdWJXaWR0aCAvKmludCovLCBzdWJIZWlnaHQgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIG1heFlPZmZzZXQgPSBoZWlnaHQgLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcbiAgICAgICAgdmFyIG1heFhPZmZzZXQgPSB3aWR0aCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6d2hpdGVzcGFjZVxuICAgICAgICB2YXIgYmxhY2tQb2ludHMgPSBuZXcgQXJyYXkoc3ViSGVpZ2h0KTsgLy8gc3ViV2lkdGhcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzdWJIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgYmxhY2tQb2ludHNbeV0gPSBuZXcgSW50MzJBcnJheShzdWJXaWR0aCk7XG4gICAgICAgICAgICB2YXIgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciB4b2Zmc2V0ID0geCA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSAweEZGO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHl5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHdpZHRoICsgeG9mZnNldDsgeXkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeXkrKywgb2Zmc2V0ICs9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgbG9va2luZyBmb3IgZ29vZCBjb250cmFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IG1pbi9tYXggdGVzdHMgb25jZSBkeW5hbWljIHJhbmdlIGlzIG1ldFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4IC0gbWluID4gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdGhlIHJlc3Qgb2YgdGhlIHJvd3MgcXVpY2tseVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh5eSsrLCBvZmZzZXQgKz0gd2lkdGg7IHl5IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHl5KyssIG9mZnNldCArPSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBlc3RpbWF0ZSBpcyB0aGUgYXZlcmFnZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICB2YXIgYXZlcmFnZSA9IHN1bSA+PiAoSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVIgKiAyKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4IC0gbWluIDw9IEh5YnJpZEJpbmFyaXplci5NSU5fRFlOQU1JQ19SQU5HRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YXJpYXRpb24gd2l0aGluIHRoZSBibG9jayBpcyBsb3csIGFzc3VtZSB0aGlzIGlzIGEgYmxvY2sgd2l0aCBvbmx5IGxpZ2h0IG9yIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGFyayBwaXhlbHMuIEluIHRoYXQgY2FzZSB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGF2ZXJhZ2UsIGFzIGl0IHdvdWxkIGRpdmlkZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvdyBjb250cmFzdCBhcmVhIGludG8gYmxhY2sgYW5kIHdoaXRlIHBpeGVscywgZXNzZW50aWFsbHkgY3JlYXRpbmcgZGF0YSBvdXQgb2Ygbm9pc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgYmxvY2sgaXMgbGlnaHQvYmFja2dyb3VuZC4gU2luY2Ugbm8gZXN0aW1hdGUgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsZXZlbCBvZiBkYXJrIHBpeGVscyBleGlzdHMgbG9jYWxseSwgdXNlIGhhbGYgdGhlIG1pbiBmb3IgdGhlIGJsb2NrLlxuICAgICAgICAgICAgICAgICAgICBhdmVyYWdlID0gbWluIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiAwICYmIHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBcIndoaXRlIGJhY2tncm91bmRcIiBhc3N1bXB0aW9uIGZvciBibG9ja3MgdGhhdCBoYXZlIG5laWdoYm9ycyBieSBjb21wYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwaXhlbHMgaW4gdGhpcyBibG9jayB0byB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGJsYWNrIHBvaW50cy4gVGhpcyBpcyBiYXNlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCBkYXJrIGJhcmNvZGUgc3ltYm9sb2d5IGlzIGFsd2F5cyBzdXJyb3VuZGVkIGJ5IHNvbWUgYW1vdW50IG9mIGxpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kIGZvciB3aGljaCByZWFzb25hYmxlIGJsYWNrIHBvaW50IGVzdGltYXRlcyB3ZXJlIG1hZGUuIFRoZSBicCBlc3RpbWF0ZWQgYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGFyaWVzIGlzIHVzZWQgZm9yIHRoZSBpbnRlcmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSAobWluIDwgYnApIGlzIGFyYml0cmFyeSBidXQgd29ya3MgYmV0dGVyIHRoYW4gb3RoZXIgaGV1cmlzdGljcyB0aGF0IHdlcmUgdHJpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCA9IChibGFja1BvaW50c1t5IC0gMV1beF0gKyAoMiAqIGJsYWNrUG9pbnRzW3ldW3ggLSAxXSkgKyBibGFja1BvaW50c1t5IC0gMV1beCAtIDFdKSAvIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldW3hdID0gYXZlcmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxhY2tQb2ludHM7XG4gICAgfTtcbiAgICAvLyBUaGlzIGNsYXNzIHVzZXMgNXg1IGJsb2NrcyB0byBjb21wdXRlIGxvY2FsIGx1bWluYW5jZSwgd2hlcmUgZWFjaCBibG9jayBpcyA4eDggcGl4ZWxzLlxuICAgIC8vIFNvIHRoaXMgaXMgdGhlIHNtYWxsZXN0IGRpbWVuc2lvbiBpbiBlYWNoIGF4aXMgd2UgY2FuIGFjY2VwdC5cbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUiA9IDM7XG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkUgPSAxIDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSOyAvLyAuLi4wMTAwLi4uMDBcbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLID0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkUgLSAxOyAvLyAuLi4wMDExLi4uMTFcbiAgICBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gPSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSAqIDU7XG4gICAgSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFID0gMjQ7XG4gICAgcmV0dXJuIEh5YnJpZEJpbmFyaXplcjtcbn0oR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSHlicmlkQmluYXJpemVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MinimalECIInput = void 0;\nvar ECIEncoderSet_1 = __webpack_require__(/*! ./ECIEncoderSet */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js\");\nvar Integer_1 = __webpack_require__(/*! ../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar COST_PER_ECI = 3; // approximated (latch + 2 codewords)\nvar MinimalECIInput = /** @class */ (function () {\n    /**\n     * Constructs a minimal input\n     *\n     * @param stringToEncode the character string to encode\n     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n     *   charset to encode any character in the input that can be encoded by it if the charset is among the\n     *   supported charsets.\n     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not GS1\n     *   input.\n     */\n    function MinimalECIInput(stringToEncode, priorityCharset, fnc1) {\n        this.fnc1 = fnc1;\n        var encoderSet = new ECIEncoderSet_1.ECIEncoderSet(stringToEncode, priorityCharset, fnc1);\n        if (encoderSet.length() === 1) {\n            // optimization for the case when all can be encoded without ECI in ISO-8859-1\n            for (var i = 0; i < this.bytes.length; i++) {\n                var c = stringToEncode.charAt(i).charCodeAt(0);\n                this.bytes[i] = c === fnc1 ? 1000 : c;\n            }\n        }\n        else {\n            this.bytes = this.encodeMinimally(stringToEncode, encoderSet, fnc1);\n        }\n    }\n    MinimalECIInput.prototype.getFNC1Character = function () {\n        return this.fnc1;\n    };\n    /**\n     * Returns the length of this input.  The length is the number\n     * of {@code byte}s, FNC1 characters or ECIs in the sequence.\n     *\n     * @return  the number of {@code char}s in this sequence\n     */\n    MinimalECIInput.prototype.length = function () {\n        return this.bytes.length;\n    };\n    MinimalECIInput.prototype.haveNCharacters = function (index, n) {\n        if (index + n - 1 >= this.bytes.length) {\n            return false;\n        }\n        for (var i = 0; i < n; i++) {\n            if (this.isECI(index + i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Returns the {@code byte} value at the specified index.  An index ranges from zero\n     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at\n     * index zero, the next at index one, and so on, as for array\n     * indexing.\n     *\n     * @param   index the index of the {@code byte} value to be returned\n     *\n     * @return  the specified {@code byte} value as character or the FNC1 character\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if the {@code index} argument is negative or not less than\n     *          {@code length()}\n     * @throws  IllegalArgumentException\n     *          if the value at the {@code index} argument is an ECI (@see #isECI)\n     */\n    MinimalECIInput.prototype.charAt = function (index) {\n        if (index < 0 || index >= this.length()) {\n            throw new Error('' + index);\n        }\n        if (this.isECI(index)) {\n            throw new Error('value at ' + index + ' is not a character but an ECI');\n        }\n        return this.isFNC1(index) ? this.fnc1 : this.bytes[index];\n    };\n    /**\n     * Returns a {@code CharSequence} that is a subsequence of this sequence.\n     * The subsequence starts with the {@code char} value at the specified index and\n     * ends with the {@code char} value at index {@code end - 1}.  The length\n     * (in {@code char}s) of the\n     * returned sequence is {@code end - start}, so if {@code start == end}\n     * then an empty sequence is returned.\n     *\n     * @param   start   the start index, inclusive\n     * @param   end     the end index, exclusive\n     *\n     * @return  the specified subsequence\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code start} or {@code end} are negative,\n     *          if {@code end} is greater than {@code length()},\n     *          or if {@code start} is greater than {@code end}\n     * @throws  IllegalArgumentException\n     *          if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)\n     */\n    MinimalECIInput.prototype.subSequence = function (start, end) {\n        if (start < 0 || start > end || end > this.length()) {\n            throw new Error('' + start);\n        }\n        var result = new StringBuilder_1.default();\n        for (var i = start; i < end; i++) {\n            if (this.isECI(i)) {\n                throw new Error('value at ' + i + ' is not a character but an ECI');\n            }\n            result.append(this.charAt(i));\n        }\n        return result.toString();\n    };\n    /**\n     * Determines if a value is an ECI\n     *\n     * @param   index the index of the value\n     *\n     * @return  true if the value at position {@code index} is an ECI\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if the {@code index} argument is negative or not less than\n     *          {@code length()}\n     */\n    MinimalECIInput.prototype.isECI = function (index) {\n        if (index < 0 || index >= this.length()) {\n            throw new Error('' + index);\n        }\n        return this.bytes[index] > 255 && this.bytes[index] <= 999;\n    };\n    /**\n     * Determines if a value is the FNC1 character\n     *\n     * @param   index the index of the value\n     *\n     * @return  true if the value at position {@code index} is the FNC1 character\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if the {@code index} argument is negative or not less than\n     *          {@code length()}\n     */\n    MinimalECIInput.prototype.isFNC1 = function (index) {\n        if (index < 0 || index >= this.length()) {\n            throw new Error('' + index);\n        }\n        return this.bytes[index] === 1000;\n    };\n    /**\n     * Returns the {@code int} ECI value at the specified index.  An index ranges from zero\n     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at\n     * index zero, the next at index one, and so on, as for array\n     * indexing.\n     *\n     * @param   index the index of the {@code int} value to be returned\n     *\n     * @return  the specified {@code int} ECI value.\n     *          The ECI specified the encoding of all bytes with a higher index until the\n     *          next ECI or until the end of the input if no other ECI follows.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if the {@code index} argument is negative or not less than\n     *          {@code length()}\n     * @throws  IllegalArgumentException\n     *          if the value at the {@code index} argument is not an ECI (@see #isECI)\n     */\n    MinimalECIInput.prototype.getECIValue = function (index) {\n        if (index < 0 || index >= this.length()) {\n            throw new Error('' + index);\n        }\n        if (!this.isECI(index)) {\n            throw new Error('value at ' + index + ' is not an ECI but a character');\n        }\n        return this.bytes[index] - 256;\n    };\n    MinimalECIInput.prototype.addEdge = function (edges, to, edge) {\n        if (edges[to][edge.encoderIndex] == null ||\n            edges[to][edge.encoderIndex].cachedTotalSize > edge.cachedTotalSize) {\n            edges[to][edge.encoderIndex] = edge;\n        }\n    };\n    MinimalECIInput.prototype.addEdges = function (stringToEncode, encoderSet, edges, from, previous, fnc1) {\n        var ch = stringToEncode.charAt(from).charCodeAt(0);\n        var start = 0;\n        var end = encoderSet.length();\n        if (encoderSet.getPriorityEncoderIndex() >= 0 &&\n            (ch === fnc1 ||\n                encoderSet.canEncode(ch, encoderSet.getPriorityEncoderIndex()))) {\n            start = encoderSet.getPriorityEncoderIndex();\n            end = start + 1;\n        }\n        for (var i = start; i < end; i++) {\n            if (ch === fnc1 || encoderSet.canEncode(ch, i)) {\n                this.addEdge(edges, from + 1, new InputEdge(ch, encoderSet, i, previous, fnc1));\n            }\n        }\n    };\n    MinimalECIInput.prototype.encodeMinimally = function (stringToEncode, encoderSet, fnc1) {\n        var inputLength = stringToEncode.length;\n        // Array that represents vertices. There is a vertex for every character and encoding.\n        var edges = new InputEdge[inputLength + 1][encoderSet.length()]();\n        this.addEdges(stringToEncode, encoderSet, edges, 0, null, fnc1);\n        for (var i = 1; i <= inputLength; i++) {\n            for (var j = 0; j < encoderSet.length(); j++) {\n                if (edges[i][j] != null && i < inputLength) {\n                    this.addEdges(stringToEncode, encoderSet, edges, i, edges[i][j], fnc1);\n                }\n            }\n            // optimize memory by removing edges that have been passed.\n            for (var j = 0; j < encoderSet.length(); j++) {\n                edges[i - 1][j] = null;\n            }\n        }\n        var minimalJ = -1;\n        var minimalSize = Integer_1.default.MAX_VALUE;\n        for (var j = 0; j < encoderSet.length(); j++) {\n            if (edges[inputLength][j] != null) {\n                var edge = edges[inputLength][j];\n                if (edge.cachedTotalSize < minimalSize) {\n                    minimalSize = edge.cachedTotalSize;\n                    minimalJ = j;\n                }\n            }\n        }\n        if (minimalJ < 0) {\n            throw new Error('Failed to encode \"' + stringToEncode + '\"');\n        }\n        var intsAL = [];\n        var current = edges[inputLength][minimalJ];\n        while (current != null) {\n            if (current.isFNC1()) {\n                intsAL.unshift(1000);\n            }\n            else {\n                var bytes = encoderSet.encode(current.c, current.encoderIndex);\n                for (var i = bytes.length - 1; i >= 0; i--) {\n                    intsAL.unshift(bytes[i] & 0xff);\n                }\n            }\n            var previousEncoderIndex = current.previous === null ? 0 : current.previous.encoderIndex;\n            if (previousEncoderIndex !== current.encoderIndex) {\n                intsAL.unshift(256 + encoderSet.getECIValue(current.encoderIndex));\n            }\n            current = current.previous;\n        }\n        var ints = [];\n        for (var i = 0; i < ints.length; i++) {\n            ints[i] = intsAL[i];\n        }\n        return ints;\n    };\n    return MinimalECIInput;\n}());\nexports.MinimalECIInput = MinimalECIInput;\nvar InputEdge = /** @class */ (function () {\n    function InputEdge(c, encoderSet, encoderIndex, previous, fnc1) {\n        this.c = c;\n        this.encoderSet = encoderSet;\n        this.encoderIndex = encoderIndex;\n        this.previous = previous;\n        this.fnc1 = fnc1;\n        this.c = c === fnc1 ? 1000 : c;\n        var size = this.isFNC1() ? 1 : encoderSet.encode(c, encoderIndex).length;\n        var previousEncoderIndex = previous === null ? 0 : previous.encoderIndex;\n        if (previousEncoderIndex !== encoderIndex) {\n            size += COST_PER_ECI;\n        }\n        if (previous != null) {\n            size += previous.cachedTotalSize;\n        }\n        this.cachedTotalSize = size;\n    }\n    InputEdge.prototype.isFNC1 = function () {\n        return this.c === 1000;\n    };\n    return InputEdge;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vTWluaW1hbEVDSUlucHV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixzQkFBc0IsbUJBQU8sQ0FBQyxrSkFBaUI7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWlCO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLHNKQUF1QjtBQUNyRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsV0FBVyxtQkFBbUIsY0FBYyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHdDQUF3QyxZQUFZO0FBQ3BELHNCQUFzQixZQUFZLGdCQUFnQixjQUFjO0FBQ2hFLFlBQVksV0FBVztBQUN2Qiw2QkFBNkIsa0JBQWtCLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLElBQUksV0FBVztBQUNoRCxvQkFBb0IsV0FBVyxpQkFBaUIsZUFBZTtBQUMvRCx1QkFBdUIsYUFBYSxpQkFBaUI7QUFDckQ7QUFDQSx5Q0FBeUMsWUFBWSxFQUFFLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixXQUFXLG1CQUFtQixjQUFjLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL01pbmltYWxFQ0lJbnB1dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWluaW1hbEVDSUlucHV0ID0gdm9pZCAwO1xudmFyIEVDSUVuY29kZXJTZXRfMSA9IHJlcXVpcmUoXCIuL0VDSUVuY29kZXJTZXRcIik7XG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvSW50ZWdlclwiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIENPU1RfUEVSX0VDSSA9IDM7IC8vIGFwcHJveGltYXRlZCAobGF0Y2ggKyAyIGNvZGV3b3JkcylcbnZhciBNaW5pbWFsRUNJSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG1pbmltYWwgaW5wdXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmdUb0VuY29kZSB0aGUgY2hhcmFjdGVyIHN0cmluZyB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlDaGFyc2V0IFRoZSBwcmVmZXJyZWQge0BsaW5rIENoYXJzZXR9LiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgaXMgbnVsbCwgdGhlIGFsZ29yaXRobVxuICAgICAqICAgY2hvb3NlcyBjaGFyc2V0cyB0aGF0IGxlYWRzIHRvIGEgbWluaW1hbCByZXByZXNlbnRhdGlvbi4gT3RoZXJ3aXNlIHRoZSBhbGdvcml0aG0gd2lsbCB1c2UgdGhlIHByaW9yaXR5XG4gICAgICogICBjaGFyc2V0IHRvIGVuY29kZSBhbnkgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IGl0IGlmIHRoZSBjaGFyc2V0IGlzIGFtb25nIHRoZVxuICAgICAqICAgc3VwcG9ydGVkIGNoYXJzZXRzLlxuICAgICAqIEBwYXJhbSBmbmMxIGRlbm90ZXMgdGhlIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdGhhdCByZXByZXNlbnRzIHRoZSBGTkMxIGNoYXJhY3RlciBvciAtMSBpZiB0aGlzIGlzIG5vdCBHUzFcbiAgICAgKiAgIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1pbmltYWxFQ0lJbnB1dChzdHJpbmdUb0VuY29kZSwgcHJpb3JpdHlDaGFyc2V0LCBmbmMxKSB7XG4gICAgICAgIHRoaXMuZm5jMSA9IGZuYzE7XG4gICAgICAgIHZhciBlbmNvZGVyU2V0ID0gbmV3IEVDSUVuY29kZXJTZXRfMS5FQ0lFbmNvZGVyU2V0KHN0cmluZ1RvRW5jb2RlLCBwcmlvcml0eUNoYXJzZXQsIGZuYzEpO1xuICAgICAgICBpZiAoZW5jb2RlclNldC5sZW5ndGgoKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciB0aGUgY2FzZSB3aGVuIGFsbCBjYW4gYmUgZW5jb2RlZCB3aXRob3V0IEVDSSBpbiBJU08tODg1OS0xXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHN0cmluZ1RvRW5jb2RlLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZXNbaV0gPSBjID09PSBmbmMxID8gMTAwMCA6IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5lbmNvZGVNaW5pbWFsbHkoc3RyaW5nVG9FbmNvZGUsIGVuY29kZXJTZXQsIGZuYzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1pbmltYWxFQ0lJbnB1dC5wcm90b3R5cGUuZ2V0Rk5DMUNoYXJhY3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm5jMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIGlucHV0LiAgVGhlIGxlbmd0aCBpcyB0aGUgbnVtYmVyXG4gICAgICogb2Yge0Bjb2RlIGJ5dGV9cywgRk5DMSBjaGFyYWN0ZXJzIG9yIEVDSXMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiAgdGhlIG51bWJlciBvZiB7QGNvZGUgY2hhcn1zIGluIHRoaXMgc2VxdWVuY2VcbiAgICAgKi9cbiAgICBNaW5pbWFsRUNJSW5wdXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoO1xuICAgIH07XG4gICAgTWluaW1hbEVDSUlucHV0LnByb3RvdHlwZS5oYXZlTkNoYXJhY3RlcnMgPSBmdW5jdGlvbiAoaW5kZXgsIG4pIHtcbiAgICAgICAgaWYgKGluZGV4ICsgbiAtIDEgPj0gdGhpcy5ieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFQ0koaW5kZXggKyBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAY29kZSBieXRlfSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiAgQW4gaW5kZXggcmFuZ2VzIGZyb20gemVyb1xuICAgICAqIHRvIHtAY29kZSBsZW5ndGgoKSAtIDF9LiAgVGhlIGZpcnN0IHtAY29kZSBieXRlfSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgaXMgYXRcbiAgICAgKiBpbmRleCB6ZXJvLCB0aGUgbmV4dCBhdCBpbmRleCBvbmUsIGFuZCBzbyBvbiwgYXMgZm9yIGFycmF5XG4gICAgICogaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHtAY29kZSBieXRlfSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICAgICAqXG4gICAgICogQHJldHVybiAgdGhlIHNwZWNpZmllZCB7QGNvZGUgYnl0ZX0gdmFsdWUgYXMgY2hhcmFjdGVyIG9yIHRoZSBGTkMxIGNoYXJhY3RlclxuICAgICAqXG4gICAgICogQHRocm93cyAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblxuICAgICAqICAgICAgICAgIGlmIHRoZSB7QGNvZGUgaW5kZXh9IGFyZ3VtZW50IGlzIG5lZ2F0aXZlIG9yIG5vdCBsZXNzIHRoYW5cbiAgICAgKiAgICAgICAgICB7QGNvZGUgbGVuZ3RoKCl9XG4gICAgICogQHRocm93cyAgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXG4gICAgICogICAgICAgICAgaWYgdGhlIHZhbHVlIGF0IHRoZSB7QGNvZGUgaW5kZXh9IGFyZ3VtZW50IGlzIGFuIEVDSSAoQHNlZSAjaXNFQ0kpXG4gICAgICovXG4gICAgTWluaW1hbEVDSUlucHV0LnByb3RvdHlwZS5jaGFyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJycgKyBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNFQ0koaW5kZXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGF0ICcgKyBpbmRleCArICcgaXMgbm90IGEgY2hhcmFjdGVyIGJ1dCBhbiBFQ0knKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0ZOQzEoaW5kZXgpID8gdGhpcy5mbmMxIDogdGhpcy5ieXRlc1tpbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0Bjb2RlIENoYXJTZXF1ZW5jZX0gdGhhdCBpcyBhIHN1YnNlcXVlbmNlIG9mIHRoaXMgc2VxdWVuY2UuXG4gICAgICogVGhlIHN1YnNlcXVlbmNlIHN0YXJ0cyB3aXRoIHRoZSB7QGNvZGUgY2hhcn0gdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBhbmRcbiAgICAgKiBlbmRzIHdpdGggdGhlIHtAY29kZSBjaGFyfSB2YWx1ZSBhdCBpbmRleCB7QGNvZGUgZW5kIC0gMX0uICBUaGUgbGVuZ3RoXG4gICAgICogKGluIHtAY29kZSBjaGFyfXMpIG9mIHRoZVxuICAgICAqIHJldHVybmVkIHNlcXVlbmNlIGlzIHtAY29kZSBlbmQgLSBzdGFydH0sIHNvIGlmIHtAY29kZSBzdGFydCA9PSBlbmR9XG4gICAgICogdGhlbiBhbiBlbXB0eSBzZXF1ZW5jZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHN0YXJ0ICAgdGhlIHN0YXJ0IGluZGV4LCBpbmNsdXNpdmVcbiAgICAgKiBAcGFyYW0gICBlbmQgICAgIHRoZSBlbmQgaW5kZXgsIGV4Y2x1c2l2ZVxuICAgICAqXG4gICAgICogQHJldHVybiAgdGhlIHNwZWNpZmllZCBzdWJzZXF1ZW5jZVxuICAgICAqXG4gICAgICogQHRocm93cyAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblxuICAgICAqICAgICAgICAgIGlmIHtAY29kZSBzdGFydH0gb3Ige0Bjb2RlIGVuZH0gYXJlIG5lZ2F0aXZlLFxuICAgICAqICAgICAgICAgIGlmIHtAY29kZSBlbmR9IGlzIGdyZWF0ZXIgdGhhbiB7QGNvZGUgbGVuZ3RoKCl9LFxuICAgICAqICAgICAgICAgIG9yIGlmIHtAY29kZSBzdGFydH0gaXMgZ3JlYXRlciB0aGFuIHtAY29kZSBlbmR9XG4gICAgICogQHRocm93cyAgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXG4gICAgICogICAgICAgICAgaWYgYSB2YWx1ZSBpbiB0aGUgcmFuZ2Uge0Bjb2RlIHN0YXJ0fS17QGNvZGUgZW5kfSBpcyBhbiBFQ0kgKEBzZWUgI2lzRUNJKVxuICAgICAqL1xuICAgIE1pbmltYWxFQ0lJbnB1dC5wcm90b3R5cGUuc3ViU2VxdWVuY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID4gZW5kIHx8IGVuZCA+IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJyArIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VDSShpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgYXQgJyArIGkgKyAnIGlzIG5vdCBhIGNoYXJhY3RlciBidXQgYW4gRUNJJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuY2hhckF0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgdmFsdWUgaXMgYW4gRUNJXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB0cnVlIGlmIHRoZSB2YWx1ZSBhdCBwb3NpdGlvbiB7QGNvZGUgaW5kZXh9IGlzIGFuIEVDSVxuICAgICAqXG4gICAgICogQHRocm93cyAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblxuICAgICAqICAgICAgICAgIGlmIHRoZSB7QGNvZGUgaW5kZXh9IGFyZ3VtZW50IGlzIG5lZ2F0aXZlIG9yIG5vdCBsZXNzIHRoYW5cbiAgICAgKiAgICAgICAgICB7QGNvZGUgbGVuZ3RoKCl9XG4gICAgICovXG4gICAgTWluaW1hbEVDSUlucHV0LnByb3RvdHlwZS5pc0VDSSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJyArIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1tpbmRleF0gPiAyNTUgJiYgdGhpcy5ieXRlc1tpbmRleF0gPD0gOTk5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIHZhbHVlIGlzIHRoZSBGTkMxIGNoYXJhY3RlclxuICAgICAqXG4gICAgICogQHBhcmFtICAgaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybiAgdHJ1ZSBpZiB0aGUgdmFsdWUgYXQgcG9zaXRpb24ge0Bjb2RlIGluZGV4fSBpcyB0aGUgRk5DMSBjaGFyYWN0ZXJcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cbiAgICAgKiAgICAgICAgICBpZiB0aGUge0Bjb2RlIGluZGV4fSBhcmd1bWVudCBpcyBuZWdhdGl2ZSBvciBub3QgbGVzcyB0aGFuXG4gICAgICogICAgICAgICAge0Bjb2RlIGxlbmd0aCgpfVxuICAgICAqL1xuICAgIE1pbmltYWxFQ0lJbnB1dC5wcm90b3R5cGUuaXNGTkMxID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW2luZGV4XSA9PT0gMTAwMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAY29kZSBpbnR9IEVDSSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiAgQW4gaW5kZXggcmFuZ2VzIGZyb20gemVyb1xuICAgICAqIHRvIHtAY29kZSBsZW5ndGgoKSAtIDF9LiAgVGhlIGZpcnN0IHtAY29kZSBieXRlfSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgaXMgYXRcbiAgICAgKiBpbmRleCB6ZXJvLCB0aGUgbmV4dCBhdCBpbmRleCBvbmUsIGFuZCBzbyBvbiwgYXMgZm9yIGFycmF5XG4gICAgICogaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHtAY29kZSBpbnR9IHZhbHVlIHRvIGJlIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB0aGUgc3BlY2lmaWVkIHtAY29kZSBpbnR9IEVDSSB2YWx1ZS5cbiAgICAgKiAgICAgICAgICBUaGUgRUNJIHNwZWNpZmllZCB0aGUgZW5jb2Rpbmcgb2YgYWxsIGJ5dGVzIHdpdGggYSBoaWdoZXIgaW5kZXggdW50aWwgdGhlXG4gICAgICogICAgICAgICAgbmV4dCBFQ0kgb3IgdW50aWwgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaWYgbm8gb3RoZXIgRUNJIGZvbGxvd3MuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzICBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXG4gICAgICogICAgICAgICAgaWYgdGhlIHtAY29kZSBpbmRleH0gYXJndW1lbnQgaXMgbmVnYXRpdmUgb3Igbm90IGxlc3MgdGhhblxuICAgICAqICAgICAgICAgIHtAY29kZSBsZW5ndGgoKX1cbiAgICAgKiBAdGhyb3dzICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cbiAgICAgKiAgICAgICAgICBpZiB0aGUgdmFsdWUgYXQgdGhlIHtAY29kZSBpbmRleH0gYXJndW1lbnQgaXMgbm90IGFuIEVDSSAoQHNlZSAjaXNFQ0kpXG4gICAgICovXG4gICAgTWluaW1hbEVDSUlucHV0LnByb3RvdHlwZS5nZXRFQ0lWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJyArIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNFQ0koaW5kZXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGF0ICcgKyBpbmRleCArICcgaXMgbm90IGFuIEVDSSBidXQgYSBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1tpbmRleF0gLSAyNTY7XG4gICAgfTtcbiAgICBNaW5pbWFsRUNJSW5wdXQucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbiAoZWRnZXMsIHRvLCBlZGdlKSB7XG4gICAgICAgIGlmIChlZGdlc1t0b11bZWRnZS5lbmNvZGVySW5kZXhdID09IG51bGwgfHxcbiAgICAgICAgICAgIGVkZ2VzW3RvXVtlZGdlLmVuY29kZXJJbmRleF0uY2FjaGVkVG90YWxTaXplID4gZWRnZS5jYWNoZWRUb3RhbFNpemUpIHtcbiAgICAgICAgICAgIGVkZ2VzW3RvXVtlZGdlLmVuY29kZXJJbmRleF0gPSBlZGdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNaW5pbWFsRUNJSW5wdXQucHJvdG90eXBlLmFkZEVkZ2VzID0gZnVuY3Rpb24gKHN0cmluZ1RvRW5jb2RlLCBlbmNvZGVyU2V0LCBlZGdlcywgZnJvbSwgcHJldmlvdXMsIGZuYzEpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyaW5nVG9FbmNvZGUuY2hhckF0KGZyb20pLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgIHZhciBlbmQgPSBlbmNvZGVyU2V0Lmxlbmd0aCgpO1xuICAgICAgICBpZiAoZW5jb2RlclNldC5nZXRQcmlvcml0eUVuY29kZXJJbmRleCgpID49IDAgJiZcbiAgICAgICAgICAgIChjaCA9PT0gZm5jMSB8fFxuICAgICAgICAgICAgICAgIGVuY29kZXJTZXQuY2FuRW5jb2RlKGNoLCBlbmNvZGVyU2V0LmdldFByaW9yaXR5RW5jb2RlckluZGV4KCkpKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBlbmNvZGVyU2V0LmdldFByaW9yaXR5RW5jb2RlckluZGV4KCk7XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gZm5jMSB8fCBlbmNvZGVyU2V0LmNhbkVuY29kZShjaCwgaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVkZ2UoZWRnZXMsIGZyb20gKyAxLCBuZXcgSW5wdXRFZGdlKGNoLCBlbmNvZGVyU2V0LCBpLCBwcmV2aW91cywgZm5jMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNaW5pbWFsRUNJSW5wdXQucHJvdG90eXBlLmVuY29kZU1pbmltYWxseSA9IGZ1bmN0aW9uIChzdHJpbmdUb0VuY29kZSwgZW5jb2RlclNldCwgZm5jMSkge1xuICAgICAgICB2YXIgaW5wdXRMZW5ndGggPSBzdHJpbmdUb0VuY29kZS5sZW5ndGg7XG4gICAgICAgIC8vIEFycmF5IHRoYXQgcmVwcmVzZW50cyB2ZXJ0aWNlcy4gVGhlcmUgaXMgYSB2ZXJ0ZXggZm9yIGV2ZXJ5IGNoYXJhY3RlciBhbmQgZW5jb2RpbmcuXG4gICAgICAgIHZhciBlZGdlcyA9IG5ldyBJbnB1dEVkZ2VbaW5wdXRMZW5ndGggKyAxXVtlbmNvZGVyU2V0Lmxlbmd0aCgpXSgpO1xuICAgICAgICB0aGlzLmFkZEVkZ2VzKHN0cmluZ1RvRW5jb2RlLCBlbmNvZGVyU2V0LCBlZGdlcywgMCwgbnVsbCwgZm5jMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGlucHV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5jb2RlclNldC5sZW5ndGgoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2ldW2pdICE9IG51bGwgJiYgaSA8IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZXMoc3RyaW5nVG9FbmNvZGUsIGVuY29kZXJTZXQsIGVkZ2VzLCBpLCBlZGdlc1tpXVtqXSwgZm5jMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3B0aW1pemUgbWVtb3J5IGJ5IHJlbW92aW5nIGVkZ2VzIHRoYXQgaGF2ZSBiZWVuIHBhc3NlZC5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5jb2RlclNldC5sZW5ndGgoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZWRnZXNbaSAtIDFdW2pdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluaW1hbEogPSAtMTtcbiAgICAgICAgdmFyIG1pbmltYWxTaXplID0gSW50ZWdlcl8xLmRlZmF1bHQuTUFYX1ZBTFVFO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuY29kZXJTZXQubGVuZ3RoKCk7IGorKykge1xuICAgICAgICAgICAgaWYgKGVkZ2VzW2lucHV0TGVuZ3RoXVtqXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpbnB1dExlbmd0aF1bal07XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuY2FjaGVkVG90YWxTaXplIDwgbWluaW1hbFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW1hbFNpemUgPSBlZGdlLmNhY2hlZFRvdGFsU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbWluaW1hbEogPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluaW1hbEogPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBlbmNvZGUgXCInICsgc3RyaW5nVG9FbmNvZGUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50c0FMID0gW107XG4gICAgICAgIHZhciBjdXJyZW50ID0gZWRnZXNbaW5wdXRMZW5ndGhdW21pbmltYWxKXTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICBpbnRzQUwudW5zaGlmdCgxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBieXRlcyA9IGVuY29kZXJTZXQuZW5jb2RlKGN1cnJlbnQuYywgY3VycmVudC5lbmNvZGVySW5kZXgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRzQUwudW5zaGlmdChieXRlc1tpXSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2aW91c0VuY29kZXJJbmRleCA9IGN1cnJlbnQucHJldmlvdXMgPT09IG51bGwgPyAwIDogY3VycmVudC5wcmV2aW91cy5lbmNvZGVySW5kZXg7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNFbmNvZGVySW5kZXggIT09IGN1cnJlbnQuZW5jb2RlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgaW50c0FMLnVuc2hpZnQoMjU2ICsgZW5jb2RlclNldC5nZXRFQ0lWYWx1ZShjdXJyZW50LmVuY29kZXJJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRzW2ldID0gaW50c0FMW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIE1pbmltYWxFQ0lJbnB1dDtcbn0oKSk7XG5leHBvcnRzLk1pbmltYWxFQ0lJbnB1dCA9IE1pbmltYWxFQ0lJbnB1dDtcbnZhciBJbnB1dEVkZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRFZGdlKGMsIGVuY29kZXJTZXQsIGVuY29kZXJJbmRleCwgcHJldmlvdXMsIGZuYzEpIHtcbiAgICAgICAgdGhpcy5jID0gYztcbiAgICAgICAgdGhpcy5lbmNvZGVyU2V0ID0gZW5jb2RlclNldDtcbiAgICAgICAgdGhpcy5lbmNvZGVySW5kZXggPSBlbmNvZGVySW5kZXg7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgdGhpcy5mbmMxID0gZm5jMTtcbiAgICAgICAgdGhpcy5jID0gYyA9PT0gZm5jMSA/IDEwMDAgOiBjO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuaXNGTkMxKCkgPyAxIDogZW5jb2RlclNldC5lbmNvZGUoYywgZW5jb2RlckluZGV4KS5sZW5ndGg7XG4gICAgICAgIHZhciBwcmV2aW91c0VuY29kZXJJbmRleCA9IHByZXZpb3VzID09PSBudWxsID8gMCA6IHByZXZpb3VzLmVuY29kZXJJbmRleDtcbiAgICAgICAgaWYgKHByZXZpb3VzRW5jb2RlckluZGV4ICE9PSBlbmNvZGVySW5kZXgpIHtcbiAgICAgICAgICAgIHNpemUgKz0gQ09TVF9QRVJfRUNJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBzaXplICs9IHByZXZpb3VzLmNhY2hlZFRvdGFsU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZFRvdGFsU2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIElucHV0RWRnZS5wcm90b3R5cGUuaXNGTkMxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jID09PSAxMDAwO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0RWRnZTtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\n/**\n * <p>This class implements a perspective transform in two dimensions. Given four source and four\n * destination points, it will compute the transformation implied between them. The code is based\n * directly upon section 3.4.2 of George Wolberg's \"Digital Image Warping\"; see pages 54-56.</p>\n *\n * @author Sean Owen\n */\nvar PerspectiveTransform = /** @class */ (function () {\n    function PerspectiveTransform(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {\n        this.a11 = a11;\n        this.a21 = a21;\n        this.a31 = a31;\n        this.a12 = a12;\n        this.a22 = a22;\n        this.a32 = a32;\n        this.a13 = a13;\n        this.a23 = a23;\n        this.a33 = a33;\n    }\n    PerspectiveTransform.quadrilateralToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {\n        var qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n        var sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n        return sToQ.times(qToS);\n    };\n    PerspectiveTransform.prototype.transformPoints = function (points) {\n        var max = points.length;\n        var a11 = this.a11;\n        var a12 = this.a12;\n        var a13 = this.a13;\n        var a21 = this.a21;\n        var a22 = this.a22;\n        var a23 = this.a23;\n        var a31 = this.a31;\n        var a32 = this.a32;\n        var a33 = this.a33;\n        for (var i = 0; i < max; i += 2) {\n            var x = points[i];\n            var y = points[i + 1];\n            var denominator = a13 * x + a23 * y + a33;\n            points[i] = (a11 * x + a21 * y + a31) / denominator;\n            points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n        }\n    };\n    PerspectiveTransform.prototype.transformPointsWithValues = function (xValues, yValues) {\n        var a11 = this.a11;\n        var a12 = this.a12;\n        var a13 = this.a13;\n        var a21 = this.a21;\n        var a22 = this.a22;\n        var a23 = this.a23;\n        var a31 = this.a31;\n        var a32 = this.a32;\n        var a33 = this.a33;\n        var n = xValues.length;\n        for (var i = 0; i < n; i++) {\n            var x = xValues[i];\n            var y = yValues[i];\n            var denominator = a13 * x + a23 * y + a33;\n            xValues[i] = (a11 * x + a21 * y + a31) / denominator;\n            yValues[i] = (a12 * x + a22 * y + a32) / denominator;\n        }\n    };\n    PerspectiveTransform.squareToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n        var dx3 = x0 - x1 + x2 - x3;\n        var dy3 = y0 - y1 + y2 - y3;\n        if (dx3 === 0.0 && dy3 === 0.0) {\n            // Affine\n            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n        }\n        else {\n            var dx1 = x1 - x2;\n            var dx2 = x3 - x2;\n            var dy1 = y1 - y2;\n            var dy2 = y3 - y2;\n            var denominator = dx1 * dy2 - dx2 * dy1;\n            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n        }\n    };\n    PerspectiveTransform.quadrilateralToSquare = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n        // Here, the adjoint serves as the inverse:\n        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();\n    };\n    PerspectiveTransform.prototype.buildAdjoint = function () {\n        // Adjoint is the transpose of the cofactor matrix:\n        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n    };\n    PerspectiveTransform.prototype.times = function (other) {\n        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n    };\n    return PerspectiveTransform;\n}());\nexports[\"default\"] = PerspectiveTransform;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vUGVyc3BlY3RpdmVUcmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2NvbW1vbi9QZXJzcGVjdGl2ZVRyYW5zZm9ybS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4vKipcbiAqIDxwPlRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIHBlcnNwZWN0aXZlIHRyYW5zZm9ybSBpbiB0d28gZGltZW5zaW9ucy4gR2l2ZW4gZm91ciBzb3VyY2UgYW5kIGZvdXJcbiAqIGRlc3RpbmF0aW9uIHBvaW50cywgaXQgd2lsbCBjb21wdXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbXBsaWVkIGJldHdlZW4gdGhlbS4gVGhlIGNvZGUgaXMgYmFzZWRcbiAqIGRpcmVjdGx5IHVwb24gc2VjdGlvbiAzLjQuMiBvZiBHZW9yZ2UgV29sYmVyZydzIFwiRGlnaXRhbCBJbWFnZSBXYXJwaW5nXCI7IHNlZSBwYWdlcyA1NC01Ni48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIFBlcnNwZWN0aXZlVHJhbnNmb3JtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcnNwZWN0aXZlVHJhbnNmb3JtKGExMSAvKmZsb2F0Ki8sIGEyMSAvKmZsb2F0Ki8sIGEzMSAvKmZsb2F0Ki8sIGExMiAvKmZsb2F0Ki8sIGEyMiAvKmZsb2F0Ki8sIGEzMiAvKmZsb2F0Ki8sIGExMyAvKmZsb2F0Ki8sIGEyMyAvKmZsb2F0Ki8sIGEzMyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgdGhpcy5hMTEgPSBhMTE7XG4gICAgICAgIHRoaXMuYTIxID0gYTIxO1xuICAgICAgICB0aGlzLmEzMSA9IGEzMTtcbiAgICAgICAgdGhpcy5hMTIgPSBhMTI7XG4gICAgICAgIHRoaXMuYTIyID0gYTIyO1xuICAgICAgICB0aGlzLmEzMiA9IGEzMjtcbiAgICAgICAgdGhpcy5hMTMgPSBhMTM7XG4gICAgICAgIHRoaXMuYTIzID0gYTIzO1xuICAgICAgICB0aGlzLmEzMyA9IGEzMztcbiAgICB9XG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCA9IGZ1bmN0aW9uICh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLywgeDBwIC8qZmxvYXQqLywgeTBwIC8qZmxvYXQqLywgeDFwIC8qZmxvYXQqLywgeTFwIC8qZmxvYXQqLywgeDJwIC8qZmxvYXQqLywgeTJwIC8qZmxvYXQqLywgeDNwIC8qZmxvYXQqLywgeTNwIC8qZmxvYXQqLykge1xuICAgICAgICB2YXIgcVRvUyA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1NxdWFyZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB2YXIgc1RvUSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MHAsIHkwcCwgeDFwLCB5MXAsIHgycCwgeTJwLCB4M3AsIHkzcCk7XG4gICAgICAgIHJldHVybiBzVG9RLnRpbWVzKHFUb1MpO1xuICAgIH07XG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgdmFyIG1heCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBhMTEgPSB0aGlzLmExMTtcbiAgICAgICAgdmFyIGExMiA9IHRoaXMuYTEyO1xuICAgICAgICB2YXIgYTEzID0gdGhpcy5hMTM7XG4gICAgICAgIHZhciBhMjEgPSB0aGlzLmEyMTtcbiAgICAgICAgdmFyIGEyMiA9IHRoaXMuYTIyO1xuICAgICAgICB2YXIgYTIzID0gdGhpcy5hMjM7XG4gICAgICAgIHZhciBhMzEgPSB0aGlzLmEzMTtcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuYTMyO1xuICAgICAgICB2YXIgYTMzID0gdGhpcy5hMzM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gYTEzICogeCArIGEyMyAqIHkgKyBhMzM7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICBwb2ludHNbaSArIDFdID0gKGExMiAqIHggKyBhMjIgKiB5ICsgYTMyKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnRzV2l0aFZhbHVlcyA9IGZ1bmN0aW9uICh4VmFsdWVzLCB5VmFsdWVzKSB7XG4gICAgICAgIHZhciBhMTEgPSB0aGlzLmExMTtcbiAgICAgICAgdmFyIGExMiA9IHRoaXMuYTEyO1xuICAgICAgICB2YXIgYTEzID0gdGhpcy5hMTM7XG4gICAgICAgIHZhciBhMjEgPSB0aGlzLmEyMTtcbiAgICAgICAgdmFyIGEyMiA9IHRoaXMuYTIyO1xuICAgICAgICB2YXIgYTIzID0gdGhpcy5hMjM7XG4gICAgICAgIHZhciBhMzEgPSB0aGlzLmEzMTtcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuYTMyO1xuICAgICAgICB2YXIgYTMzID0gdGhpcy5hMzM7XG4gICAgICAgIHZhciBuID0geFZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHhWYWx1ZXNbaV07XG4gICAgICAgICAgICB2YXIgeSA9IHlWYWx1ZXNbaV07XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgICAgICAgIHhWYWx1ZXNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB5VmFsdWVzW2ldID0gKGExMiAqIHggKyBhMjIgKiB5ICsgYTMyKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwgPSBmdW5jdGlvbiAoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgdmFyIGR4MyA9IHgwIC0geDEgKyB4MiAtIHgzO1xuICAgICAgICB2YXIgZHkzID0geTAgLSB5MSArIHkyIC0geTM7XG4gICAgICAgIGlmIChkeDMgPT09IDAuMCAmJiBkeTMgPT09IDAuMCkge1xuICAgICAgICAgICAgLy8gQWZmaW5lXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAsIHgyIC0geDEsIHgwLCB5MSAtIHkwLCB5MiAtIHkxLCB5MCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZHgxID0geDEgLSB4MjtcbiAgICAgICAgICAgIHZhciBkeDIgPSB4MyAtIHgyO1xuICAgICAgICAgICAgdmFyIGR5MSA9IHkxIC0geTI7XG4gICAgICAgICAgICB2YXIgZHkyID0geTMgLSB5MjtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IGR4MSAqIGR5MiAtIGR4MiAqIGR5MTtcbiAgICAgICAgICAgIHZhciBhMTMgPSAoZHgzICogZHkyIC0gZHgyICogZHkzKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgdmFyIGEyMyA9IChkeDEgKiBkeTMgLSBkeDMgKiBkeTEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAgKyBhMTMgKiB4MSwgeDMgLSB4MCArIGEyMyAqIHgzLCB4MCwgeTEgLSB5MCArIGExMyAqIHkxLCB5MyAtIHkwICsgYTIzICogeTMsIHkwLCBhMTMsIGEyMywgMS4wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvU3F1YXJlID0gZnVuY3Rpb24gKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovKSB7XG4gICAgICAgIC8vIEhlcmUsIHRoZSBhZGpvaW50IHNlcnZlcyBhcyB0aGUgaW52ZXJzZTpcbiAgICAgICAgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpLmJ1aWxkQWRqb2ludCgpO1xuICAgIH07XG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLmJ1aWxkQWRqb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWRqb2ludCBpcyB0aGUgdHJhbnNwb3NlIG9mIHRoZSBjb2ZhY3RvciBtYXRyaXg6XG4gICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMjIgKiB0aGlzLmEzMyAtIHRoaXMuYTIzICogdGhpcy5hMzIsIHRoaXMuYTIzICogdGhpcy5hMzEgLSB0aGlzLmEyMSAqIHRoaXMuYTMzLCB0aGlzLmEyMSAqIHRoaXMuYTMyIC0gdGhpcy5hMjIgKiB0aGlzLmEzMSwgdGhpcy5hMTMgKiB0aGlzLmEzMiAtIHRoaXMuYTEyICogdGhpcy5hMzMsIHRoaXMuYTExICogdGhpcy5hMzMgLSB0aGlzLmExMyAqIHRoaXMuYTMxLCB0aGlzLmExMiAqIHRoaXMuYTMxIC0gdGhpcy5hMTEgKiB0aGlzLmEzMiwgdGhpcy5hMTIgKiB0aGlzLmEyMyAtIHRoaXMuYTEzICogdGhpcy5hMjIsIHRoaXMuYTEzICogdGhpcy5hMjEgLSB0aGlzLmExMSAqIHRoaXMuYTIzLCB0aGlzLmExMSAqIHRoaXMuYTIyIC0gdGhpcy5hMTIgKiB0aGlzLmEyMSk7XG4gICAgfTtcbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGUudGltZXMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh0aGlzLmExMSAqIG90aGVyLmExMSArIHRoaXMuYTIxICogb3RoZXIuYTEyICsgdGhpcy5hMzEgKiBvdGhlci5hMTMsIHRoaXMuYTExICogb3RoZXIuYTIxICsgdGhpcy5hMjEgKiBvdGhlci5hMjIgKyB0aGlzLmEzMSAqIG90aGVyLmEyMywgdGhpcy5hMTEgKiBvdGhlci5hMzEgKyB0aGlzLmEyMSAqIG90aGVyLmEzMiArIHRoaXMuYTMxICogb3RoZXIuYTMzLCB0aGlzLmExMiAqIG90aGVyLmExMSArIHRoaXMuYTIyICogb3RoZXIuYTEyICsgdGhpcy5hMzIgKiBvdGhlci5hMTMsIHRoaXMuYTEyICogb3RoZXIuYTIxICsgdGhpcy5hMjIgKiBvdGhlci5hMjIgKyB0aGlzLmEzMiAqIG90aGVyLmEyMywgdGhpcy5hMTIgKiBvdGhlci5hMzEgKyB0aGlzLmEyMiAqIG90aGVyLmEzMiArIHRoaXMuYTMyICogb3RoZXIuYTMzLCB0aGlzLmExMyAqIG90aGVyLmExMSArIHRoaXMuYTIzICogb3RoZXIuYTEyICsgdGhpcy5hMzMgKiBvdGhlci5hMTMsIHRoaXMuYTEzICogb3RoZXIuYTIxICsgdGhpcy5hMjMgKiBvdGhlci5hMjIgKyB0aGlzLmEzMyAqIG90aGVyLmEyMywgdGhpcy5hMTMgKiBvdGhlci5hMzEgKyB0aGlzLmEyMyAqIG90aGVyLmEzMiArIHRoaXMuYTMzICogb3RoZXIuYTMzKTtcbiAgICB9O1xuICAgIHJldHVybiBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common {*/\n/*import java.nio.charset.Charset;*/\n/*import java.util.Map;*/\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar CharacterSetECI_1 = __webpack_require__(/*! ./CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\n/**\n * Common string-related functions.\n *\n * @author Sean Owen\n * @author Alex Dupre\n */\nvar StringUtils = /** @class */ (function () {\n    function StringUtils() {\n    }\n    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n    StringUtils.castAsNonUtf8Char = function (code, encoding) {\n        if (encoding === void 0) { encoding = null; }\n        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n        // you can see this method as a Java version of String.fromCharCode\n        var e = encoding ? encoding.getName() : this.ISO88591;\n        // use passed format (fromCharCode will return UTF8 encoding)\n        return StringEncoding_1.default.decode(new Uint8Array([code]), e);\n    };\n    /**\n     * @param bytes bytes encoding a string, whose encoding should be guessed\n     * @param hints decode hints if applicable\n     * @return name of guessed encoding; at the moment will only guess one of:\n     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n     *  default encoding if none of these can possibly be correct\n     */\n    StringUtils.guessEncoding = function (bytes, hints) {\n        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {\n            return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();\n        }\n        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n        // which should be by far the most common encodings.\n        var length = bytes.length;\n        var canBeISO88591 = true;\n        var canBeShiftJIS = true;\n        var canBeUTF8 = true;\n        var utf8BytesLeft = 0;\n        // int utf8LowChars = 0\n        var utf2BytesChars = 0;\n        var utf3BytesChars = 0;\n        var utf4BytesChars = 0;\n        var sjisBytesLeft = 0;\n        // int sjisLowChars = 0\n        var sjisKatakanaChars = 0;\n        // int sjisDoubleBytesChars = 0\n        var sjisCurKatakanaWordLength = 0;\n        var sjisCurDoubleBytesWordLength = 0;\n        var sjisMaxKatakanaWordLength = 0;\n        var sjisMaxDoubleBytesWordLength = 0;\n        // int isoLowChars = 0\n        // int isoHighChars = 0\n        var isoHighOther = 0;\n        var utf8bom = bytes.length > 3 &&\n            bytes[0] === /*(byte) */ 0xEF &&\n            bytes[1] === /*(byte) */ 0xBB &&\n            bytes[2] === /*(byte) */ 0xBF;\n        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\n            var value = bytes[i] & 0xFF;\n            // UTF-8 stuff\n            if (canBeUTF8) {\n                if (utf8BytesLeft > 0) {\n                    if ((value & 0x80) === 0) {\n                        canBeUTF8 = false;\n                    }\n                    else {\n                        utf8BytesLeft--;\n                    }\n                }\n                else if ((value & 0x80) !== 0) {\n                    if ((value & 0x40) === 0) {\n                        canBeUTF8 = false;\n                    }\n                    else {\n                        utf8BytesLeft++;\n                        if ((value & 0x20) === 0) {\n                            utf2BytesChars++;\n                        }\n                        else {\n                            utf8BytesLeft++;\n                            if ((value & 0x10) === 0) {\n                                utf3BytesChars++;\n                            }\n                            else {\n                                utf8BytesLeft++;\n                                if ((value & 0x08) === 0) {\n                                    utf4BytesChars++;\n                                }\n                                else {\n                                    canBeUTF8 = false;\n                                }\n                            }\n                        }\n                    }\n                } // else {\n                // utf8LowChars++\n                // }\n            }\n            // ISO-8859-1 stuff\n            if (canBeISO88591) {\n                if (value > 0x7F && value < 0xA0) {\n                    canBeISO88591 = false;\n                }\n                else if (value > 0x9F) {\n                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n                        isoHighOther++;\n                    } // else {\n                    // isoHighChars++\n                    // }\n                } // else {\n                // isoLowChars++\n                // }\n            }\n            // Shift_JIS stuff\n            if (canBeShiftJIS) {\n                if (sjisBytesLeft > 0) {\n                    if (value < 0x40 || value === 0x7F || value > 0xFC) {\n                        canBeShiftJIS = false;\n                    }\n                    else {\n                        sjisBytesLeft--;\n                    }\n                }\n                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n                    canBeShiftJIS = false;\n                }\n                else if (value > 0xA0 && value < 0xE0) {\n                    sjisKatakanaChars++;\n                    sjisCurDoubleBytesWordLength = 0;\n                    sjisCurKatakanaWordLength++;\n                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n                    }\n                }\n                else if (value > 0x7F) {\n                    sjisBytesLeft++;\n                    // sjisDoubleBytesChars++\n                    sjisCurKatakanaWordLength = 0;\n                    sjisCurDoubleBytesWordLength++;\n                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n                    }\n                }\n                else {\n                    // sjisLowChars++\n                    sjisCurKatakanaWordLength = 0;\n                    sjisCurDoubleBytesWordLength = 0;\n                }\n            }\n        }\n        if (canBeUTF8 && utf8BytesLeft > 0) {\n            canBeUTF8 = false;\n        }\n        if (canBeShiftJIS && sjisBytesLeft > 0) {\n            canBeShiftJIS = false;\n        }\n        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n            return StringUtils.UTF8;\n        }\n        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n            return StringUtils.SHIFT_JIS;\n        }\n        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n        // - If we saw\n        //   - only two consecutive katakana chars in the whole text, or\n        //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n        // - then we conclude Shift_JIS, else ISO-8859-1\n        if (canBeISO88591 && canBeShiftJIS) {\n            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length\n                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n        }\n        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n        if (canBeISO88591) {\n            return StringUtils.ISO88591;\n        }\n        if (canBeShiftJIS) {\n            return StringUtils.SHIFT_JIS;\n        }\n        if (canBeUTF8) {\n            return StringUtils.UTF8;\n        }\n        // Otherwise, we take a wild guess with platform encoding\n        return StringUtils.PLATFORM_DEFAULT_ENCODING;\n    };\n    /**\n     *\n     * @see https://stackoverflow.com/a/13439711/4367683\n     *\n     * @param append The new string to append.\n     * @param args Argumets values to be formated.\n     */\n    StringUtils.format = function (append) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var i = -1;\n        function callback(exp, p0, p1, p2, p3, p4) {\n            if (exp === '%%')\n                return '%';\n            if (args[++i] === undefined)\n                return undefined;\n            exp = p2 ? parseInt(p2.substr(1)) : undefined;\n            var base = p3 ? parseInt(p3.substr(1)) : undefined;\n            var val;\n            switch (p4) {\n                case 's':\n                    val = args[i];\n                    break;\n                case 'c':\n                    val = args[i][0];\n                    break;\n                case 'f':\n                    val = parseFloat(args[i]).toFixed(exp);\n                    break;\n                case 'p':\n                    val = parseFloat(args[i]).toPrecision(exp);\n                    break;\n                case 'e':\n                    val = parseFloat(args[i]).toExponential(exp);\n                    break;\n                case 'x':\n                    val = parseInt(args[i]).toString(base ? base : 16);\n                    break;\n                case 'd':\n                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                    break;\n            }\n            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n            var size = parseInt(p1); /* padding size */\n            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n            while (val.length < size)\n                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n            return val;\n        }\n        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n        return append.replace(regex, callback);\n    };\n    /**\n     *\n     */\n    StringUtils.getBytes = function (str, encoding) {\n        return StringEncoding_1.default.encode(str, encoding);\n    };\n    /**\n     * Returns the charcode at the specified index or at index zero.\n     */\n    StringUtils.getCharCode = function (str, index) {\n        if (index === void 0) { index = 0; }\n        return str.charCodeAt(index);\n    };\n    /**\n     * Returns char for given charcode\n     */\n    StringUtils.getCharAt = function (charCode) {\n        return String.fromCharCode(charCode);\n    };\n    StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // \"SJIS\"\n    StringUtils.GB2312 = 'GB2312';\n    StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // \"ISO8859_1\"\n    StringUtils.EUC_JP = 'EUC_JP';\n    StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // \"UTF8\"\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n    StringUtils.ASSUME_SHIFT_JIS = false;\n    return StringUtils;\n}());\nexports[\"default\"] = StringUtils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vU3RyaW5nVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLGtDQUFrQztBQUNsQyx1QkFBdUI7QUFDdkIsdUJBQXVCLG1CQUFPLENBQUMsOElBQW1CO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLHNKQUFtQjtBQUNuRCx1QkFBdUIsbUJBQU8sQ0FBQyx3SkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxTQUFTLGlCQUFpQixHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2REFBNkQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw2REFBNkQ7QUFDN0Q7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxpRUFBaUU7QUFDakUsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL1N0cmluZ1V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAoQykgMjAxMCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4vKmltcG9ydCBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQ7Ki9cbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4vQ2hhcmFjdGVyU2V0RUNJXCIpO1xudmFyIFN0cmluZ0VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcbi8qKlxuICogQ29tbW9uIHN0cmluZy1yZWxhdGVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBBbGV4IER1cHJlXG4gKi9cbnZhciBTdHJpbmdVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdVdGlscygpIHtcbiAgICB9XG4gICAgLy8gU0hJRlRfSklTLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORykgfHxcbiAgICAvLyBFVUNfSlAuZXF1YWxzSWdub3JlQ2FzZShQTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICBTdHJpbmdVdGlscy5jYXN0QXNOb25VdGY4Q2hhciA9IGZ1bmN0aW9uIChjb2RlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IG51bGw7IH1cbiAgICAgICAgLy8gSVNPIDg4NTktMSBpcyB0aGUgSmF2YSBkZWZhdWx0IGFzIFVURi04IGlzIEphdmFTY3JpcHRzXG4gICAgICAgIC8vIHlvdSBjYW4gc2VlIHRoaXMgbWV0aG9kIGFzIGEgSmF2YSB2ZXJzaW9uIG9mIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgdmFyIGUgPSBlbmNvZGluZyA/IGVuY29kaW5nLmdldE5hbWUoKSA6IHRoaXMuSVNPODg1OTE7XG4gICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZylcbiAgICAgICAgcmV0dXJuIFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoW2NvZGVdKSwgZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYnl0ZXMgYnl0ZXMgZW5jb2RpbmcgYSBzdHJpbmcsIHdob3NlIGVuY29kaW5nIHNob3VsZCBiZSBndWVzc2VkXG4gICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlXG4gICAgICogQHJldHVybiBuYW1lIG9mIGd1ZXNzZWQgZW5jb2Rpbmc7IGF0IHRoZSBtb21lbnQgd2lsbCBvbmx5IGd1ZXNzIG9uZSBvZjpcbiAgICAgKiAge0BsaW5rICNTSElGVF9KSVN9LCB7QGxpbmsgI1VURjh9LCB7QGxpbmsgI0lTTzg4NTkxfSwgb3IgdGhlIHBsYXRmb3JtXG4gICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdFxuICAgICAqL1xuICAgIFN0cmluZ1V0aWxzLmd1ZXNzRW5jb2RpbmcgPSBmdW5jdGlvbiAoYnl0ZXMsIGhpbnRzKSB7XG4gICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuQ0hBUkFDVEVSX1NFVCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igbm93LCBtZXJlbHkgdHJpZXMgdG8gZGlzdGluZ3Vpc2ggSVNPLTg4NTktMSwgVVRGLTggYW5kIFNoaWZ0X0pJUyxcbiAgICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGJ5IGZhciB0aGUgbW9zdCBjb21tb24gZW5jb2RpbmdzLlxuICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY2FuQmVJU084ODU5MSA9IHRydWU7XG4gICAgICAgIHZhciBjYW5CZVNoaWZ0SklTID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNhbkJlVVRGOCA9IHRydWU7XG4gICAgICAgIHZhciB1dGY4Qnl0ZXNMZWZ0ID0gMDtcbiAgICAgICAgLy8gaW50IHV0ZjhMb3dDaGFycyA9IDBcbiAgICAgICAgdmFyIHV0ZjJCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgdmFyIHV0ZjNCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgdmFyIHV0ZjRCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgdmFyIHNqaXNCeXRlc0xlZnQgPSAwO1xuICAgICAgICAvLyBpbnQgc2ppc0xvd0NoYXJzID0gMFxuICAgICAgICB2YXIgc2ppc0thdGFrYW5hQ2hhcnMgPSAwO1xuICAgICAgICAvLyBpbnQgc2ppc0RvdWJsZUJ5dGVzQ2hhcnMgPSAwXG4gICAgICAgIHZhciBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICB2YXIgc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgICAgIHZhciBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgLy8gaW50IGlzb0xvd0NoYXJzID0gMFxuICAgICAgICAvLyBpbnQgaXNvSGlnaENoYXJzID0gMFxuICAgICAgICB2YXIgaXNvSGlnaE90aGVyID0gMDtcbiAgICAgICAgdmFyIHV0Zjhib20gPSBieXRlcy5sZW5ndGggPiAzICYmXG4gICAgICAgICAgICBieXRlc1swXSA9PT0gLyooYnl0ZSkgKi8gMHhFRiAmJlxuICAgICAgICAgICAgYnl0ZXNbMV0gPT09IC8qKGJ5dGUpICovIDB4QkIgJiZcbiAgICAgICAgICAgIGJ5dGVzWzJdID09PSAvKihieXRlKSAqLyAweEJGO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiAoY2FuQmVJU084ODU5MSB8fCBjYW5CZVNoaWZ0SklTIHx8IGNhbkJlVVRGOCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgLy8gVVRGLTggc3R1ZmZcbiAgICAgICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodmFsdWUgJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg0MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MjApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMkJ5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgxMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmM0J5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MDgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY0Qnl0ZXNDaGFycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHV0ZjhMb3dDaGFycysrXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVNPLTg4NTktMSBzdHVmZlxuICAgICAgICAgICAgaWYgKGNhbkJlSVNPODg1OTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweDdGICYmIHZhbHVlIDwgMHhBMCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5CZUlTTzg4NTkxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweEMwIHx8IHZhbHVlID09PSAweEQ3IHx8IHZhbHVlID09PSAweEY3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc29IaWdoT3RoZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXNvSGlnaENoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaXNvTG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNoaWZ0X0pJUyBzdHVmZlxuICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2ppc0J5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHg0MCB8fCB2YWx1ZSA9PT0gMHg3RiB8fCB2YWx1ZSA+IDB4RkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMHg4MCB8fCB2YWx1ZSA9PT0gMHhBMCB8fCB2YWx1ZSA+IDB4RUYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4QTAgJiYgdmFsdWUgPCAweEUwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNqaXNLYXRha2FuYUNoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID4gc2ppc01heEthdGFrYW5hV29yZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA9IHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiAweDdGKSB7XG4gICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0RvdWJsZUJ5dGVzQ2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPSBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzamlzTG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVVURjggJiYgdXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWFzeSAtLSBpZiB0aGVyZSBpcyBCT00gb3IgYXQgbGVhc3QgMSB2YWxpZCBub3Qtc2luZ2xlIGJ5dGUgY2hhcmFjdGVyIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUgVVRGLTgpLCBkb25lXG4gICAgICAgIGlmIChjYW5CZVVURjggJiYgKHV0Zjhib20gfHwgdXRmMkJ5dGVzQ2hhcnMgKyB1dGYzQnl0ZXNDaGFycyArIHV0ZjRCeXRlc0NoYXJzID4gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5VVEY4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVhc3kgLS0gaWYgYXNzdW1pbmcgU2hpZnRfSklTIG9yIGF0IGxlYXN0IDMgdmFsaWQgY29uc2VjdXRpdmUgbm90LWFzY2lpIGNoYXJhY3RlcnMgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSksIGRvbmVcbiAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMgJiYgKFN0cmluZ1V0aWxzLkFTU1VNRV9TSElGVF9KSVMgfHwgc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA+PSAzIHx8IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPj0gMykpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5TSElGVF9KSVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzdGluZ3Vpc2hpbmcgU2hpZnRfSklTIGFuZCBJU08tODg1OS0xIGNhbiBiZSBhIGxpdHRsZSB0b3VnaCBmb3Igc2hvcnQgd29yZHMuIFRoZSBjcnVkZSBoZXVyaXN0aWMgaXM6XG4gICAgICAgIC8vIC0gSWYgd2Ugc2F3XG4gICAgICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcbiAgICAgICAgLy8gICAtIGF0IGxlYXN0IDEwJSBvZiBieXRlcyB0aGF0IGNvdWxkIGJlIFwidXBwZXJcIiBub3QtYWxwaGFudW1lcmljIExhdGluMSxcbiAgICAgICAgLy8gLSB0aGVuIHdlIGNvbmNsdWRlIFNoaWZ0X0pJUywgZWxzZSBJU08tODg1OS0xXG4gICAgICAgIGlmIChjYW5CZUlTTzg4NTkxICYmIGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA9PT0gMiAmJiBzamlzS2F0YWthbmFDaGFycyA9PT0gMikgfHwgaXNvSGlnaE90aGVyICogMTAgPj0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBTdHJpbmdVdGlscy5TSElGVF9KSVMgOiBTdHJpbmdVdGlscy5JU084ODU5MTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRyeSBpbiBvcmRlciBJU08tODg1OS0xLCBTaGlmdCBKSVMsIFVURi04IGFuZCBmYWxsIGJhY2sgdG8gZGVmYXVsdCBwbGF0Zm9ybSBlbmNvZGluZ1xuICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLklTTzg4NTkxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5VVEY4O1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdGFrZSBhIHdpbGQgZ3Vlc3Mgd2l0aCBwbGF0Zm9ybSBlbmNvZGluZ1xuICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTM0Mzk3MTEvNDM2NzY4M1xuICAgICAqXG4gICAgICogQHBhcmFtIGFwcGVuZCBUaGUgbmV3IHN0cmluZyB0byBhcHBlbmQuXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1ldHMgdmFsdWVzIHRvIGJlIGZvcm1hdGVkLlxuICAgICAqL1xuICAgIFN0cmluZ1V0aWxzLmZvcm1hdCA9IGZ1bmN0aW9uIChhcHBlbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIGlmIChleHAgPT09ICclJScpXG4gICAgICAgICAgICAgICAgcmV0dXJuICclJztcbiAgICAgICAgICAgIGlmIChhcmdzWysraV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZXhwID0gcDIgPyBwYXJzZUludChwMi5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgc3dpdGNoIChwNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b1ByZWNpc2lvbihleHApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0V4cG9uZW50aWFsKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludChhcmdzW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJnc1tpXSwgYmFzZSA/IGJhc2UgOiAxMCkudG9QcmVjaXNpb24oZXhwKSkudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbCkgOiAoK3ZhbCkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHAxKTsgLyogcGFkZGluZyBzaXplICovXG4gICAgICAgICAgICB2YXIgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xuICAgICAgICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgICAgIHZhbCA9IHAwICE9PSB1bmRlZmluZWQgPyB2YWwgKyBjaCA6IGNoICsgdmFsOyAvKiBpc21pbnVzPyAqL1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnZXggPSAvJSgtKT8oMD9bMC05XSspPyhbLl1bMC05XSspPyhbI11bMC05XSspPyhbc2NmcGV4ZCVdKS9nO1xuICAgICAgICByZXR1cm4gYXBwZW5kLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgU3RyaW5nVXRpbHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShzdHIsIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXJjb2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgYXQgaW5kZXggemVyby5cbiAgICAgKi9cbiAgICBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSA9IGZ1bmN0aW9uIChzdHIsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgICAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjaGFyIGZvciBnaXZlbiBjaGFyY29kZVxuICAgICAqL1xuICAgIFN0cmluZ1V0aWxzLmdldENoYXJBdCA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgfTtcbiAgICBTdHJpbmdVdGlscy5TSElGVF9KSVMgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlNKSVMuZ2V0TmFtZSgpOyAvLyBcIlNKSVNcIlxuICAgIFN0cmluZ1V0aWxzLkdCMjMxMiA9ICdHQjIzMTInO1xuICAgIFN0cmluZ1V0aWxzLklTTzg4NTkxID0gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5JU084ODU5XzEuZ2V0TmFtZSgpOyAvLyBcIklTTzg4NTlfMVwiXG4gICAgU3RyaW5nVXRpbHMuRVVDX0pQID0gJ0VVQ19KUCc7XG4gICAgU3RyaW5nVXRpbHMuVVRGOCA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuVVRGOC5nZXROYW1lKCk7IC8vIFwiVVRGOFwiXG4gICAgU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyA9IFN0cmluZ1V0aWxzLlVURjg7IC8vIFwiVVRGOFwiLy9DaGFyc2V0LmRlZmF1bHRDaGFyc2V0KCkubmFtZSgpXG4gICAgU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyA9IGZhbHNlO1xuICAgIHJldHVybiBTdHJpbmdVdGlscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHJpbmdVdGlscztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2012 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common.detector {*/\n/**\n * General math-related and numeric utility functions.\n */\nvar MathUtils = /** @class */ (function () {\n    function MathUtils() {\n    }\n    /**\n     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its\n     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut\n     * differ slightly from {@link Math#round(float)} in that half rounds down for negative\n     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.\n     *\n     * @param d real value to round\n     * @return nearest {@code int}\n     */\n    MathUtils.round = function (d /*float*/) {\n        if (isNaN(d))\n            return 0;\n        if (d <= Number.MIN_SAFE_INTEGER)\n            return Number.MIN_SAFE_INTEGER;\n        if (d >= Number.MAX_SAFE_INTEGER)\n            return Number.MAX_SAFE_INTEGER;\n        return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;\n    };\n    // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js\n    /**\n     * @param aX point A x coordinate\n     * @param aY point A y coordinate\n     * @param bX point B x coordinate\n     * @param bY point B y coordinate\n     * @return Euclidean distance between points A and B\n     */\n    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {\n        var xDiff = aX - bX;\n        var yDiff = aY - bY;\n        return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    };\n    /**\n     * @param aX point A x coordinate\n     * @param aY point A y coordinate\n     * @param bX point B x coordinate\n     * @param bY point B y coordinate\n     * @return Euclidean distance between points A and B\n     */\n    // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {\n    //   const xDiff = aX - bX\n    //   const yDiff = aY - bY\n    //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    // }\n    /**\n     * @param array values to sum\n     * @return sum of values in array\n     */\n    MathUtils.sum = function (array) {\n        var count = 0;\n        for (var i = 0, length_1 = array.length; i !== length_1; i++) {\n            var a = array[i];\n            count += a;\n        }\n        return count;\n    };\n    return MathUtils;\n}());\nexports[\"default\"] = MathUtils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvY29tbW9uL2RldGVjdG9yL01hdGhVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IgeyovXG4vKipcbiAqIEdlbmVyYWwgbWF0aC1yZWxhdGVkIGFuZCBudW1lcmljIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG52YXIgTWF0aFV0aWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGhVdGlscygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5kcyB1cCBiZWluZyBhIGJpdCBmYXN0ZXIgdGhhbiB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9LiBUaGlzIG1lcmVseSByb3VuZHMgaXRzXG4gICAgICogYXJndW1lbnQgdG8gdGhlIG5lYXJlc3QgaW50LCB3aGVyZSB4LjUgcm91bmRzIHVwIHRvIHgrMS4gU2VtYW50aWNzIG9mIHRoaXMgc2hvcnRjdXRcbiAgICAgKiBkaWZmZXIgc2xpZ2h0bHkgZnJvbSB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9IGluIHRoYXQgaGFsZiByb3VuZHMgZG93biBmb3IgbmVnYXRpdmVcbiAgICAgKiB2YWx1ZXMuIC0yLjUgcm91bmRzIHRvIC0zLCBub3QgLTIuIEZvciBwdXJwb3NlcyBoZXJlIGl0IG1ha2VzIG5vIGRpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZCByZWFsIHZhbHVlIHRvIHJvdW5kXG4gICAgICogQHJldHVybiBuZWFyZXN0IHtAY29kZSBpbnR9XG4gICAgICovXG4gICAgTWF0aFV0aWxzLnJvdW5kID0gZnVuY3Rpb24gKGQgLypmbG9hdCovKSB7XG4gICAgICAgIGlmIChpc05hTihkKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAoZCA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUilcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKGQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHJldHVybiAvKihpbnQpICovIChkICsgKGQgPCAwLjAgPyAtMC41IDogMC41KSkgfCAwO1xuICAgIH07XG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IG1heWJlIHJlbW92ZSByb3VuZCBtZXRob2QgYW5kIGNhbGwgZGlyZWN0bHkgTWF0aC5yb3VuZCwgaXQgbG9va3MgbGlrZSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGpzXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGJYIHBvaW50IEIgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxuICAgICAqL1xuICAgIE1hdGhVdGlscy5kaXN0YW5jZSA9IGZ1bmN0aW9uIChhWCAvKmZsb2F0fGludCovLCBhWSAvKmZsb2F0fGludCovLCBiWCAvKmZsb2F0fGludCovLCBiWSAvKmZsb2F0fGludCovKSB7XG4gICAgICAgIHZhciB4RGlmZiA9IGFYIC0gYlg7XG4gICAgICAgIHZhciB5RGlmZiA9IGFZIC0gYlk7XG4gICAgICAgIHJldHVybiAvKihmbG9hdCkgKi8gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhWCBwb2ludCBBIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBhWSBwb2ludCBBIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBiWSBwb2ludCBCIHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4gRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIEEgYW5kIEJcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgc3RhdGljIGRpc3RhbmNlKGFYOiBudW1iZXIgLyppbnQqLywgYVk6IG51bWJlciAvKmludCovLCBiWDogbnVtYmVyIC8qaW50Ki8sIGJZOiBudW1iZXIgLyppbnQqLyk6IGZsb2F0IHtcbiAgICAvLyAgIGNvbnN0IHhEaWZmID0gYVggLSBiWFxuICAgIC8vICAgY29uc3QgeURpZmYgPSBhWSAtIGJZXG4gICAgLy8gICByZXR1cm4gKGZsb2F0KSBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bVxuICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlcyBpbiBhcnJheVxuICAgICAqL1xuICAgIE1hdGhVdGlscy5zdW0gPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYXJyYXkubGVuZ3RoOyBpICE9PSBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgY291bnQgKz0gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0aFV0aWxzO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdGhVdGlscztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common.detector {*/\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar MathUtils_1 = __webpack_require__(/*! ./MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\nvar WhiteRectangleDetector = /** @class */ (function () {\n    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n    // }\n    /**\n     * @param image barcode image to find a rectangle in\n     * @param initSize initial size of search area around center\n     * @param x x position of search center\n     * @param y y position of search center\n     * @throws NotFoundException if image is too small to accommodate {@code initSize}\n     */\n    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n        this.image = image;\n        this.height = image.getHeight();\n        this.width = image.getWidth();\n        if (undefined === initSize || null === initSize) {\n            initSize = WhiteRectangleDetector.INIT_SIZE;\n        }\n        if (undefined === x || null === x) {\n            x = image.getWidth() / 2 | 0;\n        }\n        if (undefined === y || null === y) {\n            y = image.getHeight() / 2 | 0;\n        }\n        var halfsize = initSize / 2 | 0;\n        this.leftInit = x - halfsize;\n        this.rightInit = x + halfsize;\n        this.upInit = y - halfsize;\n        this.downInit = y + halfsize;\n        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n            throw new NotFoundException_1.default();\n        }\n    }\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region.\n     * </p>\n     *\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    WhiteRectangleDetector.prototype.detect = function () {\n        var left = this.leftInit;\n        var right = this.rightInit;\n        var up = this.upInit;\n        var down = this.downInit;\n        var sizeExceeded = false;\n        var aBlackPointFoundOnBorder = true;\n        var atLeastOneBlackPointFoundOnBorder = false;\n        var atLeastOneBlackPointFoundOnRight = false;\n        var atLeastOneBlackPointFoundOnBottom = false;\n        var atLeastOneBlackPointFoundOnLeft = false;\n        var atLeastOneBlackPointFoundOnTop = false;\n        var width = this.width;\n        var height = this.height;\n        while (aBlackPointFoundOnBorder) {\n            aBlackPointFoundOnBorder = false;\n            // .....\n            // .   |\n            // .....\n            var rightBorderNotWhite = true;\n            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                if (rightBorderNotWhite) {\n                    right++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnRight = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnRight) {\n                    right++;\n                }\n            }\n            if (right >= width) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // .   .\n            // .___.\n            var bottomBorderNotWhite = true;\n            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                if (bottomBorderNotWhite) {\n                    down++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnBottom = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnBottom) {\n                    down++;\n                }\n            }\n            if (down >= height) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // |   .\n            // .....\n            var leftBorderNotWhite = true;\n            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                if (leftBorderNotWhite) {\n                    left--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnLeft = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnLeft) {\n                    left--;\n                }\n            }\n            if (left < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            // .___.\n            // .   .\n            // .....\n            var topBorderNotWhite = true;\n            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                if (topBorderNotWhite) {\n                    up--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnTop = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnTop) {\n                    up--;\n                }\n            }\n            if (up < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            if (aBlackPointFoundOnBorder) {\n                atLeastOneBlackPointFoundOnBorder = true;\n            }\n        }\n        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n            var maxSize = right - left;\n            var z = null;\n            for (var i = 1; z === null && i < maxSize; i++) {\n                z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n            }\n            if (z == null) {\n                throw new NotFoundException_1.default();\n            }\n            var t = null;\n            // go down right\n            for (var i = 1; t === null && i < maxSize; i++) {\n                t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n            }\n            if (t == null) {\n                throw new NotFoundException_1.default();\n            }\n            var x = null;\n            // go down left\n            for (var i = 1; x === null && i < maxSize; i++) {\n                x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n            }\n            if (x == null) {\n                throw new NotFoundException_1.default();\n            }\n            var y = null;\n            // go up left\n            for (var i = 1; y === null && i < maxSize; i++) {\n                y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n            }\n            if (y == null) {\n                throw new NotFoundException_1.default();\n            }\n            return this.centerEdges(y, z, x, t);\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n        var xStep = (bX - aX) / dist;\n        var yStep = (bY - aY) / dist;\n        var image = this.image;\n        for (var i = 0; i < dist; i++) {\n            var x = MathUtils_1.default.round(aX + i * xStep);\n            var y = MathUtils_1.default.round(aY + i * yStep);\n            if (image.get(x, y)) {\n                return new ResultPoint_1.default(x, y);\n            }\n        }\n        return null;\n    };\n    /**\n     * recenters the points of a constant distance towards the center\n     *\n     * @param y bottom most point\n     * @param z left most point\n     * @param x right most point\n     * @param t top most point\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     */\n    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n        //\n        //       t            t\n        //  z                      x\n        //        x    OR    z\n        //   y                    y\n        //\n        var yi = y.getX();\n        var yj = y.getY();\n        var zi = z.getX();\n        var zj = z.getY();\n        var xi = x.getX();\n        var xj = x.getY();\n        var ti = t.getX();\n        var tj = t.getY();\n        var CORR = WhiteRectangleDetector.CORR;\n        if (yi < this.width / 2.0) {\n            return [\n                new ResultPoint_1.default(ti - CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj + CORR),\n                new ResultPoint_1.default(xi - CORR, xj - CORR),\n                new ResultPoint_1.default(yi + CORR, yj - CORR)\n            ];\n        }\n        else {\n            return [\n                new ResultPoint_1.default(ti + CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj - CORR),\n                new ResultPoint_1.default(xi - CORR, xj + CORR),\n                new ResultPoint_1.default(yi - CORR, yj - CORR)\n            ];\n        }\n    };\n    /**\n     * Determines whether a segment contains a black point\n     *\n     * @param a          min value of the scanned coordinate\n     * @param b          max value of the scanned coordinate\n     * @param fixed      value of fixed coordinate\n     * @param horizontal set to true if scan must be horizontal, false if vertical\n     * @return true if a black point has been found, else false.\n     */\n    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n        var image = this.image;\n        if (horizontal) {\n            for (var x = a; x <= b; x++) {\n                if (image.get(x, fixed)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (var y = a; y <= b; y++) {\n                if (image.get(fixed, y)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n    return WhiteRectangleDetector;\n}());\nexports[\"default\"] = WhiteRectangleDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vZGV0ZWN0b3IvV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4Q0FBOEM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsMklBQW1CO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLG1KQUFhO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vZGV0ZWN0b3IvV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IgeyovXG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRQb2ludFwiKTtcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL01hdGhVdGlsc1wiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiA8cD5cbiAqIERldGVjdHMgYSBjYW5kaWRhdGUgYmFyY29kZS1saWtlIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aXRoaW4gYW4gaW1hZ2UuIEl0XG4gKiBzdGFydHMgYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIGltYWdlLCBpbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIGNhbmRpZGF0ZVxuICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLiBCeSBrZWVwaW5nIHRyYWNrIG9mIHRoZVxuICogbGFzdCBibGFjayBwb2ludHMgaXQgZW5jb3VudGVyZWQsIGl0IGRldGVybWluZXMgdGhlIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUuXG4gKiA8L3A+XG4gKlxuICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gKi9cbnZhciBXaGl0ZVJlY3RhbmdsZURldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGltYWdlOiBCaXRNYXRyaXgpIC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uKi8ge1xuICAgIC8vICAgdGhpcyhpbWFnZSwgSU5JVF9TSVpFLCBpbWFnZS5nZXRXaWR0aCgpIC8gMiwgaW1hZ2UuZ2V0SGVpZ2h0KCkgLyAyKVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW1hZ2UgYmFyY29kZSBpbWFnZSB0byBmaW5kIGEgcmVjdGFuZ2xlIGluXG4gICAgICogQHBhcmFtIGluaXRTaXplIGluaXRpYWwgc2l6ZSBvZiBzZWFyY2ggYXJlYSBhcm91bmQgY2VudGVyXG4gICAgICogQHBhcmFtIHggeCBwb3NpdGlvbiBvZiBzZWFyY2ggY2VudGVyXG4gICAgICogQHBhcmFtIHkgeSBwb3NpdGlvbiBvZiBzZWFyY2ggY2VudGVyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBpcyB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUge0Bjb2RlIGluaXRTaXplfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IoaW1hZ2UsIGluaXRTaXplIC8qaW50Ki8sIHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGluaXRTaXplIHx8IG51bGwgPT09IGluaXRTaXplKSB7XG4gICAgICAgICAgICBpbml0U2l6ZSA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuSU5JVF9TSVpFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHggfHwgbnVsbCA9PT0geCkge1xuICAgICAgICAgICAgeCA9IGltYWdlLmdldFdpZHRoKCkgLyAyIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB5IHx8IG51bGwgPT09IHkpIHtcbiAgICAgICAgICAgIHkgPSBpbWFnZS5nZXRIZWlnaHQoKSAvIDIgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYWxmc2l6ZSA9IGluaXRTaXplIC8gMiB8IDA7XG4gICAgICAgIHRoaXMubGVmdEluaXQgPSB4IC0gaGFsZnNpemU7XG4gICAgICAgIHRoaXMucmlnaHRJbml0ID0geCArIGhhbGZzaXplO1xuICAgICAgICB0aGlzLnVwSW5pdCA9IHkgLSBoYWxmc2l6ZTtcbiAgICAgICAgdGhpcy5kb3duSW5pdCA9IHkgKyBoYWxmc2l6ZTtcbiAgICAgICAgaWYgKHRoaXMudXBJbml0IDwgMCB8fCB0aGlzLmxlZnRJbml0IDwgMCB8fCB0aGlzLmRvd25Jbml0ID49IHRoaXMuaGVpZ2h0IHx8IHRoaXMucmlnaHRJbml0ID49IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiA8cD5cbiAgICAgKiBEZXRlY3RzIGEgY2FuZGlkYXRlIGJhcmNvZGUtbGlrZSByZWN0YW5ndWxhciByZWdpb24gd2l0aGluIGFuIGltYWdlLiBJdFxuICAgICAqIHN0YXJ0cyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgaW1hZ2UsIGluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgY2FuZGlkYXRlXG4gICAgICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0BsaW5rIFJlc3VsdFBvaW50fVtdIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHJlY3Rhbmd1bGFyXG4gICAgICogICAgICAgICByZWdpb24uIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9wcG9zZWQgb24gdGhlIGRpYWdvbmFsLCBhc1xuICAgICAqICAgICAgICAgYXJlIHRoZSBzZWNvbmQgYW5kIHRoaXJkLiBUaGUgZmlyc3QgcG9pbnQgd2lsbCBiZSB0aGUgdG9wbW9zdFxuICAgICAqICAgICAgICAgcG9pbnQgYW5kIHRoZSBsYXN0LCB0aGUgYm90dG9tbW9zdC4gVGhlIHNlY29uZCBwb2ludCB3aWxsIGJlXG4gICAgICogICAgICAgICBsZWZ0bW9zdCBhbmQgdGhlIHRoaXJkLCB0aGUgcmlnaHRtb3N0XG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBEYXRhIE1hdHJpeCBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAqL1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnRJbml0O1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0SW5pdDtcbiAgICAgICAgdmFyIHVwID0gdGhpcy51cEluaXQ7XG4gICAgICAgIHZhciBkb3duID0gdGhpcy5kb3duSW5pdDtcbiAgICAgICAgdmFyIHNpemVFeGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgdmFyIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IGZhbHNlO1xuICAgICAgICB2YXIgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCA9IGZhbHNlO1xuICAgICAgICB2YXIgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gZmFsc2U7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgd2hpbGUgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgLy8gLiAgIHxcbiAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICB2YXIgcmlnaHRCb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoKHJpZ2h0Qm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0KSAmJiByaWdodCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KHVwLCBkb3duLCByaWdodCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAvLyAuICAgLlxuICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgIHZhciBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoKGJvdHRvbUJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20pICYmIGRvd24gPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCBkb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG93bisrO1xuICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG93biA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgIC8vIHwgICAuXG4gICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgdmFyIGxlZnRCb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoKGxlZnRCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkgJiYgbGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGVmdEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQodXAsIGRvd24sIGxlZnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdEJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgIC8vIC4gICAuXG4gICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgdmFyIHRvcEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICgodG9wQm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblRvcCkgJiYgdXAgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRvcEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQobGVmdCwgcmlnaHQsIHVwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9wQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblRvcCkge1xuICAgICAgICAgICAgICAgICAgICB1cC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cCA8IDApIHtcbiAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xuICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaXplRXhjZWVkZWQgJiYgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyKSB7XG4gICAgICAgICAgICB2YXIgbWF4U2l6ZSA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIHZhciB6ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyB6ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KGxlZnQsIGRvd24gLSBpLCBsZWZ0ICsgaSwgZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZ28gZG93biByaWdodFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IHQgPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQobGVmdCwgdXAgKyBpLCBsZWZ0ICsgaSwgdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGdvIGRvd24gbGVmdFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IHggPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQocmlnaHQsIHVwICsgaSwgcmlnaHQgLSBpLCB1cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSBudWxsO1xuICAgICAgICAgICAgLy8gZ28gdXAgbGVmdFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IHkgPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQocmlnaHQsIGRvd24gLSBpLCByaWdodCAtIGksIGRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbnRlckVkZ2VzKHksIHosIHgsIHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLnByb3RvdHlwZS5nZXRCbGFja1BvaW50T25TZWdtZW50ID0gZnVuY3Rpb24gKGFYIC8qZmxvYXQqLywgYVkgLypmbG9hdCovLCBiWCAvKmZsb2F0Ki8sIGJZIC8qZmxvYXQqLykge1xuICAgICAgICB2YXIgZGlzdCA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoTWF0aFV0aWxzXzEuZGVmYXVsdC5kaXN0YW5jZShhWCwgYVksIGJYLCBiWSkpO1xuICAgICAgICB2YXIgeFN0ZXAgPSAoYlggLSBhWCkgLyBkaXN0O1xuICAgICAgICB2YXIgeVN0ZXAgPSAoYlkgLSBhWSkgLyBkaXN0O1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKGFYICsgaSAqIHhTdGVwKTtcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChhWSArIGkgKiB5U3RlcCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZWNlbnRlcnMgdGhlIHBvaW50cyBvZiBhIGNvbnN0YW50IGRpc3RhbmNlIHRvd2FyZHMgdGhlIGNlbnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHkgYm90dG9tIG1vc3QgcG9pbnRcbiAgICAgKiBAcGFyYW0geiBsZWZ0IG1vc3QgcG9pbnRcbiAgICAgKiBAcGFyYW0geCByaWdodCBtb3N0IHBvaW50XG4gICAgICogQHBhcmFtIHQgdG9wIG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtAbGluayBSZXN1bHRQb2ludH1bXSBkZXNjcmliaW5nIHRoZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5ndWxhclxuICAgICAqICAgICAgICAgcmVnaW9uLiBUaGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvcHBvc2VkIG9uIHRoZSBkaWFnb25hbCwgYXNcbiAgICAgKiAgICAgICAgIGFyZSB0aGUgc2Vjb25kIGFuZCB0aGlyZC4gVGhlIGZpcnN0IHBvaW50IHdpbGwgYmUgdGhlIHRvcG1vc3RcbiAgICAgKiAgICAgICAgIHBvaW50IGFuZCB0aGUgbGFzdCwgdGhlIGJvdHRvbW1vc3QuIFRoZSBzZWNvbmQgcG9pbnQgd2lsbCBiZVxuICAgICAqICAgICAgICAgbGVmdG1vc3QgYW5kIHRoZSB0aGlyZCwgdGhlIHJpZ2h0bW9zdFxuICAgICAqL1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IucHJvdG90eXBlLmNlbnRlckVkZ2VzID0gZnVuY3Rpb24gKHksIHosIHgsIHQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgdCAgICAgICAgICAgIHRcbiAgICAgICAgLy8gIHogICAgICAgICAgICAgICAgICAgICAgeFxuICAgICAgICAvLyAgICAgICAgeCAgICBPUiAgICB6XG4gICAgICAgIC8vICAgeSAgICAgICAgICAgICAgICAgICAgeVxuICAgICAgICAvL1xuICAgICAgICB2YXIgeWkgPSB5LmdldFgoKTtcbiAgICAgICAgdmFyIHlqID0geS5nZXRZKCk7XG4gICAgICAgIHZhciB6aSA9IHouZ2V0WCgpO1xuICAgICAgICB2YXIgemogPSB6LmdldFkoKTtcbiAgICAgICAgdmFyIHhpID0geC5nZXRYKCk7XG4gICAgICAgIHZhciB4aiA9IHguZ2V0WSgpO1xuICAgICAgICB2YXIgdGkgPSB0LmdldFgoKTtcbiAgICAgICAgdmFyIHRqID0gdC5nZXRZKCk7XG4gICAgICAgIHZhciBDT1JSID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5DT1JSO1xuICAgICAgICBpZiAoeWkgPCB0aGlzLndpZHRoIC8gMi4wKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQodGkgLSBDT1JSLCB0aiArIENPUlIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoemkgKyBDT1JSLCB6aiArIENPUlIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeGkgLSBDT1JSLCB4aiAtIENPUlIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeWkgKyBDT1JSLCB5aiAtIENPUlIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHRpICsgQ09SUiwgdGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHppICsgQ09SUiwgemogLSBDT1JSKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHhpIC0gQ09SUiwgeGogKyBDT1JSKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHlpIC0gQ09SUiwgeWogLSBDT1JSKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc2VnbWVudCBjb250YWlucyBhIGJsYWNrIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAgICAgICAgICBtaW4gdmFsdWUgb2YgdGhlIHNjYW5uZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBiICAgICAgICAgIG1heCB2YWx1ZSBvZiB0aGUgc2Nhbm5lZCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGZpeGVkICAgICAgdmFsdWUgb2YgZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBob3Jpem9udGFsIHNldCB0byB0cnVlIGlmIHNjYW4gbXVzdCBiZSBob3Jpem9udGFsLCBmYWxzZSBpZiB2ZXJ0aWNhbFxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGJsYWNrIHBvaW50IGhhcyBiZWVuIGZvdW5kLCBlbHNlIGZhbHNlLlxuICAgICAqL1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IucHJvdG90eXBlLmNvbnRhaW5zQmxhY2tQb2ludCA9IGZ1bmN0aW9uIChhIC8qaW50Ki8sIGIgLyppbnQqLywgZml4ZWQgLyppbnQqLywgaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IGE7IHggPD0gYjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCBmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IGE7IHkgPD0gYjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChmaXhlZCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuSU5JVF9TSVpFID0gMTA7XG4gICAgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5DT1JSID0gMTtcbiAgICByZXR1cm4gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBXaGl0ZVJlY3RhbmdsZURldGVjdG9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>This class contains utility methods for performing mathematical operations over\n * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n *\n * <p>Throughout this package, elements of the GF are represented as an {@code int}\n * for convenience and speed (but at the cost of memory).\n * </p>\n *\n * @author Sean Owen\n * @author David Olivier\n */\nvar AbstractGenericGF = /** @class */ (function () {\n    function AbstractGenericGF() {\n    }\n    /**\n     * @return 2 to the power of a in GF(size)\n     */\n    AbstractGenericGF.prototype.exp = function (a) {\n        return this.expTable[a];\n    };\n    /**\n     * @return base 2 log of a in GF(size)\n     */\n    AbstractGenericGF.prototype.log = function (a /*int*/) {\n        if (a === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return this.logTable[a];\n    };\n    /**\n     * Implements both addition and subtraction -- they are the same in GF(size).\n     *\n     * @return sum/difference of a and b\n     */\n    AbstractGenericGF.addOrSubtract = function (a /*int*/, b /*int*/) {\n        return a ^ b;\n    };\n    return AbstractGenericGF;\n}());\nexports[\"default\"] = AbstractGenericGF;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vQWJzdHJhY3RHZW5lcmljR0YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vQWJzdHJhY3RHZW5lcmljR0YuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG4vKipcbiAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBwZXJmb3JtaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIG92ZXJcbiAqIHRoZSBHYWxvaXMgRmllbGRzLiBPcGVyYXRpb25zIHVzZSBhIGdpdmVuIHByaW1pdGl2ZSBwb2x5bm9taWFsIGluIGNhbGN1bGF0aW9ucy48L3A+XG4gKlxuICogPHA+VGhyb3VnaG91dCB0aGlzIHBhY2thZ2UsIGVsZW1lbnRzIG9mIHRoZSBHRiBhcmUgcmVwcmVzZW50ZWQgYXMgYW4ge0Bjb2RlIGludH1cbiAqIGZvciBjb252ZW5pZW5jZSBhbmQgc3BlZWQgKGJ1dCBhdCB0aGUgY29zdCBvZiBtZW1vcnkpLlxuICogPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAqL1xudmFyIEFic3RyYWN0R2VuZXJpY0dGID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0R2VuZXJpY0dGKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIDIgdG8gdGhlIHBvd2VyIG9mIGEgaW4gR0Yoc2l6ZSlcbiAgICAgKi9cbiAgICBBYnN0cmFjdEdlbmVyaWNHRi5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGJhc2UgMiBsb2cgb2YgYSBpbiBHRihzaXplKVxuICAgICAqL1xuICAgIEFic3RyYWN0R2VuZXJpY0dGLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoYSAvKmludCovKSB7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBib3RoIGFkZGl0aW9uIGFuZCBzdWJ0cmFjdGlvbiAtLSB0aGV5IGFyZSB0aGUgc2FtZSBpbiBHRihzaXplKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3VtL2RpZmZlcmVuY2Ugb2YgYSBhbmQgYlxuICAgICAqL1xuICAgIEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIGEgXiBiO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0R2VuZXJpY0dGO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0R2VuZXJpY0dGO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js\");\nvar AbstractGenericGF_1 = __webpack_require__(/*! ./AbstractGenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ArithmeticException_1 = __webpack_require__(/*! ../../ArithmeticException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js\");\n/**\n * <p>This class contains utility methods for performing mathematical operations over\n * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n *\n * <p>Throughout this package, elements of the GF are represented as an {@code int}\n * for convenience and speed (but at the cost of memory).\n * </p>\n *\n * @author Sean Owen\n * @author David Olivier\n */\nvar GenericGF = /** @class */ (function (_super) {\n    __extends(GenericGF, _super);\n    /**\n     * Create a representation of GF(size) using the given primitive polynomial.\n     *\n     * @param primitive irreducible polynomial whose coefficients are represented by\n     *  the bits of an int, where the least-significant bit represents the constant\n     *  coefficient\n     * @param size the size of the field\n     * @param b the factor b in the generator polynomial can be 0- or 1-based\n     *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).\n     *  In most cases it should be 1, but for QR code it is 0.\n     */\n    function GenericGF(primitive /*int*/, size /*int*/, generatorBase /*int*/) {\n        var _this = _super.call(this) || this;\n        _this.primitive = primitive;\n        _this.size = size;\n        _this.generatorBase = generatorBase;\n        var expTable = new Int32Array(size);\n        var x = 1;\n        for (var i = 0; i < size; i++) {\n            expTable[i] = x;\n            x *= 2; // we're assuming the generator alpha is 2\n            if (x >= size) {\n                x ^= primitive;\n                x &= size - 1;\n            }\n        }\n        _this.expTable = expTable;\n        var logTable = new Int32Array(size);\n        for (var i = 0; i < size - 1; i++) {\n            logTable[expTable[i]] = i;\n        }\n        _this.logTable = logTable;\n        // logTable[0] == 0 but this should never be used\n        _this.zero = new GenericGFPoly_1.default(_this, Int32Array.from([0]));\n        _this.one = new GenericGFPoly_1.default(_this, Int32Array.from([1]));\n        return _this;\n    }\n    GenericGF.prototype.getZero = function () {\n        return this.zero;\n    };\n    GenericGF.prototype.getOne = function () {\n        return this.one;\n    };\n    /**\n     * @return the monomial representing coefficient * x^degree\n     */\n    GenericGF.prototype.buildMonomial = function (degree /*int*/, coefficient /*int*/) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return this.zero;\n        }\n        var coefficients = new Int32Array(degree + 1);\n        coefficients[0] = coefficient;\n        return new GenericGFPoly_1.default(this, coefficients);\n    };\n    /**\n     * @return multiplicative inverse of a\n     */\n    GenericGF.prototype.inverse = function (a /*int*/) {\n        if (a === 0) {\n            throw new ArithmeticException_1.default();\n        }\n        return this.expTable[this.size - this.logTable[a] - 1];\n    };\n    /**\n     * @return product of a and b in GF(size)\n     */\n    GenericGF.prototype.multiply = function (a /*int*/, b /*int*/) {\n        if (a === 0 || b === 0) {\n            return 0;\n        }\n        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];\n    };\n    GenericGF.prototype.getSize = function () {\n        return this.size;\n    };\n    GenericGF.prototype.getGeneratorBase = function () {\n        return this.generatorBase;\n    };\n    /*@Override*/\n    GenericGF.prototype.toString = function () {\n        return ('GF(0x' + Integer_1.default.toHexString(this.primitive) + ',' + this.size + ')');\n    };\n    GenericGF.prototype.equals = function (o) {\n        return o === this;\n    };\n    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;\n    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;\n    return GenericGF;\n}(AbstractGenericGF_1.default));\nexports[\"default\"] = GenericGF;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaURBQWlEO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLDhKQUFpQjtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyxzS0FBcUI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsNklBQW9CO0FBQzVDLGlDQUFpQyxtQkFBTyxDQUFDLHFLQUFnQztBQUN6RSw0QkFBNEIsbUJBQU8sQ0FBQywySkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCw2REFBNkQ7QUFDN0QseURBQXlEO0FBQ3pELHdEQUF3RDtBQUN4RCxpRUFBaUU7QUFDakUscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uIHsqL1xudmFyIEdlbmVyaWNHRlBvbHlfMSA9IHJlcXVpcmUoXCIuL0dlbmVyaWNHRlBvbHlcIik7XG52YXIgQWJzdHJhY3RHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0R2VuZXJpY0dGXCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIEFyaXRobWV0aWNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Bcml0aG1ldGljRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyXG4gKiB0aGUgR2Fsb2lzIEZpZWxkcy4gT3BlcmF0aW9ucyB1c2UgYSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbCBpbiBjYWxjdWxhdGlvbnMuPC9wPlxuICpcbiAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9XG4gKiBmb3IgY29udmVuaWVuY2UgYW5kIHNwZWVkIChidXQgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5KS5cbiAqIDwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gKi9cbnZhciBHZW5lcmljR0YgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyaWNHRiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZXByZXNlbnRhdGlvbiBvZiBHRihzaXplKSB1c2luZyB0aGUgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJpbWl0aXZlIGlycmVkdWNpYmxlIHBvbHlub21pYWwgd2hvc2UgY29lZmZpY2llbnRzIGFyZSByZXByZXNlbnRlZCBieVxuICAgICAqICB0aGUgYml0cyBvZiBhbiBpbnQsIHdoZXJlIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgY29uc3RhbnRcbiAgICAgKiAgY29lZmZpY2llbnRcbiAgICAgKiBAcGFyYW0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZmllbGRcbiAgICAgKiBAcGFyYW0gYiB0aGUgZmFjdG9yIGIgaW4gdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsIGNhbiBiZSAwLSBvciAxLWJhc2VkXG4gICAgICogIChnKHgpID0gKHgrYV5iKSh4K2FeKGIrMSkpLi4uKHgrYV4oYisydC0xKSkpLlxuICAgICAqICBJbiBtb3N0IGNhc2VzIGl0IHNob3VsZCBiZSAxLCBidXQgZm9yIFFSIGNvZGUgaXQgaXMgMC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmljR0YocHJpbWl0aXZlIC8qaW50Ki8sIHNpemUgLyppbnQqLywgZ2VuZXJhdG9yQmFzZSAvKmludCovKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgX3RoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIF90aGlzLmdlbmVyYXRvckJhc2UgPSBnZW5lcmF0b3JCYXNlO1xuICAgICAgICB2YXIgZXhwVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgdmFyIHggPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgZXhwVGFibGVbaV0gPSB4O1xuICAgICAgICAgICAgeCAqPSAyOyAvLyB3ZSdyZSBhc3N1bWluZyB0aGUgZ2VuZXJhdG9yIGFscGhhIGlzIDJcbiAgICAgICAgICAgIGlmICh4ID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICB4IF49IHByaW1pdGl2ZTtcbiAgICAgICAgICAgICAgICB4ICY9IHNpemUgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmV4cFRhYmxlID0gZXhwVGFibGU7XG4gICAgICAgIHZhciBsb2dUYWJsZSA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemUgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxvZ1RhYmxlW2V4cFRhYmxlW2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9nVGFibGUgPSBsb2dUYWJsZTtcbiAgICAgICAgLy8gbG9nVGFibGVbMF0gPT0gMCBidXQgdGhpcyBzaG91bGQgbmV2ZXIgYmUgdXNlZFxuICAgICAgICBfdGhpcy56ZXJvID0gbmV3IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0KF90aGlzLCBJbnQzMkFycmF5LmZyb20oWzBdKSk7XG4gICAgICAgIF90aGlzLm9uZSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChfdGhpcywgSW50MzJBcnJheS5mcm9tKFsxXSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZ2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICB9O1xuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZ2V0T25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRoZSBtb25vbWlhbCByZXByZXNlbnRpbmcgY29lZmZpY2llbnQgKiB4XmRlZ3JlZVxuICAgICAqL1xuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuYnVpbGRNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykge1xuICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGRlZ3JlZSArIDEpO1xuICAgICAgICBjb2VmZmljaWVudHNbMF0gPSBjb2VmZmljaWVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdCh0aGlzLCBjb2VmZmljaWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGFcbiAgICAgKi9cbiAgICBHZW5lcmljR0YucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiAoYSAvKmludCovKSB7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLnNpemUgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHByb2R1Y3Qgb2YgYSBhbmQgYiBpbiBHRihzaXplKVxuICAgICAqL1xuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLnNpemUgLSAxKV07XG4gICAgfTtcbiAgICBHZW5lcmljR0YucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfTtcbiAgICBHZW5lcmljR0YucHJvdG90eXBlLmdldEdlbmVyYXRvckJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvckJhc2U7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgR2VuZXJpY0dGLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgnR0YoMHgnICsgSW50ZWdlcl8xLmRlZmF1bHQudG9IZXhTdHJpbmcodGhpcy5wcmltaXRpdmUpICsgJywnICsgdGhpcy5zaXplICsgJyknKTtcbiAgICB9O1xuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gPT09IHRoaXM7XG4gICAgfTtcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV8xMiA9IG5ldyBHZW5lcmljR0YoMHgxMDY5LCA0MDk2LCAxKTsgLy8geF4xMiArIHheNiArIHheNSArIHheMyArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV8xMCA9IG5ldyBHZW5lcmljR0YoMHg0MDksIDEwMjQsIDEpOyAvLyB4XjEwICsgeF4zICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzYgPSBuZXcgR2VuZXJpY0dGKDB4NDMsIDY0LCAxKTsgLy8geF42ICsgeCArIDFcbiAgICBHZW5lcmljR0YuQVpURUNfUEFSQU0gPSBuZXcgR2VuZXJpY0dGKDB4MTMsIDE2LCAxKTsgLy8geF40ICsgeCArIDFcbiAgICBHZW5lcmljR0YuUVJfQ09ERV9GSUVMRF8yNTYgPSBuZXcgR2VuZXJpY0dGKDB4MDExZCwgMjU2LCAwKTsgLy8geF44ICsgeF40ICsgeF4zICsgeF4yICsgMVxuICAgIEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTYgPSBuZXcgR2VuZXJpY0dGKDB4MDEyZCwgMjU2LCAxKTsgLy8geF44ICsgeF41ICsgeF4zICsgeF4yICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzggPSBHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2O1xuICAgIEdlbmVyaWNHRi5NQVhJQ09ERV9GSUVMRF82NCA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzY7XG4gICAgcmV0dXJuIEdlbmVyaWNHRjtcbn0oQWJzdHJhY3RHZW5lcmljR0ZfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHZW5lcmljR0Y7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js":
/*!****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar AbstractGenericGF_1 = __webpack_require__(/*! ./AbstractGenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js\");\nvar System_1 = __webpack_require__(/*! ../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>Represents a polynomial whose coefficients are elements of a GF.\n * Instances of this class are immutable.</p>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n */\nvar GenericGFPoly = /** @class */ (function () {\n    /**\n     * @param field the {@link GenericGF} instance representing the field to use\n     * to perform computations\n     * @param coefficients coefficients as ints representing elements of GF(size), arranged\n     * from most significant (highest-power term) coefficient to least significant\n     * @throws IllegalArgumentException if argument is null or empty,\n     * or if leading coefficient is 0 and this is not a\n     * constant polynomial (that is, it is not the monomial \"0\")\n     */\n    function GenericGFPoly(field, coefficients) {\n        if (coefficients.length === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        this.field = field;\n        var coefficientsLength = coefficients.length;\n        if (coefficientsLength > 1 && coefficients[0] === 0) {\n            // Leading term must be non-zero for anything except the constant polynomial \"0\"\n            var firstNonZero = 1;\n            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                firstNonZero++;\n            }\n            if (firstNonZero === coefficientsLength) {\n                this.coefficients = Int32Array.from([0]);\n            }\n            else {\n                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n            }\n        }\n        else {\n            this.coefficients = coefficients;\n        }\n    }\n    GenericGFPoly.prototype.getCoefficients = function () {\n        return this.coefficients;\n    };\n    /**\n     * @return degree of this polynomial\n     */\n    GenericGFPoly.prototype.getDegree = function () {\n        return this.coefficients.length - 1;\n    };\n    /**\n     * @return true iff this polynomial is the monomial \"0\"\n     */\n    GenericGFPoly.prototype.isZero = function () {\n        return this.coefficients[0] === 0;\n    };\n    /**\n     * @return coefficient of x^degree term in this polynomial\n     */\n    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {\n        return this.coefficients[this.coefficients.length - 1 - degree];\n    };\n    /**\n     * @return evaluation of this polynomial at a given point\n     */\n    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {\n        if (a === 0) {\n            // Just return the x^0 coefficient\n            return this.getCoefficient(0);\n        }\n        var coefficients = this.coefficients;\n        var result;\n        if (a === 1) {\n            // Just the sum of the coefficients\n            result = 0;\n            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {\n                var coefficient = coefficients[i];\n                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);\n            }\n            return result;\n        }\n        result = coefficients[0];\n        var size = coefficients.length;\n        var field = this.field;\n        for (var i = 1; i < size; i++) {\n            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);\n        }\n        return result;\n    };\n    GenericGFPoly.prototype.addOrSubtract = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero()) {\n            return other;\n        }\n        if (other.isZero()) {\n            return this;\n        }\n        var smallerCoefficients = this.coefficients;\n        var largerCoefficients = other.coefficients;\n        if (smallerCoefficients.length > largerCoefficients.length) {\n            var temp = smallerCoefficients;\n            smallerCoefficients = largerCoefficients;\n            largerCoefficients = temp;\n        }\n        var sumDiff = new Int32Array(largerCoefficients.length);\n        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n        // Copy high-order terms only found in higher-degree polynomial's coefficients\n        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n        for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n            sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n        }\n        return new GenericGFPoly(this.field, sumDiff);\n    };\n    GenericGFPoly.prototype.multiply = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero() || other.isZero()) {\n            return this.field.getZero();\n        }\n        var aCoefficients = this.coefficients;\n        var aLength = aCoefficients.length;\n        var bCoefficients = other.coefficients;\n        var bLength = bCoefficients.length;\n        var product = new Int32Array(aLength + bLength - 1);\n        var field = this.field;\n        for (var i = 0; i < aLength; i++) {\n            var aCoeff = aCoefficients[i];\n            for (var j = 0; j < bLength; j++) {\n                product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n            }\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {\n        if (scalar === 0) {\n            return this.field.getZero();\n        }\n        if (scalar === 1) {\n            return this;\n        }\n        var size = this.coefficients.length;\n        var field = this.field;\n        var product = new Int32Array(size);\n        var coefficients = this.coefficients;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], scalar);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return this.field.getZero();\n        }\n        var coefficients = this.coefficients;\n        var size = coefficients.length;\n        var product = new Int32Array(size + degree);\n        var field = this.field;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], coefficient);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.divide = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (other.isZero()) {\n            throw new IllegalArgumentException_1.default('Divide by 0');\n        }\n        var field = this.field;\n        var quotient = field.getZero();\n        var remainder = this;\n        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            var degreeDifference = remainder.getDegree() - other.getDegree();\n            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            var term = other.multiplyByMonomial(degreeDifference, scale);\n            var iterationQuotient = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.addOrSubtract(iterationQuotient);\n            remainder = remainder.addOrSubtract(term);\n        }\n        return [quotient, remainder];\n    };\n    /*@Override*/\n    GenericGFPoly.prototype.toString = function () {\n        var result = '';\n        for (var degree = this.getDegree(); degree >= 0; degree--) {\n            var coefficient = this.getCoefficient(degree);\n            if (coefficient !== 0) {\n                if (coefficient < 0) {\n                    result += ' - ';\n                    coefficient = -coefficient;\n                }\n                else {\n                    if (result.length > 0) {\n                        result += ' + ';\n                    }\n                }\n                if (degree === 0 || coefficient !== 1) {\n                    var alphaPower = this.field.log(coefficient);\n                    if (alphaPower === 0) {\n                        result += '1';\n                    }\n                    else if (alphaPower === 1) {\n                        result += 'a';\n                    }\n                    else {\n                        result += 'a^';\n                        result += alphaPower;\n                    }\n                }\n                if (degree !== 0) {\n                    if (degree === 1) {\n                        result += 'x';\n                    }\n                    else {\n                        result += 'x^';\n                        result += degree;\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    return GenericGFPoly;\n}());\nexports[\"default\"] = GenericGFPoly;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGUG9seS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpREFBaUQ7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsc0tBQXFCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQywySUFBbUI7QUFDMUMsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGUG9seS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24geyovXG52YXIgQWJzdHJhY3RHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0R2VuZXJpY0dGXCIpO1xudmFyIFN5c3RlbV8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3lzdGVtXCIpO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qKlxuICogPHA+UmVwcmVzZW50cyBhIHBvbHlub21pYWwgd2hvc2UgY29lZmZpY2llbnRzIGFyZSBlbGVtZW50cyBvZiBhIEdGLlxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGltbXV0YWJsZS48L3A+XG4gKlxuICogPHA+TXVjaCBjcmVkaXQgaXMgZHVlIHRvIFdpbGxpYW0gUnVja2xpZGdlIHNpbmNlIHBvcnRpb25zIG9mIHRoaXMgY29kZSBhcmUgYW4gaW5kaXJlY3RcbiAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBHZW5lcmljR0ZQb2x5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmaWVsZCB0aGUge0BsaW5rIEdlbmVyaWNHRn0gaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBmaWVsZCB0byB1c2VcbiAgICAgKiB0byBwZXJmb3JtIGNvbXB1dGF0aW9uc1xuICAgICAqIEBwYXJhbSBjb2VmZmljaWVudHMgY29lZmZpY2llbnRzIGFzIGludHMgcmVwcmVzZW50aW5nIGVsZW1lbnRzIG9mIEdGKHNpemUpLCBhcnJhbmdlZFxuICAgICAqIGZyb20gbW9zdCBzaWduaWZpY2FudCAoaGlnaGVzdC1wb3dlciB0ZXJtKSBjb2VmZmljaWVudCB0byBsZWFzdCBzaWduaWZpY2FudFxuICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGFyZ3VtZW50IGlzIG51bGwgb3IgZW1wdHksXG4gICAgICogb3IgaWYgbGVhZGluZyBjb2VmZmljaWVudCBpcyAwIGFuZCB0aGlzIGlzIG5vdCBhXG4gICAgICogY29uc3RhbnQgcG9seW5vbWlhbCAodGhhdCBpcywgaXQgaXMgbm90IHRoZSBtb25vbWlhbCBcIjBcIilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmljR0ZQb2x5KGZpZWxkLCBjb2VmZmljaWVudHMpIHtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB2YXIgY29lZmZpY2llbnRzTGVuZ3RoID0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBMZWFkaW5nIHRlcm0gbXVzdCBiZSBub24temVybyBmb3IgYW55dGhpbmcgZXhjZXB0IHRoZSBjb25zdGFudCBwb2x5bm9taWFsIFwiMFwiXG4gICAgICAgICAgICB2YXIgZmlyc3ROb25aZXJvID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gSW50MzJBcnJheS5mcm9tKFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7XG4gICAgICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoY29lZmZpY2llbnRzLCBmaXJzdE5vblplcm8sIHRoaXMuY29lZmZpY2llbnRzLCAwLCB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcbiAgICAgKi9cbiAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5nZXREZWdyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsIFwiMFwiXG4gICAgICovXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGNvZWZmaWNpZW50IG9mIHheZGVncmVlIHRlcm0gaW4gdGhpcyBwb2x5bm9taWFsXG4gICAgICovXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnQgPSBmdW5jdGlvbiAoZGVncmVlIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBldmFsdWF0aW9uIG9mIHRoaXMgcG9seW5vbWlhbCBhdCBhIGdpdmVuIHBvaW50XG4gICAgICovXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuZXZhbHVhdGVBdCA9IGZ1bmN0aW9uIChhIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGEgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgdGhlIHN1bSBvZiB0aGUgY29lZmZpY2llbnRzXG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gY29lZmZpY2llbnRzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRl8xLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChyZXN1bHQsIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdO1xuICAgICAgICB2YXIgc2l6ZSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRl8xLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChmaWVsZC5tdWx0aXBseShhLCByZXN1bHQpLCBjb2VmZmljaWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5hZGRPclN1YnRyYWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNtYWxsZXJDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgdmFyIGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgc21hbGxlckNvZWZmaWNpZW50cyA9IGxhcmdlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bURpZmYgPSBuZXcgSW50MzJBcnJheShsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGxlbmd0aERpZmYgPSBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShsYXJnZXJDb2VmZmljaWVudHMsIDAsIHN1bURpZmYsIDAsIGxlbmd0aERpZmYpO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoRGlmZjsgaSA8IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtRGlmZltpXSA9IEFic3RyYWN0R2VuZXJpY0dGXzEuZGVmYXVsdC5hZGRPclN1YnRyYWN0KHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcbiAgICB9O1xuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSB8fCBvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIHZhciBhTGVuZ3RoID0gYUNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBiQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICB2YXIgYkxlbmd0aCA9IGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYUNvZWZmID0gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYkxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpICsgal0gPSBBYnN0cmFjdEdlbmVyaWNHRl8xLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChwcm9kdWN0W2kgKyBqXSwgZmllbGQubXVsdGlwbHkoYUNvZWZmLCBiQ29lZmZpY2llbnRzW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcbiAgICB9O1xuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24gKHNjYWxhciAvKmludCovKSB7XG4gICAgICAgIGlmIChzY2FsYXIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGFyID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgcHJvZHVjdFtpXSA9IGZpZWxkLm11bHRpcGx5KGNvZWZmaWNpZW50c1tpXSwgc2NhbGFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgIH07XG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUubXVsdGlwbHlCeU1vbm9taWFsID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovLCBjb2VmZmljaWVudCAvKmludCovKSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgdmFyIHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUgKyBkZWdyZWUpO1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgcHJvZHVjdFtpXSA9IGZpZWxkLm11bHRpcGx5KGNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7XG4gICAgfTtcbiAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RpdmlkZSBieSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgdmFyIHF1b3RpZW50ID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICB2YXIgcmVtYWluZGVyID0gdGhpcztcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSBvdGhlci5nZXRDb2VmZmljaWVudChvdGhlci5nZXREZWdyZWUoKSk7XG4gICAgICAgIHZhciBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgIHdoaWxlIChyZW1haW5kZXIuZ2V0RGVncmVlKCkgPj0gb3RoZXIuZ2V0RGVncmVlKCkgJiYgIXJlbWFpbmRlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgdmFyIGRlZ3JlZURpZmZlcmVuY2UgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGZpZWxkLm11bHRpcGx5KHJlbWFpbmRlci5nZXRDb2VmZmljaWVudChyZW1haW5kZXIuZ2V0RGVncmVlKCkpLCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICB2YXIgdGVybSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9uUXVvdGllbnQgPSBmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQuYWRkT3JTdWJ0cmFjdChpdGVyYXRpb25RdW90aWVudCk7XG4gICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuYWRkT3JTdWJ0cmFjdCh0ZXJtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCByZW1haW5kZXJdO1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGRlZ3JlZSA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xuICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gdGhpcy5nZXRDb2VmZmljaWVudChkZWdyZWUpO1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAtICc7XG4gICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyArICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMCB8fCBjb2VmZmljaWVudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGFQb3dlciA9IHRoaXMuZmllbGQubG9nKGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhUG93ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnMSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFQb3dlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdhJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnYV4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGFscGhhUG93ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3gnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd4Xic7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGVncmVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gR2VuZXJpY0dGUG9seTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHZW5lcmljR0ZQb2x5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js":
/*!*********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar GenericGF_1 = __webpack_require__(/*! ./GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js\");\nvar ReedSolomonException_1 = __webpack_require__(/*! ../../ReedSolomonException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReedSolomonException.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\n/**\n * <p>Implements Reed-Solomon decoding, as the name implies.</p>\n *\n * <p>The algorithm will not be explained here, but the following references were helpful\n * in creating this implementation:</p>\n *\n * <ul>\n * <li>Bruce Maggs.\n * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\n * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\n * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\n * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\n * (see discussion of Euclidean algorithm)</li>\n * </ul>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n * @author William Rucklidge\n * @author sanfordsquires\n */\nvar ReedSolomonDecoder = /** @class */ (function () {\n    function ReedSolomonDecoder(field) {\n        this.field = field;\n    }\n    /**\n     * <p>Decodes given set of received codewords, which include both data and error-correction\n     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n     * in the input.</p>\n     *\n     * @param received data and error-correction codewords\n     * @param twoS number of error-correction codewords available\n     * @throws ReedSolomonException if decoding fails for any reason\n     */\n    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {\n        var field = this.field;\n        var poly = new GenericGFPoly_1.default(field, received);\n        var syndromeCoefficients = new Int32Array(twoS);\n        var noError = true;\n        for (var i = 0; i < twoS; i++) {\n            var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n            if (evalResult !== 0) {\n                noError = false;\n            }\n        }\n        if (noError) {\n            return;\n        }\n        var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);\n        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n        var sigma = sigmaOmega[0];\n        var omega = sigmaOmega[1];\n        var errorLocations = this.findErrorLocations(sigma);\n        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n        for (var i = 0; i < errorLocations.length; i++) {\n            var position = received.length - 1 - field.log(errorLocations[i]);\n            if (position < 0) {\n                throw new ReedSolomonException_1.default('Bad error location');\n            }\n            received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);\n        }\n    };\n    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {\n        // Assume a's degree is >= b's\n        if (a.getDegree() < b.getDegree()) {\n            var temp = a;\n            a = b;\n            b = temp;\n        }\n        var field = this.field;\n        var rLast = a;\n        var r = b;\n        var tLast = field.getZero();\n        var t = field.getOne();\n        // Run Euclidean algorithm until r's degree is less than R/2\n        while (r.getDegree() >= (R / 2 | 0)) {\n            var rLastLast = rLast;\n            var tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\n            if (rLast.isZero()) {\n                // Oops, Euclidean algorithm already terminated?\n                throw new ReedSolomonException_1.default('r_{i-1} was zero');\n            }\n            r = rLastLast;\n            var q = field.getZero();\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n            var dltInverse = field.inverse(denominatorLeadingTerm);\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                var degreeDiff = r.getDegree() - rLast.getDegree();\n                var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n            }\n            t = q.multiply(tLast).addOrSubtract(tLastLast);\n            if (r.getDegree() >= rLast.getDegree()) {\n                throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');\n            }\n        }\n        var sigmaTildeAtZero = t.getCoefficient(0);\n        if (sigmaTildeAtZero === 0) {\n            throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');\n        }\n        var inverse = field.inverse(sigmaTildeAtZero);\n        var sigma = t.multiplyScalar(inverse);\n        var omega = r.multiplyScalar(inverse);\n        return [sigma, omega];\n    };\n    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\n        // This is a direct application of Chien's search\n        var numErrors = errorLocator.getDegree();\n        if (numErrors === 1) { // shortcut\n            return Int32Array.from([errorLocator.getCoefficient(1)]);\n        }\n        var result = new Int32Array(numErrors);\n        var e = 0;\n        var field = this.field;\n        for (var i = 1; i < field.getSize() && e < numErrors; i++) {\n            if (errorLocator.evaluateAt(i) === 0) {\n                result[e] = field.inverse(i);\n                e++;\n            }\n        }\n        if (e !== numErrors) {\n            throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');\n        }\n        return result;\n    };\n    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {\n        // This is directly applying Forney's Formula\n        var s = errorLocations.length;\n        var result = new Int32Array(s);\n        var field = this.field;\n        for (var i = 0; i < s; i++) {\n            var xiInverse = field.inverse(errorLocations[i]);\n            var denominator = 1;\n            for (var j = 0; j < s; j++) {\n                if (i !== j) {\n                    // denominator = field.multiply(denominator,\n                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n                    // Below is a funny-looking workaround from Steven Parkes\n                    var term = field.multiply(errorLocations[j], xiInverse);\n                    var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n                    denominator = field.multiply(denominator, termPlus1);\n                }\n            }\n            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n            if (field.getGeneratorBase() !== 0) {\n                result[i] = field.multiply(result[i], xiInverse);\n            }\n        }\n        return result;\n    };\n    return ReedSolomonDecoder;\n}());\nexports[\"default\"] = ReedSolomonDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlEQUFpRDtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBYTtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyw4SkFBaUI7QUFDL0MsNkJBQTZCLG1CQUFPLENBQUMsNkpBQTRCO0FBQ2pFLDhCQUE4QixtQkFBTyxDQUFDLCtKQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uIHsqL1xudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4vR2VuZXJpY0dGXCIpO1xudmFyIEdlbmVyaWNHRlBvbHlfMSA9IHJlcXVpcmUoXCIuL0dlbmVyaWNHRlBvbHlcIik7XG52YXIgUmVlZFNvbG9tb25FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9SZWVkU29sb21vbkV4Y2VwdGlvblwiKTtcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XG4vKipcbiAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGRlY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAqXG4gKiA8cD5UaGUgYWxnb3JpdGhtIHdpbGwgbm90IGJlIGV4cGxhaW5lZCBoZXJlLCBidXQgdGhlIGZvbGxvd2luZyByZWZlcmVuY2VzIHdlcmUgaGVscGZ1bFxuICogaW4gY3JlYXRpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbjo8L3A+XG4gKlxuICogPHVsPlxuICogPGxpPkJydWNlIE1hZ2dzLlxuICogPGEgaHJlZj1cImh0dHA6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MuY211LmVkdS9wcm9qZWN0L3BzY2ljby1ndXliL3JlYWx3b3JsZC93d3cvcnNfZGVjb2RlLnBzXCI+XG4gKiBcIkRlY29kaW5nIFJlZWQtU29sb21vbiBDb2Rlc1wiPC9hPiAoc2VlIGRpc2N1c3Npb24gb2YgRm9ybmV5J3MgRm9ybXVsYSk8L2xpPlxuICogPGxpPkouSS4gSGFsbC4gPGEgaHJlZj1cInd3dy5tdGgubXN1LmVkdS9+amhhbGwvY2xhc3Nlcy9jb2Rlbm90ZXMvR1JTLnBkZlwiPlxuICogXCJDaGFwdGVyIDUuIEdlbmVyYWxpemVkIFJlZWQtU29sb21vbiBDb2Rlc1wiPC9hPlxuICogKHNlZSBkaXNjdXNzaW9uIG9mIEV1Y2xpZGVhbiBhbGdvcml0aG0pPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPHA+TXVjaCBjcmVkaXQgaXMgZHVlIHRvIFdpbGxpYW0gUnVja2xpZGdlIHNpbmNlIHBvcnRpb25zIG9mIHRoaXMgY29kZSBhcmUgYW4gaW5kaXJlY3RcbiAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gKiBAYXV0aG9yIHNhbmZvcmRzcXVpcmVzXG4gKi9cbnZhciBSZWVkU29sb21vbkRlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVlZFNvbG9tb25EZWNvZGVyKGZpZWxkKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+RGVjb2RlcyBnaXZlbiBzZXQgb2YgcmVjZWl2ZWQgY29kZXdvcmRzLCB3aGljaCBpbmNsdWRlIGJvdGggZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvblxuICAgICAqIGNvZGV3b3Jkcy4gUmVhbGx5LCB0aGlzIG1lYW5zIGl0IHVzZXMgUmVlZC1Tb2xvbW9uIHRvIGRldGVjdCBhbmQgY29ycmVjdCBlcnJvcnMsIGluLXBsYWNlLFxuICAgICAqIGluIHRoZSBpbnB1dC48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZWQgZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgKiBAcGFyYW0gdHdvUyBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgYXZhaWxhYmxlXG4gICAgICogQHRocm93cyBSZWVkU29sb21vbkV4Y2VwdGlvbiBpZiBkZWNvZGluZyBmYWlscyBmb3IgYW55IHJlYXNvblxuICAgICAqL1xuICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlY2VpdmVkLCB0d29TIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgdmFyIHBvbHkgPSBuZXcgR2VuZXJpY0dGUG9seV8xLmRlZmF1bHQoZmllbGQsIHJlY2VpdmVkKTtcbiAgICAgICAgdmFyIHN5bmRyb21lQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkodHdvUyk7XG4gICAgICAgIHZhciBub0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0d29TOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmFsUmVzdWx0ID0gcG9seS5ldmFsdWF0ZUF0KGZpZWxkLmV4cChpICsgZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpKSk7XG4gICAgICAgICAgICBzeW5kcm9tZUNvZWZmaWNpZW50c1tzeW5kcm9tZUNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gaV0gPSBldmFsUmVzdWx0O1xuICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBub0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3luZHJvbWUgPSBuZXcgR2VuZXJpY0dGUG9seV8xLmRlZmF1bHQoZmllbGQsIHN5bmRyb21lQ29lZmZpY2llbnRzKTtcbiAgICAgICAgdmFyIHNpZ21hT21lZ2EgPSB0aGlzLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobShmaWVsZC5idWlsZE1vbm9taWFsKHR3b1MsIDEpLCBzeW5kcm9tZSwgdHdvUyk7XG4gICAgICAgIHZhciBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XG4gICAgICAgIHZhciBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XG4gICAgICAgIHZhciBlcnJvckxvY2F0aW9ucyA9IHRoaXMuZmluZEVycm9yTG9jYXRpb25zKHNpZ21hKTtcbiAgICAgICAgdmFyIGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgZXJyb3JMb2NhdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9yTG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSByZWNlaXZlZC5sZW5ndGggLSAxIC0gZmllbGQubG9nKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb25fMS5kZWZhdWx0KCdCYWQgZXJyb3IgbG9jYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IEdlbmVyaWNHRl8xLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUucnVuRXVjbGlkZWFuQWxnb3JpdGhtID0gZnVuY3Rpb24gKGEsIGIsIFIgLyppbnQqLykge1xuICAgICAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICAgICAgaWYgKGEuZ2V0RGVncmVlKCkgPCBiLmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGE7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGIgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgIHZhciByTGFzdCA9IGE7XG4gICAgICAgIHZhciByID0gYjtcbiAgICAgICAgdmFyIHRMYXN0ID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgICB2YXIgdCA9IGZpZWxkLmdldE9uZSgpO1xuICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gKFIgLyAyIHwgMCkpIHtcbiAgICAgICAgICAgIHZhciByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgIHZhciB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcbiAgICAgICAgICAgIGlmIChyTGFzdC5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ3Jfe2ktMX0gd2FzIHplcm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSByTGFzdExhc3Q7XG4gICAgICAgICAgICB2YXIgcSA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgICAgdmFyIGRsdEludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVncmVlRGlmZiA9IHIuZ2V0RGVncmVlKCkgLSByTGFzdC5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyLmdldENvZWZmaWNpZW50KHIuZ2V0RGVncmVlKCkpLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICBxID0gcS5hZGRPclN1YnRyYWN0KGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgICAgICByID0gci5hZGRPclN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IHEubXVsdGlwbHkodExhc3QpLmFkZE9yU3VidHJhY3QodExhc3RMYXN0KTtcbiAgICAgICAgICAgIGlmIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RpdmlzaW9uIGFsZ29yaXRobSBmYWlsZWQgdG8gcmVkdWNlIHBvbHlub21pYWw/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZ21hVGlsZGVBdFplcm8gPSB0LmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnc2lnbWFUaWxkZSgwKSB3YXMgemVybycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnZlcnNlID0gZmllbGQuaW52ZXJzZShzaWdtYVRpbGRlQXRaZXJvKTtcbiAgICAgICAgdmFyIHNpZ21hID0gdC5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgdmFyIG9tZWdhID0gci5tdWx0aXBseVNjYWxhcihpbnZlcnNlKTtcbiAgICAgICAgcmV0dXJuIFtzaWdtYSwgb21lZ2FdO1xuICAgIH07XG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5maW5kRXJyb3JMb2NhdGlvbnMgPSBmdW5jdGlvbiAoZXJyb3JMb2NhdG9yKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcbiAgICAgICAgdmFyIG51bUVycm9ycyA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgaWYgKG51bUVycm9ycyA9PT0gMSkgeyAvLyBzaG9ydGN1dFxuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KDEpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KG51bUVycm9ycyk7XG4gICAgICAgIHZhciBlID0gMDtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBmaWVsZC5nZXRTaXplKCkgJiYgZSA8IG51bUVycm9yczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JMb2NhdG9yLmV2YWx1YXRlQXQoaSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZV0gPSBmaWVsZC5pbnZlcnNlKGkpO1xuICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb25fMS5kZWZhdWx0KCdFcnJvciBsb2NhdG9yIGRlZ3JlZSBkb2VzIG5vdCBtYXRjaCBudW1iZXIgb2Ygcm9vdHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5maW5kRXJyb3JNYWduaXR1ZGVzID0gZnVuY3Rpb24gKGVycm9yRXZhbHVhdG9yLCBlcnJvckxvY2F0aW9ucykge1xuICAgICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgICAgdmFyIHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShzKTtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4aUludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbm9taW5hdG9yID0gZmllbGQubXVsdGlwbHkoZGVub21pbmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KDEsIGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvdmUgc2hvdWxkIHdvcmsgYnV0IGZhaWxzIG9uIHNvbWUgQXBwbGUgYW5kIExpbnV4IEpES3MgZHVlIHRvIGEgSG90c3BvdCBidWcuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlbG93IGlzIGEgZnVubnktbG9va2luZyB3b3JrYXJvdW5kIGZyb20gU3RldmVuIFBhcmtlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybVBsdXMxID0gKHRlcm0gJiAweDEpID09PSAwID8gdGVybSB8IDEgOiB0ZXJtICYgfjE7XG4gICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gZmllbGQubXVsdGlwbHkoZGVub21pbmF0b3IsIHRlcm1QbHVzMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2ldID0gZmllbGQubXVsdGlwbHkoZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpLCBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yKSk7XG4gICAgICAgICAgICBpZiAoZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZmllbGQubXVsdGlwbHkocmVzdWx0W2ldLCB4aUludmVyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUmVlZFNvbG9tb25EZWNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZWRTb2xvbW9uRGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js":
/*!*********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js\");\nvar System_1 = __webpack_require__(/*! ../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>Implements Reed-Solomon encoding, as the name implies.</p>\n *\n * @author Sean Owen\n * @author William Rucklidge\n */\nvar ReedSolomonEncoder = /** @class */ (function () {\n    /**\n     * A reed solomon error-correcting encoding constructor is created by\n     * passing as Galois Field with of size equal to the number of code\n     * words (symbols) in the alphabet (the number of values in each\n     * element of arrays that are encoded/decoded).\n     * @param field A galois field with a number of elements equal to the size\n     * of the alphabet of symbols to encode.\n     */\n    function ReedSolomonEncoder(field) {\n        this.field = field;\n        this.cachedGenerators = [];\n        this.cachedGenerators.push(new GenericGFPoly_1.default(field, Int32Array.from([1])));\n    }\n    ReedSolomonEncoder.prototype.buildGenerator = function (degree /*int*/) {\n        var cachedGenerators = this.cachedGenerators;\n        if (degree >= cachedGenerators.length) {\n            var lastGenerator = cachedGenerators[cachedGenerators.length - 1];\n            var field = this.field;\n            for (var d = cachedGenerators.length; d <= degree; d++) {\n                var nextGenerator = lastGenerator.multiply(new GenericGFPoly_1.default(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));\n                cachedGenerators.push(nextGenerator);\n                lastGenerator = nextGenerator;\n            }\n        }\n        return cachedGenerators[degree];\n    };\n    /**\n     * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders\n     * to detect and correct errors that may have been introduced when the resulting\n     * data is stored or transmitted.</p>\n     *\n     * @param toEncode array used for both and output. Caller initializes the array with\n     * the code words (symbols) to be encoded followed by empty elements allocated to make\n     * space for error-correction code words in the encoded output. The array contains\n     * the encdoded output when encode returns. Code words are encoded as numbers from\n     * 0 to n-1, where n is the number of possible code words (symbols), as determined\n     * by the size of the Galois Field passed in the constructor of this object.\n     * @param ecBytes the number of elements reserved in the array (first parameter)\n     * to store error-correction code words. Thus, the number of code words (symbols)\n     * to encode in the first parameter is thus toEncode.length - ecBytes.\n     * Note, the use of \"bytes\" in the name of this parameter is misleading, as there may\n     * be more or fewer than 256 symbols being encoded, as determined by the number of\n     * elements in the Galois Field passed as a constructor to this object.\n     * @throws IllegalArgumentException thrown in response to validation errros.\n     */\n    ReedSolomonEncoder.prototype.encode = function (toEncode, ecBytes /*int*/) {\n        if (ecBytes === 0) {\n            throw new IllegalArgumentException_1.default('No error correction bytes');\n        }\n        var dataBytes = toEncode.length - ecBytes;\n        if (dataBytes <= 0) {\n            throw new IllegalArgumentException_1.default('No data bytes provided');\n        }\n        var generator = this.buildGenerator(ecBytes);\n        var infoCoefficients = new Int32Array(dataBytes);\n        System_1.default.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);\n        var info = new GenericGFPoly_1.default(this.field, infoCoefficients);\n        info = info.multiplyByMonomial(ecBytes, 1);\n        var remainder = info.divide(generator)[1];\n        var coefficients = remainder.getCoefficients();\n        var numZeroCoefficients = ecBytes - coefficients.length;\n        for (var i = 0; i < numZeroCoefficients; i++) {\n            toEncode[dataBytes + i] = 0;\n        }\n        System_1.default.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);\n    };\n    return ReedSolomonEncoder;\n}());\nexports[\"default\"] = ReedSolomonEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDhKQUFpQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsMklBQW1CO0FBQzFDLGlDQUFpQyxtQkFBTyxDQUFDLHFLQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR2VuZXJpY0dGUG9seV8xID0gcmVxdWlyZShcIi4vR2VuZXJpY0dGUG9seVwiKTtcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N5c3RlbVwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG4vKipcbiAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGVuY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBXaWxsaWFtIFJ1Y2tsaWRnZVxuICovXG52YXIgUmVlZFNvbG9tb25FbmNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEEgcmVlZCBzb2xvbW9uIGVycm9yLWNvcnJlY3RpbmcgZW5jb2RpbmcgY29uc3RydWN0b3IgaXMgY3JlYXRlZCBieVxuICAgICAqIHBhc3NpbmcgYXMgR2Fsb2lzIEZpZWxkIHdpdGggb2Ygc2l6ZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvZGVcbiAgICAgKiB3b3JkcyAoc3ltYm9scykgaW4gdGhlIGFscGhhYmV0ICh0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiBlYWNoXG4gICAgICogZWxlbWVudCBvZiBhcnJheXMgdGhhdCBhcmUgZW5jb2RlZC9kZWNvZGVkKS5cbiAgICAgKiBAcGFyYW0gZmllbGQgQSBnYWxvaXMgZmllbGQgd2l0aCBhIG51bWJlciBvZiBlbGVtZW50cyBlcXVhbCB0byB0aGUgc2l6ZVxuICAgICAqIG9mIHRoZSBhbHBoYWJldCBvZiBzeW1ib2xzIHRvIGVuY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWVkU29sb21vbkVuY29kZXIoZmllbGQpIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmNhY2hlZEdlbmVyYXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jYWNoZWRHZW5lcmF0b3JzLnB1c2gobmV3IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0KGZpZWxkLCBJbnQzMkFycmF5LmZyb20oWzFdKSkpO1xuICAgIH1cbiAgICBSZWVkU29sb21vbkVuY29kZXIucHJvdG90eXBlLmJ1aWxkR2VuZXJhdG9yID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovKSB7XG4gICAgICAgIHZhciBjYWNoZWRHZW5lcmF0b3JzID0gdGhpcy5jYWNoZWRHZW5lcmF0b3JzO1xuICAgICAgICBpZiAoZGVncmVlID49IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEdlbmVyYXRvciA9IGNhY2hlZEdlbmVyYXRvcnNbY2FjaGVkR2VuZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gY2FjaGVkR2VuZXJhdG9ycy5sZW5ndGg7IGQgPD0gZGVncmVlOyBkKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEdlbmVyYXRvciA9IGxhc3RHZW5lcmF0b3IubXVsdGlwbHkobmV3IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0KGZpZWxkLCBJbnQzMkFycmF5LmZyb20oWzEsIGZpZWxkLmV4cChkIC0gMSArIGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSldKSkpO1xuICAgICAgICAgICAgICAgIGNhY2hlZEdlbmVyYXRvcnMucHVzaChuZXh0R2VuZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdG9yID0gbmV4dEdlbmVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkR2VuZXJhdG9yc1tkZWdyZWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+RW5jb2RlIGEgc2VxdWVuY2Ugb2YgY29kZSB3b3JkcyAoc3ltYm9scykgdXNpbmcgUmVlZC1Tb2xvbW9uIHRvIGFsbG93IGRlY29kZXJzXG4gICAgICogdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycyB0aGF0IG1heSBoYXZlIGJlZW4gaW50cm9kdWNlZCB3aGVuIHRoZSByZXN1bHRpbmdcbiAgICAgKiBkYXRhIGlzIHN0b3JlZCBvciB0cmFuc21pdHRlZC48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9FbmNvZGUgYXJyYXkgdXNlZCBmb3IgYm90aCBhbmQgb3V0cHV0LiBDYWxsZXIgaW5pdGlhbGl6ZXMgdGhlIGFycmF5IHdpdGhcbiAgICAgKiB0aGUgY29kZSB3b3JkcyAoc3ltYm9scykgdG8gYmUgZW5jb2RlZCBmb2xsb3dlZCBieSBlbXB0eSBlbGVtZW50cyBhbGxvY2F0ZWQgdG8gbWFrZVxuICAgICAqIHNwYWNlIGZvciBlcnJvci1jb3JyZWN0aW9uIGNvZGUgd29yZHMgaW4gdGhlIGVuY29kZWQgb3V0cHV0LiBUaGUgYXJyYXkgY29udGFpbnNcbiAgICAgKiB0aGUgZW5jZG9kZWQgb3V0cHV0IHdoZW4gZW5jb2RlIHJldHVybnMuIENvZGUgd29yZHMgYXJlIGVuY29kZWQgYXMgbnVtYmVycyBmcm9tXG4gICAgICogMCB0byBuLTEsIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBwb3NzaWJsZSBjb2RlIHdvcmRzIChzeW1ib2xzKSwgYXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBzaXplIG9mIHRoZSBHYWxvaXMgRmllbGQgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZWNCeXRlcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlc2VydmVkIGluIHRoZSBhcnJheSAoZmlyc3QgcGFyYW1ldGVyKVxuICAgICAqIHRvIHN0b3JlIGVycm9yLWNvcnJlY3Rpb24gY29kZSB3b3Jkcy4gVGh1cywgdGhlIG51bWJlciBvZiBjb2RlIHdvcmRzIChzeW1ib2xzKVxuICAgICAqIHRvIGVuY29kZSBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRodXMgdG9FbmNvZGUubGVuZ3RoIC0gZWNCeXRlcy5cbiAgICAgKiBOb3RlLCB0aGUgdXNlIG9mIFwiYnl0ZXNcIiBpbiB0aGUgbmFtZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBtaXNsZWFkaW5nLCBhcyB0aGVyZSBtYXlcbiAgICAgKiBiZSBtb3JlIG9yIGZld2VyIHRoYW4gMjU2IHN5bWJvbHMgYmVpbmcgZW5jb2RlZCwgYXMgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIG9mXG4gICAgICogZWxlbWVudHMgaW4gdGhlIEdhbG9pcyBGaWVsZCBwYXNzZWQgYXMgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB0aHJvd24gaW4gcmVzcG9uc2UgdG8gdmFsaWRhdGlvbiBlcnJyb3MuXG4gICAgICovXG4gICAgUmVlZFNvbG9tb25FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodG9FbmNvZGUsIGVjQnl0ZXMgLyppbnQqLykge1xuICAgICAgICBpZiAoZWNCeXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05vIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gdG9FbmNvZGUubGVuZ3RoIC0gZWNCeXRlcztcbiAgICAgICAgaWYgKGRhdGFCeXRlcyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gZGF0YSBieXRlcyBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSB0aGlzLmJ1aWxkR2VuZXJhdG9yKGVjQnl0ZXMpO1xuICAgICAgICB2YXIgaW5mb0NvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGRhdGFCeXRlcyk7XG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRvRW5jb2RlLCAwLCBpbmZvQ29lZmZpY2llbnRzLCAwLCBkYXRhQnl0ZXMpO1xuICAgICAgICB2YXIgaW5mbyA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdCh0aGlzLmZpZWxkLCBpbmZvQ29lZmZpY2llbnRzKTtcbiAgICAgICAgaW5mbyA9IGluZm8ubXVsdGlwbHlCeU1vbm9taWFsKGVjQnl0ZXMsIDEpO1xuICAgICAgICB2YXIgcmVtYWluZGVyID0gaW5mby5kaXZpZGUoZ2VuZXJhdG9yKVsxXTtcbiAgICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IHJlbWFpbmRlci5nZXRDb2VmZmljaWVudHMoKTtcbiAgICAgICAgdmFyIG51bVplcm9Db2VmZmljaWVudHMgPSBlY0J5dGVzIC0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1aZXJvQ29lZmZpY2llbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHRvRW5jb2RlW2RhdGFCeXRlcyArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb2VmZmljaWVudHMsIDAsIHRvRW5jb2RlLCBkYXRhQnl0ZXMgKyBudW1aZXJvQ29lZmZpY2llbnRzLCBjb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWVkU29sb21vbkVuY29kZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVlZFNvbG9tb25FbmNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar System_1 = __webpack_require__(/*! ../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js\");\nvar Detector_1 = __webpack_require__(/*! ./detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */ (function () {\n    function DataMatrixReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    /**\n     * Locates and decodes a Data Matrix code in an image.\n     *\n     * @return a String representing the content encoded by the Data Matrix code\n     * @throws NotFoundException if a Data Matrix code cannot be found\n     * @throws FormatException if a Data Matrix code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    // @Override\n    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    //   return decode(image, null);\n    // }\n    // @Override\n    DataMatrixReader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var decoderResult;\n        var points;\n        if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decode(bits);\n            points = DataMatrixReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n            decoderResult = this.decoder.decode(detectorResult.getBits());\n            points = detectorResult.getPoints();\n        }\n        var rawBytes = decoderResult.getRawBytes();\n        var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        return result;\n    };\n    // @Override\n    DataMatrixReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n     */\n    DataMatrixReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack == null || rightBottomBlack == null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        var matrixWidth = (right - left + 1) / moduleSize;\n        var matrixHeight = (bottom - top + 1) / moduleSize;\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = moduleSize / 2;\n        top += nudge;\n        left += nudge;\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + y * moduleSize;\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + x * moduleSize, iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        while (x < width && image.get(x, y)) {\n            x++;\n        }\n        if (x === width) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = x - leftTopBlack[0];\n        if (moduleSize === 0) {\n            throw new NotFoundException_1.default();\n        }\n        return moduleSize;\n    };\n    DataMatrixReader.NO_POINTS = [];\n    return DataMatrixReader;\n}());\nexports[\"default\"] = DataMatrixReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtKQUFxQjtBQUMvQyx1QkFBdUIsbUJBQU8sQ0FBQyw4SUFBbUI7QUFDbEQsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hELGVBQWUsbUJBQU8sQ0FBQyw4SEFBVztBQUNsQywyQkFBMkIsbUJBQU8sQ0FBQyxzSkFBdUI7QUFDMUQsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwSkFBbUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsOEpBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9EYXRhTWF0cml4UmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRNZXRhZGF0YVR5cGVcIik7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TeXN0ZW1cIik7XG52YXIgRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9EZWNvZGVyXCIpO1xudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBEYXRhIE1hdHJpeCBjb2RlcyBpbiBhbiBpbWFnZS5cbiAqXG4gKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAqL1xudmFyIERhdGFNYXRyaXhSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YU1hdHJpeFJlYWRlcigpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXJfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2F0ZXMgYW5kIGRlY29kZXMgYSBEYXRhIE1hdHJpeCBjb2RlIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgRGF0YSBNYXRyaXggY29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBEYXRhIE1hdHJpeCBjb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIC8vIEBPdmVycmlkZVxuICAgIC8vIHB1YmxpYyBSZXN1bHQgZGVjb2RlKEJpbmFyeUJpdG1hcCBpbWFnZSkgdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uIHtcbiAgICAvLyAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpO1xuICAgIC8vIH1cbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBEYXRhTWF0cml4UmVhZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgIGlmIChoaW50cyA9PT0gdm9pZCAwKSB7IGhpbnRzID0gbnVsbDsgfVxuICAgICAgICB2YXIgZGVjb2RlclJlc3VsdDtcbiAgICAgICAgdmFyIHBvaW50cztcbiAgICAgICAgaWYgKGhpbnRzICE9IG51bGwgJiYgaGludHMuaGFzKERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QVVJFX0JBUkNPREUpKSB7XG4gICAgICAgICAgICB2YXIgYml0cyA9IERhdGFNYXRyaXhSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGUoYml0cyk7XG4gICAgICAgICAgICBwb2ludHMgPSBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IG5ldyBEZXRlY3Rvcl8xLmRlZmF1bHQoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCkpO1xuICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhd0J5dGVzID0gZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIHJhd0J5dGVzLCA4ICogcmF3Qnl0ZXMubGVuZ3RoLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkRBVEFfTUFUUklYLCBTeXN0ZW1fMS5kZWZhdWx0LmN1cnJlbnRUaW1lTWlsbGlzKCkpO1xuICAgICAgICB2YXIgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcbiAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlY0xldmVsID0gZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCk7XG4gICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwsIGVjTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBEYXRhTWF0cml4UmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgKiB3aGljaCBjb250YWlucyBvbmx5IGFuIHVucm90YXRlZCwgdW5za2V3ZWQsIGltYWdlIG9mIGEgY29kZSwgd2l0aCBzb21lIHdoaXRlIGJvcmRlclxuICAgICAqIGFyb3VuZCBpdC4gVGhpcyBpcyBhIHNwZWNpYWxpemVkIG1ldGhvZCB0aGF0IHdvcmtzIGV4Y2VwdGlvbmFsbHkgZmFzdCBpbiB0aGlzIHNwZWNpYWxcbiAgICAgKiBjYXNlLlxuICAgICAqXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5RUkNvZGVSZWFkZXIjZXh0cmFjdFB1cmVCaXRzKEJpdE1hdHJpeClcbiAgICAgKi9cbiAgICBEYXRhTWF0cml4UmVhZGVyLmV4dHJhY3RQdXJlQml0cyA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICB2YXIgbGVmdFRvcEJsYWNrID0gaW1hZ2UuZ2V0VG9wTGVmdE9uQml0KCk7XG4gICAgICAgIHZhciByaWdodEJvdHRvbUJsYWNrID0gaW1hZ2UuZ2V0Qm90dG9tUmlnaHRPbkJpdCgpO1xuICAgICAgICBpZiAobGVmdFRvcEJsYWNrID09IG51bGwgfHwgcmlnaHRCb3R0b21CbGFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7XG4gICAgICAgIHZhciB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgIHZhciBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xuICAgICAgICB2YXIgbGVmdCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcmlnaHRCb3R0b21CbGFja1swXTtcbiAgICAgICAgdmFyIG1hdHJpeFdpZHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gbW9kdWxlU2l6ZTtcbiAgICAgICAgdmFyIG1hdHJpeEhlaWdodCA9IChib3R0b20gLSB0b3AgKyAxKSAvIG1vZHVsZVNpemU7XG4gICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCBpbiB0aGUgXCJib3JkZXJcIiBieSBoYWxmIHRoZSBtb2R1bGUgd2lkdGggc28gdGhhdCB3ZSBzdGFydFxuICAgICAgICAvLyBzYW1wbGluZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb2R1bGUuIEp1c3QgaW4gY2FzZSB0aGUgaW1hZ2UgaXMgYVxuICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxuICAgICAgICB2YXIgbnVkZ2UgPSBtb2R1bGVTaXplIC8gMjtcbiAgICAgICAgdG9wICs9IG51ZGdlO1xuICAgICAgICBsZWZ0ICs9IG51ZGdlO1xuICAgICAgICAvLyBOb3cganVzdCByZWFkIG9mZiB0aGUgYml0c1xuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG1hdHJpeEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgaU9mZnNldCA9IHRvcCArIHkgKiBtb2R1bGVTaXplO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXRyaXhXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChsZWZ0ICsgeCAqIG1vZHVsZVNpemUsIGlPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9O1xuICAgIERhdGFNYXRyaXhSZWFkZXIubW9kdWxlU2l6ZSA9IGZ1bmN0aW9uIChsZWZ0VG9wQmxhY2ssIGltYWdlKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB4ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICB2YXIgeSA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiBpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgIHgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHggLSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgIGlmIChtb2R1bGVTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZVNpemU7XG4gICAgfTtcbiAgICBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUyA9IFtdO1xuICAgIHJldHVybiBEYXRhTWF0cml4UmVhZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFNYXRyaXhSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar EncodeHintType_1 = __webpack_require__(/*! ../EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\nvar ByteMatrix_1 = __webpack_require__(/*! ../qrcode/encoder/ByteMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js\");\nvar Charset_1 = __webpack_require__(/*! ../util/Charset */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js\");\nvar encoder_1 = __webpack_require__(/*! ./encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js\");\nvar DataMatrixWriter = /** @class */ (function () {\n    function DataMatrixWriter() {\n    }\n    DataMatrixWriter.prototype.encode = function (contents, format, width, height, hints) {\n        if (hints === void 0) { hints = null; }\n        if (contents.trim() === '') {\n            throw new Error('Found empty contents');\n        }\n        if (format !== BarcodeFormat_1.default.DATA_MATRIX) {\n            throw new Error('Can only encode DATA_MATRIX, but got ' + format);\n        }\n        if (width < 0 || height < 0) {\n            throw new Error('Requested dimensions can\\'t be negative: ' + width + 'x' + height);\n        }\n        // Try to get force shape & min / max size\n        var shape = 0 /* FORCE_NONE */;\n        var minSize = null;\n        var maxSize = null;\n        if (hints != null) {\n            var requestedShape = hints.get(EncodeHintType_1.default.DATA_MATRIX_SHAPE);\n            if (requestedShape != null) {\n                shape = requestedShape;\n            }\n            var requestedMinSize = hints.get(EncodeHintType_1.default.MIN_SIZE);\n            if (requestedMinSize != null) {\n                minSize = requestedMinSize;\n            }\n            var requestedMaxSize = hints.get(EncodeHintType_1.default.MAX_SIZE);\n            if (requestedMaxSize != null) {\n                maxSize = requestedMaxSize;\n            }\n        }\n        // 1. step: Data encodation\n        var encoded;\n        var hasCompactionHint = hints != null &&\n            hints.has(EncodeHintType_1.default.DATA_MATRIX_COMPACT) &&\n            Boolean(hints.get(EncodeHintType_1.default.DATA_MATRIX_COMPACT).toString());\n        if (hasCompactionHint) {\n            var hasGS1FormatHint = hints.has(EncodeHintType_1.default.GS1_FORMAT) &&\n                Boolean(hints.get(EncodeHintType_1.default.GS1_FORMAT).toString());\n            var charset = null;\n            var hasEncodingHint = hints.has(EncodeHintType_1.default.CHARACTER_SET);\n            if (hasEncodingHint) {\n                charset = Charset_1.default.forName(hints.get(EncodeHintType_1.default.CHARACTER_SET).toString());\n            }\n            encoded = encoder_1.MinimalEncoder.encodeHighLevel(contents, charset, hasGS1FormatHint ? 0x1d : -1, shape);\n        }\n        else {\n            var hasForceC40Hint = hints != null &&\n                hints.has(EncodeHintType_1.default.FORCE_C40) &&\n                Boolean(hints.get(EncodeHintType_1.default.FORCE_C40).toString());\n            encoded = encoder_1.HighLevelEncoder.encodeHighLevel(contents, shape, minSize, maxSize, hasForceC40Hint);\n        }\n        var symbolInfo = encoder_1.SymbolInfo.lookup(encoded.length, shape, minSize, maxSize, true);\n        // 2. step: ECC generation\n        var codewords = encoder_1.ErrorCorrection.encodeECC200(encoded, symbolInfo);\n        // 3. step: Module placement in Matrix\n        var placement = new encoder_1.DefaultPlacement(codewords, symbolInfo.getSymbolDataWidth(), symbolInfo.getSymbolDataHeight());\n        placement.place();\n        // 4. step: low-level encoding\n        return this.encodeLowLevel(placement, symbolInfo, width, height);\n    };\n    /**\n     * Encode the given symbol info to a bit matrix.\n     *\n     * @param placement  The DataMatrix placement.\n     * @param symbolInfo The symbol info to encode.\n     * @return The bit matrix generated.\n     */\n    DataMatrixWriter.prototype.encodeLowLevel = function (placement, symbolInfo, width, height) {\n        var symbolWidth = symbolInfo.getSymbolDataWidth();\n        var symbolHeight = symbolInfo.getSymbolDataHeight();\n        var matrix = new ByteMatrix_1.default(symbolInfo.getSymbolWidth(), symbolInfo.getSymbolHeight());\n        var matrixY = 0;\n        for (var y = 0; y < symbolHeight; y++) {\n            // Fill the top edge with alternate 0 / 1\n            var matrixX = void 0;\n            if (y % symbolInfo.matrixHeight === 0) {\n                matrixX = 0;\n                for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {\n                    matrix.setBoolean(matrixX, matrixY, x % 2 === 0);\n                    matrixX++;\n                }\n                matrixY++;\n            }\n            matrixX = 0;\n            for (var x = 0; x < symbolWidth; x++) {\n                // Fill the right edge with full 1\n                if (x % symbolInfo.matrixWidth === 0) {\n                    matrix.setBoolean(matrixX, matrixY, true);\n                    matrixX++;\n                }\n                matrix.setBoolean(matrixX, matrixY, placement.getBit(x, y));\n                matrixX++;\n                // Fill the right edge with alternate 0 / 1\n                if (x % symbolInfo.matrixWidth === symbolInfo.matrixWidth - 1) {\n                    matrix.setBoolean(matrixX, matrixY, y % 2 === 0);\n                    matrixX++;\n                }\n            }\n            matrixY++;\n            // Fill the bottom edge with full 1\n            if (y % symbolInfo.matrixHeight === symbolInfo.matrixHeight - 1) {\n                matrixX = 0;\n                for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {\n                    matrix.setBoolean(matrixX, matrixY, true);\n                    matrixX++;\n                }\n                matrixY++;\n            }\n        }\n        return this.convertByteMatrixToBitMatrix(matrix, width, height);\n    };\n    /**\n     * Convert the ByteMatrix to BitMatrix.\n     *\n     * @param reqHeight The requested height of the image (in pixels) with the Datamatrix code\n     * @param reqWidth The requested width of the image (in pixels) with the Datamatrix code\n     * @param matrix The input matrix.\n     * @return The output matrix.\n     */\n    DataMatrixWriter.prototype.convertByteMatrixToBitMatrix = function (matrix, reqWidth, reqHeight) {\n        var matrixWidth = matrix.getWidth();\n        var matrixHeight = matrix.getHeight();\n        var outputWidth = Math.max(reqWidth, matrixWidth);\n        var outputHeight = Math.max(reqHeight, matrixHeight);\n        var multiple = Math.min(outputWidth / matrixWidth, outputHeight / matrixHeight);\n        var leftPadding = (outputWidth - matrixWidth * multiple) / 2;\n        var topPadding = (outputHeight - matrixHeight * multiple) / 2;\n        var output;\n        // remove padding if requested width and height are too small\n        if (reqHeight < matrixHeight || reqWidth < matrixWidth) {\n            leftPadding = 0;\n            topPadding = 0;\n            output = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        }\n        else {\n            output = new BitMatrix_1.default(reqWidth, reqHeight);\n        }\n        output.clear();\n        for (var inputY = 0, outputY = topPadding; inputY < matrixHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the bytematrix\n            for (var inputX = 0, outputX = leftPadding; inputX < matrixWidth; inputX++, outputX += multiple) {\n                if (matrix.get(inputX, inputY) === 1) {\n                    output.setRegion(outputX, outputY, multiple, multiple);\n                }\n            }\n        }\n        return output;\n    };\n    return DataMatrixWriter;\n}());\nexports[\"default\"] = DataMatrixWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhXcml0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtKQUFxQjtBQUMvQyx1QkFBdUIsbUJBQU8sQ0FBQyw4SUFBbUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsb0tBQThCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLDBJQUFpQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnSkFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2RhdGFtYXRyaXgvRGF0YU1hdHJpeFdyaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQml0TWF0cml4XCIpO1xudmFyIEVuY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vRW5jb2RlSGludFR5cGVcIik7XG52YXIgQnl0ZU1hdHJpeF8xID0gcmVxdWlyZShcIi4uL3FyY29kZS9lbmNvZGVyL0J5dGVNYXRyaXhcIik7XG52YXIgQ2hhcnNldF8xID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnNldFwiKTtcbnZhciBlbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpO1xudmFyIERhdGFNYXRyaXhXcml0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YU1hdHJpeFdyaXRlcigpIHtcbiAgICB9XG4gICAgRGF0YU1hdHJpeFdyaXRlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKSB7XG4gICAgICAgIGlmIChoaW50cyA9PT0gdm9pZCAwKSB7IGhpbnRzID0gbnVsbDsgfVxuICAgICAgICBpZiAoY29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkRBVEFfTUFUUklYKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGVuY29kZSBEQVRBX01BVFJJWCwgYnV0IGdvdCAnICsgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIGRpbWVuc2lvbnMgY2FuXFwndCBiZSBuZWdhdGl2ZTogJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGZvcmNlIHNoYXBlICYgbWluIC8gbWF4IHNpemVcbiAgICAgICAgdmFyIHNoYXBlID0gMCAvKiBGT1JDRV9OT05FICovO1xuICAgICAgICB2YXIgbWluU2l6ZSA9IG51bGw7XG4gICAgICAgIHZhciBtYXhTaXplID0gbnVsbDtcbiAgICAgICAgaWYgKGhpbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ZWRTaGFwZSA9IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuREFUQV9NQVRSSVhfU0hBUEUpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHJlcXVlc3RlZFNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZE1pblNpemUgPSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1JTl9TSVpFKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRNaW5TaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaW5TaXplID0gcmVxdWVzdGVkTWluU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXF1ZXN0ZWRNYXhTaXplID0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5NQVhfU0laRSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdGVkTWF4U2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZSA9IHJlcXVlc3RlZE1heFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gc3RlcDogRGF0YSBlbmNvZGF0aW9uXG4gICAgICAgIHZhciBlbmNvZGVkO1xuICAgICAgICB2YXIgaGFzQ29tcGFjdGlvbkhpbnQgPSBoaW50cyAhPSBudWxsICYmXG4gICAgICAgICAgICBoaW50cy5oYXMoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkRBVEFfTUFUUklYX0NPTVBBQ1QpICYmXG4gICAgICAgICAgICBCb29sZWFuKGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuREFUQV9NQVRSSVhfQ09NUEFDVCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChoYXNDb21wYWN0aW9uSGludCkge1xuICAgICAgICAgICAgdmFyIGhhc0dTMUZvcm1hdEhpbnQgPSBoaW50cy5oYXMoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkdTMV9GT1JNQVQpICYmXG4gICAgICAgICAgICAgICAgQm9vbGVhbihoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkdTMV9GT1JNQVQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdmFyIGNoYXJzZXQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGhhc0VuY29kaW5nSGludCA9IGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuQ0hBUkFDVEVSX1NFVCk7XG4gICAgICAgICAgICBpZiAoaGFzRW5jb2RpbmdIaW50KSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IENoYXJzZXRfMS5kZWZhdWx0LmZvck5hbWUoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuY29kZWQgPSBlbmNvZGVyXzEuTWluaW1hbEVuY29kZXIuZW5jb2RlSGlnaExldmVsKGNvbnRlbnRzLCBjaGFyc2V0LCBoYXNHUzFGb3JtYXRIaW50ID8gMHgxZCA6IC0xLCBzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFzRm9yY2VDNDBIaW50ID0gaGludHMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRk9SQ0VfQzQwKSAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5GT1JDRV9DNDApLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZW5jb2RlZCA9IGVuY29kZXJfMS5IaWdoTGV2ZWxFbmNvZGVyLmVuY29kZUhpZ2hMZXZlbChjb250ZW50cywgc2hhcGUsIG1pblNpemUsIG1heFNpemUsIGhhc0ZvcmNlQzQwSGludCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bWJvbEluZm8gPSBlbmNvZGVyXzEuU3ltYm9sSW5mby5sb29rdXAoZW5jb2RlZC5sZW5ndGgsIHNoYXBlLCBtaW5TaXplLCBtYXhTaXplLCB0cnVlKTtcbiAgICAgICAgLy8gMi4gc3RlcDogRUNDIGdlbmVyYXRpb25cbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IGVuY29kZXJfMS5FcnJvckNvcnJlY3Rpb24uZW5jb2RlRUNDMjAwKGVuY29kZWQsIHN5bWJvbEluZm8pO1xuICAgICAgICAvLyAzLiBzdGVwOiBNb2R1bGUgcGxhY2VtZW50IGluIE1hdHJpeFxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gbmV3IGVuY29kZXJfMS5EZWZhdWx0UGxhY2VtZW50KGNvZGV3b3Jkcywgc3ltYm9sSW5mby5nZXRTeW1ib2xEYXRhV2lkdGgoKSwgc3ltYm9sSW5mby5nZXRTeW1ib2xEYXRhSGVpZ2h0KCkpO1xuICAgICAgICBwbGFjZW1lbnQucGxhY2UoKTtcbiAgICAgICAgLy8gNC4gc3RlcDogbG93LWxldmVsIGVuY29kaW5nXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUxvd0xldmVsKHBsYWNlbWVudCwgc3ltYm9sSW5mbywgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIGdpdmVuIHN5bWJvbCBpbmZvIHRvIGEgYml0IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFjZW1lbnQgIFRoZSBEYXRhTWF0cml4IHBsYWNlbWVudC5cbiAgICAgKiBAcGFyYW0gc3ltYm9sSW5mbyBUaGUgc3ltYm9sIGluZm8gdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm4gVGhlIGJpdCBtYXRyaXggZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIERhdGFNYXRyaXhXcml0ZXIucHJvdG90eXBlLmVuY29kZUxvd0xldmVsID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgc3ltYm9sSW5mbywgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgc3ltYm9sV2lkdGggPSBzeW1ib2xJbmZvLmdldFN5bWJvbERhdGFXaWR0aCgpO1xuICAgICAgICB2YXIgc3ltYm9sSGVpZ2h0ID0gc3ltYm9sSW5mby5nZXRTeW1ib2xEYXRhSGVpZ2h0KCk7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgQnl0ZU1hdHJpeF8xLmRlZmF1bHQoc3ltYm9sSW5mby5nZXRTeW1ib2xXaWR0aCgpLCBzeW1ib2xJbmZvLmdldFN5bWJvbEhlaWdodCgpKTtcbiAgICAgICAgdmFyIG1hdHJpeFkgPSAwO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHN5bWJvbEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSB0b3AgZWRnZSB3aXRoIGFsdGVybmF0ZSAwIC8gMVxuICAgICAgICAgICAgdmFyIG1hdHJpeFggPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoeSAlIHN5bWJvbEluZm8ubWF0cml4SGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4WCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzeW1ib2xJbmZvLmdldFN5bWJvbFdpZHRoKCk7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbihtYXRyaXhYLCBtYXRyaXhZLCB4ICUgMiA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4WSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4WCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN5bWJvbFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSByaWdodCBlZGdlIHdpdGggZnVsbCAxXG4gICAgICAgICAgICAgICAgaWYgKHggJSBzeW1ib2xJbmZvLm1hdHJpeFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKG1hdHJpeFgsIG1hdHJpeFksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXhYKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKG1hdHJpeFgsIG1hdHJpeFksIHBsYWNlbWVudC5nZXRCaXQoeCwgeSkpO1xuICAgICAgICAgICAgICAgIG1hdHJpeFgrKztcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSByaWdodCBlZGdlIHdpdGggYWx0ZXJuYXRlIDAgLyAxXG4gICAgICAgICAgICAgICAgaWYgKHggJSBzeW1ib2xJbmZvLm1hdHJpeFdpZHRoID09PSBzeW1ib2xJbmZvLm1hdHJpeFdpZHRoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbihtYXRyaXhYLCBtYXRyaXhZLCB5ICUgMiA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXhZKys7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBib3R0b20gZWRnZSB3aXRoIGZ1bGwgMVxuICAgICAgICAgICAgaWYgKHkgJSBzeW1ib2xJbmZvLm1hdHJpeEhlaWdodCA9PT0gc3ltYm9sSW5mby5tYXRyaXhIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4WCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzeW1ib2xJbmZvLmdldFN5bWJvbFdpZHRoKCk7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbihtYXRyaXhYLCBtYXRyaXhZLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4WCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRyaXhZKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEJ5dGVNYXRyaXhUb0JpdE1hdHJpeChtYXRyaXgsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgQnl0ZU1hdHJpeCB0byBCaXRNYXRyaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxSGVpZ2h0IFRoZSByZXF1ZXN0ZWQgaGVpZ2h0IG9mIHRoZSBpbWFnZSAoaW4gcGl4ZWxzKSB3aXRoIHRoZSBEYXRhbWF0cml4IGNvZGVcbiAgICAgKiBAcGFyYW0gcmVxV2lkdGggVGhlIHJlcXVlc3RlZCB3aWR0aCBvZiB0aGUgaW1hZ2UgKGluIHBpeGVscykgd2l0aCB0aGUgRGF0YW1hdHJpeCBjb2RlXG4gICAgICogQHBhcmFtIG1hdHJpeCBUaGUgaW5wdXQgbWF0cml4LlxuICAgICAqIEByZXR1cm4gVGhlIG91dHB1dCBtYXRyaXguXG4gICAgICovXG4gICAgRGF0YU1hdHJpeFdyaXRlci5wcm90b3R5cGUuY29udmVydEJ5dGVNYXRyaXhUb0JpdE1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgsIHJlcVdpZHRoLCByZXFIZWlnaHQpIHtcbiAgICAgICAgdmFyIG1hdHJpeFdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBtYXRyaXhIZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBvdXRwdXRXaWR0aCA9IE1hdGgubWF4KHJlcVdpZHRoLCBtYXRyaXhXaWR0aCk7XG4gICAgICAgIHZhciBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChyZXFIZWlnaHQsIG1hdHJpeEhlaWdodCk7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGgubWluKG91dHB1dFdpZHRoIC8gbWF0cml4V2lkdGgsIG91dHB1dEhlaWdodCAvIG1hdHJpeEhlaWdodCk7XG4gICAgICAgIHZhciBsZWZ0UGFkZGluZyA9IChvdXRwdXRXaWR0aCAtIG1hdHJpeFdpZHRoICogbXVsdGlwbGUpIC8gMjtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcgPSAob3V0cHV0SGVpZ2h0IC0gbWF0cml4SGVpZ2h0ICogbXVsdGlwbGUpIC8gMjtcbiAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmcgaWYgcmVxdWVzdGVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHRvbyBzbWFsbFxuICAgICAgICBpZiAocmVxSGVpZ2h0IDwgbWF0cml4SGVpZ2h0IHx8IHJlcVdpZHRoIDwgbWF0cml4V2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nID0gMDtcbiAgICAgICAgICAgIHRvcFBhZGRpbmcgPSAwO1xuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IEJpdE1hdHJpeF8xLmRlZmF1bHQobWF0cml4V2lkdGgsIG1hdHJpeEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuY2xlYXIoKTtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IG1hdHJpeEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYnl0ZW1hdHJpeFxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRYID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBtYXRyaXhXaWR0aDsgaW5wdXRYKyssIG91dHB1dFggKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0cml4LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFNYXRyaXhXcml0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YU1hdHJpeFdyaXRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar Version_1 = __webpack_require__(/*! ./Version */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @author bbrown@google.com (Brian Brown)\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n            throw new FormatException_1.default();\n        }\n        this.version = BitMatrixParser.readVersion(bitMatrix);\n        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n        this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n    }\n    BitMatrixParser.prototype.getVersion = function () {\n        return this.version;\n    };\n    /**\n     * <p>Creates the version object based on the dimension of the original bit matrix from\n     * the datamatrix code.</p>\n     *\n     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n     *\n     * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n     * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n     * @throws FormatException if the dimensions of the mapping matrix are not valid\n     * Data Matrix dimensions.\n     */\n    BitMatrixParser.readVersion = function (bitMatrix) {\n        var numRows = bitMatrix.getHeight();\n        var numColumns = bitMatrix.getWidth();\n        return Version_1.default.getVersionForDimensions(numRows, numColumns);\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n     * in the correct order in order to reconstitute the codewords bytes contained within the\n     * Data Matrix Code.</p>\n     *\n     * @return bytes encoded within the Data Matrix Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var result = new Int8Array(this.version.getTotalCodewords());\n        var resultOffset = 0;\n        var row = 4;\n        var column = 0;\n        var numRows = this.mappingBitMatrix.getHeight();\n        var numColumns = this.mappingBitMatrix.getWidth();\n        var corner1Read = false;\n        var corner2Read = false;\n        var corner3Read = false;\n        var corner4Read = false;\n        // Read all of the codewords\n        do {\n            // Check the four corner cases\n            if ((row === numRows) && (column === 0) && !corner1Read) {\n                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner1Read = true;\n            }\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {\n                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner2Read = true;\n            }\n            else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {\n                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner3Read = true;\n            }\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {\n                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner4Read = true;\n            }\n            else {\n                // Sweep upward diagonally to the right\n                do {\n                    if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                    }\n                    row -= 2;\n                    column += 2;\n                } while ((row >= 0) && (column < numColumns));\n                row += 1;\n                column += 3;\n                // Sweep downward diagonally to the left\n                do {\n                    if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                    }\n                    row += 2;\n                    column -= 2;\n                } while ((row < numRows) && (column >= 0));\n                row += 3;\n                column += 1;\n            }\n        } while ((row < numRows) || (column < numColumns));\n        if (resultOffset !== this.version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n     *\n     * @param row Row to read in the mapping matrix\n     * @param column Column to read in the mapping matrix\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return value of the given bit in the mapping matrix\n     */\n    BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\n        // Adjust the row and column indices based on boundary wrapping\n        if (row < 0) {\n            row += numRows;\n            column += 4 - ((numRows + 4) & 0x07);\n        }\n        if (column < 0) {\n            column += numColumns;\n            row += 4 - ((numColumns + 4) & 0x07);\n        }\n        this.readMappingMatrix.set(column, row);\n        return this.mappingBitMatrix.get(column, row);\n    };\n    /**\n     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n     *\n     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n     *\n     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the utah shape\n     */\n    BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 1.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.3</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 1\n     */\n    BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 2.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.4</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 2\n     */\n    BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 3.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.5</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 3\n     */\n    BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 4.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.6</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 4\n     */\n    BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Extracts the data region from a {@link BitMatrix} that contains\n     * alignment patterns.</p>\n     *\n     * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n     * @return BitMatrix that has the alignment patterns removed\n     */\n    BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\n        var symbolSizeRows = this.version.getSymbolSizeRows();\n        var symbolSizeColumns = this.version.getSymbolSizeColumns();\n        if (bitMatrix.getHeight() !== symbolSizeRows) {\n            throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');\n        }\n        var dataRegionSizeRows = this.version.getDataRegionSizeRows();\n        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n        var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);\n        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n            var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n            for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n                var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n                for (var i = 0; i < dataRegionSizeRows; ++i) {\n                    var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n                    var writeRowOffset = dataRegionRowOffset + i;\n                    for (var j = 0; j < dataRegionSizeColumns; ++j) {\n                        var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n                        if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n                            var writeColumnOffset = dataRegionColumnOffset + j;\n                            bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n                        }\n                    }\n                }\n            }\n        }\n        return bitMatrixWithoutAlignment;\n    };\n    return BitMatrixParser;\n}());\nexports[\"default\"] = BitMatrixParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvQml0TWF0cml4UGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHFKQUF3QjtBQUNsRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrSkFBVztBQUNuQyx3QkFBd0IsbUJBQU8sQ0FBQyxtSkFBdUI7QUFDdkQsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEY7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvQml0TWF0cml4UGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XG52YXIgVmVyc2lvbl8xID0gcmVxdWlyZShcIi4vVmVyc2lvblwiKTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Gb3JtYXRFeGNlcHRpb25cIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICovXG52YXIgQml0TWF0cml4UGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb24gaXMgPCA4IG9yID4gMTQ0IG9yIG5vdCAwIG1vZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQml0TWF0cml4UGFyc2VyKGJpdE1hdHJpeCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICBpZiAoZGltZW5zaW9uIDwgOCB8fCBkaW1lbnNpb24gPiAxNDQgfHwgKGRpbWVuc2lvbiAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IEJpdE1hdHJpeFBhcnNlci5yZWFkVmVyc2lvbihiaXRNYXRyaXgpO1xuICAgICAgICB0aGlzLm1hcHBpbmdCaXRNYXRyaXggPSB0aGlzLmV4dHJhY3REYXRhUmVnaW9uKGJpdE1hdHJpeCk7XG4gICAgICAgIHRoaXMucmVhZE1hcHBpbmdNYXRyaXggPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdCh0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0V2lkdGgoKSwgdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldEhlaWdodCgpKTtcbiAgICB9XG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+Q3JlYXRlcyB0aGUgdmVyc2lvbiBvYmplY3QgYmFzZWQgb24gdGhlIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgYml0IG1hdHJpeCBmcm9tXG4gICAgICogdGhlIGRhdGFtYXRyaXggY29kZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYgVGFibGUgNyAtIEVDQyAyMDAgc3ltYm9sIGF0dHJpYnV0ZXM8L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYml0TWF0cml4IE9yaWdpbmFsIHtAbGluayBCaXRNYXRyaXh9IGluY2x1ZGluZyBhbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgKiBAcmV0dXJuIHtAbGluayBWZXJzaW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBEYXRhIE1hdHJpeCBDb2RlJ3MgXCJ2ZXJzaW9uXCJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgbWFwcGluZyBtYXRyaXggYXJlIG5vdCB2YWxpZFxuICAgICAqIERhdGEgTWF0cml4IGRpbWVuc2lvbnMuXG4gICAgICovXG4gICAgQml0TWF0cml4UGFyc2VyLnJlYWRWZXJzaW9uID0gZnVuY3Rpb24gKGJpdE1hdHJpeCkge1xuICAgICAgICB2YXIgbnVtUm93cyA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIG51bUNvbHVtbnMgPSBiaXRNYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIFZlcnNpb25fMS5kZWZhdWx0LmdldFZlcnNpb25Gb3JEaW1lbnNpb25zKG51bVJvd3MsIG51bUNvbHVtbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UmVhZHMgdGhlIGJpdHMgaW4gdGhlIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGluZyB0aGUgbWFwcGluZyBtYXRyaXggKE5vIGFsaWdubWVudCBwYXR0ZXJucylcbiAgICAgKiBpbiB0aGUgY29ycmVjdCBvcmRlciBpbiBvcmRlciB0byByZWNvbnN0aXR1dGUgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZVxuICAgICAqIERhdGEgTWF0cml4IENvZGUuPC9wPlxuICAgICAqXG4gICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaXMgbm90IHJlYWRcbiAgICAgKi9cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50OEFycmF5KHRoaXMudmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKTtcbiAgICAgICAgdmFyIHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciByb3cgPSA0O1xuICAgICAgICB2YXIgY29sdW1uID0gMDtcbiAgICAgICAgdmFyIG51bVJvd3MgPSB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBjb3JuZXIxUmVhZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY29ybmVyMlJlYWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvcm5lcjNSZWFkID0gZmFsc2U7XG4gICAgICAgIHZhciBjb3JuZXI0UmVhZCA9IGZhbHNlO1xuICAgICAgICAvLyBSZWFkIGFsbCBvZiB0aGUgY29kZXdvcmRzXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBmb3VyIGNvcm5lciBjYXNlc1xuICAgICAgICAgICAgaWYgKChyb3cgPT09IG51bVJvd3MpICYmIChjb2x1bW4gPT09IDApICYmICFjb3JuZXIxUmVhZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIxKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICBjb3JuZXIxUmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzIC0gMikgJiYgKGNvbHVtbiA9PT0gMCkgJiYgKChudW1Db2x1bW5zICYgMHgwMykgIT09IDApICYmICFjb3JuZXIyUmVhZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIyKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICBjb3JuZXIyUmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzICsgNCkgJiYgKGNvbHVtbiA9PT0gMikgJiYgKChudW1Db2x1bW5zICYgMHgwNykgPT09IDApICYmICFjb3JuZXIzUmVhZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIzKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICBjb3JuZXIzUmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzIC0gMikgJiYgKGNvbHVtbiA9PT0gMCkgJiYgKChudW1Db2x1bW5zICYgMHgwNykgPT09IDQpICYmICFjb3JuZXI0UmVhZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXI0KG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICByb3cgLT0gMjtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICBjb3JuZXI0UmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTd2VlcCB1cHdhcmQgZGlhZ29uYWxseSB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocm93IDwgbnVtUm93cykgJiYgKGNvbHVtbiA+PSAwKSAmJiAhdGhpcy5yZWFkTWFwcGluZ01hdHJpeC5nZXQoY29sdW1uLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkVXRhaChyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93ID49IDApICYmIChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XG4gICAgICAgICAgICAgICAgcm93ICs9IDE7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDM7XG4gICAgICAgICAgICAgICAgLy8gU3dlZXAgZG93bndhcmQgZGlhZ29uYWxseSB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPj0gMCkgJiYgKGNvbHVtbiA8IG51bUNvbHVtbnMpICYmICF0aGlzLnJlYWRNYXBwaW5nTWF0cml4LmdldChjb2x1bW4sIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRVdGFoKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiAtPSAyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChyb3cgPCBudW1Sb3dzKSAmJiAoY29sdW1uID49IDApKTtcbiAgICAgICAgICAgICAgICByb3cgKz0gMztcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKHJvdyA8IG51bVJvd3MpIHx8IChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHRoaXMudmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5SZWFkcyBhIGJpdCBvZiB0aGUgbWFwcGluZyBtYXRyaXggYWNjb3VudGluZyBmb3IgYm91bmRhcnkgd3JhcHBpbmcuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdyBSb3cgdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgKiBAcGFyYW0gY29sdW1uIENvbHVtbiB0byByZWFkIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAqIEByZXR1cm4gdmFsdWUgb2YgdGhlIGdpdmVuIGJpdCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgKi9cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRNb2R1bGUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSByb3cgYW5kIGNvbHVtbiBpbmRpY2VzIGJhc2VkIG9uIGJvdW5kYXJ5IHdyYXBwaW5nXG4gICAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICByb3cgKz0gbnVtUm93cztcbiAgICAgICAgICAgIGNvbHVtbiArPSA0IC0gKChudW1Sb3dzICsgNCkgJiAweDA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uIDwgMCkge1xuICAgICAgICAgICAgY29sdW1uICs9IG51bUNvbHVtbnM7XG4gICAgICAgICAgICByb3cgKz0gNCAtICgobnVtQ29sdW1ucyArIDQpICYgMHgwNyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkTWFwcGluZ01hdHJpeC5zZXQoY29sdW1uLCByb3cpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldChjb2x1bW4sIHJvdyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzdGFuZGFyZCBVdGFoLXNoYXBlZCBwYXR0ZXJuLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgNS44LjEgRmlndXJlIDY8L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93IEN1cnJlbnQgcm93IGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gY29sdW1uIEN1cnJlbnQgY29sdW1uIGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgdXRhaCBzaGFwZVxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZFV0YWggPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdywgY29sdW1uIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDEuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi4zPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMVxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZENvcm5lcjEgPSBmdW5jdGlvbiAobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDIsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgzLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDIuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi40PC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMlxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZENvcm5lcjIgPSBmdW5jdGlvbiAobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMiwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSA0LCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMywgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDMuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi41PC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gM1xuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZENvcm5lcjMgPSBmdW5jdGlvbiAobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiA0LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuNjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDRcbiAgICAgKi9cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb3JuZXI0ID0gZnVuY3Rpb24gKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMywgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDIsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgyLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMywgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkV4dHJhY3RzIHRoZSBkYXRhIHJlZ2lvbiBmcm9tIGEge0BsaW5rIEJpdE1hdHJpeH0gdGhhdCBjb250YWluc1xuICAgICAqIGFsaWdubWVudCBwYXR0ZXJucy48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYml0TWF0cml4IE9yaWdpbmFsIHtAbGluayBCaXRNYXRyaXh9IHdpdGggYWxpZ25tZW50IHBhdHRlcm5zXG4gICAgICogQHJldHVybiBCaXRNYXRyaXggdGhhdCBoYXMgdGhlIGFsaWdubWVudCBwYXR0ZXJucyByZW1vdmVkXG4gICAgICovXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5leHRyYWN0RGF0YVJlZ2lvbiA9IGZ1bmN0aW9uIChiaXRNYXRyaXgpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVSb3dzKCk7XG4gICAgICAgIHZhciBzeW1ib2xTaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXRTeW1ib2xTaXplQ29sdW1ucygpO1xuICAgICAgICBpZiAoYml0TWF0cml4LmdldEhlaWdodCgpICE9PSBzeW1ib2xTaXplUm93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RpbWVuc2lvbiBvZiBiaXRNYXRyaXggbXVzdCBtYXRjaCB0aGUgdmVyc2lvbiBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFSZWdpb25TaXplUm93cyA9IHRoaXMudmVyc2lvbi5nZXREYXRhUmVnaW9uU2l6ZVJvd3MoKTtcbiAgICAgICAgdmFyIGRhdGFSZWdpb25TaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXREYXRhUmVnaW9uU2l6ZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIG51bURhdGFSZWdpb25zUm93ID0gc3ltYm9sU2l6ZVJvd3MgLyBkYXRhUmVnaW9uU2l6ZVJvd3MgfCAwO1xuICAgICAgICB2YXIgbnVtRGF0YVJlZ2lvbnNDb2x1bW4gPSBzeW1ib2xTaXplQ29sdW1ucyAvIGRhdGFSZWdpb25TaXplQ29sdW1ucyB8IDA7XG4gICAgICAgIHZhciBzaXplRGF0YVJlZ2lvblJvdyA9IG51bURhdGFSZWdpb25zUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICB2YXIgc2l6ZURhdGFSZWdpb25Db2x1bW4gPSBudW1EYXRhUmVnaW9uc0NvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgdmFyIGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChzaXplRGF0YVJlZ2lvbkNvbHVtbiwgc2l6ZURhdGFSZWdpb25Sb3cpO1xuICAgICAgICBmb3IgKHZhciBkYXRhUmVnaW9uUm93ID0gMDsgZGF0YVJlZ2lvblJvdyA8IG51bURhdGFSZWdpb25zUm93OyArK2RhdGFSZWdpb25Sb3cpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUmVnaW9uUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvdyAqIGRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgICAgIGZvciAodmFyIGRhdGFSZWdpb25Db2x1bW4gPSAwOyBkYXRhUmVnaW9uQ29sdW1uIDwgbnVtRGF0YVJlZ2lvbnNDb2x1bW47ICsrZGF0YVJlZ2lvbkNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFSZWdpb25TaXplUm93czsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvdyAqIChkYXRhUmVnaW9uU2l6ZVJvd3MgKyAyKSArIDEgKyBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVSb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93T2Zmc2V0ICsgaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRDb2x1bW5PZmZzZXQgPSBkYXRhUmVnaW9uQ29sdW1uICogKGRhdGFSZWdpb25TaXplQ29sdW1ucyArIDIpICsgMSArIGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldChyZWFkQ29sdW1uT2Zmc2V0LCByZWFkUm93T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cml0ZUNvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW5PZmZzZXQgKyBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQuc2V0KHdyaXRlQ29sdW1uT2Zmc2V0LCB3cml0ZVJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gQml0TWF0cml4UGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdE1hdHJpeFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n * is represented by an instance of this class.</p>\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataBlock = /** @class */ (function () {\n    function DataBlock(numDataCodewords, codewords) {\n        this.numDataCodewords = numDataCodewords;\n        this.codewords = codewords;\n    }\n    /**\n     * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\n     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n     * method will separate the data into original blocks.</p>\n     *\n     * @param rawCodewords bytes as read directly from the Data Matrix Code\n     * @param version version of the Data Matrix Code\n     * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n     *         Data Matrix Code\n     */\n    DataBlock.getDataBlocks = function (rawCodewords, version) {\n        var e_1, _a, e_2, _b;\n        // Figure out the number and size of data blocks used by this version\n        var ecBlocks = version.getECBlocks();\n        // First count the total number of data blocks\n        var totalBlocks = 0;\n        var ecBlockArray = ecBlocks.getECBlocks();\n        try {\n            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\n                var ecBlock = ecBlockArray_1_1.value;\n                totalBlocks += ecBlock.getCount();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Now establish DataBlocks of the appropriate size and number of data codewords\n        var result = new Array(totalBlocks);\n        var numResultBlocks = 0;\n        try {\n            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\n                var ecBlock = ecBlockArray_2_1.value;\n                for (var i = 0; i < ecBlock.getCount(); i++) {\n                    var numDataCodewords = ecBlock.getDataCodewords();\n                    var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // All blocks have the same amount of data, except that the last n\n        // (where n may be 0) have 1 less byte. Figure out where these start.\n        // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\n        var longerBlocksTotalCodewords = result[0].codewords.length;\n        // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\n        var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\n        var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;\n        // The last elements of result may be 1 element shorter for 144 matrix\n        // first fill out as many elements as all of them have minus 1\n        var rawCodewordsOffset = 0;\n        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n            for (var j = 0; j < numResultBlocks; j++) {\n                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n            }\n        }\n        // Fill out the last data block in the longer ones\n        var specialVersion = version.getVersionNumber() === 24;\n        var numLongerBlocks = specialVersion ? 8 : numResultBlocks;\n        for (var j = 0; j < numLongerBlocks; j++) {\n            result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\n        }\n        // Now add in error correction blocks\n        var max = result[0].codewords.length;\n        for (var i = longerBlocksNumDataCodewords; i < max; i++) {\n            for (var j = 0; j < numResultBlocks; j++) {\n                var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\n                var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\n                result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n            }\n        }\n        if (rawCodewordsOffset !== rawCodewords.length) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return result;\n    };\n    DataBlock.prototype.getNumDataCodewords = function () {\n        return this.numDataCodewords;\n    };\n    DataBlock.prototype.getCodewords = function () {\n        return this.codewords;\n    };\n    return DataBlock;\n}());\nexports[\"default\"] = DataBlock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGF0YUJsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHFLQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csd0JBQXdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3Ryx3QkFBd0I7QUFDaEk7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNELDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVELDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGF0YUJsb2NrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBibG9jayBvZiBkYXRhIHdpdGhpbiBhIERhdGEgTWF0cml4IENvZGUuIERhdGEgTWF0cml4IENvZGVzIG1heSBzcGxpdCB0aGVpciBkYXRhIGludG9cbiAqIG11bHRpcGxlIGJsb2NrcywgZWFjaCBvZiB3aGljaCBpcyBhIHVuaXQgb2YgZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMuIEVhY2hcbiAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxuICpcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICovXG52YXIgRGF0YUJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBjb2Rld29yZHMpIHtcbiAgICAgICAgdGhpcy5udW1EYXRhQ29kZXdvcmRzID0gbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPldoZW4gRGF0YSBNYXRyaXggQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFjdHVhbGx5IGludGVybGVhdmUgdGhlIGJ5dGVzIG9mIGVhY2ggb2YgdGhlbS5cbiAgICAgKiBUaGF0IGlzLCB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhIGJsb2NrIDEgdG8gbiBpcyB3cml0dGVuLCB0aGVuIHRoZSBzZWNvbmQgYnl0ZXMsIGFuZCBzbyBvbi4gVGhpc1xuICAgICAqIG1ldGhvZCB3aWxsIHNlcGFyYXRlIHRoZSBkYXRhIGludG8gb3JpZ2luYWwgYmxvY2tzLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYXdDb2Rld29yZHMgYnl0ZXMgYXMgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcbiAgICAgKiAgICAgICAgIERhdGEgTWF0cml4IENvZGVcbiAgICAgKi9cbiAgICBEYXRhQmxvY2suZ2V0RGF0YUJsb2NrcyA9IGZ1bmN0aW9uIChyYXdDb2Rld29yZHMsIHZlcnNpb24pIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvblxuICAgICAgICB2YXIgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzKCk7XG4gICAgICAgIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3NcbiAgICAgICAgdmFyIHRvdGFsQmxvY2tzID0gMDtcbiAgICAgICAgdmFyIGVjQmxvY2tBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2NrQXJyYXlfMSA9IF9fdmFsdWVzKGVjQmxvY2tBcnJheSksIGVjQmxvY2tBcnJheV8xXzEgPSBlY0Jsb2NrQXJyYXlfMS5uZXh0KCk7ICFlY0Jsb2NrQXJyYXlfMV8xLmRvbmU7IGVjQmxvY2tBcnJheV8xXzEgPSBlY0Jsb2NrQXJyYXlfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjQmxvY2tBcnJheV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZWNCbG9ja0FycmF5XzFfMSAmJiAhZWNCbG9ja0FycmF5XzFfMS5kb25lICYmIChfYSA9IGVjQmxvY2tBcnJheV8xLnJldHVybikpIF9hLmNhbGwoZWNCbG9ja0FycmF5XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBlc3RhYmxpc2ggRGF0YUJsb2NrcyBvZiB0aGUgYXBwcm9wcmlhdGUgc2l6ZSBhbmQgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodG90YWxCbG9ja3MpO1xuICAgICAgICB2YXIgbnVtUmVzdWx0QmxvY2tzID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGVjQmxvY2tBcnJheV8yID0gX192YWx1ZXMoZWNCbG9ja0FycmF5KSwgZWNCbG9ja0FycmF5XzJfMSA9IGVjQmxvY2tBcnJheV8yLm5leHQoKTsgIWVjQmxvY2tBcnJheV8yXzEuZG9uZTsgZWNCbG9ja0FycmF5XzJfMSA9IGVjQmxvY2tBcnJheV8yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja0FycmF5XzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjQmxvY2suZ2V0Q291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1EYXRhQ29kZXdvcmRzID0gZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1CbG9ja0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCkgKyBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBuZXcgVWludDhBcnJheShudW1CbG9ja0NvZGV3b3JkcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVjQmxvY2tBcnJheV8yXzEgJiYgIWVjQmxvY2tBcnJheV8yXzEuZG9uZSAmJiAoX2IgPSBlY0Jsb2NrQXJyYXlfMi5yZXR1cm4pKSBfYi5jYWxsKGVjQmxvY2tBcnJheV8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgYmxvY2tzIGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGRhdGEsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0IG5cbiAgICAgICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBsZXNzIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuXG4gICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlcmUgaXMgb25seSBvbmUgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgZm9yIERhdGEgTWF0cml4IGZvciBzaXplIDE0NFxuICAgICAgICB2YXIgbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgLy8gaW50IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gMTtcbiAgICAgICAgdmFyIGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCk7XG4gICAgICAgIHZhciBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMgLSAxO1xuICAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50cyBvZiByZXN1bHQgbWF5IGJlIDEgZWxlbWVudCBzaG9ydGVyIGZvciAxNDQgbWF0cml4XG4gICAgICAgIC8vIGZpcnN0IGZpbGwgb3V0IGFzIG1hbnkgZWxlbWVudHMgYXMgYWxsIG9mIHRoZW0gaGF2ZSBtaW51cyAxXG4gICAgICAgIHZhciByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xuICAgICAgICB2YXIgc3BlY2lhbFZlcnNpb24gPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA9PT0gMjQ7XG4gICAgICAgIHZhciBudW1Mb25nZXJCbG9ja3MgPSBzcGVjaWFsVmVyc2lvbiA/IDggOiBudW1SZXN1bHRCbG9ja3M7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTG9uZ2VyQmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyAtIDFdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gICAgICAgIHZhciBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBqT2Zmc2V0ID0gc3BlY2lhbFZlcnNpb24gPyAoaiArIDgpICUgbnVtUmVzdWx0QmxvY2tzIDogajtcbiAgICAgICAgICAgICAgICB2YXIgaU9mZnNldCA9IHNwZWNpYWxWZXJzaW9uICYmIGpPZmZzZXQgPiA3ID8gaSAtIDEgOiBpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtqT2Zmc2V0XS5jb2Rld29yZHNbaU9mZnNldF0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdDb2Rld29yZHNPZmZzZXQgIT09IHJhd0NvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERhdGFCbG9jay5wcm90b3R5cGUuZ2V0TnVtRGF0YUNvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtRGF0YUNvZGV3b3JkcztcbiAgICB9O1xuICAgIERhdGFCbG9jay5wcm90b3R5cGUuZ2V0Q29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUJsb2NrO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFCbG9jaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js":
/*!*************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\");\nvar BitSource_1 = __webpack_require__(/*! ../../common/BitSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Mode;\n(function (Mode) {\n    Mode[Mode[\"PAD_ENCODE\"] = 0] = \"PAD_ENCODE\";\n    Mode[Mode[\"ASCII_ENCODE\"] = 1] = \"ASCII_ENCODE\";\n    Mode[Mode[\"C40_ENCODE\"] = 2] = \"C40_ENCODE\";\n    Mode[Mode[\"TEXT_ENCODE\"] = 3] = \"TEXT_ENCODE\";\n    Mode[Mode[\"ANSIX12_ENCODE\"] = 4] = \"ANSIX12_ENCODE\";\n    Mode[Mode[\"EDIFACT_ENCODE\"] = 5] = \"EDIFACT_ENCODE\";\n    Mode[Mode[\"BASE256_ENCODE\"] = 6] = \"BASE256_ENCODE\";\n})(Mode || (Mode = {}));\n/**\n * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one Data Matrix Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>\n *\n * @author bbrown@google.com (Brian Brown)\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var resultTrailer = new StringBuilder_1.default();\n        var byteSegments = new Array();\n        var mode = Mode.ASCII_ENCODE;\n        do {\n            if (mode === Mode.ASCII_ENCODE) {\n                mode = this.decodeAsciiSegment(bits, result, resultTrailer);\n            }\n            else {\n                switch (mode) {\n                    case Mode.C40_ENCODE:\n                        this.decodeC40Segment(bits, result);\n                        break;\n                    case Mode.TEXT_ENCODE:\n                        this.decodeTextSegment(bits, result);\n                        break;\n                    case Mode.ANSIX12_ENCODE:\n                        this.decodeAnsiX12Segment(bits, result);\n                        break;\n                    case Mode.EDIFACT_ENCODE:\n                        this.decodeEdifactSegment(bits, result);\n                        break;\n                    case Mode.BASE256_ENCODE:\n                        this.decodeBase256Segment(bits, result, byteSegments);\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n                mode = Mode.ASCII_ENCODE;\n            }\n        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);\n        if (resultTrailer.length() > 0) {\n            result.append(resultTrailer.toString());\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2\n     */\n    DecodedBitStreamParser.decodeAsciiSegment = function (bits, result, resultTrailer) {\n        var upperShift = false;\n        do {\n            var oneByte = bits.readBits(8);\n            if (oneByte === 0) {\n                throw new FormatException_1.default();\n            }\n            else if (oneByte <= 128) { // ASCII data (ASCII value + 1)\n                if (upperShift) {\n                    oneByte += 128;\n                    // upperShift = false;\n                }\n                result.append(String.fromCharCode(oneByte - 1));\n                return Mode.ASCII_ENCODE;\n            }\n            else if (oneByte === 129) { // Pad\n                return Mode.PAD_ENCODE;\n            }\n            else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)\n                var value = oneByte - 130;\n                if (value < 10) { // pad with '0' for single digit values\n                    result.append('0');\n                }\n                result.append('' + value);\n            }\n            else {\n                switch (oneByte) {\n                    case 230: // Latch to C40 encodation\n                        return Mode.C40_ENCODE;\n                    case 231: // Latch to Base 256 encodation\n                        return Mode.BASE256_ENCODE;\n                    case 232: // FNC1\n                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                        break;\n                    case 233: // Structured Append\n                    case 234: // Reader Programming\n                        // Ignore these symbols for now\n                        // throw ReaderException.getInstance();\n                        break;\n                    case 235: // Upper Shift (shift to Extended ASCII)\n                        upperShift = true;\n                        break;\n                    case 236: // 05 Macro\n                        result.append('[)>\\u001E05\\u001D');\n                        resultTrailer.insert(0, '\\u001E\\u0004');\n                        break;\n                    case 237: // 06 Macro\n                        result.append('[)>\\u001E06\\u001D');\n                        resultTrailer.insert(0, '\\u001E\\u0004');\n                        break;\n                    case 238: // Latch to ANSI X12 encodation\n                        return Mode.ANSIX12_ENCODE;\n                    case 239: // Latch to Text encodation\n                        return Mode.TEXT_ENCODE;\n                    case 240: // Latch to EDIFACT encodation\n                        return Mode.EDIFACT_ENCODE;\n                    case 241: // ECI Character\n                        // TODO(bbrown): I think we need to support ECI\n                        // throw ReaderException.getInstance();\n                        // Ignore this symbol for now\n                        break;\n                    default:\n                        // Not to be used in ASCII encodation\n                        // but work around encoders that end with 254, latch back to ASCII\n                        if (oneByte !== 254 || bits.available() !== 0) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            }\n        } while (bits.available() > 0);\n        return Mode.ASCII_ENCODE;\n    };\n    /**\n     * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1\n     */\n    DecodedBitStreamParser.decodeC40Segment = function (bits, result) {\n        // Three C40 values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time\n        var upperShift = false;\n        var cValues = [];\n        var shift = 0;\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (shift) {\n                    case 0:\n                        if (cValue < 3) {\n                            shift = cValue + 1;\n                        }\n                        else if (cValue < this.C40_BASIC_SET_CHARS.length) {\n                            var c40char = this.C40_BASIC_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(c40char);\n                            }\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 1:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 128));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue));\n                        }\n                        shift = 0;\n                        break;\n                    case 2:\n                        if (cValue < this.C40_SHIFT2_SET_CHARS.length) {\n                            var c40char = this.C40_SHIFT2_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(c40char);\n                            }\n                        }\n                        else {\n                            switch (cValue) {\n                                case 27: // FNC1\n                                    result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                    break;\n                                case 30: // Upper Shift\n                                    upperShift = true;\n                                    break;\n                                default:\n                                    throw new FormatException_1.default();\n                            }\n                        }\n                        shift = 0;\n                        break;\n                    case 3:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 224));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue + 96));\n                        }\n                        shift = 0;\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2\n     */\n    DecodedBitStreamParser.decodeTextSegment = function (bits, result) {\n        // Three Text values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time\n        var upperShift = false;\n        var cValues = [];\n        var shift = 0;\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (shift) {\n                    case 0:\n                        if (cValue < 3) {\n                            shift = cValue + 1;\n                        }\n                        else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {\n                            var textChar = this.TEXT_BASIC_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 1:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 128));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue));\n                        }\n                        shift = 0;\n                        break;\n                    case 2:\n                        // Shift 2 for Text is the same encoding as C40\n                        if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {\n                            var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                        }\n                        else {\n                            switch (cValue) {\n                                case 27: // FNC1\n                                    result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                    break;\n                                case 30: // Upper Shift\n                                    upperShift = true;\n                                    break;\n                                default:\n                                    throw new FormatException_1.default();\n                            }\n                        }\n                        shift = 0;\n                        break;\n                    case 3:\n                        if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {\n                            var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                            shift = 0;\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.7\n     */\n    DecodedBitStreamParser.decodeAnsiX12Segment = function (bits, result) {\n        // Three ANSI X12 values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        var cValues = [];\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (cValue) {\n                    case 0: // X12 segment terminator <CR>\n                        result.append('\\r');\n                        break;\n                    case 1: // X12 segment separator *\n                        result.append('*');\n                        break;\n                    case 2: // X12 sub-element separator >\n                        result.append('>');\n                        break;\n                    case 3: // space\n                        result.append(' ');\n                        break;\n                    default:\n                        if (cValue < 14) { // 0 - 9\n                            result.append(String.fromCharCode(cValue + 44));\n                        }\n                        else if (cValue < 40) { // A - Z\n                            result.append(String.fromCharCode(cValue + 51));\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    DecodedBitStreamParser.parseTwoBytes = function (firstByte, secondByte, result) {\n        var fullBitValue = (firstByte << 8) + secondByte - 1;\n        var temp = Math.floor(fullBitValue / 1600);\n        result[0] = temp;\n        fullBitValue -= temp * 1600;\n        temp = Math.floor(fullBitValue / 40);\n        result[1] = temp;\n        result[2] = fullBitValue - temp * 40;\n    };\n    /**\n     * See ISO 16022:2006, 5.2.8 and Annex C Table C.3\n     */\n    DecodedBitStreamParser.decodeEdifactSegment = function (bits, result) {\n        do {\n            // If there is only two or less bytes left then it will be encoded as ASCII\n            if (bits.available() <= 16) {\n                return;\n            }\n            for (var i = 0; i < 4; i++) {\n                var edifactValue = bits.readBits(6);\n                // Check for the unlatch character\n                if (edifactValue === 0x1F) { // 011111\n                    // Read rest of byte, which should be 0, and stop\n                    var bitsLeft = 8 - bits.getBitOffset();\n                    if (bitsLeft !== 8) {\n                        bits.readBits(bitsLeft);\n                    }\n                    return;\n                }\n                if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit\n                    edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value\n                }\n                result.append(String.fromCharCode(edifactValue));\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.9 and Annex B, B.2\n     */\n    DecodedBitStreamParser.decodeBase256Segment = function (bits, result, byteSegments) {\n        // Figure out how long the Base 256 Segment is.\n        var codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed\n        var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        var count;\n        if (d1 === 0) { // Read the remainder of the symbol\n            count = bits.available() / 8 | 0;\n        }\n        else if (d1 < 250) {\n            count = d1;\n        }\n        else {\n            count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        }\n        // We're seeing NegativeArraySizeException errors from users.\n        if (count < 0) {\n            throw new FormatException_1.default();\n        }\n        var bytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            // Have seen this particular error in the wild, such as at\n            // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2\n            if (bits.available() < 8) {\n                throw new FormatException_1.default();\n            }\n            bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        }\n        byteSegments.push(bytes);\n        try {\n            result.append(StringEncoding_1.default.decode(bytes, StringUtils_1.default.ISO88591));\n        }\n        catch (uee) {\n            throw new IllegalStateException_1.default('Platform does not support required encoding: ' + uee.message);\n        }\n    };\n    /**\n     * See ISO 16022:2006, Annex B, B.2\n     */\n    DecodedBitStreamParser.unrandomize255State = function (randomizedBase256Codeword, base256CodewordPosition) {\n        var pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;\n        var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;\n        return tempVariable >= 0 ? tempVariable : tempVariable + 256;\n    };\n    /**\n     * See ISO 16022:2006, Annex C Table C.1\n     * The C40 Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [\n        '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.',\n        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_'\n    ];\n    /**\n     * See ISO 16022:2006, Annex C Table C.2\n     * The Text Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    // Shift 2 for Text is the same encoding as C40\n    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;\n    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [\n        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)\n    ];\n    return DecodedBitStreamParser;\n}());\nexports[\"default\"] = DecodedBitStreamParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyw2SkFBNEI7QUFDMUQsa0JBQWtCLG1CQUFPLENBQUMscUpBQXdCO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQywySkFBMkI7QUFDMUQsb0JBQW9CLG1CQUFPLENBQUMseUpBQTBCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLG1KQUF1QjtBQUN2RCw4QkFBOEIsbUJBQU8sQ0FBQywrSkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9kZWNvZGVyL0RlY29kZWRCaXRTdHJlYW1QYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVjb2RlclJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9EZWNvZGVyUmVzdWx0XCIpO1xudmFyIEJpdFNvdXJjZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRTb3VyY2VcIik7XG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbnZhciBTdHJpbmdFbmNvZGluZ18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nRW5jb2RpbmdcIik7XG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vU3RyaW5nVXRpbHNcIik7XG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIE1vZGU7XG4oZnVuY3Rpb24gKE1vZGUpIHtcbiAgICBNb2RlW01vZGVbXCJQQURfRU5DT0RFXCJdID0gMF0gPSBcIlBBRF9FTkNPREVcIjtcbiAgICBNb2RlW01vZGVbXCJBU0NJSV9FTkNPREVcIl0gPSAxXSA9IFwiQVNDSUlfRU5DT0RFXCI7XG4gICAgTW9kZVtNb2RlW1wiQzQwX0VOQ09ERVwiXSA9IDJdID0gXCJDNDBfRU5DT0RFXCI7XG4gICAgTW9kZVtNb2RlW1wiVEVYVF9FTkNPREVcIl0gPSAzXSA9IFwiVEVYVF9FTkNPREVcIjtcbiAgICBNb2RlW01vZGVbXCJBTlNJWDEyX0VOQ09ERVwiXSA9IDRdID0gXCJBTlNJWDEyX0VOQ09ERVwiO1xuICAgIE1vZGVbTW9kZVtcIkVESUZBQ1RfRU5DT0RFXCJdID0gNV0gPSBcIkVESUZBQ1RfRU5DT0RFXCI7XG4gICAgTW9kZVtNb2RlW1wiQkFTRTI1Nl9FTkNPREVcIl0gPSA2XSA9IFwiQkFTRTI1Nl9FTkNPREVcIjtcbn0pKE1vZGUgfHwgKE1vZGUgPSB7fSkpO1xuLyoqXG4gKiA8cD5EYXRhIE1hdHJpeCBDb2RlcyBjYW4gZW5jb2RlIHRleHQgYXMgYml0cyBpbiBvbmUgb2Ygc2V2ZXJhbCBtb2RlcywgYW5kIGNhbiB1c2UgbXVsdGlwbGUgbW9kZXNcbiAqIGluIG9uZSBEYXRhIE1hdHJpeCBDb2RlLiBUaGlzIGNsYXNzIGRlY29kZXMgdGhlIGJpdHMgYmFjayBpbnRvIHRleHQuPC9wPlxuICpcbiAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjEgLSA1LjIuOS4yPC9wPlxuICpcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcbiAgICB9XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIGJpdHMgPSBuZXcgQml0U291cmNlXzEuZGVmYXVsdChieXRlcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdFRyYWlsZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIGJ5dGVTZWdtZW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgbW9kZSA9IE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5BU0NJSV9FTkNPREUpIHtcbiAgICAgICAgICAgICAgICBtb2RlID0gdGhpcy5kZWNvZGVBc2NpaVNlZ21lbnQoYml0cywgcmVzdWx0LCByZXN1bHRUcmFpbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQzQwX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQzQwU2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5URVhUX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlVGV4dFNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQU5TSVgxMl9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFuc2lYMTJTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkVESUZBQ1RfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVFZGlmYWN0U2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5CQVNFMjU2X0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQmFzZTI1NlNlZ21lbnQoYml0cywgcmVzdWx0LCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGUuUEFEX0VOQ09ERSAmJiBiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgIGlmIChyZXN1bHRUcmFpbGVyLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChyZXN1bHRUcmFpbGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjb2RlclJlc3VsdF8xLmRlZmF1bHQoYnl0ZXMsIHJlc3VsdC50b1N0cmluZygpLCBieXRlU2VnbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJ5dGVTZWdtZW50cywgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi4zIGFuZCBBbm5leCBDLCBUYWJsZSBDLjJcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUFzY2lpU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIHJlc3VsdFRyYWlsZXIpIHtcbiAgICAgICAgdmFyIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG9uZUJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgaWYgKG9uZUJ5dGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAxMjgpIHsgLy8gQVNDSUkgZGF0YSAoQVNDSUkgdmFsdWUgKyAxKVxuICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uZUJ5dGUgKz0gMTI4O1xuICAgICAgICAgICAgICAgICAgICAvLyB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShvbmVCeXRlIC0gMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9uZUJ5dGUgPT09IDEyOSkgeyAvLyBQYWRcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5QQURfRU5DT0RFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAyMjkpIHsgLy8gMi1kaWdpdCBkYXRhIDAwLTk5IChOdW1lcmljIFZhbHVlICsgMTMwKVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9uZUJ5dGUgLSAxMzA7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHsgLy8gcGFkIHdpdGggJzAnIGZvciBzaW5nbGUgZGlnaXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob25lQnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMDogLy8gTGF0Y2ggdG8gQzQwIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkM0MF9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjMxOiAvLyBMYXRjaCB0byBCYXNlIDI1NiBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5CQVNFMjU2X0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzI6IC8vIEZOQzFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMzogLy8gU3RydWN0dXJlZCBBcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzQ6IC8vIFJlYWRlciBQcm9ncmFtbWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZXNlIHN5bWJvbHMgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgUmVhZGVyRXhjZXB0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzU6IC8vIFVwcGVyIFNoaWZ0IChzaGlmdCB0byBFeHRlbmRlZCBBU0NJSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM2OiAvLyAwNSBNYWNyb1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnWyk+XFx1MDAxRTA1XFx1MDAxRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzc6IC8vIDA2IE1hY3JvXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdbKT5cXHUwMDFFMDZcXHUwMDFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUcmFpbGVyLmluc2VydCgwLCAnXFx1MDAxRVxcdTAwMDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzODogLy8gTGF0Y2ggdG8gQU5TSSBYMTIgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQU5TSVgxMl9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM5OiAvLyBMYXRjaCB0byBUZXh0IGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLlRFWFRfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MDogLy8gTGF0Y2ggdG8gRURJRkFDVCBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5FRElGQUNUX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDE6IC8vIEVDSSBDaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogSSB0aGluayB3ZSBuZWVkIHRvIHN1cHBvcnQgRUNJXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBSZWFkZXJFeGNlcHRpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIHN5bWJvbCBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCB0byBiZSB1c2VkIGluIEFTQ0lJIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3b3JrIGFyb3VuZCBlbmNvZGVycyB0aGF0IGVuZCB3aXRoIDI1NCwgbGF0Y2ggYmFjayB0byBBU0NJSVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZUJ5dGUgIT09IDI1NCB8fCBiaXRzLmF2YWlsYWJsZSgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICByZXR1cm4gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi41IGFuZCBBbm5leCBDLCBUYWJsZSBDLjFcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUM0MFNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0KSB7XG4gICAgICAgIC8vIFRocmVlIEM0MCB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcbiAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGUgVXBwZXIgU2hpZnQgd2l0aCBDNDAgZG9lc24ndCB3b3JrIGluIHRoZSA0IHZhbHVlIHNjZW5hcmlvIGFsbCB0aGUgdGltZVxuICAgICAgICB2YXIgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICB2YXIgY1ZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBieXRlIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAyNTQpIHsgLy8gVW5sYXRjaCBjb2Rld29yZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIGJpdHMucmVhZEJpdHMoOCksIGNWYWx1ZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjVmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5DNDBfQkFTSUNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjNDBjaGFyID0gdGhpcy5DNDBfQkFTSUNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGM0MGNoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGM0MGNoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLkM0MF9TSElGVDJfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjNDBjaGFyID0gdGhpcy5DNDBfU0hJRlQyX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjNDBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjNDBjaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBGTkMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpKTsgLy8gdHJhbnNsYXRlIGFzIEFTQ0lJIDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAyMjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgOTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjYgYW5kIEFubmV4IEMsIFRhYmxlIEMuMlxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlVGV4dFNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0KSB7XG4gICAgICAgIC8vIFRocmVlIFRleHQgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXG4gICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlIFVwcGVyIFNoaWZ0IHdpdGggVGV4dCBkb2Vzbid0IHdvcmsgaW4gdGhlIDQgdmFsdWUgc2NlbmFyaW8gYWxsIHRoZSB0aW1lXG4gICAgICAgIHZhciB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgIHZhciBjVmFsdWVzID0gW107XG4gICAgICAgIHZhciBzaGlmdCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGJ5dGUgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNWYWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfQkFTSUNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRleHRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCAyIGZvciBUZXh0IGlzIHRoZSBzYW1lIGVuY29kaW5nIGFzIEM0MFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9TSElGVDJfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDJfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIFVwcGVyIFNoaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi43XG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVBbnNpWDEyU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgLy8gVGhyZWUgQU5TSSBYMTIgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXG4gICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgIHZhciBjVmFsdWVzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGJ5dGUgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogLy8gWDEyIHNlZ21lbnQgdGVybWluYXRvciA8Q1I+XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXHInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIFgxMiBzZWdtZW50IHNlcGFyYXRvciAqXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcqJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBYMTIgc3ViLWVsZW1lbnQgc2VwYXJhdG9yID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAxNCkgeyAvLyAwIC0gOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA0NCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgNDApIHsgLy8gQSAtIFpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgNTEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICB9O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIucGFyc2VUd29CeXRlcyA9IGZ1bmN0aW9uIChmaXJzdEJ5dGUsIHNlY29uZEJ5dGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgZnVsbEJpdFZhbHVlID0gKGZpcnN0Qnl0ZSA8PCA4KSArIHNlY29uZEJ5dGUgLSAxO1xuICAgICAgICB2YXIgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gMTYwMCk7XG4gICAgICAgIHJlc3VsdFswXSA9IHRlbXA7XG4gICAgICAgIGZ1bGxCaXRWYWx1ZSAtPSB0ZW1wICogMTYwMDtcbiAgICAgICAgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gNDApO1xuICAgICAgICByZXN1bHRbMV0gPSB0ZW1wO1xuICAgICAgICByZXN1bHRbMl0gPSBmdWxsQml0VmFsdWUgLSB0ZW1wICogNDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi44IGFuZCBBbm5leCBDIFRhYmxlIEMuM1xuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlRWRpZmFjdFNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgdHdvIG9yIGxlc3MgYnl0ZXMgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPD0gMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlZGlmYWN0VmFsdWUgPSBiaXRzLnJlYWRCaXRzKDYpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgdW5sYXRjaCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBpZiAoZWRpZmFjdFZhbHVlID09PSAweDFGKSB7IC8vIDAxMTExMVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHJlc3Qgb2YgYnl0ZSwgd2hpY2ggc2hvdWxkIGJlIDAsIGFuZCBzdG9wXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRzTGVmdCA9IDggLSBiaXRzLmdldEJpdE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMucmVhZEJpdHMoYml0c0xlZnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChlZGlmYWN0VmFsdWUgJiAweDIwKSA9PT0gMCkgeyAvLyBubyAxIGluIHRoZSBsZWFkaW5nICg2dGgpIGJpdFxuICAgICAgICAgICAgICAgICAgICBlZGlmYWN0VmFsdWUgfD0gMHg0MDsgLy8gQWRkIGEgbGVhZGluZyAwMSB0byB0aGUgNiBiaXQgYmluYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShlZGlmYWN0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuOSBhbmQgQW5uZXggQiwgQi4yXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCYXNlMjU2U2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIGJ5dGVTZWdtZW50cykge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IGhvdyBsb25nIHRoZSBCYXNlIDI1NiBTZWdtZW50IGlzLlxuICAgICAgICB2YXIgY29kZXdvcmRQb3NpdGlvbiA9IDEgKyBiaXRzLmdldEJ5dGVPZmZzZXQoKTsgLy8gcG9zaXRpb24gaXMgMS1pbmRleGVkXG4gICAgICAgIHZhciBkMSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICB2YXIgY291bnQ7XG4gICAgICAgIGlmIChkMSA9PT0gMCkgeyAvLyBSZWFkIHRoZSByZW1haW5kZXIgb2YgdGhlIHN5bWJvbFxuICAgICAgICAgICAgY291bnQgPSBiaXRzLmF2YWlsYWJsZSgpIC8gOCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZDEgPCAyNTApIHtcbiAgICAgICAgICAgIGNvdW50ID0gZDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IDI1MCAqIChkMSAtIDI0OSkgKyB0aGlzLnVucmFuZG9taXplMjU1U3RhdGUoYml0cy5yZWFkQml0cyg4KSwgY29kZXdvcmRQb3NpdGlvbisrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBzZWVpbmcgTmVnYXRpdmVBcnJheVNpemVFeGNlcHRpb24gZXJyb3JzIGZyb20gdXNlcnMuXG4gICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIC8vIEhhdmUgc2VlbiB0aGlzIHBhcnRpY3VsYXIgZXJyb3IgaW4gdGhlIHdpbGQsIHN1Y2ggYXMgYXRcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuYmNnZW4uY29tL2RlbW8vSURBdXRvbWF0aW9uU3RyZWFtaW5nRGF0YU1hdHJpeC5hc3B4P01PREU9MyZEPUZyZWQmUEZNVD0zJlBUPUYmWD0wLjMmTz0wJkxNPTAuMlxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzW2ldID0gdGhpcy51bnJhbmRvbWl6ZTI1NVN0YXRlKGJpdHMucmVhZEJpdHMoOCksIGNvZGV3b3JkUG9zaXRpb24rKyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2goYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZGVjb2RlKGJ5dGVzLCBTdHJpbmdVdGlsc18xLmRlZmF1bHQuSVNPODg1OTEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodWVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEuZGVmYXVsdCgnUGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBlbmNvZGluZzogJyArIHVlZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCBBbm5leCBCLCBCLjJcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnVucmFuZG9taXplMjU1U3RhdGUgPSBmdW5jdGlvbiAocmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCwgYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHBzZXVkb1JhbmRvbU51bWJlciA9ICgoMTQ5ICogYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pICUgMjU1KSArIDE7XG4gICAgICAgIHZhciB0ZW1wVmFyaWFibGUgPSByYW5kb21pemVkQmFzZTI1NkNvZGV3b3JkIC0gcHNldWRvUmFuZG9tTnVtYmVyO1xuICAgICAgICByZXR1cm4gdGVtcFZhcmlhYmxlID49IDAgPyB0ZW1wVmFyaWFibGUgOiB0ZW1wVmFyaWFibGUgKyAyNTY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEMgVGFibGUgQy4xXG4gICAgICogVGhlIEM0MCBCYXNpYyBDaGFyYWN0ZXIgU2V0ICgqJ3MgdXNlZCBmb3IgcGxhY2Vob2xkZXJzIGZvciB0aGUgc2hpZnQgdmFsdWVzKVxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX0JBU0lDX1NFVF9DSEFSUyA9IFtcbiAgICAgICAgJyonLCAnKicsICcqJywgJyAnLCAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgICAgICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLFxuICAgICAgICAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXG4gICAgXTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkM0MF9TSElGVDJfU0VUX0NIQVJTID0gW1xuICAgICAgICAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJyxcbiAgICAgICAgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEMgVGFibGUgQy4yXG4gICAgICogVGhlIFRleHQgQmFzaWMgQ2hhcmFjdGVyIFNldCAoKidzIHVzZWQgZm9yIHBsYWNlaG9sZGVycyBmb3IgdGhlIHNoaWZ0IHZhbHVlcylcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQkFTSUNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnKicsICcqJywgJyonLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAgICAgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsXG4gICAgICAgICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneidcbiAgICBdO1xuICAgIC8vIFNoaWZ0IDIgZm9yIFRleHQgaXMgdGhlIHNhbWUgZW5jb2RpbmcgYXMgQzQwXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX1NISUZUMl9TRVRfQ0hBUlMgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkM0MF9TSElGVDJfU0VUX0NIQVJTO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9TSElGVDNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnYCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLFxuICAgICAgICAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAneycsICd8JywgJ30nLCAnficsIFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KVxuICAgIF07XG4gICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\");\nvar BitMatrixParser_1 = __webpack_require__(/*! ./BitMatrixParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js\");\nvar DataBlock_1 = __webpack_require__(/*! ./DataBlock */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js\");\nvar DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n * the Data Matrix Code from an image.</p>\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.DATA_MATRIX_FIELD_256);\n    }\n    /**\n     * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n     * to mean a black module.</p>\n     *\n     * @param bits booleans representing white/black Data Matrix Code modules\n     * @return text and bytes encoded within the Data Matrix Code\n     * @throws FormatException if the Data Matrix Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decode = function (bits) {\n        var e_1, _a;\n        // Construct a parser and read version, error-correction level\n        var parser = new BitMatrixParser_1.default(bits);\n        var version = parser.getVersion();\n        // Read codewords\n        var codewords = parser.readCodewords();\n        // Separate into data blocks\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version);\n        // Count total number of data bytes\n        var totalBytes = 0;\n        try {\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n                var db = dataBlocks_1_1.value;\n                totalBytes += db.getNumDataCodewords();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var resultBytes = new Uint8Array(totalBytes);\n        var dataBlocksCount = dataBlocks.length;\n        // Error-correct and copy data blocks together into a stream of bytes\n        for (var j = 0; j < dataBlocksCount; j++) {\n            var dataBlock = dataBlocks[j];\n            var codewordBytes = dataBlock.getCodewords();\n            var numDataCodewords = dataBlock.getNumDataCodewords();\n            this.correctErrors(codewordBytes, numDataCodewords);\n            for (var i = 0; i < numDataCodewords; i++) {\n                // De-interlace data blocks.\n                resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n            }\n        }\n        // Decode the contents of that stream of bytes\n        return DecodedBitStreamParser_1.default.decode(resultBytes);\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place using Reed-Solomon error correction.</p>\n     *\n     * @param codewordBytes data and error correction codewords\n     * @param numDataCodewords number of codewords that are data bytes\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords) {\n        // const numCodewords = codewordBytes.length;\n        // First read into an array of ints\n        var codewordsInts = new Int32Array(codewordBytes);\n        // for (let i = 0; i < numCodewords; i++) {\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n        // }\n        try {\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n        }\n        catch (ignored /* ReedSolomonException */) {\n            throw new ChecksumException_1.default();\n        }\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\n        // We don't care about errors in the error-correction codewords\n        for (var i = 0; i < numDataCodewords; i++) {\n            codewordBytes[i] = codewordsInts[i];\n        }\n    };\n    return Decoder;\n}());\nexports[\"default\"] = Decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyx1SkFBeUI7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsNktBQW9DO0FBQzlELDJCQUEyQixtQkFBTyxDQUFDLCtMQUE2QztBQUNoRix3QkFBd0IsbUJBQU8sQ0FBQyxrS0FBbUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsc0pBQWE7QUFDdkMsK0JBQStCLG1CQUFPLENBQUMsZ0xBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHNCQUFzQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XG52YXIgUmVlZFNvbG9tb25EZWNvZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL1JlZWRTb2xvbW9uRGVjb2RlclwiKTtcbnZhciBCaXRNYXRyaXhQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0JpdE1hdHJpeFBhcnNlclwiKTtcbnZhciBEYXRhQmxvY2tfMSA9IHJlcXVpcmUoXCIuL0RhdGFCbG9ja1wiKTtcbnZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9EZWNvZGVkQml0U3RyZWFtUGFyc2VyXCIpO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgRGF0YSBNYXRyaXggQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nXG4gKiB0aGUgRGF0YSBNYXRyaXggQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAqXG4gKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAqL1xudmFyIERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyXzEuZGVmYXVsdChHZW5lcmljR0ZfMS5kZWZhdWx0LkRBVEFfTUFUUklYX0ZJRUxEXzI1Nik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgYSBEYXRhIE1hdHJpeCBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlblxuICAgICAqIHRvIG1lYW4gYSBibGFjayBtb2R1bGUuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIGJpdHMgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIERhdGEgTWF0cml4IENvZGUgbW9kdWxlc1xuICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgRGF0YSBNYXRyaXggQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIERlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChiaXRzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXJzZXIgYW5kIHJlYWQgdmVyc2lvbiwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlcl8xLmRlZmF1bHQoYml0cyk7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcGFyc2VyLmdldFZlcnNpb24oKTtcbiAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcbiAgICAgICAgdmFyIGRhdGFCbG9ja3MgPSBEYXRhQmxvY2tfMS5kZWZhdWx0LmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uKTtcbiAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZGF0YUJsb2Nrc18xID0gX192YWx1ZXMoZGF0YUJsb2NrcyksIGRhdGFCbG9ja3NfMV8xID0gZGF0YUJsb2Nrc18xLm5leHQoKTsgIWRhdGFCbG9ja3NfMV8xLmRvbmU7IGRhdGFCbG9ja3NfMV8xID0gZGF0YUJsb2Nrc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IGRhdGFCbG9ja3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZGIuZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUJsb2Nrc18xXzEgJiYgIWRhdGFCbG9ja3NfMV8xLmRvbmUgJiYgKF9hID0gZGF0YUJsb2Nrc18xLnJldHVybikpIF9hLmNhbGwoZGF0YUJsb2Nrc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgdmFyIGRhdGFCbG9ja3NDb3VudCA9IGRhdGFCbG9ja3MubGVuZ3RoO1xuICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhQmxvY2tzQ291bnQ7IGorKykge1xuICAgICAgICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3Nbal07XG4gICAgICAgICAgICB2YXIgY29kZXdvcmRCeXRlcyA9IGRhdGFCbG9jay5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIHZhciBudW1EYXRhQ29kZXdvcmRzID0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gRGUtaW50ZXJsYWNlIGRhdGEgYmxvY2tzLlxuICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW2kgKiBkYXRhQmxvY2tzQ291bnQgKyBqXSA9IGNvZGV3b3JkQnl0ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlc1xuICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcl8xLmRlZmF1bHQuZGVjb2RlKHJlc3VsdEJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZSB1c2luZyBSZWVkLVNvbG9tb24gZXJyb3IgY29ycmVjdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAqIEBwYXJhbSBudW1EYXRhQ29kZXdvcmRzIG51bWJlciBvZiBjb2Rld29yZHMgdGhhdCBhcmUgZGF0YSBieXRlc1xuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIERlY29kZXIucHJvdG90eXBlLmNvcnJlY3RFcnJvcnMgPSBmdW5jdGlvbiAoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcykge1xuICAgICAgICAvLyBjb25zdCBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHNcbiAgICAgICAgdmFyIGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShjb2Rld29yZEJ5dGVzKTtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKykge1xuICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgLy8gfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyogUmVlZFNvbG9tb25FeGNlcHRpb24gKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXG4gICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgY29kZXdvcmRCeXRlc1tpXSA9IGNvZGV3b3Jkc0ludHNbaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ECB = exports.ECBlocks = void 0;\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n * each set of blocks. It also holds the number of error-correction codewords per block since it\n * will be the same across all blocks within one version.</p>\n */\nvar ECBlocks = /** @class */ (function () {\n    function ECBlocks(ecCodewords, ecBlocks1, ecBlocks2) {\n        this.ecCodewords = ecCodewords;\n        this.ecBlocks = [ecBlocks1];\n        ecBlocks2 && this.ecBlocks.push(ecBlocks2);\n    }\n    ECBlocks.prototype.getECCodewords = function () {\n        return this.ecCodewords;\n    };\n    ECBlocks.prototype.getECBlocks = function () {\n        return this.ecBlocks;\n    };\n    return ECBlocks;\n}());\nexports.ECBlocks = ECBlocks;\n/**\n * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n * This includes the number of data codewords, and the number of times a block with these\n * parameters is used consecutively in the Data Matrix code version's format.</p>\n */\nvar ECB = /** @class */ (function () {\n    function ECB(count, dataCodewords) {\n        this.count = count;\n        this.dataCodewords = dataCodewords;\n    }\n    ECB.prototype.getCount = function () {\n        return this.count;\n    };\n    ECB.prototype.getDataCodewords = function () {\n        return this.dataCodewords;\n    };\n    return ECB;\n}());\nexports.ECB = ECB;\n/**\n * The Version object encapsulates attributes about a particular\n * size Data Matrix Code.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar Version = /** @class */ (function () {\n    function Version(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {\n        var e_1, _a;\n        this.versionNumber = versionNumber;\n        this.symbolSizeRows = symbolSizeRows;\n        this.symbolSizeColumns = symbolSizeColumns;\n        this.dataRegionSizeRows = dataRegionSizeRows;\n        this.dataRegionSizeColumns = dataRegionSizeColumns;\n        this.ecBlocks = ecBlocks;\n        // Calculate the total number of codewords\n        var total = 0;\n        var ecCodewords = ecBlocks.getECCodewords();\n        var ecbArray = ecBlocks.getECBlocks();\n        try {\n            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {\n                var ecBlock = ecbArray_1_1.value;\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        this.totalCodewords = total;\n    }\n    Version.prototype.getVersionNumber = function () {\n        return this.versionNumber;\n    };\n    Version.prototype.getSymbolSizeRows = function () {\n        return this.symbolSizeRows;\n    };\n    Version.prototype.getSymbolSizeColumns = function () {\n        return this.symbolSizeColumns;\n    };\n    Version.prototype.getDataRegionSizeRows = function () {\n        return this.dataRegionSizeRows;\n    };\n    Version.prototype.getDataRegionSizeColumns = function () {\n        return this.dataRegionSizeColumns;\n    };\n    Version.prototype.getTotalCodewords = function () {\n        return this.totalCodewords;\n    };\n    Version.prototype.getECBlocks = function () {\n        return this.ecBlocks;\n    };\n    /**\n     * <p>Deduces version information from Data Matrix dimensions.</p>\n     *\n     * @param numRows Number of rows in modules\n     * @param numColumns Number of columns in modules\n     * @return Version for a Data Matrix Code of those dimensions\n     * @throws FormatException if dimensions do correspond to a valid Data Matrix size\n     */\n    Version.getVersionForDimensions = function (numRows, numColumns) {\n        var e_2, _a;\n        if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {\n            throw new FormatException_1.default();\n        }\n        try {\n            for (var _b = __values(Version.VERSIONS), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var version = _c.value;\n                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {\n                    return version;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        throw new FormatException_1.default();\n    };\n    //  @Override\n    Version.prototype.toString = function () {\n        return '' + this.versionNumber;\n    };\n    /**\n     * See ISO 16022:2006 5.5.1 Table 7\n     */\n    Version.buildVersions = function () {\n        return [\n            new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),\n            new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),\n            new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),\n            new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),\n            new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),\n            new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),\n            new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),\n            new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),\n            new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),\n            new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),\n            new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),\n            new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),\n            new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),\n            new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),\n            new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),\n            new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),\n            new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),\n            new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),\n            new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),\n            new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),\n            new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),\n            new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),\n            new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),\n            new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),\n            new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),\n            new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),\n            new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),\n            new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),\n            new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),\n            new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))\n        ];\n    };\n    Version.VERSIONS = Version.buildVersions();\n    return Version;\n}());\nexports[\"default\"] = Version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvVmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsZ0JBQWdCO0FBQzlCLHdCQUF3QixtQkFBTyxDQUFDLG1KQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixvQkFBb0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9kZWNvZGVyL1ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVDQiA9IGV4cG9ydHMuRUNCbG9ja3MgPSB2b2lkIDA7XG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIHNldCBvZiBlcnJvci1jb3JyZWN0aW9uIGJsb2NrcyBpbiBvbmUgc3ltYm9sIHZlcnNpb24uIE1vc3QgdmVyc2lvbnMgd2lsbFxuICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yXG4gKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXRcbiAqIHdpbGwgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBibG9ja3Mgd2l0aGluIG9uZSB2ZXJzaW9uLjwvcD5cbiAqL1xudmFyIEVDQmxvY2tzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVDQmxvY2tzKGVjQ29kZXdvcmRzLCBlY0Jsb2NrczEsIGVjQmxvY2tzMikge1xuICAgICAgICB0aGlzLmVjQ29kZXdvcmRzID0gZWNDb2Rld29yZHM7XG4gICAgICAgIHRoaXMuZWNCbG9ja3MgPSBbZWNCbG9ja3MxXTtcbiAgICAgICAgZWNCbG9ja3MyICYmIHRoaXMuZWNCbG9ja3MucHVzaChlY0Jsb2NrczIpO1xuICAgIH1cbiAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0RUNDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzO1xuICAgIH07XG4gICAgRUNCbG9ja3MucHJvdG90eXBlLmdldEVDQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgICB9O1xuICAgIHJldHVybiBFQ0Jsb2Nrcztcbn0oKSk7XG5leHBvcnRzLkVDQmxvY2tzID0gRUNCbG9ja3M7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcbiAqIHBhcmFtZXRlcnMgaXMgdXNlZCBjb25zZWN1dGl2ZWx5IGluIHRoZSBEYXRhIE1hdHJpeCBjb2RlIHZlcnNpb24ncyBmb3JtYXQuPC9wPlxuICovXG52YXIgRUNCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVDQihjb3VudCwgZGF0YUNvZGV3b3Jkcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gICAgfVxuICAgIEVDQi5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgIH07XG4gICAgRUNCLnByb3RvdHlwZS5nZXREYXRhQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29kZXdvcmRzO1xuICAgIH07XG4gICAgcmV0dXJuIEVDQjtcbn0oKSk7XG5leHBvcnRzLkVDQiA9IEVDQjtcbi8qKlxuICogVGhlIFZlcnNpb24gb2JqZWN0IGVuY2Fwc3VsYXRlcyBhdHRyaWJ1dGVzIGFib3V0IGEgcGFydGljdWxhclxuICogc2l6ZSBEYXRhIE1hdHJpeCBDb2RlLlxuICpcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICovXG52YXIgVmVyc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIsIHN5bWJvbFNpemVSb3dzLCBzeW1ib2xTaXplQ29sdW1ucywgZGF0YVJlZ2lvblNpemVSb3dzLCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMsIGVjQmxvY2tzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0aGlzLnZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICB0aGlzLnN5bWJvbFNpemVSb3dzID0gc3ltYm9sU2l6ZVJvd3M7XG4gICAgICAgIHRoaXMuc3ltYm9sU2l6ZUNvbHVtbnMgPSBzeW1ib2xTaXplQ29sdW1ucztcbiAgICAgICAgdGhpcy5kYXRhUmVnaW9uU2l6ZVJvd3MgPSBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgIHRoaXMuZGF0YVJlZ2lvblNpemVDb2x1bW5zID0gZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIGNvZGV3b3Jkc1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICB2YXIgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpO1xuICAgICAgICB2YXIgZWNiQXJyYXkgPSBlY0Jsb2Nrcy5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZWNiQXJyYXlfMSA9IF9fdmFsdWVzKGVjYkFycmF5KSwgZWNiQXJyYXlfMV8xID0gZWNiQXJyYXlfMS5uZXh0KCk7ICFlY2JBcnJheV8xXzEuZG9uZTsgZWNiQXJyYXlfMV8xID0gZWNiQXJyYXlfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjYkFycmF5XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlY2JBcnJheV8xXzEgJiYgIWVjYkFycmF5XzFfMS5kb25lICYmIChfYSA9IGVjYkFycmF5XzEucmV0dXJuKSkgX2EuY2FsbChlY2JBcnJheV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gICAgfVxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldFZlcnNpb25OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgfTtcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRTeW1ib2xTaXplUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sU2l6ZVJvd3M7XG4gICAgfTtcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRTeW1ib2xTaXplQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sU2l6ZUNvbHVtbnM7XG4gICAgfTtcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXREYXRhUmVnaW9uU2l6ZVJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFSZWdpb25TaXplUm93cztcbiAgICB9O1xuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldERhdGFSZWdpb25TaXplQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgIH07XG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0VG90YWxDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xuICAgIH07XG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+RGVkdWNlcyB2ZXJzaW9uIGluZm9ybWF0aW9uIGZyb20gRGF0YSBNYXRyaXggZGltZW5zaW9ucy48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiBtb2R1bGVzXG4gICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gbW9kdWxlc1xuICAgICAqIEByZXR1cm4gVmVyc2lvbiBmb3IgYSBEYXRhIE1hdHJpeCBDb2RlIG9mIHRob3NlIGRpbWVuc2lvbnNcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb25zIGRvIGNvcnJlc3BvbmQgdG8gYSB2YWxpZCBEYXRhIE1hdHJpeCBzaXplXG4gICAgICovXG4gICAgVmVyc2lvbi5nZXRWZXJzaW9uRm9yRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAoKG51bVJvd3MgJiAweDAxKSAhPT0gMCB8fCAobnVtQ29sdW1ucyAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFZlcnNpb24uVkVSU0lPTlMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbi5zeW1ib2xTaXplUm93cyA9PT0gbnVtUm93cyAmJiB2ZXJzaW9uLnN5bWJvbFNpemVDb2x1bW5zID09PSBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvLyAgQE92ZXJyaWRlXG4gICAgVmVyc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiA1LjUuMSBUYWJsZSA3XG4gICAgICovXG4gICAgVmVyc2lvbi5idWlsZFZlcnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFZlcnNpb24oMSwgMTAsIDEwLCA4LCA4LCBuZXcgRUNCbG9ja3MoNSwgbmV3IEVDQigxLCAzKSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMiwgMTIsIDEyLCAxMCwgMTAsIG5ldyBFQ0Jsb2Nrcyg3LCBuZXcgRUNCKDEsIDUpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigzLCAxNCwgMTQsIDEyLCAxMiwgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDgpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig0LCAxNiwgMTYsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDEyLCBuZXcgRUNCKDEsIDEyKSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oNSwgMTgsIDE4LCAxNiwgMTYsIG5ldyBFQ0Jsb2NrcygxNCwgbmV3IEVDQigxLCAxOCkpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDYsIDIwLCAyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig3LCAyMiwgMjIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDIwLCBuZXcgRUNCKDEsIDMwKSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oOCwgMjQsIDI0LCAyMiwgMjIsIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigxLCAzNikpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDksIDI2LCAyNiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgNDQpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxMCwgMzIsIDMyLCAxNCwgMTQsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQigxLCA2MikpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDExLCAzNiwgMzYsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDQyLCBuZXcgRUNCKDEsIDg2KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTIsIDQwLCA0MCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNDgsIG5ldyBFQ0IoMSwgMTE0KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTMsIDQ0LCA0NCwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMSwgMTQ0KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTQsIDQ4LCA0OCwgMjIsIDIyLCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoMSwgMTc0KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTUsIDUyLCA1MiwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMiwgMTAyKSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTYsIDY0LCA2NCwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMiwgMTQwKSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTcsIDcyLCA3MiwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoMzYsIG5ldyBFQ0IoNCwgOTIpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxOCwgODAsIDgwLCAxOCwgMTgsIG5ldyBFQ0Jsb2Nrcyg0OCwgbmV3IEVDQig0LCAxMTQpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxOSwgODgsIDg4LCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQig0LCAxNDQpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyMCwgOTYsIDk2LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQig0LCAxNzQpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyMSwgMTA0LCAxMDQsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDYsIDEzNikpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIyLCAxMjAsIDEyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoNiwgMTc1KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjMsIDEzMiwgMTMyLCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg2MiwgbmV3IEVDQig4LCAxNjMpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyNCwgMTQ0LCAxNDQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE1NiksIG5ldyBFQ0IoMiwgMTU1KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjUsIDgsIDE4LCA2LCAxNiwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI2LCA4LCAzMiwgNiwgMTQsIG5ldyBFQ0Jsb2NrcygxMSwgbmV3IEVDQigxLCAxMCkpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI3LCAxMiwgMjYsIDEwLCAyNCwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE2KSkpLFxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjgsIDEyLCAzNiwgMTAsIDE2LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyOSwgMTYsIDM2LCAxNCwgMTYsIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigxLCAzMikpKSxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDMwLCAxNiwgNDgsIDE0LCAyMiwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDQ5KSkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBWZXJzaW9uLlZFUlNJT05TID0gVmVyc2lvbi5idWlsZFZlcnNpb25zKCk7XG4gICAgcmV0dXJuIFZlcnNpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVmVyc2lvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar WhiteRectangleDetector_1 = __webpack_require__(/*! ../../common/detector/WhiteRectangleDetector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js\");\nvar DetectorResult_1 = __webpack_require__(/*! ../../common/DetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js\");\nvar GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n        this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);\n    }\n    /**\n     * <p>Detects a Data Matrix Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    Detector.prototype.detect = function () {\n        var cornerPoints = this.rectangleDetector.detect();\n        var points = this.detectSolid1(cornerPoints);\n        points = this.detectSolid2(points);\n        points[3] = this.correctTopRight(points);\n        if (!points[3]) {\n            throw new NotFoundException_1.default();\n        }\n        points = this.shiftToModuleCenter(points);\n        var topLeft = points[0];\n        var bottomLeft = points[1];\n        var bottomRight = points[2];\n        var topRight = points[3];\n        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n        if ((dimensionTop & 0x01) === 1) {\n            dimensionTop += 1;\n        }\n        if ((dimensionRight & 0x01) === 1) {\n            dimensionRight += 1;\n        }\n        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n            // The matrix is square\n            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n        }\n        var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n        return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n    };\n    Detector.shiftPoint = function (point, to, div) {\n        var x = (to.getX() - point.getX()) / (div + 1);\n        var y = (to.getY() - point.getY()) / (div + 1);\n        return new ResultPoint_1.default(point.getX() + x, point.getY() + y);\n    };\n    Detector.moveAway = function (point, fromX, fromY) {\n        var x = point.getX();\n        var y = point.getY();\n        if (x < fromX) {\n            x -= 1;\n        }\n        else {\n            x += 1;\n        }\n        if (y < fromY) {\n            y -= 1;\n        }\n        else {\n            y += 1;\n        }\n        return new ResultPoint_1.default(x, y);\n    };\n    /**\n     * Detect a solid side which has minimum transition.\n     */\n    Detector.prototype.detectSolid1 = function (cornerPoints) {\n        // 0  2\n        // 1  3\n        var pointA = cornerPoints[0];\n        var pointB = cornerPoints[1];\n        var pointC = cornerPoints[3];\n        var pointD = cornerPoints[2];\n        var trAB = this.transitionsBetween(pointA, pointB);\n        var trBC = this.transitionsBetween(pointB, pointC);\n        var trCD = this.transitionsBetween(pointC, pointD);\n        var trDA = this.transitionsBetween(pointD, pointA);\n        // 0..3\n        // :  :\n        // 1--2\n        var min = trAB;\n        var points = [pointD, pointA, pointB, pointC];\n        if (min > trBC) {\n            min = trBC;\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        if (min > trCD) {\n            min = trCD;\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        if (min > trDA) {\n            points[0] = pointC;\n            points[1] = pointD;\n            points[2] = pointA;\n            points[3] = pointB;\n        }\n        return points;\n    };\n    /**\n     * Detect a second solid side next to first solid side.\n     */\n    Detector.prototype.detectSolid2 = function (points) {\n        // A..D\n        // :  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // Transition detection on the edge is not stable.\n        // To safely detect, shift the points to the module center.\n        var tr = this.transitionsBetween(pointA, pointD);\n        var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n        var trBA = this.transitionsBetween(pointBs, pointA);\n        var trCD = this.transitionsBetween(pointCs, pointD);\n        // 0..3\n        // |  :\n        // 1--2\n        if (trBA < trCD) {\n            // solid sides: A-B-C\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        else {\n            // solid sides: B-C-D\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        return points;\n    };\n    /**\n     * Calculates the corner position of the white top right module.\n     */\n    Detector.prototype.correctTopRight = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // shift points for safe transition detection.\n        var trTop = this.transitionsBetween(pointA, pointD);\n        var trRight = this.transitionsBetween(pointB, pointD);\n        var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n        trTop = this.transitionsBetween(pointAs, pointD);\n        trRight = this.transitionsBetween(pointCs, pointD);\n        var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n        var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n        if (!this.isValid(candidate1)) {\n            if (this.isValid(candidate2)) {\n                return candidate2;\n            }\n            return null;\n        }\n        if (!this.isValid(candidate2)) {\n            return candidate1;\n        }\n        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n        if (sumc1 > sumc2) {\n            return candidate1;\n        }\n        else {\n            return candidate2;\n        }\n    };\n    /**\n     * Shift the edge points to the module center.\n     */\n    Detector.prototype.shiftToModuleCenter = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // calculate pseudo dimensions\n        var dimH = this.transitionsBetween(pointA, pointD) + 1;\n        var dimV = this.transitionsBetween(pointC, pointD) + 1;\n        // shift points for safe dimension detection\n        var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);\n        //  calculate more precise dimensions\n        dimH = this.transitionsBetween(pointAs, pointD) + 1;\n        dimV = this.transitionsBetween(pointCs, pointD) + 1;\n        if ((dimH & 0x01) === 1) {\n            dimH += 1;\n        }\n        if ((dimV & 0x01) === 1) {\n            dimV += 1;\n        }\n        // WhiteRectangleDetector returns points inside of the rectangle.\n        // I want points on the edges.\n        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n        pointA = Detector.moveAway(pointA, centerX, centerY);\n        pointB = Detector.moveAway(pointB, centerX, centerY);\n        pointC = Detector.moveAway(pointC, centerX, centerY);\n        pointD = Detector.moveAway(pointD, centerX, centerY);\n        var pointBs;\n        var pointDs;\n        // shift points to the center of each modules\n        pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n        pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n        pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n        pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n        pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n        pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n        pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n        return [pointAs, pointBs, pointCs, pointDs];\n    };\n    Detector.prototype.isValid = function (p) {\n        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n    };\n    Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n     */\n    Detector.prototype.transitionsBetween = function (from, to) {\n        // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n        var fromX = Math.trunc(from.getX());\n        var fromY = Math.trunc(from.getY());\n        var toX = Math.trunc(to.getX());\n        var toY = Math.trunc(to.getY());\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var ystep = fromY < toY ? 1 : -1;\n        var xstep = fromX < toX ? 1 : -1;\n        var transitions = 0;\n        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n        for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n            var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n            if (isBlack !== inBlack) {\n                transitions++;\n                inBlack = isBlack;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        return transitions;\n    };\n    return Detector;\n}());\nexports[\"default\"] = Detector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2RldGVjdG9yL0RldGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixtQkFBTyxDQUFDLGlNQUE4QztBQUNyRix1QkFBdUIsbUJBQU8sQ0FBQywrSkFBNkI7QUFDNUQsNEJBQTRCLG1CQUFPLENBQUMseUtBQWtDO0FBQ3RFLDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQywySUFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2RhdGFtYXRyaXgvZGV0ZWN0b3IvRGV0ZWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9XaGl0ZVJlY3RhbmdsZURldGVjdG9yXCIpO1xudmFyIERldGVjdG9yUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0RldGVjdG9yUmVzdWx0XCIpO1xudmFyIEdyaWRTYW1wbGVySW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZVwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIERhdGEgTWF0cml4IENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIERhdGEgTWF0cml4IENvZGVcbiAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXRlY3RvcihpbWFnZSkge1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMucmVjdGFuZ2xlRGV0ZWN0b3IgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5pbWFnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPkRldGVjdHMgYSBEYXRhIE1hdHJpeCBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgRGF0YSBNYXRyaXggQ29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gRGF0YSBNYXRyaXggQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ybmVyUG9pbnRzID0gdGhpcy5yZWN0YW5nbGVEZXRlY3Rvci5kZXRlY3QoKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQxKGNvcm5lclBvaW50cyk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQyKHBvaW50cyk7XG4gICAgICAgIHBvaW50c1szXSA9IHRoaXMuY29ycmVjdFRvcFJpZ2h0KHBvaW50cyk7XG4gICAgICAgIGlmICghcG9pbnRzWzNdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRzID0gdGhpcy5zaGlmdFRvTW9kdWxlQ2VudGVyKHBvaW50cyk7XG4gICAgICAgIHZhciB0b3BMZWZ0ID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gcG9pbnRzWzJdO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSBwb2ludHNbM107XG4gICAgICAgIHZhciBkaW1lbnNpb25Ub3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbih0b3BMZWZ0LCB0b3BSaWdodCkgKyAxO1xuICAgICAgICB2YXIgZGltZW5zaW9uUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihib3R0b21SaWdodCwgdG9wUmlnaHQpICsgMTtcbiAgICAgICAgaWYgKChkaW1lbnNpb25Ub3AgJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgZGltZW5zaW9uVG9wICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChkaW1lbnNpb25SaWdodCAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25SaWdodCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICg0ICogZGltZW5zaW9uVG9wIDwgNyAqIGRpbWVuc2lvblJpZ2h0ICYmIDQgKiBkaW1lbnNpb25SaWdodCA8IDcgKiBkaW1lbnNpb25Ub3ApIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXRyaXggaXMgc3F1YXJlXG4gICAgICAgICAgICBkaW1lbnNpb25Ub3AgPSBkaW1lbnNpb25SaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvblRvcCwgZGltZW5zaW9uUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzID0gRGV0ZWN0b3Iuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCwgdG9wUmlnaHQsIGRpbWVuc2lvblRvcCwgZGltZW5zaW9uUmlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0XzEuZGVmYXVsdChiaXRzLCBbdG9wTGVmdCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0XSk7XG4gICAgfTtcbiAgICBEZXRlY3Rvci5zaGlmdFBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCB0bywgZGl2KSB7XG4gICAgICAgIHZhciB4ID0gKHRvLmdldFgoKSAtIHBvaW50LmdldFgoKSkgLyAoZGl2ICsgMSk7XG4gICAgICAgIHZhciB5ID0gKHRvLmdldFkoKSAtIHBvaW50LmdldFkoKSkgLyAoZGl2ICsgMSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHBvaW50LmdldFgoKSArIHgsIHBvaW50LmdldFkoKSArIHkpO1xuICAgIH07XG4gICAgRGV0ZWN0b3IubW92ZUF3YXkgPSBmdW5jdGlvbiAocG9pbnQsIGZyb21YLCBmcm9tWSkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LmdldFgoKTtcbiAgICAgICAgdmFyIHkgPSBwb2ludC5nZXRZKCk7XG4gICAgICAgIGlmICh4IDwgZnJvbVgpIHtcbiAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IGZyb21ZKSB7XG4gICAgICAgICAgICB5IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeCwgeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3QgYSBzb2xpZCBzaWRlIHdoaWNoIGhhcyBtaW5pbXVtIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdFNvbGlkMSA9IGZ1bmN0aW9uIChjb3JuZXJQb2ludHMpIHtcbiAgICAgICAgLy8gMCAgMlxuICAgICAgICAvLyAxICAzXG4gICAgICAgIHZhciBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgIHZhciBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XG4gICAgICAgIHZhciBwb2ludEMgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgIHZhciBwb2ludEQgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgIHZhciB0ckFCID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEIpO1xuICAgICAgICB2YXIgdHJCQyA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QiwgcG9pbnRDKTtcbiAgICAgICAgdmFyIHRyQ0QgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEMsIHBvaW50RCk7XG4gICAgICAgIHZhciB0ckRBID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRELCBwb2ludEEpO1xuICAgICAgICAvLyAwLi4zXG4gICAgICAgIC8vIDogIDpcbiAgICAgICAgLy8gMS0tMlxuICAgICAgICB2YXIgbWluID0gdHJBQjtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtwb2ludEQsIHBvaW50QSwgcG9pbnRCLCBwb2ludENdO1xuICAgICAgICBpZiAobWluID4gdHJCQykge1xuICAgICAgICAgICAgbWluID0gdHJCQztcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QjtcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QztcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50RDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID4gdHJDRCkge1xuICAgICAgICAgICAgbWluID0gdHJDRDtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QjtcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QztcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID4gdHJEQSkge1xuICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRDO1xuICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnREO1xuICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRBO1xuICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRCO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3QgYSBzZWNvbmQgc29saWQgc2lkZSBuZXh0IHRvIGZpcnN0IHNvbGlkIHNpZGUuXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdFNvbGlkMiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgLy8gQS4uRFxuICAgICAgICAvLyA6ICA6XG4gICAgICAgIC8vIEItLUNcbiAgICAgICAgdmFyIHBvaW50QSA9IHBvaW50c1swXTtcbiAgICAgICAgdmFyIHBvaW50QiA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgdmFyIHBvaW50RCA9IHBvaW50c1szXTtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiBkZXRlY3Rpb24gb24gdGhlIGVkZ2UgaXMgbm90IHN0YWJsZS5cbiAgICAgICAgLy8gVG8gc2FmZWx5IGRldGVjdCwgc2hpZnQgdGhlIHBvaW50cyB0byB0aGUgbW9kdWxlIGNlbnRlci5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpO1xuICAgICAgICB2YXIgcG9pbnRCcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRCLCBwb2ludEMsICh0ciArIDEpICogNCk7XG4gICAgICAgIHZhciBwb2ludENzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgKHRyICsgMSkgKiA0KTtcbiAgICAgICAgdmFyIHRyQkEgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEJzLCBwb2ludEEpO1xuICAgICAgICB2YXIgdHJDRCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCk7XG4gICAgICAgIC8vIDAuLjNcbiAgICAgICAgLy8gfCAgOlxuICAgICAgICAvLyAxLS0yXG4gICAgICAgIGlmICh0ckJBIDwgdHJDRCkge1xuICAgICAgICAgICAgLy8gc29saWQgc2lkZXM6IEEtQi1DXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XG4gICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEM7XG4gICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQi1DLURcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QjtcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QztcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29ybmVyIHBvc2l0aW9uIG9mIHRoZSB3aGl0ZSB0b3AgcmlnaHQgbW9kdWxlLlxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5jb3JyZWN0VG9wUmlnaHQgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIC8vIEEuLkRcbiAgICAgICAgLy8gfCAgOlxuICAgICAgICAvLyBCLS1DXG4gICAgICAgIHZhciBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBwb2ludEIgPSBwb2ludHNbMV07XG4gICAgICAgIHZhciBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgIHZhciBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgIC8vIHNoaWZ0IHBvaW50cyBmb3Igc2FmZSB0cmFuc2l0aW9uIGRldGVjdGlvbi5cbiAgICAgICAgdmFyIHRyVG9wID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpO1xuICAgICAgICB2YXIgdHJSaWdodCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QiwgcG9pbnREKTtcbiAgICAgICAgdmFyIHBvaW50QXMgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCAodHJSaWdodCArIDEpICogNCk7XG4gICAgICAgIHZhciBwb2ludENzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgKHRyVG9wICsgMSkgKiA0KTtcbiAgICAgICAgdHJUb3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpO1xuICAgICAgICB0clJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgcG9pbnREKTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZTEgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHBvaW50RC5nZXRYKCkgKyAocG9pbnRDLmdldFgoKSAtIHBvaW50Qi5nZXRYKCkpIC8gKHRyVG9wICsgMSksIHBvaW50RC5nZXRZKCkgKyAocG9pbnRDLmdldFkoKSAtIHBvaW50Qi5nZXRZKCkpIC8gKHRyVG9wICsgMSkpO1xuICAgICAgICB2YXIgY2FuZGlkYXRlMiA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocG9pbnRELmdldFgoKSArIChwb2ludEEuZ2V0WCgpIC0gcG9pbnRCLmdldFgoKSkgLyAodHJSaWdodCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50QS5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clJpZ2h0ICsgMSkpO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZChjYW5kaWRhdGUxKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZChjYW5kaWRhdGUyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW1jMSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIGNhbmRpZGF0ZTEpICsgdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgY2FuZGlkYXRlMSk7XG4gICAgICAgIHZhciBzdW1jMiA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIGNhbmRpZGF0ZTIpICsgdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgY2FuZGlkYXRlMik7XG4gICAgICAgIGlmIChzdW1jMSA+IHN1bWMyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGlmdCB0aGUgZWRnZSBwb2ludHMgdG8gdGhlIG1vZHVsZSBjZW50ZXIuXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLnNoaWZ0VG9Nb2R1bGVDZW50ZXIgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIC8vIEEuLkRcbiAgICAgICAgLy8gfCAgOlxuICAgICAgICAvLyBCLS1DXG4gICAgICAgIHZhciBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBwb2ludEIgPSBwb2ludHNbMV07XG4gICAgICAgIHZhciBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgIHZhciBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwc2V1ZG8gZGltZW5zaW9uc1xuICAgICAgICB2YXIgZGltSCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKSArIDE7XG4gICAgICAgIHZhciBkaW1WID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDLCBwb2ludEQpICsgMTtcbiAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIGRpbWVuc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgdmFyIHBvaW50QXMgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCBkaW1WICogNCk7XG4gICAgICAgIHZhciBwb2ludENzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgZGltSCAqIDQpO1xuICAgICAgICAvLyAgY2FsY3VsYXRlIG1vcmUgcHJlY2lzZSBkaW1lbnNpb25zXG4gICAgICAgIGRpbUggPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpICsgMTtcbiAgICAgICAgZGltViA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCkgKyAxO1xuICAgICAgICBpZiAoKGRpbUggJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgZGltSCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGltViAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICBkaW1WICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpdGVSZWN0YW5nbGVEZXRlY3RvciByZXR1cm5zIHBvaW50cyBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgLy8gSSB3YW50IHBvaW50cyBvbiB0aGUgZWRnZXMuXG4gICAgICAgIHZhciBjZW50ZXJYID0gKHBvaW50QS5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSArIHBvaW50RC5nZXRYKCkpIC8gNDtcbiAgICAgICAgdmFyIGNlbnRlclkgPSAocG9pbnRBLmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpICsgcG9pbnRELmdldFkoKSkgLyA0O1xuICAgICAgICBwb2ludEEgPSBEZXRlY3Rvci5tb3ZlQXdheShwb2ludEEsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBwb2ludEIgPSBEZXRlY3Rvci5tb3ZlQXdheShwb2ludEIsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBwb2ludEMgPSBEZXRlY3Rvci5tb3ZlQXdheShwb2ludEMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBwb2ludEQgPSBEZXRlY3Rvci5tb3ZlQXdheShwb2ludEQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICB2YXIgcG9pbnRCcztcbiAgICAgICAgdmFyIHBvaW50RHM7XG4gICAgICAgIC8vIHNoaWZ0IHBvaW50cyB0byB0aGUgY2VudGVyIG9mIGVhY2ggbW9kdWxlc1xuICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgZGltViAqIDQpO1xuICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEFzLCBwb2ludEQsIGRpbUggKiA0KTtcbiAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRCLCBwb2ludEEsIGRpbVYgKiA0KTtcbiAgICAgICAgcG9pbnRCcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRCcywgcG9pbnRDLCBkaW1IICogNCk7XG4gICAgICAgIHBvaW50Q3MgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRELCBkaW1WICogNCk7XG4gICAgICAgIHBvaW50Q3MgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50Q3MsIHBvaW50QiwgZGltSCAqIDQpO1xuICAgICAgICBwb2ludERzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEQsIHBvaW50QywgZGltViAqIDQpO1xuICAgICAgICBwb2ludERzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludERzLCBwb2ludEEsIGRpbUggKiA0KTtcbiAgICAgICAgcmV0dXJuIFtwb2ludEFzLCBwb2ludEJzLCBwb2ludENzLCBwb2ludERzXTtcbiAgICB9O1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAuZ2V0WCgpID49IDAgJiYgcC5nZXRYKCkgPCB0aGlzLmltYWdlLmdldFdpZHRoKCkgJiYgcC5nZXRZKCkgPiAwICYmIHAuZ2V0WSgpIDwgdGhpcy5pbWFnZS5nZXRIZWlnaHQoKTtcbiAgICB9O1xuICAgIERldGVjdG9yLnNhbXBsZUdyaWQgPSBmdW5jdGlvbiAoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSkge1xuICAgICAgICB2YXIgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2VfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQoaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksIDAuNSwgMC41LCBkaW1lbnNpb25YIC0gMC41LCAwLjUsIGRpbWVuc2lvblggLSAwLjUsIGRpbWVuc2lvblkgLSAwLjUsIDAuNSwgZGltZW5zaW9uWSAtIDAuNSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBibGFjay93aGl0ZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHR3byBwb2ludHMsIHVzaW5nIHNvbWV0aGluZyBsaWtlIEJyZXNlbmhhbSdzIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUudHJhbnNpdGlvbnNCZXR3ZWVuID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIC8vIFNlZSBRUiBDb2RlIERldGVjdG9yLCBzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oKVxuICAgICAgICB2YXIgZnJvbVggPSBNYXRoLnRydW5jKGZyb20uZ2V0WCgpKTtcbiAgICAgICAgdmFyIGZyb21ZID0gTWF0aC50cnVuYyhmcm9tLmdldFkoKSk7XG4gICAgICAgIHZhciB0b1ggPSBNYXRoLnRydW5jKHRvLmdldFgoKSk7XG4gICAgICAgIHZhciB0b1kgPSBNYXRoLnRydW5jKHRvLmdldFkoKSk7XG4gICAgICAgIHZhciBzdGVlcCA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKSA+IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZyb21YO1xuICAgICAgICAgICAgZnJvbVggPSBmcm9tWTtcbiAgICAgICAgICAgIGZyb21ZID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSB0b1g7XG4gICAgICAgICAgICB0b1ggPSB0b1k7XG4gICAgICAgICAgICB0b1kgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpO1xuICAgICAgICB2YXIgZXJyb3IgPSAtZHggLyAyO1xuICAgICAgICB2YXIgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XG4gICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IDA7XG4gICAgICAgIHZhciBpbkJsYWNrID0gdGhpcy5pbWFnZS5nZXQoc3RlZXAgPyBmcm9tWSA6IGZyb21YLCBzdGVlcCA/IGZyb21YIDogZnJvbVkpO1xuICAgICAgICBmb3IgKHZhciB4ID0gZnJvbVgsIHkgPSBmcm9tWTsgeCAhPT0gdG9YOyB4ICs9IHhzdGVwKSB7XG4gICAgICAgICAgICB2YXIgaXNCbGFjayA9IHRoaXMuaW1hZ2UuZ2V0KHN0ZWVwID8geSA6IHgsIHN0ZWVwID8geCA6IHkpO1xuICAgICAgICAgICAgaWYgKGlzQmxhY2sgIT09IGluQmxhY2spIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucysrO1xuICAgICAgICAgICAgICAgIGluQmxhY2sgPSBpc0JsYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gZHk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICBlcnJvciAtPSBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbnM7XG4gICAgfTtcbiAgICByZXR1cm4gRGV0ZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0b3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js":
/*!***************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ASCIIEncoder = void 0;\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\n// tslint:disable-next-line:no-circular-imports\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar ASCIIEncoder = /** @class */ (function () {\n    function ASCIIEncoder() {\n    }\n    ASCIIEncoder.prototype.getEncodingMode = function () {\n        return constants_1.ASCII_ENCODATION;\n    };\n    ASCIIEncoder.prototype.encode = function (context) {\n        // step B\n        var n = HighLevelEncoder_1.default.determineConsecutiveDigitCount(context.getMessage(), context.pos);\n        if (n >= 2) {\n            context.writeCodeword(this.encodeASCIIDigits(context.getMessage().charCodeAt(context.pos), context.getMessage().charCodeAt(context.pos + 1)));\n            context.pos += 2;\n        }\n        else {\n            var c = context.getCurrentChar();\n            var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n            if (newMode !== this.getEncodingMode()) {\n                switch (newMode) {\n                    case constants_1.BASE256_ENCODATION:\n                        context.writeCodeword(constants_1.LATCH_TO_BASE256);\n                        context.signalEncoderChange(constants_1.BASE256_ENCODATION);\n                        return;\n                    case constants_1.C40_ENCODATION:\n                        context.writeCodeword(constants_1.LATCH_TO_C40);\n                        context.signalEncoderChange(constants_1.C40_ENCODATION);\n                        return;\n                    case constants_1.X12_ENCODATION:\n                        context.writeCodeword(constants_1.LATCH_TO_ANSIX12);\n                        context.signalEncoderChange(constants_1.X12_ENCODATION);\n                        break;\n                    case constants_1.TEXT_ENCODATION:\n                        context.writeCodeword(constants_1.LATCH_TO_TEXT);\n                        context.signalEncoderChange(constants_1.TEXT_ENCODATION);\n                        break;\n                    case constants_1.EDIFACT_ENCODATION:\n                        context.writeCodeword(constants_1.LATCH_TO_EDIFACT);\n                        context.signalEncoderChange(constants_1.EDIFACT_ENCODATION);\n                        break;\n                    default:\n                        throw new Error('Illegal mode: ' + newMode);\n                }\n            }\n            else if (HighLevelEncoder_1.default.isExtendedASCII(c)) {\n                context.writeCodeword(constants_1.UPPER_SHIFT);\n                context.writeCodeword(c - 128 + 1);\n                context.pos++;\n            }\n            else {\n                context.writeCodeword(c + 1);\n                context.pos++;\n            }\n        }\n    };\n    ASCIIEncoder.prototype.encodeASCIIDigits = function (digit1, digit2) {\n        if (HighLevelEncoder_1.default.isDigit(digit1) && HighLevelEncoder_1.default.isDigit(digit2)) {\n            var num = (digit1 - 48) * 10 + (digit2 - 48);\n            return num + 130;\n        }\n        throw new Error('not digits: ' + digit1 + digit2);\n    };\n    return ASCIIEncoder;\n}());\nexports.ASCIIEncoder = ASCIIEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvQVNDSUlFbmNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBYTtBQUN2QztBQUNBLHlCQUF5QixtQkFBTyxDQUFDLG9LQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0IiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL0FTQ0lJRW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVNDSUlFbmNvZGVyID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBIaWdoTGV2ZWxFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9IaWdoTGV2ZWxFbmNvZGVyXCIpO1xudmFyIEFTQ0lJRW5jb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU0NJSUVuY29kZXIoKSB7XG4gICAgfVxuICAgIEFTQ0lJRW5jb2Rlci5wcm90b3R5cGUuZ2V0RW5jb2RpbmdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTjtcbiAgICB9O1xuICAgIEFTQ0lJRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gc3RlcCBCXG4gICAgICAgIHZhciBuID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuZGV0ZXJtaW5lQ29uc2VjdXRpdmVEaWdpdENvdW50KGNvbnRleHQuZ2V0TWVzc2FnZSgpLCBjb250ZXh0LnBvcyk7XG4gICAgICAgIGlmIChuID49IDIpIHtcbiAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZCh0aGlzLmVuY29kZUFTQ0lJRGlnaXRzKGNvbnRleHQuZ2V0TWVzc2FnZSgpLmNoYXJDb2RlQXQoY29udGV4dC5wb3MpLCBjb250ZXh0LmdldE1lc3NhZ2UoKS5jaGFyQ29kZUF0KGNvbnRleHQucG9zICsgMSkpKTtcbiAgICAgICAgICAgIGNvbnRleHQucG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNvbnRleHQuZ2V0Q3VycmVudENoYXIoKTtcbiAgICAgICAgICAgIHZhciBuZXdNb2RlID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQubG9va0FoZWFkVGVzdChjb250ZXh0LmdldE1lc3NhZ2UoKSwgY29udGV4dC5wb3MsIHRoaXMuZ2V0RW5jb2RpbmdNb2RlKCkpO1xuICAgICAgICAgICAgaWYgKG5ld01vZGUgIT09IHRoaXMuZ2V0RW5jb2RpbmdNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5ld01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT046XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuTEFUQ0hfVE9fQkFTRTI1Nik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZChjb25zdGFudHNfMS5MQVRDSF9UT19DNDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zaWduYWxFbmNvZGVyQ2hhbmdlKGNvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZChjb25zdGFudHNfMS5MQVRDSF9UT19BTlNJWDEyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2lnbmFsRW5jb2RlckNoYW5nZShjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT046XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuTEFUQ0hfVE9fVEVYVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuVEVYVF9FTkNPREFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkVESUZBQ1RfRU5DT0RBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZChjb25zdGFudHNfMS5MQVRDSF9UT19FRElGQUNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2lnbmFsRW5jb2RlckNoYW5nZShjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbW9kZTogJyArIG5ld01vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRXh0ZW5kZWRBU0NJSShjKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZChjb25zdGFudHNfMS5VUFBFUl9TSElGVCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC53cml0ZUNvZGV3b3JkKGMgLSAxMjggKyAxKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC53cml0ZUNvZGV3b3JkKGMgKyAxKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBU0NJSUVuY29kZXIucHJvdG90eXBlLmVuY29kZUFTQ0lJRGlnaXRzID0gZnVuY3Rpb24gKGRpZ2l0MSwgZGlnaXQyKSB7XG4gICAgICAgIGlmIChIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc0RpZ2l0KGRpZ2l0MSkgJiYgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNEaWdpdChkaWdpdDIpKSB7XG4gICAgICAgICAgICB2YXIgbnVtID0gKGRpZ2l0MSAtIDQ4KSAqIDEwICsgKGRpZ2l0MiAtIDQ4KTtcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAxMzA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZGlnaXRzOiAnICsgZGlnaXQxICsgZGlnaXQyKTtcbiAgICB9O1xuICAgIHJldHVybiBBU0NJSUVuY29kZXI7XG59KCkpO1xuZXhwb3J0cy5BU0NJSUVuY29kZXIgPSBBU0NJSUVuY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base256Encoder = void 0;\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar Base256Encoder = /** @class */ (function () {\n    function Base256Encoder() {\n    }\n    Base256Encoder.prototype.getEncodingMode = function () {\n        return constants_1.BASE256_ENCODATION;\n    };\n    Base256Encoder.prototype.encode = function (context) {\n        var buffer = new StringBuilder_1.default();\n        buffer.append(0); // Initialize length field\n        while (context.hasMoreCharacters()) {\n            var c = context.getCurrentChar();\n            buffer.append(c);\n            context.pos++;\n            var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n            if (newMode !== this.getEncodingMode()) {\n                // Return to ASCII encodation, which will actually handle latch to new mode\n                context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n                break;\n            }\n        }\n        var dataCount = buffer.length() - 1;\n        var lengthFieldSize = 1;\n        var currentSize = context.getCodewordCount() + dataCount + lengthFieldSize;\n        context.updateSymbolInfo(currentSize);\n        var mustPad = context.getSymbolInfo().getDataCapacity() - currentSize > 0;\n        if (context.hasMoreCharacters() || mustPad) {\n            if (dataCount <= 249) {\n                buffer.setCharAt(0, StringUtils_1.default.getCharAt(dataCount));\n            }\n            else if (dataCount <= 1555) {\n                buffer.setCharAt(0, StringUtils_1.default.getCharAt(Math.floor(dataCount / 250) + 249));\n                buffer.insert(1, StringUtils_1.default.getCharAt(dataCount % 250));\n            }\n            else {\n                throw new Error('Message length not in valid ranges: ' + dataCount);\n            }\n        }\n        for (var i = 0, c = buffer.length(); i < c; i++) {\n            context.writeCodeword(this.randomize255State(buffer.charAt(i).charCodeAt(0), context.getCodewordCount() + 1));\n        }\n    };\n    Base256Encoder.prototype.randomize255State = function (ch, codewordPosition) {\n        var pseudoRandom = ((149 * codewordPosition) % 255) + 1;\n        var tempVariable = ch + pseudoRandom;\n        if (tempVariable <= 255) {\n            return tempVariable;\n        }\n        else {\n            return tempVariable - 256;\n        }\n    };\n    return Base256Encoder;\n}());\nexports.Base256Encoder = Base256Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvQmFzZTI1NkVuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLG9CQUFvQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDeEQseUJBQXlCLG1CQUFPLENBQUMsb0tBQW9CO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHNKQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvQmFzZTI1NkVuY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2UyNTZFbmNvZGVyID0gdm9pZCAwO1xudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgSGlnaExldmVsRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vSGlnaExldmVsRW5jb2RlclwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBCYXNlMjU2RW5jb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlMjU2RW5jb2RlcigpIHtcbiAgICB9XG4gICAgQmFzZTI1NkVuY29kZXIucHJvdG90eXBlLmdldEVuY29kaW5nTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkJBU0UyNTZfRU5DT0RBVElPTjtcbiAgICB9O1xuICAgIEJhc2UyNTZFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIGJ1ZmZlci5hcHBlbmQoMCk7IC8vIEluaXRpYWxpemUgbGVuZ3RoIGZpZWxkXG4gICAgICAgIHdoaWxlIChjb250ZXh0Lmhhc01vcmVDaGFyYWN0ZXJzKCkpIHtcbiAgICAgICAgICAgIHZhciBjID0gY29udGV4dC5nZXRDdXJyZW50Q2hhcigpO1xuICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChjKTtcbiAgICAgICAgICAgIGNvbnRleHQucG9zKys7XG4gICAgICAgICAgICB2YXIgbmV3TW9kZSA9IEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0Lmxvb2tBaGVhZFRlc3QoY29udGV4dC5nZXRNZXNzYWdlKCksIGNvbnRleHQucG9zLCB0aGlzLmdldEVuY29kaW5nTW9kZSgpKTtcbiAgICAgICAgICAgIGlmIChuZXdNb2RlICE9PSB0aGlzLmdldEVuY29kaW5nTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRvIEFTQ0lJIGVuY29kYXRpb24sIHdoaWNoIHdpbGwgYWN0dWFsbHkgaGFuZGxlIGxhdGNoIHRvIG5ldyBtb2RlXG4gICAgICAgICAgICAgICAgY29udGV4dC5zaWduYWxFbmNvZGVyQ2hhbmdlKGNvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT04pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhQ291bnQgPSBidWZmZXIubGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgbGVuZ3RoRmllbGRTaXplID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gY29udGV4dC5nZXRDb2Rld29yZENvdW50KCkgKyBkYXRhQ291bnQgKyBsZW5ndGhGaWVsZFNpemU7XG4gICAgICAgIGNvbnRleHQudXBkYXRlU3ltYm9sSW5mbyhjdXJyZW50U2l6ZSk7XG4gICAgICAgIHZhciBtdXN0UGFkID0gY29udGV4dC5nZXRTeW1ib2xJbmZvKCkuZ2V0RGF0YUNhcGFjaXR5KCkgLSBjdXJyZW50U2l6ZSA+IDA7XG4gICAgICAgIGlmIChjb250ZXh0Lmhhc01vcmVDaGFyYWN0ZXJzKCkgfHwgbXVzdFBhZCkge1xuICAgICAgICAgICAgaWYgKGRhdGFDb3VudCA8PSAyNDkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0Q2hhckF0KDAsIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQXQoZGF0YUNvdW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhQ291bnQgPD0gMTU1NSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRDaGFyQXQoMCwgU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJBdChNYXRoLmZsb29yKGRhdGFDb3VudCAvIDI1MCkgKyAyNDkpKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuaW5zZXJ0KDEsIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQXQoZGF0YUNvdW50ICUgMjUwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgbGVuZ3RoIG5vdCBpbiB2YWxpZCByYW5nZXM6ICcgKyBkYXRhQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gYnVmZmVyLmxlbmd0aCgpOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQodGhpcy5yYW5kb21pemUyNTVTdGF0ZShidWZmZXIuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCksIGNvbnRleHQuZ2V0Q29kZXdvcmRDb3VudCgpICsgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlMjU2RW5jb2Rlci5wcm90b3R5cGUucmFuZG9taXplMjU1U3RhdGUgPSBmdW5jdGlvbiAoY2gsIGNvZGV3b3JkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHBzZXVkb1JhbmRvbSA9ICgoMTQ5ICogY29kZXdvcmRQb3NpdGlvbikgJSAyNTUpICsgMTtcbiAgICAgICAgdmFyIHRlbXBWYXJpYWJsZSA9IGNoICsgcHNldWRvUmFuZG9tO1xuICAgICAgICBpZiAodGVtcFZhcmlhYmxlIDw9IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBWYXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wVmFyaWFibGUgLSAyNTY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCYXNlMjU2RW5jb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkJhc2UyNTZFbmNvZGVyID0gQmFzZTI1NkVuY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.C40Encoder = void 0;\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar C40Encoder = /** @class */ (function () {\n    function C40Encoder() {\n    }\n    C40Encoder.prototype.getEncodingMode = function () {\n        return constants_1.C40_ENCODATION;\n    };\n    C40Encoder.prototype.encodeMaximal = function (context) {\n        var buffer = new StringBuilder_1.default();\n        var lastCharSize = 0;\n        var backtrackStartPosition = context.pos;\n        var backtrackBufferLength = 0;\n        while (context.hasMoreCharacters()) {\n            var c = context.getCurrentChar();\n            context.pos++;\n            lastCharSize = this.encodeChar(c, buffer);\n            if (buffer.length() % 3 === 0) {\n                backtrackStartPosition = context.pos;\n                backtrackBufferLength = buffer.length();\n            }\n        }\n        if (backtrackBufferLength !== buffer.length()) {\n            var unwritten = Math.floor((buffer.length() / 3) * 2);\n            var curCodewordCount = Math.floor(context.getCodewordCount() + unwritten + 1); // +1 for the latch to C40\n            context.updateSymbolInfo(curCodewordCount);\n            var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n            var rest = Math.floor(buffer.length() % 3);\n            if ((rest === 2 && available !== 2) ||\n                (rest === 1 && (lastCharSize > 3 || available !== 1))) {\n                // buffer.setLength(backtrackBufferLength);\n                context.pos = backtrackStartPosition;\n            }\n        }\n        if (buffer.length() > 0) {\n            context.writeCodeword(constants_1.LATCH_TO_C40);\n        }\n        this.handleEOD(context, buffer);\n    };\n    C40Encoder.prototype.encode = function (context) {\n        // step C\n        var buffer = new StringBuilder_1.default();\n        while (context.hasMoreCharacters()) {\n            var c = context.getCurrentChar();\n            context.pos++;\n            var lastCharSize = this.encodeChar(c, buffer);\n            var unwritten = Math.floor(buffer.length() / 3) * 2;\n            var curCodewordCount = context.getCodewordCount() + unwritten;\n            context.updateSymbolInfo(curCodewordCount);\n            var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n            if (!context.hasMoreCharacters()) {\n                // Avoid having a single C40 value in the last triplet\n                var removed = new StringBuilder_1.default();\n                if (buffer.length() % 3 === 2 && available !== 2) {\n                    lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);\n                }\n                while (buffer.length() % 3 === 1 &&\n                    (lastCharSize > 3 || available !== 1)) {\n                    lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);\n                }\n                break;\n            }\n            var count = buffer.length();\n            if (count % 3 === 0) {\n                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n                if (newMode !== this.getEncodingMode()) {\n                    // Return to ASCII encodation, which will actually handle latch to new mode\n                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n                    break;\n                }\n            }\n        }\n        this.handleEOD(context, buffer);\n    };\n    C40Encoder.prototype.backtrackOneCharacter = function (context, buffer, removed, lastCharSize) {\n        var count = buffer.length();\n        var test = buffer.toString().substring(0, count - lastCharSize);\n        buffer.setLengthToZero();\n        buffer.append(test);\n        // buffer.delete(count - lastCharSize, count);\n        /*for (let i = count - lastCharSize; i < count; i++) {\n          buffer.deleteCharAt(i);\n        }*/\n        context.pos--;\n        var c = context.getCurrentChar();\n        lastCharSize = this.encodeChar(c, removed);\n        context.resetSymbolInfo(); // Deal with possible reduction in symbol size\n        return lastCharSize;\n    };\n    C40Encoder.prototype.writeNextTriplet = function (context, buffer) {\n        context.writeCodewords(this.encodeToCodewords(buffer.toString()));\n        var test = buffer.toString().substring(3);\n        buffer.setLengthToZero();\n        buffer.append(test);\n        // buffer.delete(0, 3);\n        /*for (let i = 0; i < 3; i++) {\n          buffer.deleteCharAt(i);\n        }*/\n    };\n    /**\n     * Handle \"end of data\" situations\n     *\n     * @param context the encoder context\n     * @param buffer  the buffer with the remaining encoded characters\n     */\n    C40Encoder.prototype.handleEOD = function (context, buffer) {\n        var unwritten = Math.floor((buffer.length() / 3) * 2);\n        var rest = buffer.length() % 3;\n        var curCodewordCount = context.getCodewordCount() + unwritten;\n        context.updateSymbolInfo(curCodewordCount);\n        var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n        if (rest === 2) {\n            buffer.append('\\0'); // Shift 1\n            while (buffer.length() >= 3) {\n                this.writeNextTriplet(context, buffer);\n            }\n            if (context.hasMoreCharacters()) {\n                context.writeCodeword(constants_1.C40_UNLATCH);\n            }\n        }\n        else if (available === 1 && rest === 1) {\n            while (buffer.length() >= 3) {\n                this.writeNextTriplet(context, buffer);\n            }\n            if (context.hasMoreCharacters()) {\n                context.writeCodeword(constants_1.C40_UNLATCH);\n            }\n            // else no unlatch\n            context.pos--;\n        }\n        else if (rest === 0) {\n            while (buffer.length() >= 3) {\n                this.writeNextTriplet(context, buffer);\n            }\n            if (available > 0 || context.hasMoreCharacters()) {\n                context.writeCodeword(constants_1.C40_UNLATCH);\n            }\n        }\n        else {\n            throw new Error('Unexpected case. Please report!');\n        }\n        context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n    };\n    C40Encoder.prototype.encodeChar = function (c, sb) {\n        if (c === ' '.charCodeAt(0)) {\n            sb.append(3);\n            return 1;\n        }\n        if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {\n            sb.append(c - 48 + 4);\n            return 1;\n        }\n        if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {\n            sb.append(c - 65 + 14);\n            return 1;\n        }\n        if (c < ' '.charCodeAt(0)) {\n            sb.append(0); // Shift 1 Set\n            sb.append(c);\n            return 2;\n        }\n        if (c <= '/'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 33);\n            return 2;\n        }\n        if (c <= '@'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 58 + 15);\n            return 2;\n        }\n        if (c <= '_'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 91 + 22);\n            return 2;\n        }\n        if (c <= 127) {\n            sb.append(2); // Shift 3 Set\n            sb.append(c - 96);\n            return 2;\n        }\n        sb.append(1 + \"\\u001E\"); // Shift 2, Upper Shift\n        var len = 2;\n        len += this.encodeChar(c - 128, sb);\n        return len;\n    };\n    C40Encoder.prototype.encodeToCodewords = function (sb) {\n        var v = 1600 * sb.charCodeAt(0) + 40 * sb.charCodeAt(1) + sb.charCodeAt(2) + 1;\n        var cw1 = v / 256;\n        var cw2 = v % 256;\n        var result = new StringBuilder_1.default();\n        result.append(cw1);\n        result.append(cw2);\n        return result.toString();\n    };\n    return C40Encoder;\n}());\nexports.C40Encoder = C40Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvQzQwRW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsc0JBQXNCLG1CQUFPLENBQUMseUpBQTBCO0FBQ3hELHlCQUF5QixtQkFBTyxDQUFDLG9LQUFvQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvQzQwRW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQzQwRW5jb2RlciA9IHZvaWQgMDtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIEhpZ2hMZXZlbEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0hpZ2hMZXZlbEVuY29kZXJcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgQzQwRW5jb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDNDBFbmNvZGVyKCkge1xuICAgIH1cbiAgICBDNDBFbmNvZGVyLnByb3RvdHlwZS5nZXRFbmNvZGluZ01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTjtcbiAgICB9O1xuICAgIEM0MEVuY29kZXIucHJvdG90eXBlLmVuY29kZU1heGltYWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHZhciBsYXN0Q2hhclNpemUgPSAwO1xuICAgICAgICB2YXIgYmFja3RyYWNrU3RhcnRQb3NpdGlvbiA9IGNvbnRleHQucG9zO1xuICAgICAgICB2YXIgYmFja3RyYWNrQnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKGNvbnRleHQuaGFzTW9yZUNoYXJhY3RlcnMoKSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjb250ZXh0LmdldEN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICBjb250ZXh0LnBvcysrO1xuICAgICAgICAgICAgbGFzdENoYXJTaXplID0gdGhpcy5lbmNvZGVDaGFyKGMsIGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCgpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJhY2t0cmFja1N0YXJ0UG9zaXRpb24gPSBjb250ZXh0LnBvcztcbiAgICAgICAgICAgICAgICBiYWNrdHJhY2tCdWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2t0cmFja0J1ZmZlckxlbmd0aCAhPT0gYnVmZmVyLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICB2YXIgdW53cml0dGVuID0gTWF0aC5mbG9vcigoYnVmZmVyLmxlbmd0aCgpIC8gMykgKiAyKTtcbiAgICAgICAgICAgIHZhciBjdXJDb2Rld29yZENvdW50ID0gTWF0aC5mbG9vcihjb250ZXh0LmdldENvZGV3b3JkQ291bnQoKSArIHVud3JpdHRlbiArIDEpOyAvLyArMSBmb3IgdGhlIGxhdGNoIHRvIEM0MFxuICAgICAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKGN1ckNvZGV3b3JkQ291bnQpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGNvbnRleHQuZ2V0U3ltYm9sSW5mbygpLmdldERhdGFDYXBhY2l0eSgpIC0gY3VyQ29kZXdvcmRDb3VudDtcbiAgICAgICAgICAgIHZhciByZXN0ID0gTWF0aC5mbG9vcihidWZmZXIubGVuZ3RoKCkgJSAzKTtcbiAgICAgICAgICAgIGlmICgocmVzdCA9PT0gMiAmJiBhdmFpbGFibGUgIT09IDIpIHx8XG4gICAgICAgICAgICAgICAgKHJlc3QgPT09IDEgJiYgKGxhc3RDaGFyU2l6ZSA+IDMgfHwgYXZhaWxhYmxlICE9PSAxKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIuc2V0TGVuZ3RoKGJhY2t0cmFja0J1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5wb3MgPSBiYWNrdHJhY2tTdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuTEFUQ0hfVE9fQzQwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVPRChjb250ZXh0LCBidWZmZXIpO1xuICAgIH07XG4gICAgQzQwRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gc3RlcCBDXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgd2hpbGUgKGNvbnRleHQuaGFzTW9yZUNoYXJhY3RlcnMoKSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjb250ZXh0LmdldEN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICBjb250ZXh0LnBvcysrO1xuICAgICAgICAgICAgdmFyIGxhc3RDaGFyU2l6ZSA9IHRoaXMuZW5jb2RlQ2hhcihjLCBidWZmZXIpO1xuICAgICAgICAgICAgdmFyIHVud3JpdHRlbiA9IE1hdGguZmxvb3IoYnVmZmVyLmxlbmd0aCgpIC8gMykgKiAyO1xuICAgICAgICAgICAgdmFyIGN1ckNvZGV3b3JkQ291bnQgPSBjb250ZXh0LmdldENvZGV3b3JkQ291bnQoKSArIHVud3JpdHRlbjtcbiAgICAgICAgICAgIGNvbnRleHQudXBkYXRlU3ltYm9sSW5mbyhjdXJDb2Rld29yZENvdW50KTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBjb250ZXh0LmdldFN5bWJvbEluZm8oKS5nZXREYXRhQ2FwYWNpdHkoKSAtIGN1ckNvZGV3b3JkQ291bnQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaGFzTW9yZUNoYXJhY3RlcnMoKSkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGhhdmluZyBhIHNpbmdsZSBDNDAgdmFsdWUgaW4gdGhlIGxhc3QgdHJpcGxldFxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGgoKSAlIDMgPT09IDIgJiYgYXZhaWxhYmxlICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyU2l6ZSA9IHRoaXMuYmFja3RyYWNrT25lQ2hhcmFjdGVyKGNvbnRleHQsIGJ1ZmZlciwgcmVtb3ZlZCwgbGFzdENoYXJTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGgoKSAlIDMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGxhc3RDaGFyU2l6ZSA+IDMgfHwgYXZhaWxhYmxlICE9PSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhclNpemUgPSB0aGlzLmJhY2t0cmFja09uZUNoYXJhY3Rlcihjb250ZXh0LCBidWZmZXIsIHJlbW92ZWQsIGxhc3RDaGFyU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gYnVmZmVyLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGNvdW50ICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdNb2RlID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQubG9va0FoZWFkVGVzdChjb250ZXh0LmdldE1lc3NhZ2UoKSwgY29udGV4dC5wb3MsIHRoaXMuZ2V0RW5jb2RpbmdNb2RlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNb2RlICE9PSB0aGlzLmdldEVuY29kaW5nTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0byBBU0NJSSBlbmNvZGF0aW9uLCB3aGljaCB3aWxsIGFjdHVhbGx5IGhhbmRsZSBsYXRjaCB0byBuZXcgbW9kZVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVPRChjb250ZXh0LCBidWZmZXIpO1xuICAgIH07XG4gICAgQzQwRW5jb2Rlci5wcm90b3R5cGUuYmFja3RyYWNrT25lQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvbnRleHQsIGJ1ZmZlciwgcmVtb3ZlZCwgbGFzdENoYXJTaXplKSB7XG4gICAgICAgIHZhciBjb3VudCA9IGJ1ZmZlci5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHRlc3QgPSBidWZmZXIudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwgY291bnQgLSBsYXN0Q2hhclNpemUpO1xuICAgICAgICBidWZmZXIuc2V0TGVuZ3RoVG9aZXJvKCk7XG4gICAgICAgIGJ1ZmZlci5hcHBlbmQodGVzdCk7XG4gICAgICAgIC8vIGJ1ZmZlci5kZWxldGUoY291bnQgLSBsYXN0Q2hhclNpemUsIGNvdW50KTtcbiAgICAgICAgLypmb3IgKGxldCBpID0gY291bnQgLSBsYXN0Q2hhclNpemU7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLmRlbGV0ZUNoYXJBdChpKTtcbiAgICAgICAgfSovXG4gICAgICAgIGNvbnRleHQucG9zLS07XG4gICAgICAgIHZhciBjID0gY29udGV4dC5nZXRDdXJyZW50Q2hhcigpO1xuICAgICAgICBsYXN0Q2hhclNpemUgPSB0aGlzLmVuY29kZUNoYXIoYywgcmVtb3ZlZCk7XG4gICAgICAgIGNvbnRleHQucmVzZXRTeW1ib2xJbmZvKCk7IC8vIERlYWwgd2l0aCBwb3NzaWJsZSByZWR1Y3Rpb24gaW4gc3ltYm9sIHNpemVcbiAgICAgICAgcmV0dXJuIGxhc3RDaGFyU2l6ZTtcbiAgICB9O1xuICAgIEM0MEVuY29kZXIucHJvdG90eXBlLndyaXRlTmV4dFRyaXBsZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZHModGhpcy5lbmNvZGVUb0NvZGV3b3JkcyhidWZmZXIudG9TdHJpbmcoKSkpO1xuICAgICAgICB2YXIgdGVzdCA9IGJ1ZmZlci50b1N0cmluZygpLnN1YnN0cmluZygzKTtcbiAgICAgICAgYnVmZmVyLnNldExlbmd0aFRvWmVybygpO1xuICAgICAgICBidWZmZXIuYXBwZW5kKHRlc3QpO1xuICAgICAgICAvLyBidWZmZXIuZGVsZXRlKDAsIDMpO1xuICAgICAgICAvKmZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLmRlbGV0ZUNoYXJBdChpKTtcbiAgICAgICAgfSovXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgXCJlbmQgb2YgZGF0YVwiIHNpdHVhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBlbmNvZGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYnVmZmVyICB0aGUgYnVmZmVyIHdpdGggdGhlIHJlbWFpbmluZyBlbmNvZGVkIGNoYXJhY3RlcnNcbiAgICAgKi9cbiAgICBDNDBFbmNvZGVyLnByb3RvdHlwZS5oYW5kbGVFT0QgPSBmdW5jdGlvbiAoY29udGV4dCwgYnVmZmVyKSB7XG4gICAgICAgIHZhciB1bndyaXR0ZW4gPSBNYXRoLmZsb29yKChidWZmZXIubGVuZ3RoKCkgLyAzKSAqIDIpO1xuICAgICAgICB2YXIgcmVzdCA9IGJ1ZmZlci5sZW5ndGgoKSAlIDM7XG4gICAgICAgIHZhciBjdXJDb2Rld29yZENvdW50ID0gY29udGV4dC5nZXRDb2Rld29yZENvdW50KCkgKyB1bndyaXR0ZW47XG4gICAgICAgIGNvbnRleHQudXBkYXRlU3ltYm9sSW5mbyhjdXJDb2Rld29yZENvdW50KTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGNvbnRleHQuZ2V0U3ltYm9sSW5mbygpLmdldERhdGFDYXBhY2l0eSgpIC0gY3VyQ29kZXdvcmRDb3VudDtcbiAgICAgICAgaWYgKHJlc3QgPT09IDIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoJ1xcMCcpOyAvLyBTaGlmdCAxXG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCgpID49IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTmV4dFRyaXBsZXQoY29udGV4dCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lmhhc01vcmVDaGFyYWN0ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuQzQwX1VOTEFUQ0gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF2YWlsYWJsZSA9PT0gMSAmJiByZXN0ID09PSAxKSB7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCgpID49IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTmV4dFRyaXBsZXQoY29udGV4dCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lmhhc01vcmVDaGFyYWN0ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuQzQwX1VOTEFUQ0gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBubyB1bmxhdGNoXG4gICAgICAgICAgICBjb250ZXh0LnBvcy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3QgPT09IDApIHtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoKCkgPj0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVOZXh0VHJpcGxldChjb250ZXh0LCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSA+IDAgfHwgY29udGV4dC5oYXNNb3JlQ2hhcmFjdGVycygpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC53cml0ZUNvZGV3b3JkKGNvbnN0YW50c18xLkM0MF9VTkxBVENIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjYXNlLiBQbGVhc2UgcmVwb3J0IScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2lnbmFsRW5jb2RlckNoYW5nZShjb25zdGFudHNfMS5BU0NJSV9FTkNPREFUSU9OKTtcbiAgICB9O1xuICAgIEM0MEVuY29kZXIucHJvdG90eXBlLmVuY29kZUNoYXIgPSBmdW5jdGlvbiAoYywgc2IpIHtcbiAgICAgICAgaWYgKGMgPT09ICcgJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoMyk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA+PSAnMCcuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICc5Jy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoYyAtIDQ4ICsgNCk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA+PSAnQScuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICdaJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoYyAtIDY1ICsgMTQpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAnICcuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDApOyAvLyBTaGlmdCAxIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMpO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPD0gJy8nLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgxKTsgLy8gU2hpZnQgMiBTZXRcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gMzMpO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPD0gJ0AnLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgxKTsgLy8gU2hpZnQgMiBTZXRcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gNTggKyAxNSk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8PSAnXycuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDEpOyAvLyBTaGlmdCAyIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMgLSA5MSArIDIyKTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDw9IDEyNykge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDIpOyAvLyBTaGlmdCAzIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMgLSA5Nik7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBzYi5hcHBlbmQoMSArIFwiXFx1MDAxRVwiKTsgLy8gU2hpZnQgMiwgVXBwZXIgU2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IDI7XG4gICAgICAgIGxlbiArPSB0aGlzLmVuY29kZUNoYXIoYyAtIDEyOCwgc2IpO1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH07XG4gICAgQzQwRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlVG9Db2Rld29yZHMgPSBmdW5jdGlvbiAoc2IpIHtcbiAgICAgICAgdmFyIHYgPSAxNjAwICogc2IuY2hhckNvZGVBdCgwKSArIDQwICogc2IuY2hhckNvZGVBdCgxKSArIHNiLmNoYXJDb2RlQXQoMikgKyAxO1xuICAgICAgICB2YXIgY3cxID0gdiAvIDI1NjtcbiAgICAgICAgdmFyIGN3MiA9IHYgJSAyNTY7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZChjdzEpO1xuICAgICAgICByZXN1bHQuYXBwZW5kKGN3Mik7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBDNDBFbmNvZGVyO1xufSgpKTtcbmV4cG9ydHMuQzQwRW5jb2RlciA9IEM0MEVuY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\n/**\n * Symbol Character Placement Program. Adapted from Annex M.1 in ISO/IEC 16022:2000(E).\n */\nvar DefaultPlacement = /** @class */ (function () {\n    /**\n     * Main constructor\n     *\n     * @param codewords the codewords to place\n     * @param numcols   the number of columns\n     * @param numrows   the number of rows\n     */\n    function DefaultPlacement(codewords, numcols, numrows) {\n        this.codewords = codewords;\n        this.numcols = numcols;\n        this.numrows = numrows;\n        this.bits = new Uint8Array(numcols * numrows);\n        Arrays_1.default.fill(this.bits, 2); // Initialize with \"not set\" value\n    }\n    DefaultPlacement.prototype.getNumrows = function () {\n        return this.numrows;\n    };\n    DefaultPlacement.prototype.getNumcols = function () {\n        return this.numcols;\n    };\n    DefaultPlacement.prototype.getBits = function () {\n        return this.bits;\n    };\n    DefaultPlacement.prototype.getBit = function (col, row) {\n        return this.bits[row * this.numcols + col] === 1;\n    };\n    DefaultPlacement.prototype.setBit = function (col, row, bit) {\n        this.bits[row * this.numcols + col] = bit ? 1 : 0;\n    };\n    DefaultPlacement.prototype.noBit = function (col, row) {\n        return this.bits[row * this.numcols + col] === 2;\n    };\n    DefaultPlacement.prototype.place = function () {\n        var pos = 0;\n        var row = 4;\n        var col = 0;\n        do {\n            // repeatedly first check for one of the special corner cases, then...\n            if (row === this.numrows && col === 0) {\n                this.corner1(pos++);\n            }\n            if (row === this.numrows - 2 && col === 0 && this.numcols % 4 !== 0) {\n                this.corner2(pos++);\n            }\n            if (row === this.numrows - 2 && col === 0 && this.numcols % 8 === 4) {\n                this.corner3(pos++);\n            }\n            if (row === this.numrows + 4 && col === 2 && this.numcols % 8 === 0) {\n                this.corner4(pos++);\n            }\n            // sweep upward diagonally, inserting successive characters...\n            do {\n                if (row < this.numrows && col >= 0 && this.noBit(col, row)) {\n                    this.utah(row, col, pos++);\n                }\n                row -= 2;\n                col += 2;\n            } while (row >= 0 && col < this.numcols);\n            row++;\n            col += 3;\n            // and then sweep downward diagonally, inserting successive characters, ...\n            do {\n                if (row >= 0 && col < this.numcols && this.noBit(col, row)) {\n                    this.utah(row, col, pos++);\n                }\n                row += 2;\n                col -= 2;\n            } while (row < this.numrows && col >= 0);\n            row += 3;\n            col++;\n            // ...until the entire array is scanned\n        } while (row < this.numrows || col < this.numcols);\n        // Lastly, if the lower right-hand corner is untouched, fill in fixed pattern\n        if (this.noBit(this.numcols - 1, this.numrows - 1)) {\n            this.setBit(this.numcols - 1, this.numrows - 1, true);\n            this.setBit(this.numcols - 2, this.numrows - 2, true);\n        }\n    };\n    DefaultPlacement.prototype.module = function (row, col, pos, bit) {\n        if (row < 0) {\n            row += this.numrows;\n            col += 4 - ((this.numrows + 4) % 8);\n        }\n        if (col < 0) {\n            col += this.numcols;\n            row += 4 - ((this.numcols + 4) % 8);\n        }\n        // Note the conversion:\n        var v = this.codewords.charCodeAt(pos);\n        v &= 1 << (8 - bit);\n        this.setBit(col, row, v !== 0);\n    };\n    /**\n     * Places the 8 bits of a utah-shaped symbol character in ECC200.\n     *\n     * @param row the row\n     * @param col the column\n     * @param pos character position\n     */\n    DefaultPlacement.prototype.utah = function (row, col, pos) {\n        this.module(row - 2, col - 2, pos, 1);\n        this.module(row - 2, col - 1, pos, 2);\n        this.module(row - 1, col - 2, pos, 3);\n        this.module(row - 1, col - 1, pos, 4);\n        this.module(row - 1, col, pos, 5);\n        this.module(row, col - 2, pos, 6);\n        this.module(row, col - 1, pos, 7);\n        this.module(row, col, pos, 8);\n    };\n    DefaultPlacement.prototype.corner1 = function (pos) {\n        this.module(this.numrows - 1, 0, pos, 1);\n        this.module(this.numrows - 1, 1, pos, 2);\n        this.module(this.numrows - 1, 2, pos, 3);\n        this.module(0, this.numcols - 2, pos, 4);\n        this.module(0, this.numcols - 1, pos, 5);\n        this.module(1, this.numcols - 1, pos, 6);\n        this.module(2, this.numcols - 1, pos, 7);\n        this.module(3, this.numcols - 1, pos, 8);\n    };\n    DefaultPlacement.prototype.corner2 = function (pos) {\n        this.module(this.numrows - 3, 0, pos, 1);\n        this.module(this.numrows - 2, 0, pos, 2);\n        this.module(this.numrows - 1, 0, pos, 3);\n        this.module(0, this.numcols - 4, pos, 4);\n        this.module(0, this.numcols - 3, pos, 5);\n        this.module(0, this.numcols - 2, pos, 6);\n        this.module(0, this.numcols - 1, pos, 7);\n        this.module(1, this.numcols - 1, pos, 8);\n    };\n    DefaultPlacement.prototype.corner3 = function (pos) {\n        this.module(this.numrows - 3, 0, pos, 1);\n        this.module(this.numrows - 2, 0, pos, 2);\n        this.module(this.numrows - 1, 0, pos, 3);\n        this.module(0, this.numcols - 2, pos, 4);\n        this.module(0, this.numcols - 1, pos, 5);\n        this.module(1, this.numcols - 1, pos, 6);\n        this.module(2, this.numcols - 1, pos, 7);\n        this.module(3, this.numcols - 1, pos, 8);\n    };\n    DefaultPlacement.prototype.corner4 = function (pos) {\n        this.module(this.numrows - 1, 0, pos, 1);\n        this.module(this.numrows - 1, this.numcols - 1, pos, 2);\n        this.module(0, this.numcols - 3, pos, 3);\n        this.module(0, this.numcols - 2, pos, 4);\n        this.module(0, this.numcols - 1, pos, 5);\n        this.module(1, this.numcols - 3, pos, 6);\n        this.module(1, this.numcols - 2, pos, 7);\n        this.module(1, this.numcols - 1, pos, 8);\n    };\n    return DefaultPlacement;\n}());\nexports[\"default\"] = DefaultPlacement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRGVmYXVsdFBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsMklBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL0RlZmF1bHRQbGFjZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXJyYXlzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9BcnJheXNcIik7XG4vKipcbiAqIFN5bWJvbCBDaGFyYWN0ZXIgUGxhY2VtZW50IFByb2dyYW0uIEFkYXB0ZWQgZnJvbSBBbm5leCBNLjEgaW4gSVNPL0lFQyAxNjAyMjoyMDAwKEUpLlxuICovXG52YXIgRGVmYXVsdFBsYWNlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBNYWluIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRzIHRoZSBjb2Rld29yZHMgdG8gcGxhY2VcbiAgICAgKiBAcGFyYW0gbnVtY29scyAgIHRoZSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqIEBwYXJhbSBudW1yb3dzICAgdGhlIG51bWJlciBvZiByb3dzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVmYXVsdFBsYWNlbWVudChjb2Rld29yZHMsIG51bWNvbHMsIG51bXJvd3MpIHtcbiAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XG4gICAgICAgIHRoaXMubnVtY29scyA9IG51bWNvbHM7XG4gICAgICAgIHRoaXMubnVtcm93cyA9IG51bXJvd3M7XG4gICAgICAgIHRoaXMuYml0cyA9IG5ldyBVaW50OEFycmF5KG51bWNvbHMgKiBudW1yb3dzKTtcbiAgICAgICAgQXJyYXlzXzEuZGVmYXVsdC5maWxsKHRoaXMuYml0cywgMik7IC8vIEluaXRpYWxpemUgd2l0aCBcIm5vdCBzZXRcIiB2YWx1ZVxuICAgIH1cbiAgICBEZWZhdWx0UGxhY2VtZW50LnByb3RvdHlwZS5nZXROdW1yb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1yb3dzO1xuICAgIH07XG4gICAgRGVmYXVsdFBsYWNlbWVudC5wcm90b3R5cGUuZ2V0TnVtY29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtY29scztcbiAgICB9O1xuICAgIERlZmF1bHRQbGFjZW1lbnQucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgfTtcbiAgICBEZWZhdWx0UGxhY2VtZW50LnByb3RvdHlwZS5nZXRCaXQgPSBmdW5jdGlvbiAoY29sLCByb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0c1tyb3cgKiB0aGlzLm51bWNvbHMgKyBjb2xdID09PSAxO1xuICAgIH07XG4gICAgRGVmYXVsdFBsYWNlbWVudC5wcm90b3R5cGUuc2V0Qml0ID0gZnVuY3Rpb24gKGNvbCwgcm93LCBiaXQpIHtcbiAgICAgICAgdGhpcy5iaXRzW3JvdyAqIHRoaXMubnVtY29scyArIGNvbF0gPSBiaXQgPyAxIDogMDtcbiAgICB9O1xuICAgIERlZmF1bHRQbGFjZW1lbnQucHJvdG90eXBlLm5vQml0ID0gZnVuY3Rpb24gKGNvbCwgcm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHNbcm93ICogdGhpcy5udW1jb2xzICsgY29sXSA9PT0gMjtcbiAgICB9O1xuICAgIERlZmF1bHRQbGFjZW1lbnQucHJvdG90eXBlLnBsYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIHJvdyA9IDQ7XG4gICAgICAgIHZhciBjb2wgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyByZXBlYXRlZGx5IGZpcnN0IGNoZWNrIGZvciBvbmUgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNhc2VzLCB0aGVuLi4uXG4gICAgICAgICAgICBpZiAocm93ID09PSB0aGlzLm51bXJvd3MgJiYgY29sID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JuZXIxKHBvcysrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IHRoaXMubnVtcm93cyAtIDIgJiYgY29sID09PSAwICYmIHRoaXMubnVtY29scyAlIDQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcm5lcjIocG9zKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdyA9PT0gdGhpcy5udW1yb3dzIC0gMiAmJiBjb2wgPT09IDAgJiYgdGhpcy5udW1jb2xzICUgOCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ybmVyMyhwb3MrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID09PSB0aGlzLm51bXJvd3MgKyA0ICYmIGNvbCA9PT0gMiAmJiB0aGlzLm51bWNvbHMgJSA4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JuZXI0KHBvcysrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN3ZWVwIHVwd2FyZCBkaWFnb25hbGx5LCBpbnNlcnRpbmcgc3VjY2Vzc2l2ZSBjaGFyYWN0ZXJzLi4uXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXMubnVtcm93cyAmJiBjb2wgPj0gMCAmJiB0aGlzLm5vQml0KGNvbCwgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnV0YWgocm93LCBjb2wsIHBvcysrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgY29sICs9IDI7XG4gICAgICAgICAgICB9IHdoaWxlIChyb3cgPj0gMCAmJiBjb2wgPCB0aGlzLm51bWNvbHMpO1xuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICBjb2wgKz0gMztcbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIHN3ZWVwIGRvd253YXJkIGRpYWdvbmFsbHksIGluc2VydGluZyBzdWNjZXNzaXZlIGNoYXJhY3RlcnMsIC4uLlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPj0gMCAmJiBjb2wgPCB0aGlzLm51bWNvbHMgJiYgdGhpcy5ub0JpdChjb2wsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dGFoKHJvdywgY29sLCBwb3MrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvdyArPSAyO1xuICAgICAgICAgICAgICAgIGNvbCAtPSAyO1xuICAgICAgICAgICAgfSB3aGlsZSAocm93IDwgdGhpcy5udW1yb3dzICYmIGNvbCA+PSAwKTtcbiAgICAgICAgICAgIHJvdyArPSAzO1xuICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICAvLyAuLi51bnRpbCB0aGUgZW50aXJlIGFycmF5IGlzIHNjYW5uZWRcbiAgICAgICAgfSB3aGlsZSAocm93IDwgdGhpcy5udW1yb3dzIHx8IGNvbCA8IHRoaXMubnVtY29scyk7XG4gICAgICAgIC8vIExhc3RseSwgaWYgdGhlIGxvd2VyIHJpZ2h0LWhhbmQgY29ybmVyIGlzIHVudG91Y2hlZCwgZmlsbCBpbiBmaXhlZCBwYXR0ZXJuXG4gICAgICAgIGlmICh0aGlzLm5vQml0KHRoaXMubnVtY29scyAtIDEsIHRoaXMubnVtcm93cyAtIDEpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJpdCh0aGlzLm51bWNvbHMgLSAxLCB0aGlzLm51bXJvd3MgLSAxLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qml0KHRoaXMubnVtY29scyAtIDIsIHRoaXMubnVtcm93cyAtIDIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0UGxhY2VtZW50LnByb3RvdHlwZS5tb2R1bGUgPSBmdW5jdGlvbiAocm93LCBjb2wsIHBvcywgYml0KSB7XG4gICAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICByb3cgKz0gdGhpcy5udW1yb3dzO1xuICAgICAgICAgICAgY29sICs9IDQgLSAoKHRoaXMubnVtcm93cyArIDQpICUgOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbCA8IDApIHtcbiAgICAgICAgICAgIGNvbCArPSB0aGlzLm51bWNvbHM7XG4gICAgICAgICAgICByb3cgKz0gNCAtICgodGhpcy5udW1jb2xzICsgNCkgJSA4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoZSBjb252ZXJzaW9uOlxuICAgICAgICB2YXIgdiA9IHRoaXMuY29kZXdvcmRzLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgdiAmPSAxIDw8ICg4IC0gYml0KTtcbiAgICAgICAgdGhpcy5zZXRCaXQoY29sLCByb3csIHYgIT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHRoZSA4IGJpdHMgb2YgYSB1dGFoLXNoYXBlZCBzeW1ib2wgY2hhcmFjdGVyIGluIEVDQzIwMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgdGhlIHJvd1xuICAgICAqIEBwYXJhbSBjb2wgdGhlIGNvbHVtblxuICAgICAqIEBwYXJhbSBwb3MgY2hhcmFjdGVyIHBvc2l0aW9uXG4gICAgICovXG4gICAgRGVmYXVsdFBsYWNlbWVudC5wcm90b3R5cGUudXRhaCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgcG9zKSB7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdyAtIDIsIGNvbCAtIDIsIHBvcywgMSk7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdyAtIDIsIGNvbCAtIDEsIHBvcywgMik7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdyAtIDEsIGNvbCAtIDIsIHBvcywgMyk7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdyAtIDEsIGNvbCAtIDEsIHBvcywgNCk7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdyAtIDEsIGNvbCwgcG9zLCA1KTtcbiAgICAgICAgdGhpcy5tb2R1bGUocm93LCBjb2wgLSAyLCBwb3MsIDYpO1xuICAgICAgICB0aGlzLm1vZHVsZShyb3csIGNvbCAtIDEsIHBvcywgNyk7XG4gICAgICAgIHRoaXMubW9kdWxlKHJvdywgY29sLCBwb3MsIDgpO1xuICAgIH07XG4gICAgRGVmYXVsdFBsYWNlbWVudC5wcm90b3R5cGUuY29ybmVyMSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5tb2R1bGUodGhpcy5udW1yb3dzIC0gMSwgMCwgcG9zLCAxKTtcbiAgICAgICAgdGhpcy5tb2R1bGUodGhpcy5udW1yb3dzIC0gMSwgMSwgcG9zLCAyKTtcbiAgICAgICAgdGhpcy5tb2R1bGUodGhpcy5udW1yb3dzIC0gMSwgMiwgcG9zLCAzKTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMCwgdGhpcy5udW1jb2xzIC0gMiwgcG9zLCA0KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMCwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA1KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMSwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA2KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMiwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA3KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMywgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA4KTtcbiAgICB9O1xuICAgIERlZmF1bHRQbGFjZW1lbnQucHJvdG90eXBlLmNvcm5lcjIgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMubW9kdWxlKHRoaXMubnVtcm93cyAtIDMsIDAsIHBvcywgMSk7XG4gICAgICAgIHRoaXMubW9kdWxlKHRoaXMubnVtcm93cyAtIDIsIDAsIHBvcywgMik7XG4gICAgICAgIHRoaXMubW9kdWxlKHRoaXMubnVtcm93cyAtIDEsIDAsIHBvcywgMyk7XG4gICAgICAgIHRoaXMubW9kdWxlKDAsIHRoaXMubnVtY29scyAtIDQsIHBvcywgNCk7XG4gICAgICAgIHRoaXMubW9kdWxlKDAsIHRoaXMubnVtY29scyAtIDMsIHBvcywgNSk7XG4gICAgICAgIHRoaXMubW9kdWxlKDAsIHRoaXMubnVtY29scyAtIDIsIHBvcywgNik7XG4gICAgICAgIHRoaXMubW9kdWxlKDAsIHRoaXMubnVtY29scyAtIDEsIHBvcywgNyk7XG4gICAgICAgIHRoaXMubW9kdWxlKDEsIHRoaXMubnVtY29scyAtIDEsIHBvcywgOCk7XG4gICAgfTtcbiAgICBEZWZhdWx0UGxhY2VtZW50LnByb3RvdHlwZS5jb3JuZXIzID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLm1vZHVsZSh0aGlzLm51bXJvd3MgLSAzLCAwLCBwb3MsIDEpO1xuICAgICAgICB0aGlzLm1vZHVsZSh0aGlzLm51bXJvd3MgLSAyLCAwLCBwb3MsIDIpO1xuICAgICAgICB0aGlzLm1vZHVsZSh0aGlzLm51bXJvd3MgLSAxLCAwLCBwb3MsIDMpO1xuICAgICAgICB0aGlzLm1vZHVsZSgwLCB0aGlzLm51bWNvbHMgLSAyLCBwb3MsIDQpO1xuICAgICAgICB0aGlzLm1vZHVsZSgwLCB0aGlzLm51bWNvbHMgLSAxLCBwb3MsIDUpO1xuICAgICAgICB0aGlzLm1vZHVsZSgxLCB0aGlzLm51bWNvbHMgLSAxLCBwb3MsIDYpO1xuICAgICAgICB0aGlzLm1vZHVsZSgyLCB0aGlzLm51bWNvbHMgLSAxLCBwb3MsIDcpO1xuICAgICAgICB0aGlzLm1vZHVsZSgzLCB0aGlzLm51bWNvbHMgLSAxLCBwb3MsIDgpO1xuICAgIH07XG4gICAgRGVmYXVsdFBsYWNlbWVudC5wcm90b3R5cGUuY29ybmVyNCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5tb2R1bGUodGhpcy5udW1yb3dzIC0gMSwgMCwgcG9zLCAxKTtcbiAgICAgICAgdGhpcy5tb2R1bGUodGhpcy5udW1yb3dzIC0gMSwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCAyKTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMCwgdGhpcy5udW1jb2xzIC0gMywgcG9zLCAzKTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMCwgdGhpcy5udW1jb2xzIC0gMiwgcG9zLCA0KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMCwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA1KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMSwgdGhpcy5udW1jb2xzIC0gMywgcG9zLCA2KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMSwgdGhpcy5udW1jb2xzIC0gMiwgcG9zLCA3KTtcbiAgICAgICAgdGhpcy5tb2R1bGUoMSwgdGhpcy5udW1jb2xzIC0gMSwgcG9zLCA4KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0UGxhY2VtZW50O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRQbGFjZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EdifactEncoder = void 0;\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar EdifactEncoder = /** @class */ (function () {\n    function EdifactEncoder() {\n    }\n    EdifactEncoder.prototype.getEncodingMode = function () {\n        return constants_1.EDIFACT_ENCODATION;\n    };\n    EdifactEncoder.prototype.encode = function (context) {\n        // step F\n        var buffer = new StringBuilder_1.default();\n        while (context.hasMoreCharacters()) {\n            var c = context.getCurrentChar();\n            this.encodeChar(c, buffer);\n            context.pos++;\n            var count = buffer.length();\n            if (count >= 4) {\n                context.writeCodewords(this.encodeToCodewords(buffer.toString()));\n                var test_1 = buffer.toString().substring(4);\n                buffer.setLengthToZero();\n                buffer.append(test_1);\n                // buffer.delete(0, 4);\n                // for (let i = 0; i < 4; i++) {\n                //  buffer.deleteCharAt(i);\n                // }\n                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n                if (newMode !== this.getEncodingMode()) {\n                    // Return to ASCII encodation, which will actually handle latch to new mode\n                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n                    break;\n                }\n            }\n        }\n        buffer.append(StringUtils_1.default.getCharAt(31)); // Unlatch\n        this.handleEOD(context, buffer);\n    };\n    /**\n     * Handle \"end of data\" situations\n     *\n     * @param context the encoder context\n     * @param buffer  the buffer with the remaining encoded characters\n     */\n    EdifactEncoder.prototype.handleEOD = function (context, buffer) {\n        try {\n            var count = buffer.length();\n            if (count === 0) {\n                return; // Already finished\n            }\n            if (count === 1) {\n                // Only an unlatch at the end\n                context.updateSymbolInfo();\n                var available = context.getSymbolInfo().getDataCapacity() -\n                    context.getCodewordCount();\n                var remaining = context.getRemainingCharacters();\n                // The following two lines are a hack inspired by the 'fix' from https://sourceforge.net/p/barcode4j/svn/221/\n                if (remaining > available) {\n                    context.updateSymbolInfo(context.getCodewordCount() + 1);\n                    available =\n                        context.getSymbolInfo().getDataCapacity() -\n                            context.getCodewordCount();\n                }\n                if (remaining <= available && available <= 2) {\n                    return; // No unlatch\n                }\n            }\n            if (count > 4) {\n                throw new Error('Count must not exceed 4');\n            }\n            var restChars = count - 1;\n            var encoded = this.encodeToCodewords(buffer.toString());\n            var endOfSymbolReached = !context.hasMoreCharacters();\n            var restInAscii = endOfSymbolReached && restChars <= 2;\n            if (restChars <= 2) {\n                context.updateSymbolInfo(context.getCodewordCount() + restChars);\n                var available = context.getSymbolInfo().getDataCapacity() -\n                    context.getCodewordCount();\n                if (available >= 3) {\n                    restInAscii = false;\n                    context.updateSymbolInfo(context.getCodewordCount() + encoded.length);\n                    // available = context.symbolInfo.dataCapacity - context.getCodewordCount();\n                }\n            }\n            if (restInAscii) {\n                context.resetSymbolInfo();\n                context.pos -= restChars;\n            }\n            else {\n                context.writeCodewords(encoded);\n            }\n        }\n        finally {\n            context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n        }\n    };\n    EdifactEncoder.prototype.encodeChar = function (c, sb) {\n        if (c >= ' '.charCodeAt(0) && c <= '?'.charCodeAt(0)) {\n            sb.append(c);\n        }\n        else if (c >= '@'.charCodeAt(0) && c <= '^'.charCodeAt(0)) {\n            sb.append(StringUtils_1.default.getCharAt(c - 64));\n        }\n        else {\n            HighLevelEncoder_1.default.illegalCharacter(StringUtils_1.default.getCharAt(c));\n        }\n    };\n    EdifactEncoder.prototype.encodeToCodewords = function (sb) {\n        var len = sb.length;\n        if (len === 0) {\n            throw new Error('StringBuilder must not be empty');\n        }\n        var c1 = sb.charAt(0).charCodeAt(0);\n        var c2 = len >= 2 ? sb.charAt(1).charCodeAt(0) : 0;\n        var c3 = len >= 3 ? sb.charAt(2).charCodeAt(0) : 0;\n        var c4 = len >= 4 ? sb.charAt(3).charCodeAt(0) : 0;\n        var v = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4;\n        var cw1 = (v >> 16) & 255;\n        var cw2 = (v >> 8) & 255;\n        var cw3 = v & 255;\n        var res = new StringBuilder_1.default();\n        res.append(cw1);\n        if (len >= 2) {\n            res.append(cw2);\n        }\n        if (len >= 3) {\n            res.append(cw3);\n        }\n        return res.toString();\n    };\n    return EdifactEncoder;\n}());\nexports.EdifactEncoder = EdifactEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRWRpZmFjdEVuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLG9CQUFvQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsc0pBQWE7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsb0tBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0IiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL0VkaWZhY3RFbmNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FZGlmYWN0RW5jb2RlciA9IHZvaWQgMDtcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9TdHJpbmdVdGlsc1wiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIEhpZ2hMZXZlbEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0hpZ2hMZXZlbEVuY29kZXJcIik7XG52YXIgRWRpZmFjdEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRpZmFjdEVuY29kZXIoKSB7XG4gICAgfVxuICAgIEVkaWZhY3RFbmNvZGVyLnByb3RvdHlwZS5nZXRFbmNvZGluZ01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT047XG4gICAgfTtcbiAgICBFZGlmYWN0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gc3RlcCBGXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgd2hpbGUgKGNvbnRleHQuaGFzTW9yZUNoYXJhY3RlcnMoKSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjb250ZXh0LmdldEN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNoYXIoYywgYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnRleHQucG9zKys7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBidWZmZXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPj0gNCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQud3JpdGVDb2Rld29yZHModGhpcy5lbmNvZGVUb0NvZGV3b3JkcyhidWZmZXIudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0XzEgPSBidWZmZXIudG9TdHJpbmcoKS5zdWJzdHJpbmcoNCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldExlbmd0aFRvWmVybygpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodGVzdF8xKTtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIuZGVsZXRlKDAsIDQpO1xuICAgICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gIGJ1ZmZlci5kZWxldGVDaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHZhciBuZXdNb2RlID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQubG9va0FoZWFkVGVzdChjb250ZXh0LmdldE1lc3NhZ2UoKSwgY29udGV4dC5wb3MsIHRoaXMuZ2V0RW5jb2RpbmdNb2RlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNb2RlICE9PSB0aGlzLmdldEVuY29kaW5nTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0byBBU0NJSSBlbmNvZGF0aW9uLCB3aGljaCB3aWxsIGFjdHVhbGx5IGhhbmRsZSBsYXRjaCB0byBuZXcgbW9kZVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuYXBwZW5kKFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQXQoMzEpKTsgLy8gVW5sYXRjaFxuICAgICAgICB0aGlzLmhhbmRsZUVPRChjb250ZXh0LCBidWZmZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIFwiZW5kIG9mIGRhdGFcIiBzaXR1YXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZW5jb2RlciBjb250ZXh0XG4gICAgICogQHBhcmFtIGJ1ZmZlciAgdGhlIGJ1ZmZlciB3aXRoIHRoZSByZW1haW5pbmcgZW5jb2RlZCBjaGFyYWN0ZXJzXG4gICAgICovXG4gICAgRWRpZmFjdEVuY29kZXIucHJvdG90eXBlLmhhbmRsZUVPRCA9IGZ1bmN0aW9uIChjb250ZXh0LCBidWZmZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGJ1ZmZlci5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSBmaW5pc2hlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhbiB1bmxhdGNoIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBjb250ZXh0LnVwZGF0ZVN5bWJvbEluZm8oKTtcbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gY29udGV4dC5nZXRTeW1ib2xJbmZvKCkuZ2V0RGF0YUNhcGFjaXR5KCkgLVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldENvZGV3b3JkQ291bnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY29udGV4dC5nZXRSZW1haW5pbmdDaGFyYWN0ZXJzKCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0d28gbGluZXMgYXJlIGEgaGFjayBpbnNwaXJlZCBieSB0aGUgJ2ZpeCcgZnJvbSBodHRwczovL3NvdXJjZWZvcmdlLm5ldC9wL2JhcmNvZGU0ai9zdm4vMjIxL1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPiBhdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKGNvbnRleHQuZ2V0Q29kZXdvcmRDb3VudCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldFN5bWJvbEluZm8oKS5nZXREYXRhQ2FwYWNpdHkoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRDb2Rld29yZENvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gYXZhaWxhYmxlICYmIGF2YWlsYWJsZSA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gTm8gdW5sYXRjaFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdW50IG11c3Qgbm90IGV4Y2VlZCA0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdENoYXJzID0gY291bnQgLSAxO1xuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSB0aGlzLmVuY29kZVRvQ29kZXdvcmRzKGJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBlbmRPZlN5bWJvbFJlYWNoZWQgPSAhY29udGV4dC5oYXNNb3JlQ2hhcmFjdGVycygpO1xuICAgICAgICAgICAgdmFyIHJlc3RJbkFzY2lpID0gZW5kT2ZTeW1ib2xSZWFjaGVkICYmIHJlc3RDaGFycyA8PSAyO1xuICAgICAgICAgICAgaWYgKHJlc3RDaGFycyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKGNvbnRleHQuZ2V0Q29kZXdvcmRDb3VudCgpICsgcmVzdENoYXJzKTtcbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gY29udGV4dC5nZXRTeW1ib2xJbmZvKCkuZ2V0RGF0YUNhcGFjaXR5KCkgLVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldENvZGV3b3JkQ291bnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdEluQXNjaWkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKGNvbnRleHQuZ2V0Q29kZXdvcmRDb3VudCgpICsgZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGUgPSBjb250ZXh0LnN5bWJvbEluZm8uZGF0YUNhcGFjaXR5IC0gY29udGV4dC5nZXRDb2Rld29yZENvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3RJbkFzY2lpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXNldFN5bWJvbEluZm8oKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBvcyAtPSByZXN0Q2hhcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmRzKGVuY29kZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY29udGV4dC5zaWduYWxFbmNvZGVyQ2hhbmdlKGNvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT04pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGlmYWN0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlQ2hhciA9IGZ1bmN0aW9uIChjLCBzYikge1xuICAgICAgICBpZiAoYyA+PSAnICcuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICc/Jy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+PSAnQCcuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICdeJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJBdChjIC0gNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlsbGVnYWxDaGFyYWN0ZXIoU3RyaW5nVXRpbHNfMS5kZWZhdWx0LmdldENoYXJBdChjKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaWZhY3RFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVUb0NvZGV3b3JkcyA9IGZ1bmN0aW9uIChzYikge1xuICAgICAgICB2YXIgbGVuID0gc2IubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZ0J1aWxkZXIgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYzEgPSBzYi5jaGFyQXQoMCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgdmFyIGMyID0gbGVuID49IDIgPyBzYi5jaGFyQXQoMSkuY2hhckNvZGVBdCgwKSA6IDA7XG4gICAgICAgIHZhciBjMyA9IGxlbiA+PSAzID8gc2IuY2hhckF0KDIpLmNoYXJDb2RlQXQoMCkgOiAwO1xuICAgICAgICB2YXIgYzQgPSBsZW4gPj0gNCA/IHNiLmNoYXJBdCgzKS5jaGFyQ29kZUF0KDApIDogMDtcbiAgICAgICAgdmFyIHYgPSAoYzEgPDwgMTgpICsgKGMyIDw8IDEyKSArIChjMyA8PCA2KSArIGM0O1xuICAgICAgICB2YXIgY3cxID0gKHYgPj4gMTYpICYgMjU1O1xuICAgICAgICB2YXIgY3cyID0gKHYgPj4gOCkgJiAyNTU7XG4gICAgICAgIHZhciBjdzMgPSB2ICYgMjU1O1xuICAgICAgICB2YXIgcmVzID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHJlcy5hcHBlbmQoY3cxKTtcbiAgICAgICAgaWYgKGxlbiA+PSAyKSB7XG4gICAgICAgICAgICByZXMuYXBwZW5kKGN3Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+PSAzKSB7XG4gICAgICAgICAgICByZXMuYXBwZW5kKGN3Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIEVkaWZhY3RFbmNvZGVyO1xufSgpKTtcbmV4cG9ydHMuRWRpZmFjdEVuY29kZXIgPSBFZGlmYWN0RW5jb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EncoderContext = void 0;\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar SymbolInfo_1 = __webpack_require__(/*! ./SymbolInfo */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js\");\nvar EncoderContext = /** @class */ (function () {\n    function EncoderContext(msg) {\n        this.msg = msg;\n        this.pos = 0;\n        this.skipAtEnd = 0;\n        // From this point on Strings are not Unicode anymore!\n        var msgBinary = msg.split('').map(function (c) { return c.charCodeAt(0); });\n        var sb = new StringBuilder_1.default();\n        for (var i = 0, c = msgBinary.length; i < c; i++) {\n            var ch = String.fromCharCode(msgBinary[i] & 0xff);\n            if (ch === '?' && msg.charAt(i) !== '?') {\n                throw new Error('Message contains characters outside ISO-8859-1 encoding.');\n            }\n            sb.append(ch);\n        }\n        this.msg = sb.toString(); // Not Unicode here!\n        this.shape = 0 /* FORCE_NONE */;\n        this.codewords = new StringBuilder_1.default();\n        this.newEncoding = -1;\n    }\n    EncoderContext.prototype.setSymbolShape = function (shape) {\n        this.shape = shape;\n    };\n    EncoderContext.prototype.setSizeConstraints = function (minSize, maxSize) {\n        this.minSize = minSize;\n        this.maxSize = maxSize;\n    };\n    EncoderContext.prototype.getMessage = function () {\n        return this.msg;\n    };\n    EncoderContext.prototype.setSkipAtEnd = function (count) {\n        this.skipAtEnd = count;\n    };\n    EncoderContext.prototype.getCurrentChar = function () {\n        return this.msg.charCodeAt(this.pos);\n    };\n    EncoderContext.prototype.getCurrent = function () {\n        return this.msg.charCodeAt(this.pos);\n    };\n    EncoderContext.prototype.getCodewords = function () {\n        return this.codewords;\n    };\n    EncoderContext.prototype.writeCodewords = function (codewords) {\n        this.codewords.append(codewords);\n    };\n    EncoderContext.prototype.writeCodeword = function (codeword) {\n        this.codewords.append(codeword);\n    };\n    EncoderContext.prototype.getCodewordCount = function () {\n        return this.codewords.length();\n    };\n    EncoderContext.prototype.getNewEncoding = function () {\n        return this.newEncoding;\n    };\n    EncoderContext.prototype.signalEncoderChange = function (encoding) {\n        this.newEncoding = encoding;\n    };\n    EncoderContext.prototype.resetEncoderSignal = function () {\n        this.newEncoding = -1;\n    };\n    EncoderContext.prototype.hasMoreCharacters = function () {\n        return this.pos < this.getTotalMessageCharCount();\n    };\n    EncoderContext.prototype.getTotalMessageCharCount = function () {\n        return this.msg.length - this.skipAtEnd;\n    };\n    EncoderContext.prototype.getRemainingCharacters = function () {\n        return this.getTotalMessageCharCount() - this.pos;\n    };\n    EncoderContext.prototype.getSymbolInfo = function () {\n        return this.symbolInfo;\n    };\n    EncoderContext.prototype.updateSymbolInfo = function (len) {\n        if (len === void 0) { len = this.getCodewordCount(); }\n        if (this.symbolInfo == null || len > this.symbolInfo.getDataCapacity()) {\n            this.symbolInfo = SymbolInfo_1.default.lookup(len, this.shape, this.minSize, this.maxSize, true);\n        }\n    };\n    EncoderContext.prototype.resetSymbolInfo = function () {\n        this.symbolInfo = null;\n    };\n    return EncoderContext;\n}());\nexports.EncoderContext = EncoderContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRW5jb2RlckNvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLHNCQUFzQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyx3SkFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUJBQXlCO0FBQ2xGO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRW5jb2RlckNvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVuY29kZXJDb250ZXh0ID0gdm9pZCAwO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgU3ltYm9sSW5mb18xID0gcmVxdWlyZShcIi4vU3ltYm9sSW5mb1wiKTtcbnZhciBFbmNvZGVyQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmNvZGVyQ29udGV4dChtc2cpIHtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5za2lwQXRFbmQgPSAwO1xuICAgICAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24gU3RyaW5ncyBhcmUgbm90IFVuaWNvZGUgYW55bW9yZSFcbiAgICAgICAgdmFyIG1zZ0JpbmFyeSA9IG1zZy5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNoYXJDb2RlQXQoMCk7IH0pO1xuICAgICAgICB2YXIgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMgPSBtc2dCaW5hcnkubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1zZ0JpbmFyeVtpXSAmIDB4ZmYpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnPycgJiYgbXNnLmNoYXJBdChpKSAhPT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3V0c2lkZSBJU08tODg1OS0xIGVuY29kaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuYXBwZW5kKGNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1zZyA9IHNiLnRvU3RyaW5nKCk7IC8vIE5vdCBVbmljb2RlIGhlcmUhXG4gICAgICAgIHRoaXMuc2hhcGUgPSAwIC8qIEZPUkNFX05PTkUgKi87XG4gICAgICAgIHRoaXMuY29kZXdvcmRzID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubmV3RW5jb2RpbmcgPSAtMTtcbiAgICB9XG4gICAgRW5jb2RlckNvbnRleHQucHJvdG90eXBlLnNldFN5bWJvbFNoYXBlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5zZXRTaXplQ29uc3RyYWludHMgPSBmdW5jdGlvbiAobWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgICAgICB0aGlzLm1pblNpemUgPSBtaW5TaXplO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgIH07XG4gICAgRW5jb2RlckNvbnRleHQucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZztcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5zZXRTa2lwQXRFbmQgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdGhpcy5za2lwQXRFbmQgPSBjb3VudDtcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5nZXRDdXJyZW50Q2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIH07XG4gICAgRW5jb2RlckNvbnRleHQucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5nZXRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS53cml0ZUNvZGV3b3JkcyA9IGZ1bmN0aW9uIChjb2Rld29yZHMpIHtcbiAgICAgICAgdGhpcy5jb2Rld29yZHMuYXBwZW5kKGNvZGV3b3Jkcyk7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUud3JpdGVDb2Rld29yZCA9IGZ1bmN0aW9uIChjb2Rld29yZCkge1xuICAgICAgICB0aGlzLmNvZGV3b3Jkcy5hcHBlbmQoY29kZXdvcmQpO1xuICAgIH07XG4gICAgRW5jb2RlckNvbnRleHQucHJvdG90eXBlLmdldENvZGV3b3JkQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3Jkcy5sZW5ndGgoKTtcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5nZXROZXdFbmNvZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3RW5jb2Rpbmc7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUuc2lnbmFsRW5jb2RlckNoYW5nZSA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICB0aGlzLm5ld0VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUucmVzZXRFbmNvZGVyU2lnbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5ld0VuY29kaW5nID0gLTE7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUuaGFzTW9yZUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA8IHRoaXMuZ2V0VG90YWxNZXNzYWdlQ2hhckNvdW50KCk7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUuZ2V0VG90YWxNZXNzYWdlQ2hhckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cubGVuZ3RoIC0gdGhpcy5za2lwQXRFbmQ7XG4gICAgfTtcbiAgICBFbmNvZGVyQ29udGV4dC5wcm90b3R5cGUuZ2V0UmVtYWluaW5nQ2hhcmFjdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxNZXNzYWdlQ2hhckNvdW50KCkgLSB0aGlzLnBvcztcbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5nZXRTeW1ib2xJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xJbmZvO1xuICAgIH07XG4gICAgRW5jb2RlckNvbnRleHQucHJvdG90eXBlLnVwZGF0ZVN5bWJvbEluZm8gPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSB0aGlzLmdldENvZGV3b3JkQ291bnQoKTsgfVxuICAgICAgICBpZiAodGhpcy5zeW1ib2xJbmZvID09IG51bGwgfHwgbGVuID4gdGhpcy5zeW1ib2xJbmZvLmdldERhdGFDYXBhY2l0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbEluZm8gPSBTeW1ib2xJbmZvXzEuZGVmYXVsdC5sb29rdXAobGVuLCB0aGlzLnNoYXBlLCB0aGlzLm1pblNpemUsIHRoaXMubWF4U2l6ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXJDb250ZXh0LnByb3RvdHlwZS5yZXNldFN5bWJvbEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sSW5mbyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RlckNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5FbmNvZGVyQ29udGV4dCA9IEVuY29kZXJDb250ZXh0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\n/**\n * Error Correction Code for ECC200.\n */\nvar ErrorCorrection = /** @class */ (function () {\n    function ErrorCorrection() {\n    }\n    /**\n     * Creates the ECC200 error correction for an encoded message.\n     *\n     * @param codewords  the codewords\n     * @param symbolInfo information about the symbol to be encoded\n     * @return the codewords with interleaved error correction.\n     */\n    ErrorCorrection.encodeECC200 = function (codewords, symbolInfo) {\n        if (codewords.length !== symbolInfo.getDataCapacity()) {\n            throw new Error('The number of codewords does not match the selected symbol');\n        }\n        var sb = new StringBuilder_1.default();\n        sb.append(codewords);\n        var blockCount = symbolInfo.getInterleavedBlockCount();\n        if (blockCount === 1) {\n            var ecc = this.createECCBlock(codewords, symbolInfo.getErrorCodewords());\n            sb.append(ecc);\n        }\n        else {\n            // sb.setLength(sb.capacity());\n            var dataSizes = [];\n            var errorSizes = [];\n            for (var i = 0; i < blockCount; i++) {\n                dataSizes[i] = symbolInfo.getDataLengthForInterleavedBlock(i + 1);\n                errorSizes[i] = symbolInfo.getErrorLengthForInterleavedBlock(i + 1);\n            }\n            for (var block = 0; block < blockCount; block++) {\n                var temp = new StringBuilder_1.default();\n                for (var d = block; d < symbolInfo.getDataCapacity(); d += blockCount) {\n                    temp.append(codewords.charAt(d));\n                }\n                var ecc = this.createECCBlock(temp.toString(), errorSizes[block]);\n                var pos = 0;\n                for (var e = block; e < errorSizes[block] * blockCount; e += blockCount) {\n                    sb.setCharAt(symbolInfo.getDataCapacity() + e, ecc.charAt(pos++));\n                }\n            }\n        }\n        return sb.toString();\n    };\n    ErrorCorrection.createECCBlock = function (codewords, numECWords) {\n        var table = -1;\n        for (var i = 0; i < constants_1.FACTOR_SETS.length; i++) {\n            if (constants_1.FACTOR_SETS[i] === numECWords) {\n                table = i;\n                break;\n            }\n        }\n        if (table < 0) {\n            throw new Error('Illegal number of error correction codewords specified: ' + numECWords);\n        }\n        var poly = constants_1.FACTORS[table];\n        var ecc = [];\n        for (var i = 0; i < numECWords; i++) {\n            ecc[i] = 0;\n        }\n        for (var i = 0; i < codewords.length; i++) {\n            var m = ecc[numECWords - 1] ^ codewords.charAt(i).charCodeAt(0);\n            for (var k = numECWords - 1; k > 0; k--) {\n                if (m !== 0 && poly[k] !== 0) {\n                    ecc[k] = ecc[k - 1] ^ constants_1.ALOG[(constants_1.LOG[m] + constants_1.LOG[poly[k]]) % 255];\n                }\n                else {\n                    ecc[k] = ecc[k - 1];\n                }\n            }\n            if (m !== 0 && poly[0] !== 0) {\n                ecc[0] = constants_1.ALOG[(constants_1.LOG[m] + constants_1.LOG[poly[0]]) % 255];\n            }\n            else {\n                ecc[0] = 0;\n            }\n        }\n        var eccReversed = [];\n        for (var i = 0; i < numECWords; i++) {\n            eccReversed[i] = ecc[numECWords - i - 1];\n        }\n        return eccReversed.map(function (c) { return String.fromCharCode(c); }).join('');\n    };\n    return ErrorCorrection;\n}());\nexports[\"default\"] = ErrorCorrection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRXJyb3JDb3JyZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBLG9DQUFvQyxrQ0FBa0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUU7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvRXJyb3JDb3JyZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEVycm9yIENvcnJlY3Rpb24gQ29kZSBmb3IgRUNDMjAwLlxuICovXG52YXIgRXJyb3JDb3JyZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgRUNDMjAwIGVycm9yIGNvcnJlY3Rpb24gZm9yIGFuIGVuY29kZWQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2Rld29yZHMgIHRoZSBjb2Rld29yZHNcbiAgICAgKiBAcGFyYW0gc3ltYm9sSW5mbyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3ltYm9sIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcmV0dXJuIHRoZSBjb2Rld29yZHMgd2l0aCBpbnRlcmxlYXZlZCBlcnJvciBjb3JyZWN0aW9uLlxuICAgICAqL1xuICAgIEVycm9yQ29ycmVjdGlvbi5lbmNvZGVFQ0MyMDAgPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBzeW1ib2xJbmZvKSB7XG4gICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoICE9PSBzeW1ib2xJbmZvLmdldERhdGFDYXBhY2l0eSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgY29kZXdvcmRzIGRvZXMgbm90IG1hdGNoIHRoZSBzZWxlY3RlZCBzeW1ib2wnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgc2IuYXBwZW5kKGNvZGV3b3Jkcyk7XG4gICAgICAgIHZhciBibG9ja0NvdW50ID0gc3ltYm9sSW5mby5nZXRJbnRlcmxlYXZlZEJsb2NrQ291bnQoKTtcbiAgICAgICAgaWYgKGJsb2NrQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBlY2MgPSB0aGlzLmNyZWF0ZUVDQ0Jsb2NrKGNvZGV3b3Jkcywgc3ltYm9sSW5mby5nZXRFcnJvckNvZGV3b3JkcygpKTtcbiAgICAgICAgICAgIHNiLmFwcGVuZChlY2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2Iuc2V0TGVuZ3RoKHNiLmNhcGFjaXR5KCkpO1xuICAgICAgICAgICAgdmFyIGRhdGFTaXplcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGVycm9yU2l6ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNpemVzW2ldID0gc3ltYm9sSW5mby5nZXREYXRhTGVuZ3RoRm9ySW50ZXJsZWF2ZWRCbG9jayhpICsgMSk7XG4gICAgICAgICAgICAgICAgZXJyb3JTaXplc1tpXSA9IHN5bWJvbEluZm8uZ2V0RXJyb3JMZW5ndGhGb3JJbnRlcmxlYXZlZEJsb2NrKGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrID0gMDsgYmxvY2sgPCBibG9ja0NvdW50OyBibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gYmxvY2s7IGQgPCBzeW1ib2xJbmZvLmdldERhdGFDYXBhY2l0eSgpOyBkICs9IGJsb2NrQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5hcHBlbmQoY29kZXdvcmRzLmNoYXJBdChkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlY2MgPSB0aGlzLmNyZWF0ZUVDQ0Jsb2NrKHRlbXAudG9TdHJpbmcoKSwgZXJyb3JTaXplc1tibG9ja10pO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBibG9jazsgZSA8IGVycm9yU2l6ZXNbYmxvY2tdICogYmxvY2tDb3VudDsgZSArPSBibG9ja0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLnNldENoYXJBdChzeW1ib2xJbmZvLmdldERhdGFDYXBhY2l0eSgpICsgZSwgZWNjLmNoYXJBdChwb3MrKykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEVycm9yQ29ycmVjdGlvbi5jcmVhdGVFQ0NCbG9jayA9IGZ1bmN0aW9uIChjb2Rld29yZHMsIG51bUVDV29yZHMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RhbnRzXzEuRkFDVE9SX1NFVFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb25zdGFudHNfMS5GQUNUT1JfU0VUU1tpXSA9PT0gbnVtRUNXb3Jkcykge1xuICAgICAgICAgICAgICAgIHRhYmxlID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFibGUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIHNwZWNpZmllZDogJyArIG51bUVDV29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2x5ID0gY29uc3RhbnRzXzEuRkFDVE9SU1t0YWJsZV07XG4gICAgICAgIHZhciBlY2MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FQ1dvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIGVjY1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2Rld29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtID0gZWNjW251bUVDV29yZHMgLSAxXSBeIGNvZGV3b3Jkcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBudW1FQ1dvcmRzIC0gMTsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSAwICYmIHBvbHlba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZWNjW2tdID0gZWNjW2sgLSAxXSBeIGNvbnN0YW50c18xLkFMT0dbKGNvbnN0YW50c18xLkxPR1ttXSArIGNvbnN0YW50c18xLkxPR1twb2x5W2tdXSkgJSAyNTVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWNjW2tdID0gZWNjW2sgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobSAhPT0gMCAmJiBwb2x5WzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZWNjWzBdID0gY29uc3RhbnRzXzEuQUxPR1soY29uc3RhbnRzXzEuTE9HW21dICsgY29uc3RhbnRzXzEuTE9HW3BvbHlbMF1dKSAlIDI1NV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlY2NbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlY2NSZXZlcnNlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVDV29yZHM7IGkrKykge1xuICAgICAgICAgICAgZWNjUmV2ZXJzZWRbaV0gPSBlY2NbbnVtRUNXb3JkcyAtIGkgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWNjUmV2ZXJzZWQubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpOyB9KS5qb2luKCcnKTtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckNvcnJlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb3JyZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// tslint:disable-next-line:no-circular-imports\nvar ASCIIEncoder_1 = __webpack_require__(/*! ./ASCIIEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js\");\n// tslint:disable-next-line:no-circular-imports\nvar Base256Encoder_1 = __webpack_require__(/*! ./Base256Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js\");\n// tslint:disable-next-line:no-circular-imports\nvar C40Encoder_1 = __webpack_require__(/*! ./C40Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\n// tslint:disable-next-line:no-circular-imports\nvar EdifactEncoder_1 = __webpack_require__(/*! ./EdifactEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js\");\nvar EncoderContext_1 = __webpack_require__(/*! ./EncoderContext */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js\");\n// tslint:disable-next-line:no-circular-imports\nvar X12Encoder_1 = __webpack_require__(/*! ./X12Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js\");\n// tslint:disable-next-line:no-circular-imports\nvar TextEncoder_1 = __webpack_require__(/*! ./TextEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js\");\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\n/**\n * DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in\n * annex S.\n */\nvar HighLevelEncoder = /** @class */ (function () {\n    function HighLevelEncoder() {\n    }\n    HighLevelEncoder.randomize253State = function (codewordPosition) {\n        var pseudoRandom = ((149 * codewordPosition) % 253) + 1;\n        var tempVariable = constants_1.PAD + pseudoRandom;\n        return tempVariable <= 254 ? tempVariable : tempVariable - 254;\n    };\n    /**\n     * Performs message encoding of a DataMatrix message using the algorithm described in annex P\n     * of ISO/IEC 16022:2000(E).\n     *\n     * @param msg     the message\n     * @param shape   requested shape. May be {@code SymbolShapeHint.FORCE_NONE},\n     *                {@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.\n     * @param minSize the minimum symbol size constraint or null for no constraint\n     * @param maxSize the maximum symbol size constraint or null for no constraint\n     * @param forceC40 enforce C40 encoding\n     * @return the encoded message (the char values range from 0 to 255)\n     */\n    HighLevelEncoder.encodeHighLevel = function (msg, shape, minSize, maxSize, forceC40) {\n        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }\n        if (minSize === void 0) { minSize = null; }\n        if (maxSize === void 0) { maxSize = null; }\n        if (forceC40 === void 0) { forceC40 = false; }\n        // the codewords 0..255 are encoded as Unicode characters\n        var c40Encoder = new C40Encoder_1.C40Encoder();\n        var encoders = [\n            new ASCIIEncoder_1.ASCIIEncoder(),\n            c40Encoder,\n            new TextEncoder_1.TextEncoder(),\n            new X12Encoder_1.X12Encoder(),\n            new EdifactEncoder_1.EdifactEncoder(),\n            new Base256Encoder_1.Base256Encoder(),\n        ];\n        var context = new EncoderContext_1.EncoderContext(msg);\n        context.setSymbolShape(shape);\n        context.setSizeConstraints(minSize, maxSize);\n        if (msg.startsWith(constants_1.MACRO_05_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {\n            context.writeCodeword(constants_1.MACRO_05);\n            context.setSkipAtEnd(2);\n            context.pos += constants_1.MACRO_05_HEADER.length;\n        }\n        else if (msg.startsWith(constants_1.MACRO_06_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {\n            context.writeCodeword(constants_1.MACRO_06);\n            context.setSkipAtEnd(2);\n            context.pos += constants_1.MACRO_06_HEADER.length;\n        }\n        var encodingMode = constants_1.ASCII_ENCODATION; // Default mode\n        if (forceC40) {\n            c40Encoder.encodeMaximal(context);\n            encodingMode = context.getNewEncoding();\n            context.resetEncoderSignal();\n        }\n        while (context.hasMoreCharacters()) {\n            encoders[encodingMode].encode(context);\n            if (context.getNewEncoding() >= 0) {\n                encodingMode = context.getNewEncoding();\n                context.resetEncoderSignal();\n            }\n        }\n        var len = context.getCodewordCount();\n        context.updateSymbolInfo();\n        var capacity = context.getSymbolInfo().getDataCapacity();\n        if (len < capacity &&\n            encodingMode !== constants_1.ASCII_ENCODATION &&\n            encodingMode !== constants_1.BASE256_ENCODATION &&\n            encodingMode !== constants_1.EDIFACT_ENCODATION) {\n            context.writeCodeword('\\u00fe'); // Unlatch (254)\n        }\n        // Padding\n        var codewords = context.getCodewords();\n        if (codewords.length() < capacity) {\n            codewords.append(constants_1.PAD);\n        }\n        while (codewords.length() < capacity) {\n            codewords.append(this.randomize253State(codewords.length() + 1));\n        }\n        return context.getCodewords().toString();\n    };\n    HighLevelEncoder.lookAheadTest = function (msg, startpos, currentMode) {\n        var newMode = this.lookAheadTestIntern(msg, startpos, currentMode);\n        if (currentMode === constants_1.X12_ENCODATION && newMode === constants_1.X12_ENCODATION) {\n            var endpos = Math.min(startpos + 3, msg.length);\n            for (var i = startpos; i < endpos; i++) {\n                if (!this.isNativeX12(msg.charCodeAt(i))) {\n                    return constants_1.ASCII_ENCODATION;\n                }\n            }\n        }\n        else if (currentMode === constants_1.EDIFACT_ENCODATION &&\n            newMode === constants_1.EDIFACT_ENCODATION) {\n            var endpos = Math.min(startpos + 4, msg.length);\n            for (var i = startpos; i < endpos; i++) {\n                if (!this.isNativeEDIFACT(msg.charCodeAt(i))) {\n                    return constants_1.ASCII_ENCODATION;\n                }\n            }\n        }\n        return newMode;\n    };\n    HighLevelEncoder.lookAheadTestIntern = function (msg, startpos, currentMode) {\n        if (startpos >= msg.length) {\n            return currentMode;\n        }\n        var charCounts;\n        // step J\n        if (currentMode === constants_1.ASCII_ENCODATION) {\n            charCounts = [0, 1, 1, 1, 1, 1.25];\n        }\n        else {\n            charCounts = [1, 2, 2, 2, 2, 2.25];\n            charCounts[currentMode] = 0;\n        }\n        var charsProcessed = 0;\n        var mins = new Uint8Array(6);\n        var intCharCounts = [];\n        while (true) {\n            // step K\n            if (startpos + charsProcessed === msg.length) {\n                Arrays_1.default.fill(mins, 0);\n                Arrays_1.default.fill(intCharCounts, 0);\n                var min = this.findMinimums(charCounts, intCharCounts, Integer_1.default.MAX_VALUE, mins);\n                var minCount = this.getMinimumCount(mins);\n                if (intCharCounts[constants_1.ASCII_ENCODATION] === min) {\n                    return constants_1.ASCII_ENCODATION;\n                }\n                if (minCount === 1) {\n                    if (mins[constants_1.BASE256_ENCODATION] > 0) {\n                        return constants_1.BASE256_ENCODATION;\n                    }\n                    if (mins[constants_1.EDIFACT_ENCODATION] > 0) {\n                        return constants_1.EDIFACT_ENCODATION;\n                    }\n                    if (mins[constants_1.TEXT_ENCODATION] > 0) {\n                        return constants_1.TEXT_ENCODATION;\n                    }\n                    if (mins[constants_1.X12_ENCODATION] > 0) {\n                        return constants_1.X12_ENCODATION;\n                    }\n                }\n                return constants_1.C40_ENCODATION;\n            }\n            var c = msg.charCodeAt(startpos + charsProcessed);\n            charsProcessed++;\n            // step L\n            if (this.isDigit(c)) {\n                charCounts[constants_1.ASCII_ENCODATION] += 0.5;\n            }\n            else if (this.isExtendedASCII(c)) {\n                charCounts[constants_1.ASCII_ENCODATION] = Math.ceil(charCounts[constants_1.ASCII_ENCODATION]);\n                charCounts[constants_1.ASCII_ENCODATION] += 2.0;\n            }\n            else {\n                charCounts[constants_1.ASCII_ENCODATION] = Math.ceil(charCounts[constants_1.ASCII_ENCODATION]);\n                charCounts[constants_1.ASCII_ENCODATION]++;\n            }\n            // step M\n            if (this.isNativeC40(c)) {\n                charCounts[constants_1.C40_ENCODATION] += 2.0 / 3.0;\n            }\n            else if (this.isExtendedASCII(c)) {\n                charCounts[constants_1.C40_ENCODATION] += 8.0 / 3.0;\n            }\n            else {\n                charCounts[constants_1.C40_ENCODATION] += 4.0 / 3.0;\n            }\n            // step N\n            if (this.isNativeText(c)) {\n                charCounts[constants_1.TEXT_ENCODATION] += 2.0 / 3.0;\n            }\n            else if (this.isExtendedASCII(c)) {\n                charCounts[constants_1.TEXT_ENCODATION] += 8.0 / 3.0;\n            }\n            else {\n                charCounts[constants_1.TEXT_ENCODATION] += 4.0 / 3.0;\n            }\n            // step O\n            if (this.isNativeX12(c)) {\n                charCounts[constants_1.X12_ENCODATION] += 2.0 / 3.0;\n            }\n            else if (this.isExtendedASCII(c)) {\n                charCounts[constants_1.X12_ENCODATION] += 13.0 / 3.0;\n            }\n            else {\n                charCounts[constants_1.X12_ENCODATION] += 10.0 / 3.0;\n            }\n            // step P\n            if (this.isNativeEDIFACT(c)) {\n                charCounts[constants_1.EDIFACT_ENCODATION] += 3.0 / 4.0;\n            }\n            else if (this.isExtendedASCII(c)) {\n                charCounts[constants_1.EDIFACT_ENCODATION] += 17.0 / 4.0;\n            }\n            else {\n                charCounts[constants_1.EDIFACT_ENCODATION] += 13.0 / 4.0;\n            }\n            // step Q\n            if (this.isSpecialB256(c)) {\n                charCounts[constants_1.BASE256_ENCODATION] += 4.0;\n            }\n            else {\n                charCounts[constants_1.BASE256_ENCODATION]++;\n            }\n            // step R\n            if (charsProcessed >= 4) {\n                Arrays_1.default.fill(mins, 0);\n                Arrays_1.default.fill(intCharCounts, 0);\n                this.findMinimums(charCounts, intCharCounts, Integer_1.default.MAX_VALUE, mins);\n                if (intCharCounts[constants_1.ASCII_ENCODATION] <\n                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION])) {\n                    return constants_1.ASCII_ENCODATION;\n                }\n                if (intCharCounts[constants_1.BASE256_ENCODATION] < intCharCounts[constants_1.ASCII_ENCODATION] ||\n                    intCharCounts[constants_1.BASE256_ENCODATION] + 1 <\n                        this.min(intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION])) {\n                    return constants_1.BASE256_ENCODATION;\n                }\n                if (intCharCounts[constants_1.EDIFACT_ENCODATION] + 1 <\n                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {\n                    return constants_1.EDIFACT_ENCODATION;\n                }\n                if (intCharCounts[constants_1.TEXT_ENCODATION] + 1 <\n                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {\n                    return constants_1.TEXT_ENCODATION;\n                }\n                if (intCharCounts[constants_1.X12_ENCODATION] + 1 <\n                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {\n                    return constants_1.X12_ENCODATION;\n                }\n                if (intCharCounts[constants_1.C40_ENCODATION] + 1 <\n                    this.min(intCharCounts[constants_1.ASCII_ENCODATION], intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION])) {\n                    if (intCharCounts[constants_1.C40_ENCODATION] < intCharCounts[constants_1.X12_ENCODATION]) {\n                        return constants_1.C40_ENCODATION;\n                    }\n                    if (intCharCounts[constants_1.C40_ENCODATION] === intCharCounts[constants_1.X12_ENCODATION]) {\n                        var p = startpos + charsProcessed + 1;\n                        while (p < msg.length) {\n                            var tc = msg.charCodeAt(p);\n                            if (this.isX12TermSep(tc)) {\n                                return constants_1.X12_ENCODATION;\n                            }\n                            if (!this.isNativeX12(tc)) {\n                                break;\n                            }\n                            p++;\n                        }\n                        return constants_1.C40_ENCODATION;\n                    }\n                }\n            }\n        }\n    };\n    HighLevelEncoder.min = function (f1, f2, f3, f4, f5) {\n        var val = Math.min(f1, Math.min(f2, Math.min(f3, f4)));\n        if (f5 === undefined) {\n            return val;\n        }\n        else {\n            return Math.min(val, f5);\n        }\n    };\n    HighLevelEncoder.findMinimums = function (charCounts, intCharCounts, min, mins) {\n        for (var i = 0; i < 6; i++) {\n            var current = (intCharCounts[i] = Math.ceil(charCounts[i]));\n            if (min > current) {\n                min = current;\n                Arrays_1.default.fill(mins, 0);\n            }\n            if (min === current) {\n                mins[i] = mins[i] + 1;\n            }\n        }\n        return min;\n    };\n    HighLevelEncoder.getMinimumCount = function (mins) {\n        var minCount = 0;\n        for (var i = 0; i < 6; i++) {\n            minCount += mins[i];\n        }\n        return minCount || 0;\n    };\n    HighLevelEncoder.isDigit = function (ch) {\n        return ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0);\n    };\n    HighLevelEncoder.isExtendedASCII = function (ch) {\n        return ch >= 128 && ch <= 255;\n    };\n    HighLevelEncoder.isNativeC40 = function (ch) {\n        return (ch === ' '.charCodeAt(0) ||\n            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||\n            (ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0)));\n    };\n    HighLevelEncoder.isNativeText = function (ch) {\n        return (ch === ' '.charCodeAt(0) ||\n            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||\n            (ch >= 'a'.charCodeAt(0) && ch <= 'z'.charCodeAt(0)));\n    };\n    HighLevelEncoder.isNativeX12 = function (ch) {\n        return (this.isX12TermSep(ch) ||\n            ch === ' '.charCodeAt(0) ||\n            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||\n            (ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0)));\n    };\n    HighLevelEncoder.isX12TermSep = function (ch) {\n        return (ch === 13 || // CR\n            ch === '*'.charCodeAt(0) ||\n            ch === '>'.charCodeAt(0));\n    };\n    HighLevelEncoder.isNativeEDIFACT = function (ch) {\n        return ch >= ' '.charCodeAt(0) && ch <= '^'.charCodeAt(0);\n    };\n    HighLevelEncoder.isSpecialB256 = function (ch) {\n        return false; // TODO NOT IMPLEMENTED YET!!!\n    };\n    /**\n     * Determines the number of consecutive characters that are encodable using numeric compaction.\n     *\n     * @param msg      the message\n     * @param startpos the start position within the message\n     * @return the requested character count\n     */\n    HighLevelEncoder.determineConsecutiveDigitCount = function (msg, startpos) {\n        if (startpos === void 0) { startpos = 0; }\n        var len = msg.length;\n        var idx = startpos;\n        while (idx < len && this.isDigit(msg.charCodeAt(idx))) {\n            idx++;\n        }\n        return idx - startpos;\n    };\n    HighLevelEncoder.illegalCharacter = function (singleCharacter) {\n        var hex = Integer_1.default.toHexString(singleCharacter.charCodeAt(0));\n        hex = '0000'.substring(0, 4 - hex.length) + hex;\n        throw new Error('Illegal character: ' + singleCharacter + ' (0x' + hex + ')');\n    };\n    return HighLevelEncoder;\n}());\nexports[\"default\"] = HighLevelEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvSGlnaExldmVsRW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDRKQUFnQjtBQUM3QztBQUNBLHVCQUF1QixtQkFBTyxDQUFDLGdLQUFrQjtBQUNqRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHdKQUFjO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLHNKQUFhO0FBQ3ZDO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsZ0tBQWtCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLGdLQUFrQjtBQUNqRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHdKQUFjO0FBQ3pDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMEpBQWU7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDJJQUFtQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2SUFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEYsdUJBQXVCLG9DQUFvQyxJQUFJLHNDQUFzQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2RhdGFtYXRyaXgvZW5jb2Rlci9IaWdoTGV2ZWxFbmNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBBU0NJSUVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0FTQ0lJRW5jb2RlclwiKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jaXJjdWxhci1pbXBvcnRzXG52YXIgQmFzZTI1NkVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2UyNTZFbmNvZGVyXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBDNDBFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9DNDBFbmNvZGVyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBFZGlmYWN0RW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vRWRpZmFjdEVuY29kZXJcIik7XG52YXIgRW5jb2RlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0VuY29kZXJDb250ZXh0XCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBYMTJFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9YMTJFbmNvZGVyXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNpcmN1bGFyLWltcG9ydHNcbnZhciBUZXh0RW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vVGV4dEVuY29kZXJcIik7XG52YXIgQXJyYXlzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9BcnJheXNcIik7XG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcbi8qKlxuICogRGF0YU1hdHJpeCBFQ0MgMjAwIGRhdGEgZW5jb2RlciBmb2xsb3dpbmcgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gSVNPL0lFQyAxNjAyMjoyMDAoRSkgaW5cbiAqIGFubmV4IFMuXG4gKi9cbnZhciBIaWdoTGV2ZWxFbmNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpZ2hMZXZlbEVuY29kZXIoKSB7XG4gICAgfVxuICAgIEhpZ2hMZXZlbEVuY29kZXIucmFuZG9taXplMjUzU3RhdGUgPSBmdW5jdGlvbiAoY29kZXdvcmRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcHNldWRvUmFuZG9tID0gKCgxNDkgKiBjb2Rld29yZFBvc2l0aW9uKSAlIDI1MykgKyAxO1xuICAgICAgICB2YXIgdGVtcFZhcmlhYmxlID0gY29uc3RhbnRzXzEuUEFEICsgcHNldWRvUmFuZG9tO1xuICAgICAgICByZXR1cm4gdGVtcFZhcmlhYmxlIDw9IDI1NCA/IHRlbXBWYXJpYWJsZSA6IHRlbXBWYXJpYWJsZSAtIDI1NDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG1lc3NhZ2UgZW5jb2Rpbmcgb2YgYSBEYXRhTWF0cml4IG1lc3NhZ2UgdXNpbmcgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gYW5uZXggUFxuICAgICAqIG9mIElTTy9JRUMgMTYwMjI6MjAwMChFKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgICAgIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHNoYXBlICAgcmVxdWVzdGVkIHNoYXBlLiBNYXkgYmUge0Bjb2RlIFN5bWJvbFNoYXBlSGludC5GT1JDRV9OT05FfSxcbiAgICAgKiAgICAgICAgICAgICAgICB7QGNvZGUgU3ltYm9sU2hhcGVIaW50LkZPUkNFX1NRVUFSRX0gb3Ige0Bjb2RlIFN5bWJvbFNoYXBlSGludC5GT1JDRV9SRUNUQU5HTEV9LlxuICAgICAqIEBwYXJhbSBtaW5TaXplIHRoZSBtaW5pbXVtIHN5bWJvbCBzaXplIGNvbnN0cmFpbnQgb3IgbnVsbCBmb3Igbm8gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSBtYXhTaXplIHRoZSBtYXhpbXVtIHN5bWJvbCBzaXplIGNvbnN0cmFpbnQgb3IgbnVsbCBmb3Igbm8gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSBmb3JjZUM0MCBlbmZvcmNlIEM0MCBlbmNvZGluZ1xuICAgICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAodGhlIGNoYXIgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAyNTUpXG4gICAgICovXG4gICAgSGlnaExldmVsRW5jb2Rlci5lbmNvZGVIaWdoTGV2ZWwgPSBmdW5jdGlvbiAobXNnLCBzaGFwZSwgbWluU2l6ZSwgbWF4U2l6ZSwgZm9yY2VDNDApIHtcbiAgICAgICAgaWYgKHNoYXBlID09PSB2b2lkIDApIHsgc2hhcGUgPSAwIC8qIEZPUkNFX05PTkUgKi87IH1cbiAgICAgICAgaWYgKG1pblNpemUgPT09IHZvaWQgMCkgeyBtaW5TaXplID0gbnVsbDsgfVxuICAgICAgICBpZiAobWF4U2l6ZSA9PT0gdm9pZCAwKSB7IG1heFNpemUgPSBudWxsOyB9XG4gICAgICAgIGlmIChmb3JjZUM0MCA9PT0gdm9pZCAwKSB7IGZvcmNlQzQwID0gZmFsc2U7IH1cbiAgICAgICAgLy8gdGhlIGNvZGV3b3JkcyAwLi4yNTUgYXJlIGVuY29kZWQgYXMgVW5pY29kZSBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBjNDBFbmNvZGVyID0gbmV3IEM0MEVuY29kZXJfMS5DNDBFbmNvZGVyKCk7XG4gICAgICAgIHZhciBlbmNvZGVycyA9IFtcbiAgICAgICAgICAgIG5ldyBBU0NJSUVuY29kZXJfMS5BU0NJSUVuY29kZXIoKSxcbiAgICAgICAgICAgIGM0MEVuY29kZXIsXG4gICAgICAgICAgICBuZXcgVGV4dEVuY29kZXJfMS5UZXh0RW5jb2RlcigpLFxuICAgICAgICAgICAgbmV3IFgxMkVuY29kZXJfMS5YMTJFbmNvZGVyKCksXG4gICAgICAgICAgICBuZXcgRWRpZmFjdEVuY29kZXJfMS5FZGlmYWN0RW5jb2RlcigpLFxuICAgICAgICAgICAgbmV3IEJhc2UyNTZFbmNvZGVyXzEuQmFzZTI1NkVuY29kZXIoKSxcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgRW5jb2RlckNvbnRleHRfMS5FbmNvZGVyQ29udGV4dChtc2cpO1xuICAgICAgICBjb250ZXh0LnNldFN5bWJvbFNoYXBlKHNoYXBlKTtcbiAgICAgICAgY29udGV4dC5zZXRTaXplQ29uc3RyYWludHMobWluU2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgIGlmIChtc2cuc3RhcnRzV2l0aChjb25zdGFudHNfMS5NQUNST18wNV9IRUFERVIpICYmIG1zZy5lbmRzV2l0aChjb25zdGFudHNfMS5NQUNST19UUkFJTEVSKSkge1xuICAgICAgICAgICAgY29udGV4dC53cml0ZUNvZGV3b3JkKGNvbnN0YW50c18xLk1BQ1JPXzA1KTtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0U2tpcEF0RW5kKDIpO1xuICAgICAgICAgICAgY29udGV4dC5wb3MgKz0gY29uc3RhbnRzXzEuTUFDUk9fMDVfSEVBREVSLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuc3RhcnRzV2l0aChjb25zdGFudHNfMS5NQUNST18wNl9IRUFERVIpICYmIG1zZy5lbmRzV2l0aChjb25zdGFudHNfMS5NQUNST19UUkFJTEVSKSkge1xuICAgICAgICAgICAgY29udGV4dC53cml0ZUNvZGV3b3JkKGNvbnN0YW50c18xLk1BQ1JPXzA2KTtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0U2tpcEF0RW5kKDIpO1xuICAgICAgICAgICAgY29udGV4dC5wb3MgKz0gY29uc3RhbnRzXzEuTUFDUk9fMDZfSEVBREVSLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5jb2RpbmdNb2RlID0gY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTjsgLy8gRGVmYXVsdCBtb2RlXG4gICAgICAgIGlmIChmb3JjZUM0MCkge1xuICAgICAgICAgICAgYzQwRW5jb2Rlci5lbmNvZGVNYXhpbWFsKGNvbnRleHQpO1xuICAgICAgICAgICAgZW5jb2RpbmdNb2RlID0gY29udGV4dC5nZXROZXdFbmNvZGluZygpO1xuICAgICAgICAgICAgY29udGV4dC5yZXNldEVuY29kZXJTaWduYWwoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29udGV4dC5oYXNNb3JlQ2hhcmFjdGVycygpKSB7XG4gICAgICAgICAgICBlbmNvZGVyc1tlbmNvZGluZ01vZGVdLmVuY29kZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmdldE5ld0VuY29kaW5nKCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nTW9kZSA9IGNvbnRleHQuZ2V0TmV3RW5jb2RpbmcoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc2V0RW5jb2RlclNpZ25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBjb250ZXh0LmdldENvZGV3b3JkQ291bnQoKTtcbiAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKCk7XG4gICAgICAgIHZhciBjYXBhY2l0eSA9IGNvbnRleHQuZ2V0U3ltYm9sSW5mbygpLmdldERhdGFDYXBhY2l0eSgpO1xuICAgICAgICBpZiAobGVuIDwgY2FwYWNpdHkgJiZcbiAgICAgICAgICAgIGVuY29kaW5nTW9kZSAhPT0gY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTiAmJlxuICAgICAgICAgICAgZW5jb2RpbmdNb2RlICE9PSBjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT04gJiZcbiAgICAgICAgICAgIGVuY29kaW5nTW9kZSAhPT0gY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OKSB7XG4gICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoJ1xcdTAwZmUnKTsgLy8gVW5sYXRjaCAoMjU0KVxuICAgICAgICB9XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IGNvbnRleHQuZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoKCkgPCBjYXBhY2l0eSkge1xuICAgICAgICAgICAgY29kZXdvcmRzLmFwcGVuZChjb25zdGFudHNfMS5QQUQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb2Rld29yZHMubGVuZ3RoKCkgPCBjYXBhY2l0eSkge1xuICAgICAgICAgICAgY29kZXdvcmRzLmFwcGVuZCh0aGlzLnJhbmRvbWl6ZTI1M1N0YXRlKGNvZGV3b3Jkcy5sZW5ndGgoKSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dC5nZXRDb2Rld29yZHMoKS50b1N0cmluZygpO1xuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5sb29rQWhlYWRUZXN0ID0gZnVuY3Rpb24gKG1zZywgc3RhcnRwb3MsIGN1cnJlbnRNb2RlKSB7XG4gICAgICAgIHZhciBuZXdNb2RlID0gdGhpcy5sb29rQWhlYWRUZXN0SW50ZXJuKG1zZywgc3RhcnRwb3MsIGN1cnJlbnRNb2RlKTtcbiAgICAgICAgaWYgKGN1cnJlbnRNb2RlID09PSBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTiAmJiBuZXdNb2RlID09PSBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTikge1xuICAgICAgICAgICAgdmFyIGVuZHBvcyA9IE1hdGgubWluKHN0YXJ0cG9zICsgMywgbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRwb3M7IGkgPCBlbmRwb3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc05hdGl2ZVgxMihtc2cuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRNb2RlID09PSBjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT04gJiZcbiAgICAgICAgICAgIG5ld01vZGUgPT09IGNvbnN0YW50c18xLkVESUZBQ1RfRU5DT0RBVElPTikge1xuICAgICAgICAgICAgdmFyIGVuZHBvcyA9IE1hdGgubWluKHN0YXJ0cG9zICsgNCwgbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRwb3M7IGkgPCBlbmRwb3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc05hdGl2ZUVESUZBQ1QobXNnLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5BU0NJSV9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TW9kZTtcbiAgICB9O1xuICAgIEhpZ2hMZXZlbEVuY29kZXIubG9va0FoZWFkVGVzdEludGVybiA9IGZ1bmN0aW9uIChtc2csIHN0YXJ0cG9zLCBjdXJyZW50TW9kZSkge1xuICAgICAgICBpZiAoc3RhcnRwb3MgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRNb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyQ291bnRzO1xuICAgICAgICAvLyBzdGVwIEpcbiAgICAgICAgaWYgKGN1cnJlbnRNb2RlID09PSBjb25zdGFudHNfMS5BU0NJSV9FTkNPREFUSU9OKSB7XG4gICAgICAgICAgICBjaGFyQ291bnRzID0gWzAsIDEsIDEsIDEsIDEsIDEuMjVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhckNvdW50cyA9IFsxLCAyLCAyLCAyLCAyLCAyLjI1XTtcbiAgICAgICAgICAgIGNoYXJDb3VudHNbY3VycmVudE1vZGVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhcnNQcm9jZXNzZWQgPSAwO1xuICAgICAgICB2YXIgbWlucyA9IG5ldyBVaW50OEFycmF5KDYpO1xuICAgICAgICB2YXIgaW50Q2hhckNvdW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gc3RlcCBLXG4gICAgICAgICAgICBpZiAoc3RhcnRwb3MgKyBjaGFyc1Byb2Nlc3NlZCA9PT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIEFycmF5c18xLmRlZmF1bHQuZmlsbChtaW5zLCAwKTtcbiAgICAgICAgICAgICAgICBBcnJheXNfMS5kZWZhdWx0LmZpbGwoaW50Q2hhckNvdW50cywgMCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMuZmluZE1pbmltdW1zKGNoYXJDb3VudHMsIGludENoYXJDb3VudHMsIEludGVnZXJfMS5kZWZhdWx0Lk1BWF9WQUxVRSwgbWlucyk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkNvdW50ID0gdGhpcy5nZXRNaW5pbXVtQ291bnQobWlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0gPT09IG1pbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbkNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5zW2NvbnN0YW50c18xLkJBU0UyNTZfRU5DT0RBVElPTl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5zW2NvbnN0YW50c18xLkVESUZBQ1RfRU5DT0RBVElPTl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5zW2NvbnN0YW50c18xLlRFWFRfRU5DT0RBVElPTl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuVEVYVF9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5zW2NvbnN0YW50c18xLlgxMl9FTkNPREFUSU9OXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQzQwX0VOQ09EQVRJT047XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KHN0YXJ0cG9zICsgY2hhcnNQcm9jZXNzZWQpO1xuICAgICAgICAgICAgY2hhcnNQcm9jZXNzZWQrKztcbiAgICAgICAgICAgIC8vIHN0ZXAgTFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0gKz0gMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0V4dGVuZGVkQVNDSUkoYykpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dID0gTWF0aC5jZWlsKGNoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0pO1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0gKz0gMi4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50c1tjb25zdGFudHNfMS5BU0NJSV9FTkNPREFUSU9OXSA9IE1hdGguY2VpbChjaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dKTtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGVwIE1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmF0aXZlQzQwKGMpKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50c1tjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTl0gKz0gMi4wIC8gMy4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0V4dGVuZGVkQVNDSUkoYykpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSArPSA4LjAgLyAzLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSArPSA0LjAgLyAzLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGVwIE5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmF0aXZlVGV4dChjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuVEVYVF9FTkNPREFUSU9OXSArPSAyLjAgLyAzLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzRXh0ZW5kZWRBU0NJSShjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuVEVYVF9FTkNPREFUSU9OXSArPSA4LjAgLyAzLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLlRFWFRfRU5DT0RBVElPTl0gKz0gNC4wIC8gMy4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RlcCBPXG4gICAgICAgICAgICBpZiAodGhpcy5pc05hdGl2ZVgxMihjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuWDEyX0VOQ09EQVRJT05dICs9IDIuMCAvIDMuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFeHRlbmRlZEFTQ0lJKGMpKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50c1tjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTl0gKz0gMTMuMCAvIDMuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuWDEyX0VOQ09EQVRJT05dICs9IDEwLjAgLyAzLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGVwIFBcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmF0aXZlRURJRkFDVChjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OXSArPSAzLjAgLyA0LjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzRXh0ZW5kZWRBU0NJSShjKSkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudHNbY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OXSArPSAxNy4wIC8gNC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50c1tjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT05dICs9IDEzLjAgLyA0LjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGVwIFFcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3BlY2lhbEIyNTYoYykpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRzW2NvbnN0YW50c18xLkJBU0UyNTZfRU5DT0RBVElPTl0gKz0gNC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50c1tjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT05dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGVwIFJcbiAgICAgICAgICAgIGlmIChjaGFyc1Byb2Nlc3NlZCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgQXJyYXlzXzEuZGVmYXVsdC5maWxsKG1pbnMsIDApO1xuICAgICAgICAgICAgICAgIEFycmF5c18xLmRlZmF1bHQuZmlsbChpbnRDaGFyQ291bnRzLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRNaW5pbXVtcyhjaGFyQ291bnRzLCBpbnRDaGFyQ291bnRzLCBJbnRlZ2VyXzEuZGVmYXVsdC5NQVhfVkFMVUUsIG1pbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dIDxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4oaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLlgxMl9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT05dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OXSA8IGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0gfHxcbiAgICAgICAgICAgICAgICAgICAgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT05dICsgMSA8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbihpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLlgxMl9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT05dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT05dICsgMSA8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluKGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTl0sIGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuVEVYVF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTl0sIGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLlRFWFRfRU5DT0RBVElPTl0gKyAxIDxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW4oaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5CQVNFMjU2X0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5FRElGQUNUX0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLlgxMl9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5BU0NJSV9FTkNPREFUSU9OXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLlRFWFRfRU5DT0RBVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuWDEyX0VOQ09EQVRJT05dICsgMSA8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluKGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuQkFTRTI1Nl9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTl0sIGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuWDEyX0VOQ09EQVRJT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSArIDEgPFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbihpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkFTQ0lJX0VOQ09EQVRJT05dLCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkJBU0UyNTZfRU5DT0RBVElPTl0sIGludENoYXJDb3VudHNbY29uc3RhbnRzXzEuRURJRkFDVF9FTkNPREFUSU9OXSwgaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT05dKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5DNDBfRU5DT0RBVElPTl0gPCBpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLlgxMl9FTkNPREFUSU9OXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRDaGFyQ291bnRzW2NvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OXSA9PT0gaW50Q2hhckNvdW50c1tjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gc3RhcnRwb3MgKyBjaGFyc1Byb2Nlc3NlZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA8IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGMgPSBtc2cuY2hhckNvZGVBdChwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1gxMlRlcm1TZXAodGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTmF0aXZlWDEyKHRjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkM0MF9FTkNPREFUSU9OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLm1pbiA9IGZ1bmN0aW9uIChmMSwgZjIsIGYzLCBmNCwgZjUpIHtcbiAgICAgICAgdmFyIHZhbCA9IE1hdGgubWluKGYxLCBNYXRoLm1pbihmMiwgTWF0aC5taW4oZjMsIGY0KSkpO1xuICAgICAgICBpZiAoZjUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2YWwsIGY1KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5maW5kTWluaW11bXMgPSBmdW5jdGlvbiAoY2hhckNvdW50cywgaW50Q2hhckNvdW50cywgbWluLCBtaW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IChpbnRDaGFyQ291bnRzW2ldID0gTWF0aC5jZWlsKGNoYXJDb3VudHNbaV0pKTtcbiAgICAgICAgICAgIGlmIChtaW4gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBBcnJheXNfMS5kZWZhdWx0LmZpbGwobWlucywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluc1tpXSA9IG1pbnNbaV0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLmdldE1pbmltdW1Db3VudCA9IGZ1bmN0aW9uIChtaW5zKSB7XG4gICAgICAgIHZhciBtaW5Db3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBtaW5Db3VudCArPSBtaW5zW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5Db3VudCB8fCAwO1xuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5pc0RpZ2l0ID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAnOScuY2hhckNvZGVBdCgwKTtcbiAgICB9O1xuICAgIEhpZ2hMZXZlbEVuY29kZXIuaXNFeHRlbmRlZEFTQ0lJID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAxMjggJiYgY2ggPD0gMjU1O1xuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5pc05hdGl2ZUM0MCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnICcuY2hhckNvZGVBdCgwKSB8fFxuICAgICAgICAgICAgKGNoID49ICcwJy5jaGFyQ29kZUF0KDApICYmIGNoIDw9ICc5Jy5jaGFyQ29kZUF0KDApKSB8fFxuICAgICAgICAgICAgKGNoID49ICdBJy5jaGFyQ29kZUF0KDApICYmIGNoIDw9ICdaJy5jaGFyQ29kZUF0KDApKSk7XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLmlzTmF0aXZlVGV4dCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnICcuY2hhckNvZGVBdCgwKSB8fFxuICAgICAgICAgICAgKGNoID49ICcwJy5jaGFyQ29kZUF0KDApICYmIGNoIDw9ICc5Jy5jaGFyQ29kZUF0KDApKSB8fFxuICAgICAgICAgICAgKGNoID49ICdhJy5jaGFyQ29kZUF0KDApICYmIGNoIDw9ICd6Jy5jaGFyQ29kZUF0KDApKSk7XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLmlzTmF0aXZlWDEyID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc1gxMlRlcm1TZXAoY2gpIHx8XG4gICAgICAgICAgICBjaCA9PT0gJyAnLmNoYXJDb2RlQXQoMCkgfHxcbiAgICAgICAgICAgIChjaCA+PSAnMCcuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAnOScuY2hhckNvZGVBdCgwKSkgfHxcbiAgICAgICAgICAgIChjaCA+PSAnQScuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAnWicuY2hhckNvZGVBdCgwKSkpO1xuICAgIH07XG4gICAgSGlnaExldmVsRW5jb2Rlci5pc1gxMlRlcm1TZXAgPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMTMgfHwgLy8gQ1JcbiAgICAgICAgICAgIGNoID09PSAnKicuY2hhckNvZGVBdCgwKSB8fFxuICAgICAgICAgICAgY2ggPT09ICc+Jy5jaGFyQ29kZUF0KDApKTtcbiAgICB9O1xuICAgIEhpZ2hMZXZlbEVuY29kZXIuaXNOYXRpdmVFRElGQUNUID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAnICcuY2hhckNvZGVBdCgwKSAmJiBjaCA8PSAnXicuY2hhckNvZGVBdCgwKTtcbiAgICB9O1xuICAgIEhpZ2hMZXZlbEVuY29kZXIuaXNTcGVjaWFsQjI1NiA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRPRE8gTk9UIElNUExFTUVOVEVEIFlFVCEhIVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGNoYXJhY3RlcnMgdGhhdCBhcmUgZW5jb2RhYmxlIHVzaW5nIG51bWVyaWMgY29tcGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgICAgICB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBzdGFydHBvcyB0aGUgc3RhcnQgcG9zaXRpb24gd2l0aGluIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB0aGUgcmVxdWVzdGVkIGNoYXJhY3RlciBjb3VudFxuICAgICAqL1xuICAgIEhpZ2hMZXZlbEVuY29kZXIuZGV0ZXJtaW5lQ29uc2VjdXRpdmVEaWdpdENvdW50ID0gZnVuY3Rpb24gKG1zZywgc3RhcnRwb3MpIHtcbiAgICAgICAgaWYgKHN0YXJ0cG9zID09PSB2b2lkIDApIHsgc3RhcnRwb3MgPSAwOyB9XG4gICAgICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gc3RhcnRwb3M7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4gJiYgdGhpcy5pc0RpZ2l0KG1zZy5jaGFyQ29kZUF0KGlkeCkpKSB7XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4IC0gc3RhcnRwb3M7XG4gICAgfTtcbiAgICBIaWdoTGV2ZWxFbmNvZGVyLmlsbGVnYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgICAgIHZhciBoZXggPSBJbnRlZ2VyXzEuZGVmYXVsdC50b0hleFN0cmluZyhzaW5nbGVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIGhleCA9ICcwMDAwJy5zdWJzdHJpbmcoMCwgNCAtIGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyOiAnICsgc2luZ2xlQ2hhcmFjdGVyICsgJyAoMHgnICsgaGV4ICsgJyknKTtcbiAgICB9O1xuICAgIHJldHVybiBIaWdoTGV2ZWxFbmNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhpZ2hMZXZlbEVuY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MinimalEncoder = void 0;\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar MinimalECIInput_1 = __webpack_require__(/*! ../../common/MinimalECIInput */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar Mode;\n(function (Mode) {\n    Mode[Mode[\"ASCII\"] = 0] = \"ASCII\";\n    Mode[Mode[\"C40\"] = 1] = \"C40\";\n    Mode[Mode[\"TEXT\"] = 2] = \"TEXT\";\n    Mode[Mode[\"X12\"] = 3] = \"X12\";\n    Mode[Mode[\"EDF\"] = 4] = \"EDF\";\n    Mode[Mode[\"B256\"] = 5] = \"B256\";\n})(Mode || (Mode = {}));\nvar C40_SHIFT2_CHARS = [\n    '!',\n    '\"',\n    '#',\n    '$',\n    '%',\n    '&',\n    \"'\",\n    '(',\n    ')',\n    '*',\n    '+',\n    ',',\n    '-',\n    '.',\n    '/',\n    ':',\n    ';',\n    '<',\n    '=',\n    '>',\n    '?',\n    '@',\n    '[',\n    '\\\\',\n    ']',\n    '^',\n    '_',\n];\nvar MinimalEncoder = /** @class */ (function () {\n    function MinimalEncoder() {\n    }\n    MinimalEncoder.isExtendedASCII = function (ch, fnc1) {\n        return ch !== fnc1 && ch >= 128 && ch <= 255;\n    };\n    MinimalEncoder.isInC40Shift1Set = function (ch) {\n        return ch <= 31;\n    };\n    MinimalEncoder.isInC40Shift2Set = function (ch, fnc1) {\n        var e_1, _a;\n        try {\n            for (var C40_SHIFT2_CHARS_1 = __values(C40_SHIFT2_CHARS), C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next(); !C40_SHIFT2_CHARS_1_1.done; C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next()) {\n                var c40Shift2Char = C40_SHIFT2_CHARS_1_1.value;\n                if (c40Shift2Char.charCodeAt(0) === ch) {\n                    return true;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (C40_SHIFT2_CHARS_1_1 && !C40_SHIFT2_CHARS_1_1.done && (_a = C40_SHIFT2_CHARS_1.return)) _a.call(C40_SHIFT2_CHARS_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return ch === fnc1;\n    };\n    MinimalEncoder.isInTextShift1Set = function (ch) {\n        return this.isInC40Shift1Set(ch);\n    };\n    MinimalEncoder.isInTextShift2Set = function (ch, fnc1) {\n        return this.isInC40Shift2Set(ch, fnc1);\n    };\n    /**\n     * Performs message encoding of a DataMatrix message\n     *\n     * @param msg the message\n     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n     *   charset to encode any character in the input that can be encoded by it if the charset is among the\n     *   supported charsets.\n     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1\n     *   bar code. If the value is not -1 then a FNC1 is also prepended.\n     * @param shape requested shape.\n     * @return the encoded message (the char values range from 0 to 255)\n     */\n    MinimalEncoder.encodeHighLevel = function (msg, priorityCharset, fnc1, shape) {\n        if (priorityCharset === void 0) { priorityCharset = null; }\n        if (fnc1 === void 0) { fnc1 = -1; }\n        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }\n        var macroId = 0;\n        if (msg.startsWith(constants_1.MACRO_05_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {\n            macroId = 5;\n            msg = msg.substring(constants_1.MACRO_05_HEADER.length, msg.length - 2);\n        }\n        else if (msg.startsWith(constants_1.MACRO_06_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {\n            macroId = 6;\n            msg = msg.substring(constants_1.MACRO_06_HEADER.length, msg.length - 2);\n        }\n        return decodeURIComponent(escape(String.fromCharCode.apply(String, __spread(this.encode(msg, priorityCharset, fnc1, shape, macroId)))));\n    };\n    /**\n     * Encodes input minimally and returns an array of the codewords\n     *\n     * @param input The string to encode\n     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm\n     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority\n     *   charset to encode any character in the input that can be encoded by it if the charset is among the\n     *   supported charsets.\n     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1\n     *   bar code. If the value is not -1 then a FNC1 is also prepended.\n     * @param shape requested shape.\n     * @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.\n     * @return An array of bytes representing the codewords of a minimal encoding.\n     */\n    MinimalEncoder.encode = function (input, priorityCharset, fnc1, shape, macroId) {\n        return this.encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();\n    };\n    MinimalEncoder.addEdge = function (edges, edge) {\n        var vertexIndex = edge.fromPosition + edge.characterLength;\n        if (edges[vertexIndex][edge.getEndMode()] === null ||\n            edges[vertexIndex][edge.getEndMode()].cachedTotalSize >\n                edge.cachedTotalSize) {\n            edges[vertexIndex][edge.getEndMode()] = edge;\n        }\n    };\n    /** @return the number of words in which the string starting at from can be encoded in c40 or text mode.\n     *  The number of characters encoded is returned in characterLength.\n     *  The number of characters encoded is also minimal in the sense that the algorithm stops as soon\n     *  as a character encoding fills a C40 word competely (three C40 values). An exception is at the\n     *  end of the string where two C40 values are allowed (according to the spec the third c40 value\n     *  is filled  with 0 (Shift 1) in this case).\n     */\n    MinimalEncoder.getNumberOfC40Words = function (input, from, c40, characterLength) {\n        var thirdsCount = 0;\n        for (var i = from; i < input.length(); i++) {\n            if (input.isECI(i)) {\n                characterLength[0] = 0;\n                return 0;\n            }\n            var ci = input.charAt(i);\n            if ((c40 && HighLevelEncoder_1.default.isNativeC40(ci)) ||\n                (!c40 && HighLevelEncoder_1.default.isNativeText(ci))) {\n                thirdsCount++; // native\n            }\n            else if (!MinimalEncoder.isExtendedASCII(ci, input.getFNC1Character())) {\n                thirdsCount += 2; // shift\n            }\n            else {\n                var asciiValue = ci & 0xff;\n                if (asciiValue >= 128 &&\n                    ((c40 && HighLevelEncoder_1.default.isNativeC40(asciiValue - 128)) ||\n                        (!c40 && HighLevelEncoder_1.default.isNativeText(asciiValue - 128)))) {\n                    thirdsCount += 3; // shift, Upper shift\n                }\n                else {\n                    thirdsCount += 4; // shift, Upper shift, shift\n                }\n            }\n            if (thirdsCount % 3 === 0 ||\n                ((thirdsCount - 2) % 3 === 0 && i + 1 === input.length())) {\n                characterLength[0] = i - from + 1;\n                return Math.ceil(thirdsCount / 3.0);\n            }\n        }\n        characterLength[0] = 0;\n        return 0;\n    };\n    MinimalEncoder.addEdges = function (input, edges, from, previous) {\n        var e_2, _a;\n        if (input.isECI(from)) {\n            this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));\n            return;\n        }\n        var ch = input.charAt(from);\n        if (previous === null || previous.getEndMode() !== Mode.EDF) {\n            // not possible to unlatch a full EDF edge to something\n            // else\n            if (HighLevelEncoder_1.default.isDigit(ch) &&\n                input.haveNCharacters(from, 2) &&\n                HighLevelEncoder_1.default.isDigit(input.charAt(from + 1))) {\n                // two digits ASCII encoded\n                this.addEdge(edges, new Edge(input, Mode.ASCII, from, 2, previous));\n            }\n            else {\n                // one ASCII encoded character or an extended character via Upper Shift\n                this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));\n            }\n            var modes = [Mode.C40, Mode.TEXT];\n            try {\n                for (var modes_1 = __values(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {\n                    var mode = modes_1_1.value;\n                    var characterLength = [];\n                    if (MinimalEncoder.getNumberOfC40Words(input, from, mode === Mode.C40, characterLength) > 0) {\n                        this.addEdge(edges, new Edge(input, mode, from, characterLength[0], previous));\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (modes_1_1 && !modes_1_1.done && (_a = modes_1.return)) _a.call(modes_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            if (input.haveNCharacters(from, 3) &&\n                HighLevelEncoder_1.default.isNativeX12(input.charAt(from)) &&\n                HighLevelEncoder_1.default.isNativeX12(input.charAt(from + 1)) &&\n                HighLevelEncoder_1.default.isNativeX12(input.charAt(from + 2))) {\n                this.addEdge(edges, new Edge(input, Mode.X12, from, 3, previous));\n            }\n            this.addEdge(edges, new Edge(input, Mode.B256, from, 1, previous));\n        }\n        // We create 4 EDF edges,  with 1, 2 3 or 4 characters length. The fourth normally doesn't have a latch to ASCII\n        // unless it is 2 characters away from the end of the input.\n        var i;\n        for (i = 0; i < 3; i++) {\n            var pos = from + i;\n            if (input.haveNCharacters(pos, 1) &&\n                HighLevelEncoder_1.default.isNativeEDIFACT(input.charAt(pos))) {\n                this.addEdge(edges, new Edge(input, Mode.EDF, from, i + 1, previous));\n            }\n            else {\n                break;\n            }\n        }\n        if (i === 3 &&\n            input.haveNCharacters(from, 4) &&\n            HighLevelEncoder_1.default.isNativeEDIFACT(input.charAt(from + 3))) {\n            this.addEdge(edges, new Edge(input, Mode.EDF, from, 4, previous));\n        }\n    };\n    MinimalEncoder.encodeMinimally = function (input) {\n        /* The minimal encoding is computed by Dijkstra. The acyclic graph is modeled as follows:\n         * A vertex represents a combination of a position in the input and an encoding mode where position 0\n         * denotes the position left of the first character, 1 the position left of the second character and so on.\n         * Likewise the end vertices are located after the last character at position input.length().\n         * For any position there might be up to six vertices, one for each of the encoding types ASCII, C40, TEXT, X12,\n         * EDF and B256.\n         *\n         * As an example consider the input string \"ABC123\" then at position 0 there is only one vertex with the default\n         * ASCII encodation. At position 3 there might be vertices for the types ASCII, C40, X12, EDF and B256.\n         *\n         * An edge leading to such a vertex encodes one or more of the characters left of the position that the vertex\n         * represents. It encodes the characters in the encoding mode of the vertex that it ends on. In other words,\n         * all edges leading to a particular vertex encode the same characters (the length of the suffix can vary) using the same\n         * encoding mode.\n         * As an example consider the input string \"ABC123\" and the vertex (4,EDF). Possible edges leading to this vertex\n         * are:\n         *   (0,ASCII)  --EDF(ABC1)--> (4,EDF)\n         *   (1,ASCII)  --EDF(BC1)-->  (4,EDF)\n         *   (1,B256)   --EDF(BC1)-->  (4,EDF)\n         *   (1,EDF)    --EDF(BC1)-->  (4,EDF)\n         *   (2,ASCII)  --EDF(C1)-->   (4,EDF)\n         *   (2,B256)   --EDF(C1)-->   (4,EDF)\n         *   (2,EDF)    --EDF(C1)-->   (4,EDF)\n         *   (3,ASCII)  --EDF(1)-->    (4,EDF)\n         *   (3,B256)   --EDF(1)-->    (4,EDF)\n         *   (3,EDF)    --EDF(1)-->    (4,EDF)\n         *   (3,C40)    --EDF(1)-->    (4,EDF)\n         *   (3,X12)    --EDF(1)-->    (4,EDF)\n         *\n         * The edges leading to a vertex are stored in such a way that there is a fast way to enumerate the edges ending\n         * on a particular vertex.\n         *\n         * The algorithm processes the vertices in order of their position thereby performing the following:\n         *\n         * For every vertex at position i the algorithm enumerates the edges ending on the vertex and removes all but the\n         * shortest from that list.\n         * Then it processes the vertices for the position i+1. If i+1 == input.length() then the algorithm ends\n         * and chooses the the edge with the smallest size from any of the edges leading to vertices at this position.\n         * Otherwise the algorithm computes all possible outgoing edges for the vertices at the position i+1\n         *\n         * Examples:\n         * The process is illustrated by showing the graph (edges) after each iteration from left to right over the input:\n         * An edge is drawn as follows \"(\" + fromVertex + \") -- \" + encodingMode + \"(\" + encodedInput + \") (\" +\n         * accumulatedSize + \") --> (\" + toVertex + \")\"\n         *\n         * Example 1 encoding the string \"ABCDEFG\":\n         *\n         *\n         * Situation after adding edges to the start vertex (0,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n         * (0,ASCII) C40(ABC) (3) --> (3,C40)\n         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n         * (0,ASCII) X12(ABC) (3) --> (3,X12)\n         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n         *\n         * Situation after adding edges to vertices at position 1\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n         * (0,ASCII) C40(ABC) (3) --> (3,C40)\n         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n         * (0,ASCII) X12(ABC) (3) --> (3,X12)\n         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) B256(B) (4) --> (2,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) ASCII(B) (4) --> (2,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)\n         * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)\n         * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)\n         *\n         * Edge \"(1,ASCII) ASCII(B) (2) --> (2,ASCII)\" is minimal for the vertex (2,ASCII) so that edge \"(1,B256) ASCII(B) (4) --> (2,ASCII)\" is removed.\n         * Edge \"(1,B256) B256(B) (3) --> (2,B256)\" is minimal for the vertext (2,B256) so that the edge \"(1,ASCII) B256(B) (4) --> (2,B256)\" is removed.\n         *\n         * Situation after adding edges to vertices at position 2\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n         * (0,ASCII) C40(ABC) (3) --> (3,C40)\n         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n         * (0,ASCII) X12(ABC) (3) --> (3,X12)\n         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)\n         * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)\n         * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) ASCII(C) (5) --> (3,ASCII)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) B256(C) (6) --> (3,B256)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CD) (7) --> (4,EDF)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) C40(CDE) (6) --> (5,C40)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) TEXT(CDE) (8) --> (5,TEXT)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) X12(CDE) (6) --> (5,X12)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDE) (7) --> (5,EDF)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDEF) (7) --> (6,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) B256(C) (5) --> (3,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CD) (6) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDE) (6) --> (5,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) ASCII(C) (4) --> (3,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CD) (6) --> (4,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) C40(CDE) (5) --> (5,C40)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) TEXT(CDE) (7) --> (5,TEXT)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) X12(CDE) (5) --> (5,X12)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDE) (6) --> (5,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDEF) (6) --> (6,EDF)\n         *\n         * Edge \"(2,ASCII) ASCII(C) (3) --> (3,ASCII)\" is minimal for the vertex (3,ASCII) so that edges \"(2,EDF) ASCII(C) (5) --> (3,ASCII)\"\n         * and \"(2,B256) ASCII(C) (4) --> (3,ASCII)\" can be removed.\n         * Edge \"(0,ASCII) EDF(ABC) (4) --> (3,EDF)\" is minimal for the vertex (3,EDF) so that edges \"(1,ASCII) EDF(BC) (5) --> (3,EDF)\"\n         * and \"(1,B256) EDF(BC) (6) --> (3,EDF)\" can be removed.\n         * Edge \"(2,B256) B256(C) (4) --> (3,B256)\" is minimal for the vertex (3,B256) so that edges \"(2,ASCII) B256(C) (5) --> (3,B256)\"\n         * and \"(2,EDF) B256(C) (6) --> (3,B256)\" can be removed.\n         *\n         * This continues for vertices 3 thru 7\n         *\n         * Situation after adding edges to vertices at position 7\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256)\n         * (0,ASCII) EDF(AB) (4) --> (2,EDF)\n         * (0,ASCII) C40(ABC) (3) --> (3,C40)\n         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)\n         * (0,ASCII) X12(ABC) (3) --> (3,X12)\n         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)\n         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)\n         * (0,ASCII) C40(ABC) (3) --> (3,C40) C40(DEF) (5) --> (6,C40)\n         * (0,ASCII) X12(ABC) (3) --> (3,X12) X12(DEF) (5) --> (6,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40) C40(EFG) (6) --> (7,C40)    //Solution 1\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12) X12(EFG) (6) --> (7,X12)    //Solution 2\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) TEXT(DEF) (8) --> (6,TEXT)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) EDF(DEFG) (7) --> (7,EDF)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) TEXT(EFG) (9) --> (7,TEXT)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256)\n         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII) ASCII(G) (7) --> (7,ASCII)\n         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256) B256(G) (8) --> (7,B256)\n         *\n         * Hence a minimal encoding of \"ABCDEFG\" is either ASCII(A),C40(BCDEFG) or ASCII(A), X12(BCDEFG) with a size of 5 bytes.\n         */\n        var inputLength = input.length();\n        // Array that represents vertices. There is a vertex for every character and mode.\n        // The last dimension in the array below encodes the 6 modes ASCII, C40, TEXT, X12, EDF and B256\n        var edges = Array(inputLength + 1)\n            .fill(null)\n            .map(function () { return Array(6).fill(0); });\n        this.addEdges(input, edges, 0, null);\n        for (var i = 1; i <= inputLength; i++) {\n            for (var j = 0; j < 6; j++) {\n                if (edges[i][j] !== null && i < inputLength) {\n                    this.addEdges(input, edges, i, edges[i][j]);\n                }\n            }\n            // optimize memory by removing edges that have been passed.\n            for (var j = 0; j < 6; j++) {\n                edges[i - 1][j] = null;\n            }\n        }\n        var minimalJ = -1;\n        var minimalSize = Integer_1.default.MAX_VALUE;\n        for (var j = 0; j < 6; j++) {\n            if (edges[inputLength][j] !== null) {\n                var edge = edges[inputLength][j];\n                var size = j >= 1 && j <= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize; // C40, TEXT and X12 need an\n                // extra unlatch at the end\n                if (size < minimalSize) {\n                    minimalSize = size;\n                    minimalJ = j;\n                }\n            }\n        }\n        if (minimalJ < 0) {\n            throw new Error('Failed to encode \"' + input + '\"');\n        }\n        return new Result(edges[inputLength][minimalJ]);\n    };\n    return MinimalEncoder;\n}());\nexports.MinimalEncoder = MinimalEncoder;\nvar Result = /** @class */ (function () {\n    function Result(solution) {\n        var input = solution.input;\n        var size = 0;\n        var bytesAL = [];\n        var randomizePostfixLength = [];\n        var randomizeLengths = [];\n        if ((solution.mode === Mode.C40 ||\n            solution.mode === Mode.TEXT ||\n            solution.mode === Mode.X12) &&\n            solution.getEndMode() !== Mode.ASCII) {\n            size += this.prepend(Edge.getBytes(254), bytesAL);\n        }\n        var current = solution;\n        while (current !== null) {\n            size += this.prepend(current.getDataBytes(), bytesAL);\n            if (current.previous === null ||\n                current.getPreviousStartMode() !== current.getMode()) {\n                if (current.getMode() === Mode.B256) {\n                    if (size <= 249) {\n                        bytesAL.unshift(size);\n                        size++;\n                    }\n                    else {\n                        bytesAL.unshift(size % 250);\n                        bytesAL.unshift(size / 250 + 249);\n                        size += 2;\n                    }\n                    randomizePostfixLength.push(bytesAL.length);\n                    randomizeLengths.push(size);\n                }\n                this.prepend(current.getLatchBytes(), bytesAL);\n                size = 0;\n            }\n            current = current.previous;\n        }\n        if (input.getMacroId() === 5) {\n            size += this.prepend(Edge.getBytes(236), bytesAL);\n        }\n        else if (input.getMacroId() === 6) {\n            size += this.prepend(Edge.getBytes(237), bytesAL);\n        }\n        if (input.getFNC1Character() > 0) {\n            size += this.prepend(Edge.getBytes(232), bytesAL);\n        }\n        for (var i = 0; i < randomizePostfixLength.length; i++) {\n            this.applyRandomPattern(bytesAL, bytesAL.length - randomizePostfixLength[i], randomizeLengths[i]);\n        }\n        // add padding\n        var capacity = solution.getMinSymbolSize(bytesAL.length);\n        if (bytesAL.length < capacity) {\n            bytesAL.push(129);\n        }\n        while (bytesAL.length < capacity) {\n            bytesAL.push(this.randomize253State(bytesAL.length + 1));\n        }\n        this.bytes = new Uint8Array(bytesAL.length);\n        for (var i = 0; i < this.bytes.length; i++) {\n            this.bytes[i] = bytesAL[i];\n        }\n    }\n    Result.prototype.prepend = function (bytes, into) {\n        for (var i = bytes.length - 1; i >= 0; i--) {\n            into.unshift(bytes[i]);\n        }\n        return bytes.length;\n    };\n    Result.prototype.randomize253State = function (codewordPosition) {\n        var pseudoRandom = ((149 * codewordPosition) % 253) + 1;\n        var tempVariable = 129 + pseudoRandom;\n        return tempVariable <= 254 ? tempVariable : tempVariable - 254;\n    };\n    Result.prototype.applyRandomPattern = function (bytesAL, startPosition, length) {\n        for (var i = 0; i < length; i++) {\n            // See \"B.1 253-state algorithm\n            var Pad_codeword_position = startPosition + i;\n            var Pad_codeword_value = bytesAL[Pad_codeword_position] & 0xff;\n            var pseudo_random_number = ((149 * (Pad_codeword_position + 1)) % 255) + 1;\n            var temp_variable = Pad_codeword_value + pseudo_random_number;\n            bytesAL[Pad_codeword_position] =\n                temp_variable <= 255 ? temp_variable : temp_variable - 256;\n        }\n    };\n    Result.prototype.getBytes = function () {\n        return this.bytes;\n    };\n    return Result;\n}());\nvar Edge = /** @class */ (function () {\n    function Edge(input, mode, fromPosition, characterLength, previous) {\n        this.input = input;\n        this.mode = mode;\n        this.fromPosition = fromPosition;\n        this.characterLength = characterLength;\n        this.previous = previous;\n        this.allCodewordCapacities = [\n            3, 5, 8, 10, 12, 16, 18, 22, 30, 32, 36, 44, 49, 62, 86, 114, 144, 174, 204,\n            280, 368, 456, 576, 696, 816, 1050, 1304, 1558,\n        ];\n        this.squareCodewordCapacities = [\n            3, 5, 8, 12, 18, 22, 30, 36, 44, 62, 86, 114, 144, 174, 204, 280, 368, 456,\n            576, 696, 816, 1050, 1304, 1558,\n        ];\n        this.rectangularCodewordCapacities = [5, 10, 16, 33, 32, 49];\n        if (!(fromPosition + characterLength <= input.length())) {\n            throw new Error('Invalid edge');\n        }\n        var size = previous !== null ? previous.cachedTotalSize : 0;\n        var previousMode = this.getPreviousMode();\n        /*\n         * Switching modes\n         * ASCII -> C40: latch 230\n         * ASCII -> TEXT: latch 239\n         * ASCII -> X12: latch 238\n         * ASCII -> EDF: latch 240\n         * ASCII -> B256: latch 231\n         * C40 -> ASCII: word(c1,c2,c3), 254\n         * TEXT -> ASCII: word(c1,c2,c3), 254\n         * X12 -> ASCII: word(c1,c2,c3), 254\n         * EDIFACT -> ASCII: Unlatch character,0,0,0 or c1,Unlatch character,0,0 or c1,c2,Unlatch character,0 or\n         * c1,c2,c3,Unlatch character\n         * B256 -> ASCII: without latch after n bytes\n         */\n        switch (mode) {\n            case Mode.ASCII:\n                size++;\n                if (input.isECI(fromPosition) ||\n                    MinimalEncoder.isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {\n                    size++;\n                }\n                if (previousMode === Mode.C40 ||\n                    previousMode === Mode.TEXT ||\n                    previousMode === Mode.X12) {\n                    size++; // unlatch 254 to ASCII\n                }\n                break;\n            case Mode.B256:\n                size++;\n                if (previousMode !== Mode.B256) {\n                    size++; // byte count\n                }\n                else if (this.getB256Size() === 250) {\n                    size++; // extra byte count\n                }\n                if (previousMode === Mode.ASCII) {\n                    size++; // latch to B256\n                }\n                else if (previousMode === Mode.C40 ||\n                    previousMode === Mode.TEXT ||\n                    previousMode === Mode.X12) {\n                    size += 2; // unlatch to ASCII, latch to B256\n                }\n                break;\n            case Mode.C40:\n            case Mode.TEXT:\n            case Mode.X12:\n                if (mode === Mode.X12) {\n                    size += 2;\n                }\n                else {\n                    var charLen = [];\n                    size +=\n                        MinimalEncoder.getNumberOfC40Words(input, fromPosition, mode === Mode.C40, charLen) * 2;\n                }\n                if (previousMode === Mode.ASCII || previousMode === Mode.B256) {\n                    size++; // additional byte for latch from ASCII to this mode\n                }\n                else if (previousMode !== mode &&\n                    (previousMode === Mode.C40 ||\n                        previousMode === Mode.TEXT ||\n                        previousMode === Mode.X12)) {\n                    size += 2; // unlatch 254 to ASCII followed by latch to this mode\n                }\n                break;\n            case Mode.EDF:\n                size += 3;\n                if (previousMode === Mode.ASCII || previousMode === Mode.B256) {\n                    size++; // additional byte for latch from ASCII to this mode\n                }\n                else if (previousMode === Mode.C40 ||\n                    previousMode === Mode.TEXT ||\n                    previousMode === Mode.X12) {\n                    size += 2; // unlatch 254 to ASCII followed by latch to this mode\n                }\n                break;\n        }\n        this.cachedTotalSize = size;\n    }\n    // does not count beyond 250\n    Edge.prototype.getB256Size = function () {\n        var cnt = 0;\n        var current = this;\n        while (current !== null && current.mode === Mode.B256 && cnt <= 250) {\n            cnt++;\n            current = current.previous;\n        }\n        return cnt;\n    };\n    Edge.prototype.getPreviousStartMode = function () {\n        return this.previous === null ? Mode.ASCII : this.previous.mode;\n    };\n    Edge.prototype.getPreviousMode = function () {\n        return this.previous === null ? Mode.ASCII : this.previous.getEndMode();\n    };\n    /** Returns Mode.ASCII in case that:\n     *  - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2\n     *    ASCII bytes.\n     *  - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.\n     *  Returns mode in all other cases.\n     * */\n    Edge.prototype.getEndMode = function () {\n        if (this.mode === Mode.EDF) {\n            if (this.characterLength < 4) {\n                return Mode.ASCII;\n            }\n            var lastASCII = this.getLastASCII(); // see 5.2.8.2 EDIFACT encodation Rules\n            if (lastASCII > 0 &&\n                this.getCodewordsRemaining(this.cachedTotalSize + lastASCII) <=\n                    2 - lastASCII) {\n                return Mode.ASCII;\n            }\n        }\n        if (this.mode === Mode.C40 ||\n            this.mode === Mode.TEXT ||\n            this.mode === Mode.X12) {\n            // see 5.2.5.2 C40 encodation rules and 5.2.7.2 ANSI X12 encodation rules\n            if (this.fromPosition + this.characterLength >= this.input.length() &&\n                this.getCodewordsRemaining(this.cachedTotalSize) === 0) {\n                return Mode.ASCII;\n            }\n            var lastASCII = this.getLastASCII();\n            if (lastASCII === 1 &&\n                this.getCodewordsRemaining(this.cachedTotalSize + 1) === 0) {\n                return Mode.ASCII;\n            }\n        }\n        return this.mode;\n    };\n    Edge.prototype.getMode = function () {\n        return this.mode;\n    };\n    /** Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly\n     *  two consecutive digits and a non extended character or of 4 digits.\n     *  Returns 0 in any other case\n     **/\n    Edge.prototype.getLastASCII = function () {\n        var length = this.input.length();\n        var from = this.fromPosition + this.characterLength;\n        if (length - from > 4 || from >= length) {\n            return 0;\n        }\n        if (length - from === 1) {\n            if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {\n                return 0;\n            }\n            return 1;\n        }\n        if (length - from === 2) {\n            if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character()) ||\n                MinimalEncoder.isExtendedASCII(this.input.charAt(from + 1), this.input.getFNC1Character())) {\n                return 0;\n            }\n            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&\n                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1))) {\n                return 1;\n            }\n            return 2;\n        }\n        if (length - from === 3) {\n            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&\n                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&\n                !MinimalEncoder.isExtendedASCII(this.input.charAt(from + 2), this.input.getFNC1Character())) {\n                return 2;\n            }\n            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&\n                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 2)) &&\n                !MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {\n                return 2;\n            }\n            return 0;\n        }\n        if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&\n            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&\n            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 2)) &&\n            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 3))) {\n            return 2;\n        }\n        return 0;\n    };\n    /** Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal\n     * number of codewords.\n     **/\n    Edge.prototype.getMinSymbolSize = function (minimum) {\n        var e_3, _a, e_4, _b, e_5, _c;\n        switch (this.input.getShapeHint()) {\n            case 1 /* FORCE_SQUARE */:\n                try {\n                    for (var _d = __values(this.squareCodewordCapacities), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var capacity = _e.value;\n                        if (capacity >= minimum) {\n                            return capacity;\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n                break;\n            case 2 /* FORCE_RECTANGLE */:\n                try {\n                    for (var _f = __values(this.rectangularCodewordCapacities), _g = _f.next(); !_g.done; _g = _f.next()) {\n                        var capacity = _g.value;\n                        if (capacity >= minimum) {\n                            return capacity;\n                        }\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n                break;\n        }\n        try {\n            for (var _h = __values(this.allCodewordCapacities), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var capacity = _j.value;\n                if (capacity >= minimum) {\n                    return capacity;\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        return this.allCodewordCapacities[this.allCodewordCapacities.length - 1];\n    };\n    /** Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given\n     * minimal number of codewords.\n     **/\n    Edge.prototype.getCodewordsRemaining = function (minimum) {\n        return this.getMinSymbolSize(minimum) - minimum;\n    };\n    Edge.getBytes = function (c1, c2) {\n        var result = new Uint8Array(c2 ? 2 : 1);\n        result[0] = c1;\n        if (c2) {\n            result[1] = c2;\n        }\n        return result;\n    };\n    Edge.prototype.setC40Word = function (bytes, offset, c1, c2, c3) {\n        var val16 = 1600 * (c1 & 0xff) + 40 * (c2 & 0xff) + (c3 & 0xff) + 1;\n        bytes[offset] = val16 / 256;\n        bytes[offset + 1] = val16 % 256;\n    };\n    Edge.prototype.getX12Value = function (c) {\n        return c === 13\n            ? 0\n            : c === 42\n                ? 1\n                : c === 62\n                    ? 2\n                    : c === 32\n                        ? 3\n                        : c >= 48 && c <= 57\n                            ? c - 44\n                            : c >= 65 && c <= 90\n                                ? c - 51\n                                : c;\n    };\n    Edge.prototype.getX12Words = function () {\n        if (!(this.characterLength % 3 === 0)) {\n            throw new Error('X12 words must be a multiple of 3');\n        }\n        var result = new Uint8Array((this.characterLength / 3) * 2);\n        for (var i = 0; i < result.length; i += 2) {\n            this.setC40Word(result, i, this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3)), this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3 + 1)), this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3 + 2)));\n        }\n        return result;\n    };\n    Edge.prototype.getShiftValue = function (c, c40, fnc1) {\n        return (c40 && MinimalEncoder.isInC40Shift1Set(c)) ||\n            (!c40 && MinimalEncoder.isInTextShift1Set(c))\n            ? 0\n            : (c40 && MinimalEncoder.isInC40Shift2Set(c, fnc1)) ||\n                (!c40 && MinimalEncoder.isInTextShift2Set(c, fnc1))\n                ? 1\n                : 2;\n    };\n    Edge.prototype.getC40Value = function (c40, setIndex, c, fnc1) {\n        if (c === fnc1) {\n            if (!(setIndex === 2)) {\n                throw new Error('FNC1 cannot be used in C40 shift 2');\n            }\n            return 27;\n        }\n        if (c40) {\n            return c <= 31\n                ? c\n                : c === 32\n                    ? 3\n                    : c <= 47\n                        ? c - 33\n                        : c <= 57\n                            ? c - 44\n                            : c <= 64\n                                ? c - 43\n                                : c <= 90\n                                    ? c - 51\n                                    : c <= 95\n                                        ? c - 69\n                                        : c <= 127\n                                            ? c - 96\n                                            : c;\n        }\n        else {\n            return c === 0\n                ? 0\n                : setIndex === 0 && c <= 3\n                    ? c - 1 // is this a bug in the spec?\n                    : setIndex === 1 && c <= 31\n                        ? c\n                        : c === 32\n                            ? 3\n                            : c >= 33 && c <= 47\n                                ? c - 33\n                                : c >= 48 && c <= 57\n                                    ? c - 44\n                                    : c >= 58 && c <= 64\n                                        ? c - 43\n                                        : c >= 65 && c <= 90\n                                            ? c - 64\n                                            : c >= 91 && c <= 95\n                                                ? c - 69\n                                                : c === 96\n                                                    ? 0\n                                                    : c >= 97 && c <= 122\n                                                        ? c - 83\n                                                        : c >= 123 && c <= 127\n                                                            ? c - 96\n                                                            : c;\n        }\n    };\n    Edge.prototype.getC40Words = function (c40, fnc1) {\n        var c40Values = [];\n        for (var i = 0; i < this.characterLength; i++) {\n            var ci = this.input.charAt(this.fromPosition + i);\n            if ((c40 && HighLevelEncoder_1.default.isNativeC40(ci)) ||\n                (!c40 && HighLevelEncoder_1.default.isNativeText(ci))) {\n                c40Values.push(this.getC40Value(c40, 0, ci, fnc1));\n            }\n            else if (!MinimalEncoder.isExtendedASCII(ci, fnc1)) {\n                var shiftValue = this.getShiftValue(ci, c40, fnc1);\n                c40Values.push(shiftValue); // Shift[123]\n                c40Values.push(this.getC40Value(c40, shiftValue, ci, fnc1));\n            }\n            else {\n                var asciiValue = (ci & 0xff) - 128;\n                if ((c40 && HighLevelEncoder_1.default.isNativeC40(asciiValue)) ||\n                    (!c40 && HighLevelEncoder_1.default.isNativeText(asciiValue))) {\n                    c40Values.push(1); // Shift 2\n                    c40Values.push(30); // Upper Shift\n                    c40Values.push(this.getC40Value(c40, 0, asciiValue, fnc1));\n                }\n                else {\n                    c40Values.push(1); // Shift 2\n                    c40Values.push(30); // Upper Shift\n                    var shiftValue = this.getShiftValue(asciiValue, c40, fnc1);\n                    c40Values.push(shiftValue); // Shift[123]\n                    c40Values.push(this.getC40Value(c40, shiftValue, asciiValue, fnc1));\n                }\n            }\n        }\n        if (c40Values.length % 3 !== 0) {\n            if (!((c40Values.length - 2) % 3 === 0 &&\n                this.fromPosition + this.characterLength === this.input.length())) {\n                throw new Error('C40 words must be a multiple of 3');\n            }\n            c40Values.push(0); // pad with 0 (Shift 1)\n        }\n        var result = new Uint8Array((c40Values.length / 3) * 2);\n        var byteIndex = 0;\n        for (var i = 0; i < c40Values.length; i += 3) {\n            this.setC40Word(result, byteIndex, c40Values[i] & 0xff, c40Values[i + 1] & 0xff, c40Values[i + 2] & 0xff);\n            byteIndex += 2;\n        }\n        return result;\n    };\n    Edge.prototype.getEDFBytes = function () {\n        var numberOfThirds = Math.ceil(this.characterLength / 4.0);\n        var result = new Uint8Array(numberOfThirds * 3);\n        var pos = this.fromPosition;\n        var endPos = Math.min(this.fromPosition + this.characterLength - 1, this.input.length() - 1);\n        for (var i = 0; i < numberOfThirds; i += 3) {\n            var edfValues = [];\n            for (var j = 0; j < 4; j++) {\n                if (pos <= endPos) {\n                    edfValues[j] = this.input.charAt(pos++) & 0x3f;\n                }\n                else {\n                    edfValues[j] = pos === endPos + 1 ? 0x1f : 0;\n                }\n            }\n            var val24 = edfValues[0] << 18;\n            val24 |= edfValues[1] << 12;\n            val24 |= edfValues[2] << 6;\n            val24 |= edfValues[3];\n            result[i] = (val24 >> 16) & 0xff;\n            result[i + 1] = (val24 >> 8) & 0xff;\n            result[i + 2] = val24 & 0xff;\n        }\n        return result;\n    };\n    Edge.prototype.getLatchBytes = function () {\n        switch (this.getPreviousMode()) {\n            case Mode.ASCII:\n            case Mode.B256: // after B256 ends (via length) we are back to ASCII\n                switch (this.mode) {\n                    case Mode.B256:\n                        return Edge.getBytes(231);\n                    case Mode.C40:\n                        return Edge.getBytes(230);\n                    case Mode.TEXT:\n                        return Edge.getBytes(239);\n                    case Mode.X12:\n                        return Edge.getBytes(238);\n                    case Mode.EDF:\n                        return Edge.getBytes(240);\n                }\n                break;\n            case Mode.C40:\n            case Mode.TEXT:\n            case Mode.X12:\n                if (this.mode !== this.getPreviousMode()) {\n                    switch (this.mode) {\n                        case Mode.ASCII:\n                            return Edge.getBytes(254);\n                        case Mode.B256:\n                            return Edge.getBytes(254, 231);\n                        case Mode.C40:\n                            return Edge.getBytes(254, 230);\n                        case Mode.TEXT:\n                            return Edge.getBytes(254, 239);\n                        case Mode.X12:\n                            return Edge.getBytes(254, 238);\n                        case Mode.EDF:\n                            return Edge.getBytes(254, 240);\n                    }\n                }\n                break;\n            case Mode.EDF:\n                // The rightmost EDIFACT edge always contains an unlatch character\n                if (this.mode !== Mode.EDF) {\n                    throw new Error('Cannot switch from EDF to ' + this.mode);\n                }\n                break;\n        }\n        return new Uint8Array(0);\n    };\n    // Important: The function does not return the length bytes (one or two) in case of B256 encoding\n    Edge.prototype.getDataBytes = function () {\n        switch (this.mode) {\n            case Mode.ASCII:\n                if (this.input.isECI(this.fromPosition)) {\n                    return Edge.getBytes(241, this.input.getECIValue(this.fromPosition) + 1);\n                }\n                else if (MinimalEncoder.isExtendedASCII(this.input.charAt(this.fromPosition), this.input.getFNC1Character())) {\n                    return Edge.getBytes(235, this.input.charAt(this.fromPosition) - 127);\n                }\n                else if (this.characterLength === 2) {\n                    return Edge.getBytes(this.input.charAt(this.fromPosition) * 10 +\n                        this.input.charAt(this.fromPosition + 1) +\n                        130);\n                }\n                else if (this.input.isFNC1(this.fromPosition)) {\n                    return Edge.getBytes(232);\n                }\n                else {\n                    return Edge.getBytes(this.input.charAt(this.fromPosition) + 1);\n                }\n            case Mode.B256:\n                return Edge.getBytes(this.input.charAt(this.fromPosition));\n            case Mode.C40:\n                return this.getC40Words(true, this.input.getFNC1Character());\n            case Mode.TEXT:\n                return this.getC40Words(false, this.input.getFNC1Character());\n            case Mode.X12:\n                return this.getX12Words();\n            case Mode.EDF:\n                return this.getEDFBytes();\n        }\n    };\n    return Edge;\n}());\nvar Input = /** @class */ (function (_super) {\n    __extends(Input, _super);\n    function Input(stringToEncode, priorityCharset, fnc1, shape, macroId) {\n        var _this = _super.call(this, stringToEncode, priorityCharset, fnc1) || this;\n        _this.shape = shape;\n        _this.macroId = macroId;\n        return _this;\n    }\n    Input.prototype.getMacroId = function () {\n        return this.macroId;\n    };\n    Input.prototype.getShapeHint = function () {\n        return this.shape;\n    };\n    return Input;\n}(MinimalECIInput_1.MinimalECIInput));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvTWluaW1hbEVuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLHNKQUFhO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG9LQUFvQjtBQUNyRCx3QkFBd0IsbUJBQU8sQ0FBQyxpS0FBOEI7QUFDOUQsZ0JBQWdCLG1CQUFPLENBQUMsNklBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsNEJBQTRCO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsVUFBVTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxVQUFVO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFVBQVU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdDQUF3QztBQUN4QztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL2RhdGFtYXRyaXgvZW5jb2Rlci9NaW5pbWFsRW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZCkgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWluaW1hbEVuY29kZXIgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgSGlnaExldmVsRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vSGlnaExldmVsRW5jb2RlclwiKTtcbnZhciBNaW5pbWFsRUNJSW5wdXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vTWluaW1hbEVDSUlucHV0XCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XG52YXIgTW9kZTtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIE1vZGVbTW9kZVtcIkFTQ0lJXCJdID0gMF0gPSBcIkFTQ0lJXCI7XG4gICAgTW9kZVtNb2RlW1wiQzQwXCJdID0gMV0gPSBcIkM0MFwiO1xuICAgIE1vZGVbTW9kZVtcIlRFWFRcIl0gPSAyXSA9IFwiVEVYVFwiO1xuICAgIE1vZGVbTW9kZVtcIlgxMlwiXSA9IDNdID0gXCJYMTJcIjtcbiAgICBNb2RlW01vZGVbXCJFREZcIl0gPSA0XSA9IFwiRURGXCI7XG4gICAgTW9kZVtNb2RlW1wiQjI1NlwiXSA9IDVdID0gXCJCMjU2XCI7XG59KShNb2RlIHx8IChNb2RlID0ge30pKTtcbnZhciBDNDBfU0hJRlQyX0NIQVJTID0gW1xuICAgICchJyxcbiAgICAnXCInLFxuICAgICcjJyxcbiAgICAnJCcsXG4gICAgJyUnLFxuICAgICcmJyxcbiAgICBcIidcIixcbiAgICAnKCcsXG4gICAgJyknLFxuICAgICcqJyxcbiAgICAnKycsXG4gICAgJywnLFxuICAgICctJyxcbiAgICAnLicsXG4gICAgJy8nLFxuICAgICc6JyxcbiAgICAnOycsXG4gICAgJzwnLFxuICAgICc9JyxcbiAgICAnPicsXG4gICAgJz8nLFxuICAgICdAJyxcbiAgICAnWycsXG4gICAgJ1xcXFwnLFxuICAgICddJyxcbiAgICAnXicsXG4gICAgJ18nLFxuXTtcbnZhciBNaW5pbWFsRW5jb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaW5pbWFsRW5jb2RlcigpIHtcbiAgICB9XG4gICAgTWluaW1hbEVuY29kZXIuaXNFeHRlbmRlZEFTQ0lJID0gZnVuY3Rpb24gKGNoLCBmbmMxKSB7XG4gICAgICAgIHJldHVybiBjaCAhPT0gZm5jMSAmJiBjaCA+PSAxMjggJiYgY2ggPD0gMjU1O1xuICAgIH07XG4gICAgTWluaW1hbEVuY29kZXIuaXNJbkM0MFNoaWZ0MVNldCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gY2ggPD0gMzE7XG4gICAgfTtcbiAgICBNaW5pbWFsRW5jb2Rlci5pc0luQzQwU2hpZnQyU2V0ID0gZnVuY3Rpb24gKGNoLCBmbmMxKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgQzQwX1NISUZUMl9DSEFSU18xID0gX192YWx1ZXMoQzQwX1NISUZUMl9DSEFSUyksIEM0MF9TSElGVDJfQ0hBUlNfMV8xID0gQzQwX1NISUZUMl9DSEFSU18xLm5leHQoKTsgIUM0MF9TSElGVDJfQ0hBUlNfMV8xLmRvbmU7IEM0MF9TSElGVDJfQ0hBUlNfMV8xID0gQzQwX1NISUZUMl9DSEFSU18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjNDBTaGlmdDJDaGFyID0gQzQwX1NISUZUMl9DSEFSU18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGM0MFNoaWZ0MkNoYXIuY2hhckNvZGVBdCgwKSA9PT0gY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoQzQwX1NISUZUMl9DSEFSU18xXzEgJiYgIUM0MF9TSElGVDJfQ0hBUlNfMV8xLmRvbmUgJiYgKF9hID0gQzQwX1NISUZUMl9DSEFSU18xLnJldHVybikpIF9hLmNhbGwoQzQwX1NISUZUMl9DSEFSU18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2ggPT09IGZuYzE7XG4gICAgfTtcbiAgICBNaW5pbWFsRW5jb2Rlci5pc0luVGV4dFNoaWZ0MVNldCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luQzQwU2hpZnQxU2V0KGNoKTtcbiAgICB9O1xuICAgIE1pbmltYWxFbmNvZGVyLmlzSW5UZXh0U2hpZnQyU2V0ID0gZnVuY3Rpb24gKGNoLCBmbmMxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5DNDBTaGlmdDJTZXQoY2gsIGZuYzEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbWVzc2FnZSBlbmNvZGluZyBvZiBhIERhdGFNYXRyaXggbWVzc2FnZVxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwcmlvcml0eUNoYXJzZXQgVGhlIHByZWZlcnJlZCB7QGxpbmsgQ2hhcnNldH0uIFdoZW4gdGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudCBpcyBudWxsLCB0aGUgYWxnb3JpdGhtXG4gICAgICogICBjaG9vc2VzIGNoYXJzZXRzIHRoYXQgbGVhZHMgdG8gYSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uLiBPdGhlcndpc2UgdGhlIGFsZ29yaXRobSB3aWxsIHVzZSB0aGUgcHJpb3JpdHlcbiAgICAgKiAgIGNoYXJzZXQgdG8gZW5jb2RlIGFueSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0IHRoYXQgY2FuIGJlIGVuY29kZWQgYnkgaXQgaWYgdGhlIGNoYXJzZXQgaXMgYW1vbmcgdGhlXG4gICAgICogICBzdXBwb3J0ZWQgY2hhcnNldHMuXG4gICAgICogQHBhcmFtIGZuYzEgZGVub3RlcyB0aGUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCB0aGF0IHJlcHJlc2VudHMgdGhlIEZOQzEgY2hhcmFjdGVyIG9yIC0xIGlmIHRoaXMgaXMgbm90IGEgR1MxXG4gICAgICogICBiYXIgY29kZS4gSWYgdGhlIHZhbHVlIGlzIG5vdCAtMSB0aGVuIGEgRk5DMSBpcyBhbHNvIHByZXBlbmRlZC5cbiAgICAgKiBAcGFyYW0gc2hhcGUgcmVxdWVzdGVkIHNoYXBlLlxuICAgICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAodGhlIGNoYXIgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAyNTUpXG4gICAgICovXG4gICAgTWluaW1hbEVuY29kZXIuZW5jb2RlSGlnaExldmVsID0gZnVuY3Rpb24gKG1zZywgcHJpb3JpdHlDaGFyc2V0LCBmbmMxLCBzaGFwZSkge1xuICAgICAgICBpZiAocHJpb3JpdHlDaGFyc2V0ID09PSB2b2lkIDApIHsgcHJpb3JpdHlDaGFyc2V0ID0gbnVsbDsgfVxuICAgICAgICBpZiAoZm5jMSA9PT0gdm9pZCAwKSB7IGZuYzEgPSAtMTsgfVxuICAgICAgICBpZiAoc2hhcGUgPT09IHZvaWQgMCkgeyBzaGFwZSA9IDAgLyogRk9SQ0VfTk9ORSAqLzsgfVxuICAgICAgICB2YXIgbWFjcm9JZCA9IDA7XG4gICAgICAgIGlmIChtc2cuc3RhcnRzV2l0aChjb25zdGFudHNfMS5NQUNST18wNV9IRUFERVIpICYmIG1zZy5lbmRzV2l0aChjb25zdGFudHNfMS5NQUNST19UUkFJTEVSKSkge1xuICAgICAgICAgICAgbWFjcm9JZCA9IDU7XG4gICAgICAgICAgICBtc2cgPSBtc2cuc3Vic3RyaW5nKGNvbnN0YW50c18xLk1BQ1JPXzA1X0hFQURFUi5sZW5ndGgsIG1zZy5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuc3RhcnRzV2l0aChjb25zdGFudHNfMS5NQUNST18wNl9IRUFERVIpICYmIG1zZy5lbmRzV2l0aChjb25zdGFudHNfMS5NQUNST19UUkFJTEVSKSkge1xuICAgICAgICAgICAgbWFjcm9JZCA9IDY7XG4gICAgICAgICAgICBtc2cgPSBtc2cuc3Vic3RyaW5nKGNvbnN0YW50c18xLk1BQ1JPXzA2X0hFQURFUi5sZW5ndGgsIG1zZy5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgX19zcHJlYWQodGhpcy5lbmNvZGUobXNnLCBwcmlvcml0eUNoYXJzZXQsIGZuYzEsIHNoYXBlLCBtYWNyb0lkKSkpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGlucHV0IG1pbmltYWxseSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY29kZXdvcmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlDaGFyc2V0IFRoZSBwcmVmZXJyZWQge0BsaW5rIENoYXJzZXR9LiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgaXMgbnVsbCwgdGhlIGFsZ29yaXRobVxuICAgICAqICAgY2hvb3NlcyBjaGFyc2V0cyB0aGF0IGxlYWRzIHRvIGEgbWluaW1hbCByZXByZXNlbnRhdGlvbi4gT3RoZXJ3aXNlIHRoZSBhbGdvcml0aG0gd2lsbCB1c2UgdGhlIHByaW9yaXR5XG4gICAgICogICBjaGFyc2V0IHRvIGVuY29kZSBhbnkgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IGl0IGlmIHRoZSBjaGFyc2V0IGlzIGFtb25nIHRoZVxuICAgICAqICAgc3VwcG9ydGVkIGNoYXJzZXRzLlxuICAgICAqIEBwYXJhbSBmbmMxIGRlbm90ZXMgdGhlIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdGhhdCByZXByZXNlbnRzIHRoZSBGTkMxIGNoYXJhY3RlciBvciAtMSBpZiB0aGlzIGlzIG5vdCBhIEdTMVxuICAgICAqICAgYmFyIGNvZGUuIElmIHRoZSB2YWx1ZSBpcyBub3QgLTEgdGhlbiBhIEZOQzEgaXMgYWxzbyBwcmVwZW5kZWQuXG4gICAgICogQHBhcmFtIHNoYXBlIHJlcXVlc3RlZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gbWFjcm9JZCBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hY3JvIGZ1bmN0aW9uIGluIGNhc2UgdGhhdCBhIHZhbHVlIG9mIDUgb3IgNiBpcyBzcGVjaWZpZWQuXG4gICAgICogQHJldHVybiBBbiBhcnJheSBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGNvZGV3b3JkcyBvZiBhIG1pbmltYWwgZW5jb2RpbmcuXG4gICAgICovXG4gICAgTWluaW1hbEVuY29kZXIuZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0LCBwcmlvcml0eUNoYXJzZXQsIGZuYzEsIHNoYXBlLCBtYWNyb0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZU1pbmltYWxseShuZXcgSW5wdXQoaW5wdXQsIHByaW9yaXR5Q2hhcnNldCwgZm5jMSwgc2hhcGUsIG1hY3JvSWQpKS5nZXRCeXRlcygpO1xuICAgIH07XG4gICAgTWluaW1hbEVuY29kZXIuYWRkRWRnZSA9IGZ1bmN0aW9uIChlZGdlcywgZWRnZSkge1xuICAgICAgICB2YXIgdmVydGV4SW5kZXggPSBlZGdlLmZyb21Qb3NpdGlvbiArIGVkZ2UuY2hhcmFjdGVyTGVuZ3RoO1xuICAgICAgICBpZiAoZWRnZXNbdmVydGV4SW5kZXhdW2VkZ2UuZ2V0RW5kTW9kZSgpXSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgZWRnZXNbdmVydGV4SW5kZXhdW2VkZ2UuZ2V0RW5kTW9kZSgpXS5jYWNoZWRUb3RhbFNpemUgPlxuICAgICAgICAgICAgICAgIGVkZ2UuY2FjaGVkVG90YWxTaXplKSB7XG4gICAgICAgICAgICBlZGdlc1t2ZXJ0ZXhJbmRleF1bZWRnZS5nZXRFbmRNb2RlKCldID0gZWRnZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEByZXR1cm4gdGhlIG51bWJlciBvZiB3b3JkcyBpbiB3aGljaCB0aGUgc3RyaW5nIHN0YXJ0aW5nIGF0IGZyb20gY2FuIGJlIGVuY29kZWQgaW4gYzQwIG9yIHRleHQgbW9kZS5cbiAgICAgKiAgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGVuY29kZWQgaXMgcmV0dXJuZWQgaW4gY2hhcmFjdGVyTGVuZ3RoLlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZW5jb2RlZCBpcyBhbHNvIG1pbmltYWwgaW4gdGhlIHNlbnNlIHRoYXQgdGhlIGFsZ29yaXRobSBzdG9wcyBhcyBzb29uXG4gICAgICogIGFzIGEgY2hhcmFjdGVyIGVuY29kaW5nIGZpbGxzIGEgQzQwIHdvcmQgY29tcGV0ZWx5ICh0aHJlZSBDNDAgdmFsdWVzKS4gQW4gZXhjZXB0aW9uIGlzIGF0IHRoZVxuICAgICAqICBlbmQgb2YgdGhlIHN0cmluZyB3aGVyZSB0d28gQzQwIHZhbHVlcyBhcmUgYWxsb3dlZCAoYWNjb3JkaW5nIHRvIHRoZSBzcGVjIHRoZSB0aGlyZCBjNDAgdmFsdWVcbiAgICAgKiAgaXMgZmlsbGVkICB3aXRoIDAgKFNoaWZ0IDEpIGluIHRoaXMgY2FzZSkuXG4gICAgICovXG4gICAgTWluaW1hbEVuY29kZXIuZ2V0TnVtYmVyT2ZDNDBXb3JkcyA9IGZ1bmN0aW9uIChpbnB1dCwgZnJvbSwgYzQwLCBjaGFyYWN0ZXJMZW5ndGgpIHtcbiAgICAgICAgdmFyIHRoaXJkc0NvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBpbnB1dC5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaXNFQ0koaSkpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJMZW5ndGhbMF0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNpID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKChjNDAgJiYgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNOYXRpdmVDNDAoY2kpKSB8fFxuICAgICAgICAgICAgICAgICghYzQwICYmIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzTmF0aXZlVGV4dChjaSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcmRzQ291bnQrKzsgLy8gbmF0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghTWluaW1hbEVuY29kZXIuaXNFeHRlbmRlZEFTQ0lJKGNpLCBpbnB1dC5nZXRGTkMxQ2hhcmFjdGVyKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcmRzQ291bnQgKz0gMjsgLy8gc2hpZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhc2NpaVZhbHVlID0gY2kgJiAweGZmO1xuICAgICAgICAgICAgICAgIGlmIChhc2NpaVZhbHVlID49IDEyOCAmJlxuICAgICAgICAgICAgICAgICAgICAoKGM0MCAmJiBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc05hdGl2ZUM0MChhc2NpaVZhbHVlIC0gMTI4KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICghYzQwICYmIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzTmF0aXZlVGV4dChhc2NpaVZhbHVlIC0gMTI4KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXJkc0NvdW50ICs9IDM7IC8vIHNoaWZ0LCBVcHBlciBzaGlmdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcmRzQ291bnQgKz0gNDsgLy8gc2hpZnQsIFVwcGVyIHNoaWZ0LCBzaGlmdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlyZHNDb3VudCAlIDMgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAoKHRoaXJkc0NvdW50IC0gMikgJSAzID09PSAwICYmIGkgKyAxID09PSBpbnB1dC5sZW5ndGgoKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJMZW5ndGhbMF0gPSBpIC0gZnJvbSArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlyZHNDb3VudCAvIDMuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcmFjdGVyTGVuZ3RoWzBdID0gMDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBNaW5pbWFsRW5jb2Rlci5hZGRFZGdlcyA9IGZ1bmN0aW9uIChpbnB1dCwgZWRnZXMsIGZyb20sIHByZXZpb3VzKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAoaW5wdXQuaXNFQ0koZnJvbSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZShlZGdlcywgbmV3IEVkZ2UoaW5wdXQsIE1vZGUuQVNDSUksIGZyb20sIDEsIHByZXZpb3VzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KGZyb20pO1xuICAgICAgICBpZiAocHJldmlvdXMgPT09IG51bGwgfHwgcHJldmlvdXMuZ2V0RW5kTW9kZSgpICE9PSBNb2RlLkVERikge1xuICAgICAgICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIHVubGF0Y2ggYSBmdWxsIEVERiBlZGdlIHRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQoY2gpICYmXG4gICAgICAgICAgICAgICAgaW5wdXQuaGF2ZU5DaGFyYWN0ZXJzKGZyb20sIDIpICYmXG4gICAgICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNEaWdpdChpbnB1dC5jaGFyQXQoZnJvbSArIDEpKSkge1xuICAgICAgICAgICAgICAgIC8vIHR3byBkaWdpdHMgQVNDSUkgZW5jb2RlZFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZShlZGdlcywgbmV3IEVkZ2UoaW5wdXQsIE1vZGUuQVNDSUksIGZyb20sIDIsIHByZXZpb3VzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvbmUgQVNDSUkgZW5jb2RlZCBjaGFyYWN0ZXIgb3IgYW4gZXh0ZW5kZWQgY2hhcmFjdGVyIHZpYSBVcHBlciBTaGlmdFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZShlZGdlcywgbmV3IEVkZ2UoaW5wdXQsIE1vZGUuQVNDSUksIGZyb20sIDEsIHByZXZpb3VzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9kZXMgPSBbTW9kZS5DNDAsIE1vZGUuVEVYVF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG1vZGVzXzEgPSBfX3ZhbHVlcyhtb2RlcyksIG1vZGVzXzFfMSA9IG1vZGVzXzEubmV4dCgpOyAhbW9kZXNfMV8xLmRvbmU7IG1vZGVzXzFfMSA9IG1vZGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gbW9kZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyTGVuZ3RoID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChNaW5pbWFsRW5jb2Rlci5nZXROdW1iZXJPZkM0MFdvcmRzKGlucHV0LCBmcm9tLCBtb2RlID09PSBNb2RlLkM0MCwgY2hhcmFjdGVyTGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZShlZGdlcywgbmV3IEVkZ2UoaW5wdXQsIG1vZGUsIGZyb20sIGNoYXJhY3Rlckxlbmd0aFswXSwgcHJldmlvdXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZXNfMV8xICYmICFtb2Rlc18xXzEuZG9uZSAmJiAoX2EgPSBtb2Rlc18xLnJldHVybikpIF9hLmNhbGwobW9kZXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dC5oYXZlTkNoYXJhY3RlcnMoZnJvbSwgMykgJiZcbiAgICAgICAgICAgICAgICBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc05hdGl2ZVgxMihpbnB1dC5jaGFyQXQoZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNOYXRpdmVYMTIoaW5wdXQuY2hhckF0KGZyb20gKyAxKSkgJiZcbiAgICAgICAgICAgICAgICBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc05hdGl2ZVgxMihpbnB1dC5jaGFyQXQoZnJvbSArIDIpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZShlZGdlcywgbmV3IEVkZ2UoaW5wdXQsIE1vZGUuWDEyLCBmcm9tLCAzLCBwcmV2aW91cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRFZGdlKGVkZ2VzLCBuZXcgRWRnZShpbnB1dCwgTW9kZS5CMjU2LCBmcm9tLCAxLCBwcmV2aW91cykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNyZWF0ZSA0IEVERiBlZGdlcywgIHdpdGggMSwgMiAzIG9yIDQgY2hhcmFjdGVycyBsZW5ndGguIFRoZSBmb3VydGggbm9ybWFsbHkgZG9lc24ndCBoYXZlIGEgbGF0Y2ggdG8gQVNDSUlcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIDIgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZnJvbSArIGk7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGF2ZU5DaGFyYWN0ZXJzKHBvcywgMSkgJiZcbiAgICAgICAgICAgICAgICBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc05hdGl2ZUVESUZBQ1QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFZGdlKGVkZ2VzLCBuZXcgRWRnZShpbnB1dCwgTW9kZS5FREYsIGZyb20sIGkgKyAxLCBwcmV2aW91cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDMgJiZcbiAgICAgICAgICAgIGlucHV0LmhhdmVOQ2hhcmFjdGVycyhmcm9tLCA0KSAmJlxuICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNOYXRpdmVFRElGQUNUKGlucHV0LmNoYXJBdChmcm9tICsgMykpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVkZ2UoZWRnZXMsIG5ldyBFZGdlKGlucHV0LCBNb2RlLkVERiwgZnJvbSwgNCwgcHJldmlvdXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWluaW1hbEVuY29kZXIuZW5jb2RlTWluaW1hbGx5ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIC8qIFRoZSBtaW5pbWFsIGVuY29kaW5nIGlzIGNvbXB1dGVkIGJ5IERpamtzdHJhLiBUaGUgYWN5Y2xpYyBncmFwaCBpcyBtb2RlbGVkIGFzIGZvbGxvd3M6XG4gICAgICAgICAqIEEgdmVydGV4IHJlcHJlc2VudHMgYSBjb21iaW5hdGlvbiBvZiBhIHBvc2l0aW9uIGluIHRoZSBpbnB1dCBhbmQgYW4gZW5jb2RpbmcgbW9kZSB3aGVyZSBwb3NpdGlvbiAwXG4gICAgICAgICAqIGRlbm90ZXMgdGhlIHBvc2l0aW9uIGxlZnQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciwgMSB0aGUgcG9zaXRpb24gbGVmdCBvZiB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgc28gb24uXG4gICAgICAgICAqIExpa2V3aXNlIHRoZSBlbmQgdmVydGljZXMgYXJlIGxvY2F0ZWQgYWZ0ZXIgdGhlIGxhc3QgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGlucHV0Lmxlbmd0aCgpLlxuICAgICAgICAgKiBGb3IgYW55IHBvc2l0aW9uIHRoZXJlIG1pZ2h0IGJlIHVwIHRvIHNpeCB2ZXJ0aWNlcywgb25lIGZvciBlYWNoIG9mIHRoZSBlbmNvZGluZyB0eXBlcyBBU0NJSSwgQzQwLCBURVhULCBYMTIsXG4gICAgICAgICAqIEVERiBhbmQgQjI1Ni5cbiAgICAgICAgICpcbiAgICAgICAgICogQXMgYW4gZXhhbXBsZSBjb25zaWRlciB0aGUgaW5wdXQgc3RyaW5nIFwiQUJDMTIzXCIgdGhlbiBhdCBwb3NpdGlvbiAwIHRoZXJlIGlzIG9ubHkgb25lIHZlcnRleCB3aXRoIHRoZSBkZWZhdWx0XG4gICAgICAgICAqIEFTQ0lJIGVuY29kYXRpb24uIEF0IHBvc2l0aW9uIDMgdGhlcmUgbWlnaHQgYmUgdmVydGljZXMgZm9yIHRoZSB0eXBlcyBBU0NJSSwgQzQwLCBYMTIsIEVERiBhbmQgQjI1Ni5cbiAgICAgICAgICpcbiAgICAgICAgICogQW4gZWRnZSBsZWFkaW5nIHRvIHN1Y2ggYSB2ZXJ0ZXggZW5jb2RlcyBvbmUgb3IgbW9yZSBvZiB0aGUgY2hhcmFjdGVycyBsZWZ0IG9mIHRoZSBwb3NpdGlvbiB0aGF0IHRoZSB2ZXJ0ZXhcbiAgICAgICAgICogcmVwcmVzZW50cy4gSXQgZW5jb2RlcyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgZW5jb2RpbmcgbW9kZSBvZiB0aGUgdmVydGV4IHRoYXQgaXQgZW5kcyBvbi4gSW4gb3RoZXIgd29yZHMsXG4gICAgICAgICAqIGFsbCBlZGdlcyBsZWFkaW5nIHRvIGEgcGFydGljdWxhciB2ZXJ0ZXggZW5jb2RlIHRoZSBzYW1lIGNoYXJhY3RlcnMgKHRoZSBsZW5ndGggb2YgdGhlIHN1ZmZpeCBjYW4gdmFyeSkgdXNpbmcgdGhlIHNhbWVcbiAgICAgICAgICogZW5jb2RpbmcgbW9kZS5cbiAgICAgICAgICogQXMgYW4gZXhhbXBsZSBjb25zaWRlciB0aGUgaW5wdXQgc3RyaW5nIFwiQUJDMTIzXCIgYW5kIHRoZSB2ZXJ0ZXggKDQsRURGKS4gUG9zc2libGUgZWRnZXMgbGVhZGluZyB0byB0aGlzIHZlcnRleFxuICAgICAgICAgKiBhcmU6XG4gICAgICAgICAqICAgKDAsQVNDSUkpICAtLUVERihBQkMxKS0tPiAoNCxFREYpXG4gICAgICAgICAqICAgKDEsQVNDSUkpICAtLUVERihCQzEpLS0+ICAoNCxFREYpXG4gICAgICAgICAqICAgKDEsQjI1NikgICAtLUVERihCQzEpLS0+ICAoNCxFREYpXG4gICAgICAgICAqICAgKDEsRURGKSAgICAtLUVERihCQzEpLS0+ICAoNCxFREYpXG4gICAgICAgICAqICAgKDIsQVNDSUkpICAtLUVERihDMSktLT4gICAoNCxFREYpXG4gICAgICAgICAqICAgKDIsQjI1NikgICAtLUVERihDMSktLT4gICAoNCxFREYpXG4gICAgICAgICAqICAgKDIsRURGKSAgICAtLUVERihDMSktLT4gICAoNCxFREYpXG4gICAgICAgICAqICAgKDMsQVNDSUkpICAtLUVERigxKS0tPiAgICAoNCxFREYpXG4gICAgICAgICAqICAgKDMsQjI1NikgICAtLUVERigxKS0tPiAgICAoNCxFREYpXG4gICAgICAgICAqICAgKDMsRURGKSAgICAtLUVERigxKS0tPiAgICAoNCxFREYpXG4gICAgICAgICAqICAgKDMsQzQwKSAgICAtLUVERigxKS0tPiAgICAoNCxFREYpXG4gICAgICAgICAqICAgKDMsWDEyKSAgICAtLUVERigxKS0tPiAgICAoNCxFREYpXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBlZGdlcyBsZWFkaW5nIHRvIGEgdmVydGV4IGFyZSBzdG9yZWQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZXJlIGlzIGEgZmFzdCB3YXkgdG8gZW51bWVyYXRlIHRoZSBlZGdlcyBlbmRpbmdcbiAgICAgICAgICogb24gYSBwYXJ0aWN1bGFyIHZlcnRleC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFsZ29yaXRobSBwcm9jZXNzZXMgdGhlIHZlcnRpY2VzIGluIG9yZGVyIG9mIHRoZWlyIHBvc2l0aW9uIHRoZXJlYnkgcGVyZm9ybWluZyB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXZlcnkgdmVydGV4IGF0IHBvc2l0aW9uIGkgdGhlIGFsZ29yaXRobSBlbnVtZXJhdGVzIHRoZSBlZGdlcyBlbmRpbmcgb24gdGhlIHZlcnRleCBhbmQgcmVtb3ZlcyBhbGwgYnV0IHRoZVxuICAgICAgICAgKiBzaG9ydGVzdCBmcm9tIHRoYXQgbGlzdC5cbiAgICAgICAgICogVGhlbiBpdCBwcm9jZXNzZXMgdGhlIHZlcnRpY2VzIGZvciB0aGUgcG9zaXRpb24gaSsxLiBJZiBpKzEgPT0gaW5wdXQubGVuZ3RoKCkgdGhlbiB0aGUgYWxnb3JpdGhtIGVuZHNcbiAgICAgICAgICogYW5kIGNob29zZXMgdGhlIHRoZSBlZGdlIHdpdGggdGhlIHNtYWxsZXN0IHNpemUgZnJvbSBhbnkgb2YgdGhlIGVkZ2VzIGxlYWRpbmcgdG8gdmVydGljZXMgYXQgdGhpcyBwb3NpdGlvbi5cbiAgICAgICAgICogT3RoZXJ3aXNlIHRoZSBhbGdvcml0aG0gY29tcHV0ZXMgYWxsIHBvc3NpYmxlIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgdmVydGljZXMgYXQgdGhlIHBvc2l0aW9uIGkrMVxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlczpcbiAgICAgICAgICogVGhlIHByb2Nlc3MgaXMgaWxsdXN0cmF0ZWQgYnkgc2hvd2luZyB0aGUgZ3JhcGggKGVkZ2VzKSBhZnRlciBlYWNoIGl0ZXJhdGlvbiBmcm9tIGxlZnQgdG8gcmlnaHQgb3ZlciB0aGUgaW5wdXQ6XG4gICAgICAgICAqIEFuIGVkZ2UgaXMgZHJhd24gYXMgZm9sbG93cyBcIihcIiArIGZyb21WZXJ0ZXggKyBcIikgLS0gXCIgKyBlbmNvZGluZ01vZGUgKyBcIihcIiArIGVuY29kZWRJbnB1dCArIFwiKSAoXCIgK1xuICAgICAgICAgKiBhY2N1bXVsYXRlZFNpemUgKyBcIikgLS0+IChcIiArIHRvVmVydGV4ICsgXCIpXCJcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSAxIGVuY29kaW5nIHRoZSBzdHJpbmcgXCJBQkNERUZHXCI6XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpdHVhdGlvbiBhZnRlciBhZGRpbmcgZWRnZXMgdG8gdGhlIHN0YXJ0IHZlcnRleCAoMCxBU0NJSSlcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQikgKDQpIC0tPiAoMixFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBDNDAoQUJDKSAoMykgLS0+ICgzLEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIFRFWFQoQUJDKSAoNSkgLS0+ICgzLFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBYMTIoQUJDKSAoMykgLS0+ICgzLFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQkMpICg0KSAtLT4gKDMsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCQ0QpICg0KSAtLT4gKDQsRURGKVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaXR1YXRpb24gYWZ0ZXIgYWRkaW5nIGVkZ2VzIHRvIHZlcnRpY2VzIGF0IHBvc2l0aW9uIDFcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQikgKDQpIC0tPiAoMixFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBDNDAoQUJDKSAoMykgLS0+ICgzLEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIFRFWFQoQUJDKSAoNSkgLS0+ICgzLFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBYMTIoQUJDKSAoMykgLS0+ICgzLFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQkMpICg0KSAtLT4gKDMsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCQ0QpICg0KSAtLT4gKDQsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSlcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEIyNTYoQikgKDQpIC0tPiAoMixCMjU2KVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgRURGKEJDKSAoNSkgLS0+ICgzLEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEM0MChCQ0QpICg0KSAtLT4gKDQsQzQwKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgVEVYVChCQ0QpICg2KSAtLT4gKDQsVEVYVClcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIFgxMihCQ0QpICg0KSAtLT4gKDQsWDEyKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgRURGKEJDRCkgKDUpIC0tPiAoNCxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBFREYoQkNERSkgKDUpIC0tPiAoNSxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgQVNDSUkoQikgKDQpIC0tPiAoMixBU0NJSSlcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBFREYoQkMpICg2KSAtLT4gKDMsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEM0MChCQ0QpICg1KSAtLT4gKDQsQzQwKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIFRFWFQoQkNEKSAoNykgLS0+ICg0LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgWDEyKEJDRCkgKDUpIC0tPiAoNCxYMTIpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgRURGKEJDRCkgKDYpIC0tPiAoNCxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgRURGKEJDREUpICg2KSAtLT4gKDUsRURGKVxuICAgICAgICAgKlxuICAgICAgICAgKiBFZGdlIFwiKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpXCIgaXMgbWluaW1hbCBmb3IgdGhlIHZlcnRleCAoMixBU0NJSSkgc28gdGhhdCBlZGdlIFwiKDEsQjI1NikgQVNDSUkoQikgKDQpIC0tPiAoMixBU0NJSSlcIiBpcyByZW1vdmVkLlxuICAgICAgICAgKiBFZGdlIFwiKDEsQjI1NikgQjI1NihCKSAoMykgLS0+ICgyLEIyNTYpXCIgaXMgbWluaW1hbCBmb3IgdGhlIHZlcnRleHQgKDIsQjI1Nikgc28gdGhhdCB0aGUgZWRnZSBcIigxLEFTQ0lJKSBCMjU2KEIpICg0KSAtLT4gKDIsQjI1NilcIiBpcyByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaXR1YXRpb24gYWZ0ZXIgYWRkaW5nIGVkZ2VzIHRvIHZlcnRpY2VzIGF0IHBvc2l0aW9uIDJcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQikgKDQpIC0tPiAoMixFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBDNDAoQUJDKSAoMykgLS0+ICgzLEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIFRFWFQoQUJDKSAoNSkgLS0+ICgzLFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBYMTIoQUJDKSAoMykgLS0+ICgzLFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQkMpICg0KSAtLT4gKDMsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCQ0QpICg0KSAtLT4gKDQsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSlcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEVERihCQykgKDUpIC0tPiAoMyxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBDNDAoQkNEKSAoNCkgLS0+ICg0LEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIFRFWFQoQkNEKSAoNikgLS0+ICg0LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBYMTIoQkNEKSAoNCkgLS0+ICg0LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEVERihCQ0QpICg1KSAtLT4gKDQsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgRURGKEJDREUpICg1KSAtLT4gKDUsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEVERihCQykgKDYpIC0tPiAoMyxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgQzQwKEJDRCkgKDUpIC0tPiAoNCxDNDApXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgVEVYVChCQ0QpICg3KSAtLT4gKDQsVEVYVClcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBYMTIoQkNEKSAoNSkgLS0+ICg0LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBFREYoQkNEKSAoNikgLS0+ICg0LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBFREYoQkNERSkgKDYpIC0tPiAoNSxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUIpICg0KSAtLT4gKDIsRURGKSBBU0NJSShDKSAoNSkgLS0+ICgzLEFTQ0lJKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCKSAoNCkgLS0+ICgyLEVERikgQjI1NihDKSAoNikgLS0+ICgzLEIyNTYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUIpICg0KSAtLT4gKDIsRURGKSBFREYoQ0QpICg3KSAtLT4gKDQsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCKSAoNCkgLS0+ICgyLEVERikgQzQwKENERSkgKDYpIC0tPiAoNSxDNDApXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUIpICg0KSAtLT4gKDIsRURGKSBURVhUKENERSkgKDgpIC0tPiAoNSxURVhUKVxuICAgICAgICAgKiAoMCxBU0NJSSkgRURGKEFCKSAoNCkgLS0+ICgyLEVERikgWDEyKENERSkgKDYpIC0tPiAoNSxYMTIpXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUIpICg0KSAtLT4gKDIsRURGKSBFREYoQ0RFKSAoNykgLS0+ICg1LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQikgKDQpIC0tPiAoMixFREYpIEVERihDREVGKSAoNykgLS0+ICg2LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEFTQ0lJKEMpICgzKSAtLT4gKDMsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBCMjU2KEMpICg1KSAtLT4gKDMsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEVERihDRCkgKDYpIC0tPiAoNCxFREYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBDNDAoQ0RFKSAoNSkgLS0+ICg1LEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIFRFWFQoQ0RFKSAoNykgLS0+ICg1LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBYMTIoQ0RFKSAoNSkgLS0+ICg1LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEVERihDREUpICg2KSAtLT4gKDUsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSkgRURGKENERUYpICg2KSAtLT4gKDYsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KSBBU0NJSShDKSAoNCkgLS0+ICgzLEFTQ0lJKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KSBCMjU2KEMpICg0KSAtLT4gKDMsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NikgRURGKENEKSAoNikgLS0+ICg0LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NikgQzQwKENERSkgKDUpIC0tPiAoNSxDNDApXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgQjI1NihCKSAoMykgLS0+ICgyLEIyNTYpIFRFWFQoQ0RFKSAoNykgLS0+ICg1LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgQjI1NihCKSAoMykgLS0+ICgyLEIyNTYpIFgxMihDREUpICg1KSAtLT4gKDUsWDEyKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KSBFREYoQ0RFKSAoNikgLS0+ICg1LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NikgRURGKENERUYpICg2KSAtLT4gKDYsRURGKVxuICAgICAgICAgKlxuICAgICAgICAgKiBFZGdlIFwiKDIsQVNDSUkpIEFTQ0lJKEMpICgzKSAtLT4gKDMsQVNDSUkpXCIgaXMgbWluaW1hbCBmb3IgdGhlIHZlcnRleCAoMyxBU0NJSSkgc28gdGhhdCBlZGdlcyBcIigyLEVERikgQVNDSUkoQykgKDUpIC0tPiAoMyxBU0NJSSlcIlxuICAgICAgICAgKiBhbmQgXCIoMixCMjU2KSBBU0NJSShDKSAoNCkgLS0+ICgzLEFTQ0lJKVwiIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICAgKiBFZGdlIFwiKDAsQVNDSUkpIEVERihBQkMpICg0KSAtLT4gKDMsRURGKVwiIGlzIG1pbmltYWwgZm9yIHRoZSB2ZXJ0ZXggKDMsRURGKSBzbyB0aGF0IGVkZ2VzIFwiKDEsQVNDSUkpIEVERihCQykgKDUpIC0tPiAoMyxFREYpXCJcbiAgICAgICAgICogYW5kIFwiKDEsQjI1NikgRURGKEJDKSAoNikgLS0+ICgzLEVERilcIiBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgICogRWRnZSBcIigyLEIyNTYpIEIyNTYoQykgKDQpIC0tPiAoMyxCMjU2KVwiIGlzIG1pbmltYWwgZm9yIHRoZSB2ZXJ0ZXggKDMsQjI1Nikgc28gdGhhdCBlZGdlcyBcIigyLEFTQ0lJKSBCMjU2KEMpICg1KSAtLT4gKDMsQjI1NilcIlxuICAgICAgICAgKiBhbmQgXCIoMixFREYpIEIyNTYoQykgKDYpIC0tPiAoMyxCMjU2KVwiIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNvbnRpbnVlcyBmb3IgdmVydGljZXMgMyB0aHJ1IDdcbiAgICAgICAgICpcbiAgICAgICAgICogU2l0dWF0aW9uIGFmdGVyIGFkZGluZyBlZGdlcyB0byB2ZXJ0aWNlcyBhdCBwb3NpdGlvbiA3XG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUIpICg0KSAtLT4gKDIsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQzQwKEFCQykgKDMpIC0tPiAoMyxDNDApXG4gICAgICAgICAqICgwLEFTQ0lJKSBURVhUKEFCQykgKDUpIC0tPiAoMyxURVhUKVxuICAgICAgICAgKiAoMCxBU0NJSSkgWDEyKEFCQykgKDMpIC0tPiAoMyxYMTIpXG4gICAgICAgICAqICgwLEFTQ0lJKSBFREYoQUJDKSAoNCkgLS0+ICgzLEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEVERihBQkNEKSAoNCkgLS0+ICg0LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBDNDAoQkNEKSAoNCkgLS0+ICg0LEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIFRFWFQoQkNEKSAoNikgLS0+ICg0LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBYMTIoQkNEKSAoNCkgLS0+ICg0LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEVERihCQ0RFKSAoNSkgLS0+ICg1LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEM0MChBQkMpICgzKSAtLT4gKDMsQzQwKSBDNDAoREVGKSAoNSkgLS0+ICg2LEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIFgxMihBQkMpICgzKSAtLT4gKDMsWDEyKSBYMTIoREVGKSAoNSkgLS0+ICg2LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEFTQ0lJKEMpICgzKSAtLT4gKDMsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBDNDAoQ0RFKSAoNSkgLS0+ICg1LEM0MClcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIFRFWFQoQ0RFKSAoNykgLS0+ICg1LFRFWFQpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBYMTIoQ0RFKSAoNSkgLS0+ICg1LFgxMilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEVERihDREVGKSAoNikgLS0+ICg2LEVERilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEM0MChCQ0QpICg0KSAtLT4gKDQsQzQwKSBDNDAoRUZHKSAoNikgLS0+ICg3LEM0MCkgICAgLy9Tb2x1dGlvbiAxXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBYMTIoQkNEKSAoNCkgLS0+ICg0LFgxMikgWDEyKEVGRykgKDYpIC0tPiAoNyxYMTIpICAgIC8vU29sdXRpb24gMlxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KSBCMjU2KEMpICg0KSAtLT4gKDMsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEFTQ0lJKEMpICgzKSAtLT4gKDMsQVNDSUkpIEFTQ0lJKEQpICg0KSAtLT4gKDQsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBBU0NJSShDKSAoMykgLS0+ICgzLEFTQ0lJKSBURVhUKERFRikgKDgpIC0tPiAoNixURVhUKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSkgQVNDSUkoQykgKDMpIC0tPiAoMyxBU0NJSSkgRURGKERFRkcpICg3KSAtLT4gKDcsRURGKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQjI1NihBKSAoMykgLS0+ICgxLEIyNTYpIEIyNTYoQikgKDMpIC0tPiAoMixCMjU2KSBCMjU2KEMpICg0KSAtLT4gKDMsQjI1NikgQjI1NihEKSAoNSkgLS0+ICg0LEIyNTYpXG4gICAgICAgICAqICgwLEFTQ0lJKSBBU0NJSShBKSAoMSkgLS0+ICgxLEFTQ0lJKSBBU0NJSShCKSAoMikgLS0+ICgyLEFTQ0lJKSBBU0NJSShDKSAoMykgLS0+ICgzLEFTQ0lJKSBBU0NJSShEKSAoNCkgLS0+ICg0LEFTQ0lJKSBBU0NJSShFKSAoNSkgLS0+ICg1LEFTQ0lJKVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSkgQVNDSUkoQykgKDMpIC0tPiAoMyxBU0NJSSkgQVNDSUkoRCkgKDQpIC0tPiAoNCxBU0NJSSkgVEVYVChFRkcpICg5KSAtLT4gKDcsVEVYVClcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NikgQjI1NihDKSAoNCkgLS0+ICgzLEIyNTYpIEIyNTYoRCkgKDUpIC0tPiAoNCxCMjU2KSBCMjU2KEUpICg2KSAtLT4gKDUsQjI1NilcbiAgICAgICAgICogKDAsQVNDSUkpIEFTQ0lJKEEpICgxKSAtLT4gKDEsQVNDSUkpIEFTQ0lJKEIpICgyKSAtLT4gKDIsQVNDSUkpIEFTQ0lJKEMpICgzKSAtLT4gKDMsQVNDSUkpIEFTQ0lJKEQpICg0KSAtLT4gKDQsQVNDSUkpIEFTQ0lJKEUpICg1KSAtLT4gKDUsQVNDSUkpIEFTQ0lJKEYpICg2KSAtLT4gKDYsQVNDSUkpXG4gICAgICAgICAqICgwLEFTQ0lJKSBCMjU2KEEpICgzKSAtLT4gKDEsQjI1NikgQjI1NihCKSAoMykgLS0+ICgyLEIyNTYpIEIyNTYoQykgKDQpIC0tPiAoMyxCMjU2KSBCMjU2KEQpICg1KSAtLT4gKDQsQjI1NikgQjI1NihFKSAoNikgLS0+ICg1LEIyNTYpIEIyNTYoRikgKDcpIC0tPiAoNixCMjU2KVxuICAgICAgICAgKiAoMCxBU0NJSSkgQVNDSUkoQSkgKDEpIC0tPiAoMSxBU0NJSSkgQVNDSUkoQikgKDIpIC0tPiAoMixBU0NJSSkgQVNDSUkoQykgKDMpIC0tPiAoMyxBU0NJSSkgQVNDSUkoRCkgKDQpIC0tPiAoNCxBU0NJSSkgQVNDSUkoRSkgKDUpIC0tPiAoNSxBU0NJSSkgQVNDSUkoRikgKDYpIC0tPiAoNixBU0NJSSkgQVNDSUkoRykgKDcpIC0tPiAoNyxBU0NJSSlcbiAgICAgICAgICogKDAsQVNDSUkpIEIyNTYoQSkgKDMpIC0tPiAoMSxCMjU2KSBCMjU2KEIpICgzKSAtLT4gKDIsQjI1NikgQjI1NihDKSAoNCkgLS0+ICgzLEIyNTYpIEIyNTYoRCkgKDUpIC0tPiAoNCxCMjU2KSBCMjU2KEUpICg2KSAtLT4gKDUsQjI1NikgQjI1NihGKSAoNykgLS0+ICg2LEIyNTYpIEIyNTYoRykgKDgpIC0tPiAoNyxCMjU2KVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZW5jZSBhIG1pbmltYWwgZW5jb2Rpbmcgb2YgXCJBQkNERUZHXCIgaXMgZWl0aGVyIEFTQ0lJKEEpLEM0MChCQ0RFRkcpIG9yIEFTQ0lJKEEpLCBYMTIoQkNERUZHKSB3aXRoIGEgc2l6ZSBvZiA1IGJ5dGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gICAgICAgIC8vIEFycmF5IHRoYXQgcmVwcmVzZW50cyB2ZXJ0aWNlcy4gVGhlcmUgaXMgYSB2ZXJ0ZXggZm9yIGV2ZXJ5IGNoYXJhY3RlciBhbmQgbW9kZS5cbiAgICAgICAgLy8gVGhlIGxhc3QgZGltZW5zaW9uIGluIHRoZSBhcnJheSBiZWxvdyBlbmNvZGVzIHRoZSA2IG1vZGVzIEFTQ0lJLCBDNDAsIFRFWFQsIFgxMiwgRURGIGFuZCBCMjU2XG4gICAgICAgIHZhciBlZGdlcyA9IEFycmF5KGlucHV0TGVuZ3RoICsgMSlcbiAgICAgICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDYpLmZpbGwoMCk7IH0pO1xuICAgICAgICB0aGlzLmFkZEVkZ2VzKGlucHV0LCBlZGdlcywgMCwgbnVsbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGlucHV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2ldW2pdICE9PSBudWxsICYmIGkgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVkZ2VzKGlucHV0LCBlZGdlcywgaSwgZWRnZXNbaV1bal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGltaXplIG1lbW9yeSBieSByZW1vdmluZyBlZGdlcyB0aGF0IGhhdmUgYmVlbiBwYXNzZWQuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY7IGorKykge1xuICAgICAgICAgICAgICAgIGVkZ2VzW2kgLSAxXVtqXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbmltYWxKID0gLTE7XG4gICAgICAgIHZhciBtaW5pbWFsU2l6ZSA9IEludGVnZXJfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChlZGdlc1tpbnB1dExlbmd0aF1bal0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lucHV0TGVuZ3RoXVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGogPj0gMSAmJiBqIDw9IDMgPyBlZGdlLmNhY2hlZFRvdGFsU2l6ZSArIDEgOiBlZGdlLmNhY2hlZFRvdGFsU2l6ZTsgLy8gQzQwLCBURVhUIGFuZCBYMTIgbmVlZCBhblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIHVubGF0Y2ggYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgbWluaW1hbFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW1hbFNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBtaW5pbWFsSiA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5pbWFsSiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGVuY29kZSBcIicgKyBpbnB1dCArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGVkZ2VzW2lucHV0TGVuZ3RoXVttaW5pbWFsSl0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1pbmltYWxFbmNvZGVyO1xufSgpKTtcbmV4cG9ydHMuTWluaW1hbEVuY29kZXIgPSBNaW5pbWFsRW5jb2RlcjtcbnZhciBSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0KHNvbHV0aW9uKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHNvbHV0aW9uLmlucHV0O1xuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIHZhciBieXRlc0FMID0gW107XG4gICAgICAgIHZhciByYW5kb21pemVQb3N0Zml4TGVuZ3RoID0gW107XG4gICAgICAgIHZhciByYW5kb21pemVMZW5ndGhzID0gW107XG4gICAgICAgIGlmICgoc29sdXRpb24ubW9kZSA9PT0gTW9kZS5DNDAgfHxcbiAgICAgICAgICAgIHNvbHV0aW9uLm1vZGUgPT09IE1vZGUuVEVYVCB8fFxuICAgICAgICAgICAgc29sdXRpb24ubW9kZSA9PT0gTW9kZS5YMTIpICYmXG4gICAgICAgICAgICBzb2x1dGlvbi5nZXRFbmRNb2RlKCkgIT09IE1vZGUuQVNDSUkpIHtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5wcmVwZW5kKEVkZ2UuZ2V0Qnl0ZXMoMjU0KSwgYnl0ZXNBTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzb2x1dGlvbjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5wcmVwZW5kKGN1cnJlbnQuZ2V0RGF0YUJ5dGVzKCksIGJ5dGVzQUwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQucHJldmlvdXMgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50LmdldFByZXZpb3VzU3RhcnRNb2RlKCkgIT09IGN1cnJlbnQuZ2V0TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZ2V0TW9kZSgpID09PSBNb2RlLkIyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPD0gMjQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0FMLnVuc2hpZnQoc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0FMLnVuc2hpZnQoc2l6ZSAlIDI1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0FMLnVuc2hpZnQoc2l6ZSAvIDI1MCArIDI0OSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmFuZG9taXplUG9zdGZpeExlbmd0aC5wdXNoKGJ5dGVzQUwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9taXplTGVuZ3Rocy5wdXNoKHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByZXBlbmQoY3VycmVudC5nZXRMYXRjaEJ5dGVzKCksIGJ5dGVzQUwpO1xuICAgICAgICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmdldE1hY3JvSWQoKSA9PT0gNSkge1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLnByZXBlbmQoRWRnZS5nZXRCeXRlcygyMzYpLCBieXRlc0FMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5nZXRNYWNyb0lkKCkgPT09IDYpIHtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5wcmVwZW5kKEVkZ2UuZ2V0Qnl0ZXMoMjM3KSwgYnl0ZXNBTCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmdldEZOQzFDaGFyYWN0ZXIoKSA+IDApIHtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5wcmVwZW5kKEVkZ2UuZ2V0Qnl0ZXMoMjMyKSwgYnl0ZXNBTCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5kb21pemVQb3N0Zml4TGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5UmFuZG9tUGF0dGVybihieXRlc0FMLCBieXRlc0FMLmxlbmd0aCAtIHJhbmRvbWl6ZVBvc3RmaXhMZW5ndGhbaV0sIHJhbmRvbWl6ZUxlbmd0aHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IHNvbHV0aW9uLmdldE1pblN5bWJvbFNpemUoYnl0ZXNBTC5sZW5ndGgpO1xuICAgICAgICBpZiAoYnl0ZXNBTC5sZW5ndGggPCBjYXBhY2l0eSkge1xuICAgICAgICAgICAgYnl0ZXNBTC5wdXNoKDEyOSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGJ5dGVzQUwubGVuZ3RoIDwgY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIGJ5dGVzQUwucHVzaCh0aGlzLnJhbmRvbWl6ZTI1M1N0YXRlKGJ5dGVzQUwubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlc0FMLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ieXRlc1tpXSA9IGJ5dGVzQUxbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzdWx0LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKGJ5dGVzLCBpbnRvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaW50by51bnNoaWZ0KGJ5dGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5yYW5kb21pemUyNTNTdGF0ZSA9IGZ1bmN0aW9uIChjb2Rld29yZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBwc2V1ZG9SYW5kb20gPSAoKDE0OSAqIGNvZGV3b3JkUG9zaXRpb24pICUgMjUzKSArIDE7XG4gICAgICAgIHZhciB0ZW1wVmFyaWFibGUgPSAxMjkgKyBwc2V1ZG9SYW5kb207XG4gICAgICAgIHJldHVybiB0ZW1wVmFyaWFibGUgPD0gMjU0ID8gdGVtcFZhcmlhYmxlIDogdGVtcFZhcmlhYmxlIC0gMjU0O1xuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5hcHBseVJhbmRvbVBhdHRlcm4gPSBmdW5jdGlvbiAoYnl0ZXNBTCwgc3RhcnRQb3NpdGlvbiwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFNlZSBcIkIuMSAyNTMtc3RhdGUgYWxnb3JpdGhtXG4gICAgICAgICAgICB2YXIgUGFkX2NvZGV3b3JkX3Bvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiArIGk7XG4gICAgICAgICAgICB2YXIgUGFkX2NvZGV3b3JkX3ZhbHVlID0gYnl0ZXNBTFtQYWRfY29kZXdvcmRfcG9zaXRpb25dICYgMHhmZjtcbiAgICAgICAgICAgIHZhciBwc2V1ZG9fcmFuZG9tX251bWJlciA9ICgoMTQ5ICogKFBhZF9jb2Rld29yZF9wb3NpdGlvbiArIDEpKSAlIDI1NSkgKyAxO1xuICAgICAgICAgICAgdmFyIHRlbXBfdmFyaWFibGUgPSBQYWRfY29kZXdvcmRfdmFsdWUgKyBwc2V1ZG9fcmFuZG9tX251bWJlcjtcbiAgICAgICAgICAgIGJ5dGVzQUxbUGFkX2NvZGV3b3JkX3Bvc2l0aW9uXSA9XG4gICAgICAgICAgICAgICAgdGVtcF92YXJpYWJsZSA8PSAyNTUgPyB0ZW1wX3ZhcmlhYmxlIDogdGVtcF92YXJpYWJsZSAtIDI1NjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzdWx0O1xufSgpKTtcbnZhciBFZGdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkZ2UoaW5wdXQsIG1vZGUsIGZyb21Qb3NpdGlvbiwgY2hhcmFjdGVyTGVuZ3RoLCBwcmV2aW91cykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuZnJvbVBvc2l0aW9uID0gZnJvbVBvc2l0aW9uO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlckxlbmd0aCA9IGNoYXJhY3Rlckxlbmd0aDtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB0aGlzLmFsbENvZGV3b3JkQ2FwYWNpdGllcyA9IFtcbiAgICAgICAgICAgIDMsIDUsIDgsIDEwLCAxMiwgMTYsIDE4LCAyMiwgMzAsIDMyLCAzNiwgNDQsIDQ5LCA2MiwgODYsIDExNCwgMTQ0LCAxNzQsIDIwNCxcbiAgICAgICAgICAgIDI4MCwgMzY4LCA0NTYsIDU3NiwgNjk2LCA4MTYsIDEwNTAsIDEzMDQsIDE1NTgsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuc3F1YXJlQ29kZXdvcmRDYXBhY2l0aWVzID0gW1xuICAgICAgICAgICAgMywgNSwgOCwgMTIsIDE4LCAyMiwgMzAsIDM2LCA0NCwgNjIsIDg2LCAxMTQsIDE0NCwgMTc0LCAyMDQsIDI4MCwgMzY4LCA0NTYsXG4gICAgICAgICAgICA1NzYsIDY5NiwgODE2LCAxMDUwLCAxMzA0LCAxNTU4LFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnJlY3Rhbmd1bGFyQ29kZXdvcmRDYXBhY2l0aWVzID0gWzUsIDEwLCAxNiwgMzMsIDMyLCA0OV07XG4gICAgICAgIGlmICghKGZyb21Qb3NpdGlvbiArIGNoYXJhY3Rlckxlbmd0aCA8PSBpbnB1dC5sZW5ndGgoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlZGdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSBwcmV2aW91cyAhPT0gbnVsbCA/IHByZXZpb3VzLmNhY2hlZFRvdGFsU2l6ZSA6IDA7XG4gICAgICAgIHZhciBwcmV2aW91c01vZGUgPSB0aGlzLmdldFByZXZpb3VzTW9kZSgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBTd2l0Y2hpbmcgbW9kZXNcbiAgICAgICAgICogQVNDSUkgLT4gQzQwOiBsYXRjaCAyMzBcbiAgICAgICAgICogQVNDSUkgLT4gVEVYVDogbGF0Y2ggMjM5XG4gICAgICAgICAqIEFTQ0lJIC0+IFgxMjogbGF0Y2ggMjM4XG4gICAgICAgICAqIEFTQ0lJIC0+IEVERjogbGF0Y2ggMjQwXG4gICAgICAgICAqIEFTQ0lJIC0+IEIyNTY6IGxhdGNoIDIzMVxuICAgICAgICAgKiBDNDAgLT4gQVNDSUk6IHdvcmQoYzEsYzIsYzMpLCAyNTRcbiAgICAgICAgICogVEVYVCAtPiBBU0NJSTogd29yZChjMSxjMixjMyksIDI1NFxuICAgICAgICAgKiBYMTIgLT4gQVNDSUk6IHdvcmQoYzEsYzIsYzMpLCAyNTRcbiAgICAgICAgICogRURJRkFDVCAtPiBBU0NJSTogVW5sYXRjaCBjaGFyYWN0ZXIsMCwwLDAgb3IgYzEsVW5sYXRjaCBjaGFyYWN0ZXIsMCwwIG9yIGMxLGMyLFVubGF0Y2ggY2hhcmFjdGVyLDAgb3JcbiAgICAgICAgICogYzEsYzIsYzMsVW5sYXRjaCBjaGFyYWN0ZXJcbiAgICAgICAgICogQjI1NiAtPiBBU0NJSTogd2l0aG91dCBsYXRjaCBhZnRlciBuIGJ5dGVzXG4gICAgICAgICAqL1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTW9kZS5BU0NJSTpcbiAgICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmlzRUNJKGZyb21Qb3NpdGlvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgTWluaW1hbEVuY29kZXIuaXNFeHRlbmRlZEFTQ0lJKGlucHV0LmNoYXJBdChmcm9tUG9zaXRpb24pLCBpbnB1dC5nZXRGTkMxQ2hhcmFjdGVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZSA9PT0gTW9kZS5DNDAgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNNb2RlID09PSBNb2RlLlRFWFQgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNNb2RlID09PSBNb2RlLlgxMikge1xuICAgICAgICAgICAgICAgICAgICBzaXplKys7IC8vIHVubGF0Y2ggMjU0IHRvIEFTQ0lJXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkIyNTY6XG4gICAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGUgIT09IE1vZGUuQjI1Nikge1xuICAgICAgICAgICAgICAgICAgICBzaXplKys7IC8vIGJ5dGUgY291bnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nZXRCMjU2U2l6ZSgpID09PSAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSsrOyAvLyBleHRyYSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGUgPT09IE1vZGUuQVNDSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSsrOyAvLyBsYXRjaCB0byBCMjU2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZpb3VzTW9kZSA9PT0gTW9kZS5DNDAgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNNb2RlID09PSBNb2RlLlRFWFQgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNNb2RlID09PSBNb2RlLlgxMikge1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IDI7IC8vIHVubGF0Y2ggdG8gQVNDSUksIGxhdGNoIHRvIEIyNTZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1vZGUuQzQwOlxuICAgICAgICAgICAgY2FzZSBNb2RlLlRFWFQ6XG4gICAgICAgICAgICBjYXNlIE1vZGUuWDEyOlxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlLlgxMikge1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckxlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBNaW5pbWFsRW5jb2Rlci5nZXROdW1iZXJPZkM0MFdvcmRzKGlucHV0LCBmcm9tUG9zaXRpb24sIG1vZGUgPT09IE1vZGUuQzQwLCBjaGFyTGVuKSAqIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGUgPT09IE1vZGUuQVNDSUkgfHwgcHJldmlvdXNNb2RlID09PSBNb2RlLkIyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSsrOyAvLyBhZGRpdGlvbmFsIGJ5dGUgZm9yIGxhdGNoIGZyb20gQVNDSUkgdG8gdGhpcyBtb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZpb3VzTW9kZSAhPT0gbW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAocHJldmlvdXNNb2RlID09PSBNb2RlLkM0MCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNNb2RlID09PSBNb2RlLlRFWFQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTW9kZSA9PT0gTW9kZS5YMTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gMjsgLy8gdW5sYXRjaCAyNTQgdG8gQVNDSUkgZm9sbG93ZWQgYnkgbGF0Y2ggdG8gdGhpcyBtb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkVERjpcbiAgICAgICAgICAgICAgICBzaXplICs9IDM7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZSA9PT0gTW9kZS5BU0NJSSB8fCBwcmV2aW91c01vZGUgPT09IE1vZGUuQjI1Nikge1xuICAgICAgICAgICAgICAgICAgICBzaXplKys7IC8vIGFkZGl0aW9uYWwgYnl0ZSBmb3IgbGF0Y2ggZnJvbSBBU0NJSSB0byB0aGlzIG1vZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXNNb2RlID09PSBNb2RlLkM0MCB8fFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c01vZGUgPT09IE1vZGUuVEVYVCB8fFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c01vZGUgPT09IE1vZGUuWDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gMjsgLy8gdW5sYXRjaCAyNTQgdG8gQVNDSUkgZm9sbG93ZWQgYnkgbGF0Y2ggdG8gdGhpcyBtb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVkVG90YWxTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgLy8gZG9lcyBub3QgY291bnQgYmV5b25kIDI1MFxuICAgIEVkZ2UucHJvdG90eXBlLmdldEIyNTZTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY250ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1vZGUgPT09IE1vZGUuQjI1NiAmJiBjbnQgPD0gMjUwKSB7XG4gICAgICAgICAgICBjbnQrKztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbnQ7XG4gICAgfTtcbiAgICBFZGdlLnByb3RvdHlwZS5nZXRQcmV2aW91c1N0YXJ0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMgPT09IG51bGwgPyBNb2RlLkFTQ0lJIDogdGhpcy5wcmV2aW91cy5tb2RlO1xuICAgIH07XG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0UHJldmlvdXNNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyA9PT0gbnVsbCA/IE1vZGUuQVNDSUkgOiB0aGlzLnByZXZpb3VzLmdldEVuZE1vZGUoKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIE1vZGUuQVNDSUkgaW4gY2FzZSB0aGF0OlxuICAgICAqICAtIE1vZGUgaXMgRURJRkFDVCBhbmQgY2hhcmFjdGVyTGVuZ3RoIGlzIGxlc3MgdGhhbiA0IG9yIHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBjYW4gYmUgZW5jb2RlZCBpbiBhdCBtb3N0IDJcbiAgICAgKiAgICBBU0NJSSBieXRlcy5cbiAgICAgKiAgLSBNb2RlIGlzIEM0MCwgVEVYVCBvciBYMTIgYW5kIHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBjYW4gYmUgZW5jb2RlZCBpbiBhdCBtb3N0IDEgQVNDSUkgYnl0ZS5cbiAgICAgKiAgUmV0dXJucyBtb2RlIGluIGFsbCBvdGhlciBjYXNlcy5cbiAgICAgKiAqL1xuICAgIEVkZ2UucHJvdG90eXBlLmdldEVuZE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IE1vZGUuRURGKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFyYWN0ZXJMZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdEFTQ0lJID0gdGhpcy5nZXRMYXN0QVNDSUkoKTsgLy8gc2VlIDUuMi44LjIgRURJRkFDVCBlbmNvZGF0aW9uIFJ1bGVzXG4gICAgICAgICAgICBpZiAobGFzdEFTQ0lJID4gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29kZXdvcmRzUmVtYWluaW5nKHRoaXMuY2FjaGVkVG90YWxTaXplICsgbGFzdEFTQ0lJKSA8PVxuICAgICAgICAgICAgICAgICAgICAyIC0gbGFzdEFTQ0lJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gTW9kZS5DNDAgfHxcbiAgICAgICAgICAgIHRoaXMubW9kZSA9PT0gTW9kZS5URVhUIHx8XG4gICAgICAgICAgICB0aGlzLm1vZGUgPT09IE1vZGUuWDEyKSB7XG4gICAgICAgICAgICAvLyBzZWUgNS4yLjUuMiBDNDAgZW5jb2RhdGlvbiBydWxlcyBhbmQgNS4yLjcuMiBBTlNJIFgxMiBlbmNvZGF0aW9uIHJ1bGVzXG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tUG9zaXRpb24gKyB0aGlzLmNoYXJhY3Rlckxlbmd0aCA+PSB0aGlzLmlucHV0Lmxlbmd0aCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb2Rld29yZHNSZW1haW5pbmcodGhpcy5jYWNoZWRUb3RhbFNpemUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdEFTQ0lJID0gdGhpcy5nZXRMYXN0QVNDSUkoKTtcbiAgICAgICAgICAgIGlmIChsYXN0QVNDSUkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvZGV3b3Jkc1JlbWFpbmluZyh0aGlzLmNhY2hlZFRvdGFsU2l6ZSArIDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgICB9O1xuICAgIEVkZ2UucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgfTtcbiAgICAvKiogUGVla3MgYWhlYWQgYW5kIHJldHVybnMgMSBpZiB0aGUgcG9zdGZpeCBjb25zaXN0cyBvZiBleGFjdGx5IHR3byBkaWdpdHMsIDIgaWYgdGhlIHBvc3RmaXggY29uc2lzdHMgb2YgZXhhY3RseVxuICAgICAqICB0d28gY29uc2VjdXRpdmUgZGlnaXRzIGFuZCBhIG5vbiBleHRlbmRlZCBjaGFyYWN0ZXIgb3Igb2YgNCBkaWdpdHMuXG4gICAgICogIFJldHVybnMgMCBpbiBhbnkgb3RoZXIgY2FzZVxuICAgICAqKi9cbiAgICBFZGdlLnByb3RvdHlwZS5nZXRMYXN0QVNDSUkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmlucHV0Lmxlbmd0aCgpO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbVBvc2l0aW9uICsgdGhpcy5jaGFyYWN0ZXJMZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggLSBmcm9tID4gNCB8fCBmcm9tID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCAtIGZyb20gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChNaW5pbWFsRW5jb2Rlci5pc0V4dGVuZGVkQVNDSUkodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCAtIGZyb20gPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChNaW5pbWFsRW5jb2Rlci5pc0V4dGVuZGVkQVNDSUkodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSB8fFxuICAgICAgICAgICAgICAgIE1pbmltYWxFbmNvZGVyLmlzRXh0ZW5kZWRBU0NJSSh0aGlzLmlucHV0LmNoYXJBdChmcm9tICsgMSksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJBdChmcm9tICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIC0gZnJvbSA9PT0gMykge1xuICAgICAgICAgICAgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJBdChmcm9tICsgMSkpICYmXG4gICAgICAgICAgICAgICAgIU1pbmltYWxFbmNvZGVyLmlzRXh0ZW5kZWRBU0NJSSh0aGlzLmlucHV0LmNoYXJBdChmcm9tICsgMiksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSArIDEpKSAmJlxuICAgICAgICAgICAgICAgIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSArIDIpKSAmJlxuICAgICAgICAgICAgICAgICFNaW5pbWFsRW5jb2Rlci5pc0V4dGVuZGVkQVNDSUkodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSkpICYmXG4gICAgICAgICAgICBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc0RpZ2l0KHRoaXMuaW5wdXQuY2hhckF0KGZyb20gKyAxKSkgJiZcbiAgICAgICAgICAgIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzRGlnaXQodGhpcy5pbnB1dC5jaGFyQXQoZnJvbSArIDIpKSAmJlxuICAgICAgICAgICAgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJBdChmcm9tICsgMykpKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBjYXBhY2l0eSBpbiBjb2Rld29yZHMgb2YgdGhlIHNtYWxsZXN0IHN5bWJvbCB0aGF0IGhhcyBlbm91Z2ggY2FwYWNpdHkgdG8gZml0IHRoZSBnaXZlbiBtaW5pbWFsXG4gICAgICogbnVtYmVyIG9mIGNvZGV3b3Jkcy5cbiAgICAgKiovXG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0TWluU3ltYm9sU2l6ZSA9IGZ1bmN0aW9uIChtaW5pbXVtKSB7XG4gICAgICAgIHZhciBlXzMsIF9hLCBlXzQsIF9iLCBlXzUsIF9jO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuZ2V0U2hhcGVIaW50KCkpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBGT1JDRV9TUVVBUkUgKi86XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSBfX3ZhbHVlcyh0aGlzLnNxdWFyZUNvZGV3b3JkQ2FwYWNpdGllcyksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXBhY2l0eSA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFjaXR5ID49IG1pbmltdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZSAmJiAhX2UuZG9uZSAmJiAoX2EgPSBfZC5yZXR1cm4pKSBfYS5jYWxsKF9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIEZPUkNFX1JFQ1RBTkdMRSAqLzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IF9fdmFsdWVzKHRoaXMucmVjdGFuZ3VsYXJDb2Rld29yZENhcGFjaXRpZXMpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FwYWNpdHkgPSBfZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBhY2l0eSA+PSBtaW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2ggPSBfX3ZhbHVlcyh0aGlzLmFsbENvZGV3b3JkQ2FwYWNpdGllcyksIF9qID0gX2gubmV4dCgpOyAhX2ouZG9uZTsgX2ogPSBfaC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwYWNpdHkgPSBfai52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FwYWNpdHkgPj0gbWluaW11bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2ogJiYgIV9qLmRvbmUgJiYgKF9jID0gX2gucmV0dXJuKSkgX2MuY2FsbChfaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ29kZXdvcmRDYXBhY2l0aWVzW3RoaXMuYWxsQ29kZXdvcmRDYXBhY2l0aWVzLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIHJlbWFpbmluZyBjYXBhY2l0eSBpbiBjb2Rld29yZHMgb2YgdGhlIHNtYWxsZXN0IHN5bWJvbCB0aGF0IGhhcyBlbm91Z2ggY2FwYWNpdHkgdG8gZml0IHRoZSBnaXZlblxuICAgICAqIG1pbmltYWwgbnVtYmVyIG9mIGNvZGV3b3Jkcy5cbiAgICAgKiovXG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0Q29kZXdvcmRzUmVtYWluaW5nID0gZnVuY3Rpb24gKG1pbmltdW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWluU3ltYm9sU2l6ZShtaW5pbXVtKSAtIG1pbmltdW07XG4gICAgfTtcbiAgICBFZGdlLmdldEJ5dGVzID0gZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYzIgPyAyIDogMSk7XG4gICAgICAgIHJlc3VsdFswXSA9IGMxO1xuICAgICAgICBpZiAoYzIpIHtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IGMyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFZGdlLnByb3RvdHlwZS5zZXRDNDBXb3JkID0gZnVuY3Rpb24gKGJ5dGVzLCBvZmZzZXQsIGMxLCBjMiwgYzMpIHtcbiAgICAgICAgdmFyIHZhbDE2ID0gMTYwMCAqIChjMSAmIDB4ZmYpICsgNDAgKiAoYzIgJiAweGZmKSArIChjMyAmIDB4ZmYpICsgMTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0XSA9IHZhbDE2IC8gMjU2O1xuICAgICAgICBieXRlc1tvZmZzZXQgKyAxXSA9IHZhbDE2ICUgMjU2O1xuICAgIH07XG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0WDEyVmFsdWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMTNcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiBjID09PSA0MlxuICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgIDogYyA9PT0gNjJcbiAgICAgICAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgICAgICAgIDogYyA9PT0gMzJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gM1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBjID49IDQ4ICYmIGMgPD0gNTdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMgLSA0NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYyA+PSA2NSAmJiBjIDw9IDkwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYyAtIDUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYztcbiAgICB9O1xuICAgIEVkZ2UucHJvdG90eXBlLmdldFgxMldvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISh0aGlzLmNoYXJhY3Rlckxlbmd0aCAlIDMgPT09IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1gxMiB3b3JkcyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodGhpcy5jaGFyYWN0ZXJMZW5ndGggLyAzKSAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdGhpcy5zZXRDNDBXb3JkKHJlc3VsdCwgaSwgdGhpcy5nZXRYMTJWYWx1ZSh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbiArIChpIC8gMikgKiAzKSksIHRoaXMuZ2V0WDEyVmFsdWUodGhpcy5pbnB1dC5jaGFyQXQodGhpcy5mcm9tUG9zaXRpb24gKyAoaSAvIDIpICogMyArIDEpKSwgdGhpcy5nZXRYMTJWYWx1ZSh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbiArIChpIC8gMikgKiAzICsgMikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0U2hpZnRWYWx1ZSA9IGZ1bmN0aW9uIChjLCBjNDAsIGZuYzEpIHtcbiAgICAgICAgcmV0dXJuIChjNDAgJiYgTWluaW1hbEVuY29kZXIuaXNJbkM0MFNoaWZ0MVNldChjKSkgfHxcbiAgICAgICAgICAgICghYzQwICYmIE1pbmltYWxFbmNvZGVyLmlzSW5UZXh0U2hpZnQxU2V0KGMpKVxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IChjNDAgJiYgTWluaW1hbEVuY29kZXIuaXNJbkM0MFNoaWZ0MlNldChjLCBmbmMxKSkgfHxcbiAgICAgICAgICAgICAgICAoIWM0MCAmJiBNaW5pbWFsRW5jb2Rlci5pc0luVGV4dFNoaWZ0MlNldChjLCBmbmMxKSlcbiAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICA6IDI7XG4gICAgfTtcbiAgICBFZGdlLnByb3RvdHlwZS5nZXRDNDBWYWx1ZSA9IGZ1bmN0aW9uIChjNDAsIHNldEluZGV4LCBjLCBmbmMxKSB7XG4gICAgICAgIGlmIChjID09PSBmbmMxKSB7XG4gICAgICAgICAgICBpZiAoIShzZXRJbmRleCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZOQzEgY2Fubm90IGJlIHVzZWQgaW4gQzQwIHNoaWZ0IDInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAyNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYzQwKSB7XG4gICAgICAgICAgICByZXR1cm4gYyA8PSAzMVxuICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgIDogYyA9PT0gMzJcbiAgICAgICAgICAgICAgICAgICAgPyAzXG4gICAgICAgICAgICAgICAgICAgIDogYyA8PSA0N1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gMzNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYyA8PSA1N1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYyAtIDQ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjIDw9IDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYyAtIDQzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYyA8PSA5MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gNTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYyA8PSA5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYyAtIDY5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMgLSA5NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYyA9PT0gMFxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogc2V0SW5kZXggPT09IDAgJiYgYyA8PSAzXG4gICAgICAgICAgICAgICAgICAgID8gYyAtIDEgLy8gaXMgdGhpcyBhIGJ1ZyBpbiB0aGUgc3BlYz9cbiAgICAgICAgICAgICAgICAgICAgOiBzZXRJbmRleCA9PT0gMSAmJiBjIDw9IDMxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYyA9PT0gMzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGMgPj0gMzMgJiYgYyA8PSA0N1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMgLSAzM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGMgPj0gNDggJiYgYyA8PSA1N1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gNDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYyA+PSA1OCAmJiBjIDw9IDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gNDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGMgPj0gNjUgJiYgYyA8PSA5MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGMgLSA2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGMgPj0gOTEgJiYgYyA8PSA5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gNjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYyA9PT0gOTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGMgPj0gOTcgJiYgYyA8PSAxMjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gODNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjID49IDEyMyAmJiBjIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjIC0gOTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0QzQwV29yZHMgPSBmdW5jdGlvbiAoYzQwLCBmbmMxKSB7XG4gICAgICAgIHZhciBjNDBWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYXJhY3Rlckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2kgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbiArIGkpO1xuICAgICAgICAgICAgaWYgKChjNDAgJiYgSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQuaXNOYXRpdmVDNDAoY2kpKSB8fFxuICAgICAgICAgICAgICAgICghYzQwICYmIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzTmF0aXZlVGV4dChjaSkpKSB7XG4gICAgICAgICAgICAgICAgYzQwVmFsdWVzLnB1c2godGhpcy5nZXRDNDBWYWx1ZShjNDAsIDAsIGNpLCBmbmMxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghTWluaW1hbEVuY29kZXIuaXNFeHRlbmRlZEFTQ0lJKGNpLCBmbmMxKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaGlmdFZhbHVlID0gdGhpcy5nZXRTaGlmdFZhbHVlKGNpLCBjNDAsIGZuYzEpO1xuICAgICAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKHNoaWZ0VmFsdWUpOyAvLyBTaGlmdFsxMjNdXG4gICAgICAgICAgICAgICAgYzQwVmFsdWVzLnB1c2godGhpcy5nZXRDNDBWYWx1ZShjNDAsIHNoaWZ0VmFsdWUsIGNpLCBmbmMxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNjaWlWYWx1ZSA9IChjaSAmIDB4ZmYpIC0gMTI4O1xuICAgICAgICAgICAgICAgIGlmICgoYzQwICYmIEhpZ2hMZXZlbEVuY29kZXJfMS5kZWZhdWx0LmlzTmF0aXZlQzQwKGFzY2lpVmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIWM0MCAmJiBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pc05hdGl2ZVRleHQoYXNjaWlWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKDEpOyAvLyBTaGlmdCAyXG4gICAgICAgICAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKDMwKTsgLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgYzQwVmFsdWVzLnB1c2godGhpcy5nZXRDNDBWYWx1ZShjNDAsIDAsIGFzY2lpVmFsdWUsIGZuYzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKDEpOyAvLyBTaGlmdCAyXG4gICAgICAgICAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKDMwKTsgLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0VmFsdWUgPSB0aGlzLmdldFNoaWZ0VmFsdWUoYXNjaWlWYWx1ZSwgYzQwLCBmbmMxKTtcbiAgICAgICAgICAgICAgICAgICAgYzQwVmFsdWVzLnB1c2goc2hpZnRWYWx1ZSk7IC8vIFNoaWZ0WzEyM11cbiAgICAgICAgICAgICAgICAgICAgYzQwVmFsdWVzLnB1c2godGhpcy5nZXRDNDBWYWx1ZShjNDAsIHNoaWZ0VmFsdWUsIGFzY2lpVmFsdWUsIGZuYzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGM0MFZhbHVlcy5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoISgoYzQwVmFsdWVzLmxlbmd0aCAtIDIpICUgMyA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVBvc2l0aW9uICsgdGhpcy5jaGFyYWN0ZXJMZW5ndGggPT09IHRoaXMuaW5wdXQubGVuZ3RoKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDNDAgd29yZHMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGM0MFZhbHVlcy5wdXNoKDApOyAvLyBwYWQgd2l0aCAwIChTaGlmdCAxKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSgoYzQwVmFsdWVzLmxlbmd0aCAvIDMpICogMik7XG4gICAgICAgIHZhciBieXRlSW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM0MFZhbHVlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgdGhpcy5zZXRDNDBXb3JkKHJlc3VsdCwgYnl0ZUluZGV4LCBjNDBWYWx1ZXNbaV0gJiAweGZmLCBjNDBWYWx1ZXNbaSArIDFdICYgMHhmZiwgYzQwVmFsdWVzW2kgKyAyXSAmIDB4ZmYpO1xuICAgICAgICAgICAgYnl0ZUluZGV4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEVkZ2UucHJvdG90eXBlLmdldEVERkJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZUaGlyZHMgPSBNYXRoLmNlaWwodGhpcy5jaGFyYWN0ZXJMZW5ndGggLyA0LjApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobnVtYmVyT2ZUaGlyZHMgKiAzKTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZnJvbVBvc2l0aW9uO1xuICAgICAgICB2YXIgZW5kUG9zID0gTWF0aC5taW4odGhpcy5mcm9tUG9zaXRpb24gKyB0aGlzLmNoYXJhY3Rlckxlbmd0aCAtIDEsIHRoaXMuaW5wdXQubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZlRoaXJkczsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgZWRmVmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZlZhbHVlc1tqXSA9IHRoaXMuaW5wdXQuY2hhckF0KHBvcysrKSAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGZWYWx1ZXNbal0gPSBwb3MgPT09IGVuZFBvcyArIDEgPyAweDFmIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsMjQgPSBlZGZWYWx1ZXNbMF0gPDwgMTg7XG4gICAgICAgICAgICB2YWwyNCB8PSBlZGZWYWx1ZXNbMV0gPDwgMTI7XG4gICAgICAgICAgICB2YWwyNCB8PSBlZGZWYWx1ZXNbMl0gPDwgNjtcbiAgICAgICAgICAgIHZhbDI0IHw9IGVkZlZhbHVlc1szXTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9ICh2YWwyNCA+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0W2kgKyAxXSA9ICh2YWwyNCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbaSArIDJdID0gdmFsMjQgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFZGdlLnByb3RvdHlwZS5nZXRMYXRjaEJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0UHJldmlvdXNNb2RlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgTW9kZS5BU0NJSTpcbiAgICAgICAgICAgIGNhc2UgTW9kZS5CMjU2OiAvLyBhZnRlciBCMjU2IGVuZHMgKHZpYSBsZW5ndGgpIHdlIGFyZSBiYWNrIHRvIEFTQ0lJXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkIyNTY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcygyMzEpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQzQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2UuZ2V0Qnl0ZXMoMjMwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlRFWFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcygyMzkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuWDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2UuZ2V0Qnl0ZXMoMjM4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkVERjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGdlLmdldEJ5dGVzKDI0MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkM0MDpcbiAgICAgICAgICAgIGNhc2UgTW9kZS5URVhUOlxuICAgICAgICAgICAgY2FzZSBNb2RlLlgxMjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlICE9PSB0aGlzLmdldFByZXZpb3VzTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQVNDSUk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2UuZ2V0Qnl0ZXMoMjU0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5CMjU2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGdlLmdldEJ5dGVzKDI1NCwgMjMxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5DNDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2UuZ2V0Qnl0ZXMoMjU0LCAyMzApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlRFWFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2UuZ2V0Qnl0ZXMoMjU0LCAyMzkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlgxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcygyNTQsIDIzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuRURGOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGdlLmdldEJ5dGVzKDI1NCwgMjQwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTW9kZS5FREY6XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJpZ2h0bW9zdCBFRElGQUNUIGVkZ2UgYWx3YXlzIGNvbnRhaW5zIGFuIHVubGF0Y2ggY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gTW9kZS5FREYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIGZyb20gRURGIHRvICcgKyB0aGlzLm1vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfTtcbiAgICAvLyBJbXBvcnRhbnQ6IFRoZSBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gdGhlIGxlbmd0aCBieXRlcyAob25lIG9yIHR3bykgaW4gY2FzZSBvZiBCMjU2IGVuY29kaW5nXG4gICAgRWRnZS5wcm90b3R5cGUuZ2V0RGF0YUJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBNb2RlLkFTQ0lJOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmlzRUNJKHRoaXMuZnJvbVBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcygyNDEsIHRoaXMuaW5wdXQuZ2V0RUNJVmFsdWUodGhpcy5mcm9tUG9zaXRpb24pICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1pbmltYWxFbmNvZGVyLmlzRXh0ZW5kZWRBU0NJSSh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbiksIHRoaXMuaW5wdXQuZ2V0Rk5DMUNoYXJhY3RlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcygyMzUsIHRoaXMuaW5wdXQuY2hhckF0KHRoaXMuZnJvbVBvc2l0aW9uKSAtIDEyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hhcmFjdGVyTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGdlLmdldEJ5dGVzKHRoaXMuaW5wdXQuY2hhckF0KHRoaXMuZnJvbVBvc2l0aW9uKSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY2hhckF0KHRoaXMuZnJvbVBvc2l0aW9uICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMTMwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbnB1dC5pc0ZOQzEodGhpcy5mcm9tUG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGdlLmdldEJ5dGVzKDIzMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcyh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1vZGUuQjI1NjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRnZS5nZXRCeXRlcyh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLmZyb21Qb3NpdGlvbikpO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkM0MDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDNDBXb3Jkcyh0cnVlLCB0aGlzLmlucHV0LmdldEZOQzFDaGFyYWN0ZXIoKSk7XG4gICAgICAgICAgICBjYXNlIE1vZGUuVEVYVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDNDBXb3JkcyhmYWxzZSwgdGhpcy5pbnB1dC5nZXRGTkMxQ2hhcmFjdGVyKCkpO1xuICAgICAgICAgICAgY2FzZSBNb2RlLlgxMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRYMTJXb3JkcygpO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkVERjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFREZCeXRlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRWRnZTtcbn0oKSk7XG52YXIgSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElucHV0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElucHV0KHN0cmluZ1RvRW5jb2RlLCBwcmlvcml0eUNoYXJzZXQsIGZuYzEsIHNoYXBlLCBtYWNyb0lkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHN0cmluZ1RvRW5jb2RlLCBwcmlvcml0eUNoYXJzZXQsIGZuYzEpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIF90aGlzLm1hY3JvSWQgPSBtYWNyb0lkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElucHV0LnByb3RvdHlwZS5nZXRNYWNyb0lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWNyb0lkO1xuICAgIH07XG4gICAgSW5wdXQucHJvdG90eXBlLmdldFNoYXBlSGludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGU7XG4gICAgfTtcbiAgICByZXR1cm4gSW5wdXQ7XG59KE1pbmltYWxFQ0lJbnB1dF8xLk1pbmltYWxFQ0lJbnB1dCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PROD_SYMBOLS = void 0;\n/**\n * Symbol info table for DataMatrix.\n */\nvar SymbolInfo = /** @class */ (function () {\n    function SymbolInfo(rectangular, dataCapacity, errorCodewords, matrixWidth, matrixHeight, dataRegions, rsBlockData, rsBlockError) {\n        if (rsBlockData === void 0) { rsBlockData = 0; }\n        if (rsBlockError === void 0) { rsBlockError = 0; }\n        this.rectangular = rectangular;\n        this.dataCapacity = dataCapacity;\n        this.errorCodewords = errorCodewords;\n        this.matrixWidth = matrixWidth;\n        this.matrixHeight = matrixHeight;\n        this.dataRegions = dataRegions;\n        this.rsBlockData = rsBlockData;\n        this.rsBlockError = rsBlockError;\n    }\n    SymbolInfo.lookup = function (dataCodewords, shape, minSize, maxSize, fail) {\n        var e_1, _a;\n        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }\n        if (minSize === void 0) { minSize = null; }\n        if (maxSize === void 0) { maxSize = null; }\n        if (fail === void 0) { fail = true; }\n        try {\n            for (var PROD_SYMBOLS_1 = __values(exports.PROD_SYMBOLS), PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next(); !PROD_SYMBOLS_1_1.done; PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next()) {\n                var symbol = PROD_SYMBOLS_1_1.value;\n                if (shape === 1 /* FORCE_SQUARE */ && symbol.rectangular) {\n                    continue;\n                }\n                if (shape === 2 /* FORCE_RECTANGLE */ && !symbol.rectangular) {\n                    continue;\n                }\n                if (minSize != null &&\n                    (symbol.getSymbolWidth() < minSize.getWidth() ||\n                        symbol.getSymbolHeight() < minSize.getHeight())) {\n                    continue;\n                }\n                if (maxSize != null &&\n                    (symbol.getSymbolWidth() > maxSize.getWidth() ||\n                        symbol.getSymbolHeight() > maxSize.getHeight())) {\n                    continue;\n                }\n                if (dataCodewords <= symbol.dataCapacity) {\n                    return symbol;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (PROD_SYMBOLS_1_1 && !PROD_SYMBOLS_1_1.done && (_a = PROD_SYMBOLS_1.return)) _a.call(PROD_SYMBOLS_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (fail) {\n            throw new Error(\"Can't find a symbol arrangement that matches the message. Data codewords: \" +\n                dataCodewords);\n        }\n        return null;\n    };\n    SymbolInfo.prototype.getHorizontalDataRegions = function () {\n        switch (this.dataRegions) {\n            case 1:\n                return 1;\n            case 2:\n            case 4:\n                return 2;\n            case 16:\n                return 4;\n            case 36:\n                return 6;\n            default:\n                throw new Error('Cannot handle this number of data regions');\n        }\n    };\n    SymbolInfo.prototype.getVerticalDataRegions = function () {\n        switch (this.dataRegions) {\n            case 1:\n            case 2:\n                return 1;\n            case 4:\n                return 2;\n            case 16:\n                return 4;\n            case 36:\n                return 6;\n            default:\n                throw new Error('Cannot handle this number of data regions');\n        }\n    };\n    SymbolInfo.prototype.getSymbolDataWidth = function () {\n        return this.getHorizontalDataRegions() * this.matrixWidth;\n    };\n    SymbolInfo.prototype.getSymbolDataHeight = function () {\n        return this.getVerticalDataRegions() * this.matrixHeight;\n    };\n    SymbolInfo.prototype.getSymbolWidth = function () {\n        return this.getSymbolDataWidth() + this.getHorizontalDataRegions() * 2;\n    };\n    SymbolInfo.prototype.getSymbolHeight = function () {\n        return this.getSymbolDataHeight() + this.getVerticalDataRegions() * 2;\n    };\n    SymbolInfo.prototype.getCodewordCount = function () {\n        return this.dataCapacity + this.errorCodewords;\n    };\n    SymbolInfo.prototype.getInterleavedBlockCount = function () {\n        if (!this.rsBlockData)\n            return 1;\n        return this.dataCapacity / this.rsBlockData;\n    };\n    SymbolInfo.prototype.getDataCapacity = function () {\n        return this.dataCapacity;\n    };\n    SymbolInfo.prototype.getErrorCodewords = function () {\n        return this.errorCodewords;\n    };\n    SymbolInfo.prototype.getDataLengthForInterleavedBlock = function (index) {\n        return this.rsBlockData;\n    };\n    SymbolInfo.prototype.getErrorLengthForInterleavedBlock = function (index) {\n        return this.rsBlockError;\n    };\n    return SymbolInfo;\n}());\nexports[\"default\"] = SymbolInfo;\nvar DataMatrixSymbolInfo144 = /** @class */ (function (_super) {\n    __extends(DataMatrixSymbolInfo144, _super);\n    function DataMatrixSymbolInfo144() {\n        return _super.call(this, false, 1558, 620, 22, 22, 36, -1, 62) || this;\n    }\n    DataMatrixSymbolInfo144.prototype.getInterleavedBlockCount = function () {\n        return 10;\n    };\n    DataMatrixSymbolInfo144.prototype.getDataLengthForInterleavedBlock = function (index) {\n        return index <= 8 ? 156 : 155;\n    };\n    return DataMatrixSymbolInfo144;\n}(SymbolInfo));\nexports.PROD_SYMBOLS = [\n    new SymbolInfo(false, 3, 5, 8, 8, 1),\n    new SymbolInfo(false, 5, 7, 10, 10, 1),\n    /*rect*/ new SymbolInfo(true, 5, 7, 16, 6, 1),\n    new SymbolInfo(false, 8, 10, 12, 12, 1),\n    /*rect*/ new SymbolInfo(true, 10, 11, 14, 6, 2),\n    new SymbolInfo(false, 12, 12, 14, 14, 1),\n    /*rect*/ new SymbolInfo(true, 16, 14, 24, 10, 1),\n    new SymbolInfo(false, 18, 14, 16, 16, 1),\n    new SymbolInfo(false, 22, 18, 18, 18, 1),\n    /*rect*/ new SymbolInfo(true, 22, 18, 16, 10, 2),\n    new SymbolInfo(false, 30, 20, 20, 20, 1),\n    /*rect*/ new SymbolInfo(true, 32, 24, 16, 14, 2),\n    new SymbolInfo(false, 36, 24, 22, 22, 1),\n    new SymbolInfo(false, 44, 28, 24, 24, 1),\n    /*rect*/ new SymbolInfo(true, 49, 28, 22, 14, 2),\n    new SymbolInfo(false, 62, 36, 14, 14, 4),\n    new SymbolInfo(false, 86, 42, 16, 16, 4),\n    new SymbolInfo(false, 114, 48, 18, 18, 4),\n    new SymbolInfo(false, 144, 56, 20, 20, 4),\n    new SymbolInfo(false, 174, 68, 22, 22, 4),\n    new SymbolInfo(false, 204, 84, 24, 24, 4, 102, 42),\n    new SymbolInfo(false, 280, 112, 14, 14, 16, 140, 56),\n    new SymbolInfo(false, 368, 144, 16, 16, 16, 92, 36),\n    new SymbolInfo(false, 456, 192, 18, 18, 16, 114, 48),\n    new SymbolInfo(false, 576, 224, 20, 20, 16, 144, 56),\n    new SymbolInfo(false, 696, 272, 22, 22, 16, 174, 68),\n    new SymbolInfo(false, 816, 336, 24, 24, 16, 136, 56),\n    new SymbolInfo(false, 1050, 408, 18, 18, 36, 175, 68),\n    new SymbolInfo(false, 1304, 496, 20, 20, 36, 163, 62),\n    new DataMatrixSymbolInfo144(),\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvU3ltYm9sSW5mby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CO0FBQ0EsZ0hBQWdILHdCQUF3QjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvU3ltYm9sSW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QUk9EX1NZTUJPTFMgPSB2b2lkIDA7XG4vKipcbiAqIFN5bWJvbCBpbmZvIHRhYmxlIGZvciBEYXRhTWF0cml4LlxuICovXG52YXIgU3ltYm9sSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTeW1ib2xJbmZvKHJlY3Rhbmd1bGFyLCBkYXRhQ2FwYWNpdHksIGVycm9yQ29kZXdvcmRzLCBtYXRyaXhXaWR0aCwgbWF0cml4SGVpZ2h0LCBkYXRhUmVnaW9ucywgcnNCbG9ja0RhdGEsIHJzQmxvY2tFcnJvcikge1xuICAgICAgICBpZiAocnNCbG9ja0RhdGEgPT09IHZvaWQgMCkgeyByc0Jsb2NrRGF0YSA9IDA7IH1cbiAgICAgICAgaWYgKHJzQmxvY2tFcnJvciA9PT0gdm9pZCAwKSB7IHJzQmxvY2tFcnJvciA9IDA7IH1cbiAgICAgICAgdGhpcy5yZWN0YW5ndWxhciA9IHJlY3Rhbmd1bGFyO1xuICAgICAgICB0aGlzLmRhdGFDYXBhY2l0eSA9IGRhdGFDYXBhY2l0eTtcbiAgICAgICAgdGhpcy5lcnJvckNvZGV3b3JkcyA9IGVycm9yQ29kZXdvcmRzO1xuICAgICAgICB0aGlzLm1hdHJpeFdpZHRoID0gbWF0cml4V2lkdGg7XG4gICAgICAgIHRoaXMubWF0cml4SGVpZ2h0ID0gbWF0cml4SGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGFSZWdpb25zID0gZGF0YVJlZ2lvbnM7XG4gICAgICAgIHRoaXMucnNCbG9ja0RhdGEgPSByc0Jsb2NrRGF0YTtcbiAgICAgICAgdGhpcy5yc0Jsb2NrRXJyb3IgPSByc0Jsb2NrRXJyb3I7XG4gICAgfVxuICAgIFN5bWJvbEluZm8ubG9va3VwID0gZnVuY3Rpb24gKGRhdGFDb2Rld29yZHMsIHNoYXBlLCBtaW5TaXplLCBtYXhTaXplLCBmYWlsKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAoc2hhcGUgPT09IHZvaWQgMCkgeyBzaGFwZSA9IDAgLyogRk9SQ0VfTk9ORSAqLzsgfVxuICAgICAgICBpZiAobWluU2l6ZSA9PT0gdm9pZCAwKSB7IG1pblNpemUgPSBudWxsOyB9XG4gICAgICAgIGlmIChtYXhTaXplID09PSB2b2lkIDApIHsgbWF4U2l6ZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGZhaWwgPT09IHZvaWQgMCkgeyBmYWlsID0gdHJ1ZTsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgUFJPRF9TWU1CT0xTXzEgPSBfX3ZhbHVlcyhleHBvcnRzLlBST0RfU1lNQk9MUyksIFBST0RfU1lNQk9MU18xXzEgPSBQUk9EX1NZTUJPTFNfMS5uZXh0KCk7ICFQUk9EX1NZTUJPTFNfMV8xLmRvbmU7IFBST0RfU1lNQk9MU18xXzEgPSBQUk9EX1NZTUJPTFNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gUFJPRF9TWU1CT0xTXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT09IDEgLyogRk9SQ0VfU1FVQVJFICovICYmIHN5bWJvbC5yZWN0YW5ndWxhcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlID09PSAyIC8qIEZPUkNFX1JFQ1RBTkdMRSAqLyAmJiAhc3ltYm9sLnJlY3Rhbmd1bGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWluU2l6ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIChzeW1ib2wuZ2V0U3ltYm9sV2lkdGgoKSA8IG1pblNpemUuZ2V0V2lkdGgoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmdldFN5bWJvbEhlaWdodCgpIDwgbWluU2l6ZS5nZXRIZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXhTaXplICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN5bWJvbC5nZXRTeW1ib2xXaWR0aCgpID4gbWF4U2l6ZS5nZXRXaWR0aCgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZ2V0U3ltYm9sSGVpZ2h0KCkgPiBtYXhTaXplLmdldEhlaWdodCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDb2Rld29yZHMgPD0gc3ltYm9sLmRhdGFDYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFBST0RfU1lNQk9MU18xXzEgJiYgIVBST0RfU1lNQk9MU18xXzEuZG9uZSAmJiAoX2EgPSBQUk9EX1NZTUJPTFNfMS5yZXR1cm4pKSBfYS5jYWxsKFBST0RfU1lNQk9MU18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBhIHN5bWJvbCBhcnJhbmdlbWVudCB0aGF0IG1hdGNoZXMgdGhlIG1lc3NhZ2UuIERhdGEgY29kZXdvcmRzOiBcIiArXG4gICAgICAgICAgICAgICAgZGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXRIb3Jpem9udGFsRGF0YVJlZ2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kYXRhUmVnaW9ucykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhbmRsZSB0aGlzIG51bWJlciBvZiBkYXRhIHJlZ2lvbnMnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ltYm9sSW5mby5wcm90b3R5cGUuZ2V0VmVydGljYWxEYXRhUmVnaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRhdGFSZWdpb25zKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGFuZGxlIHRoaXMgbnVtYmVyIG9mIGRhdGEgcmVnaW9ucycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXRTeW1ib2xEYXRhV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhvcml6b250YWxEYXRhUmVnaW9ucygpICogdGhpcy5tYXRyaXhXaWR0aDtcbiAgICB9O1xuICAgIFN5bWJvbEluZm8ucHJvdG90eXBlLmdldFN5bWJvbERhdGFIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZlcnRpY2FsRGF0YVJlZ2lvbnMoKSAqIHRoaXMubWF0cml4SGVpZ2h0O1xuICAgIH07XG4gICAgU3ltYm9sSW5mby5wcm90b3R5cGUuZ2V0U3ltYm9sV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN5bWJvbERhdGFXaWR0aCgpICsgdGhpcy5nZXRIb3Jpem9udGFsRGF0YVJlZ2lvbnMoKSAqIDI7XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXRTeW1ib2xIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN5bWJvbERhdGFIZWlnaHQoKSArIHRoaXMuZ2V0VmVydGljYWxEYXRhUmVnaW9ucygpICogMjtcbiAgICB9O1xuICAgIFN5bWJvbEluZm8ucHJvdG90eXBlLmdldENvZGV3b3JkQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDYXBhY2l0eSArIHRoaXMuZXJyb3JDb2Rld29yZHM7XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXRJbnRlcmxlYXZlZEJsb2NrQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yc0Jsb2NrRGF0YSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2FwYWNpdHkgLyB0aGlzLnJzQmxvY2tEYXRhO1xuICAgIH07XG4gICAgU3ltYm9sSW5mby5wcm90b3R5cGUuZ2V0RGF0YUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2FwYWNpdHk7XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXRFcnJvckNvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb2Rld29yZHM7XG4gICAgfTtcbiAgICBTeW1ib2xJbmZvLnByb3RvdHlwZS5nZXREYXRhTGVuZ3RoRm9ySW50ZXJsZWF2ZWRCbG9jayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yc0Jsb2NrRGF0YTtcbiAgICB9O1xuICAgIFN5bWJvbEluZm8ucHJvdG90eXBlLmdldEVycm9yTGVuZ3RoRm9ySW50ZXJsZWF2ZWRCbG9jayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yc0Jsb2NrRXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gU3ltYm9sSW5mbztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTeW1ib2xJbmZvO1xudmFyIERhdGFNYXRyaXhTeW1ib2xJbmZvMTQ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRhTWF0cml4U3ltYm9sSW5mbzE0NCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRhTWF0cml4U3ltYm9sSW5mbzE0NCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlLCAxNTU4LCA2MjAsIDIyLCAyMiwgMzYsIC0xLCA2MikgfHwgdGhpcztcbiAgICB9XG4gICAgRGF0YU1hdHJpeFN5bWJvbEluZm8xNDQucHJvdG90eXBlLmdldEludGVybGVhdmVkQmxvY2tDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEwO1xuICAgIH07XG4gICAgRGF0YU1hdHJpeFN5bWJvbEluZm8xNDQucHJvdG90eXBlLmdldERhdGFMZW5ndGhGb3JJbnRlcmxlYXZlZEJsb2NrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA8PSA4ID8gMTU2IDogMTU1O1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFNYXRyaXhTeW1ib2xJbmZvMTQ0O1xufShTeW1ib2xJbmZvKSk7XG5leHBvcnRzLlBST0RfU1lNQk9MUyA9IFtcbiAgICBuZXcgU3ltYm9sSW5mbyhmYWxzZSwgMywgNSwgOCwgOCwgMSksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDUsIDcsIDEwLCAxMCwgMSksXG4gICAgLypyZWN0Ki8gbmV3IFN5bWJvbEluZm8odHJ1ZSwgNSwgNywgMTYsIDYsIDEpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCA4LCAxMCwgMTIsIDEyLCAxKSxcbiAgICAvKnJlY3QqLyBuZXcgU3ltYm9sSW5mbyh0cnVlLCAxMCwgMTEsIDE0LCA2LCAyKSxcbiAgICBuZXcgU3ltYm9sSW5mbyhmYWxzZSwgMTIsIDEyLCAxNCwgMTQsIDEpLFxuICAgIC8qcmVjdCovIG5ldyBTeW1ib2xJbmZvKHRydWUsIDE2LCAxNCwgMjQsIDEwLCAxKSxcbiAgICBuZXcgU3ltYm9sSW5mbyhmYWxzZSwgMTgsIDE0LCAxNiwgMTYsIDEpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAyMiwgMTgsIDE4LCAxOCwgMSksXG4gICAgLypyZWN0Ki8gbmV3IFN5bWJvbEluZm8odHJ1ZSwgMjIsIDE4LCAxNiwgMTAsIDIpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAzMCwgMjAsIDIwLCAyMCwgMSksXG4gICAgLypyZWN0Ki8gbmV3IFN5bWJvbEluZm8odHJ1ZSwgMzIsIDI0LCAxNiwgMTQsIDIpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAzNiwgMjQsIDIyLCAyMiwgMSksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDQ0LCAyOCwgMjQsIDI0LCAxKSxcbiAgICAvKnJlY3QqLyBuZXcgU3ltYm9sSW5mbyh0cnVlLCA0OSwgMjgsIDIyLCAxNCwgMiksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDYyLCAzNiwgMTQsIDE0LCA0KSxcbiAgICBuZXcgU3ltYm9sSW5mbyhmYWxzZSwgODYsIDQyLCAxNiwgMTYsIDQpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAxMTQsIDQ4LCAxOCwgMTgsIDQpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAxNDQsIDU2LCAyMCwgMjAsIDQpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAxNzQsIDY4LCAyMiwgMjIsIDQpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAyMDQsIDg0LCAyNCwgMjQsIDQsIDEwMiwgNDIpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCAyODAsIDExMiwgMTQsIDE0LCAxNiwgMTQwLCA1NiksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDM2OCwgMTQ0LCAxNiwgMTYsIDE2LCA5MiwgMzYpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCA0NTYsIDE5MiwgMTgsIDE4LCAxNiwgMTE0LCA0OCksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDU3NiwgMjI0LCAyMCwgMjAsIDE2LCAxNDQsIDU2KSxcbiAgICBuZXcgU3ltYm9sSW5mbyhmYWxzZSwgNjk2LCAyNzIsIDIyLCAyMiwgMTYsIDE3NCwgNjgpLFxuICAgIG5ldyBTeW1ib2xJbmZvKGZhbHNlLCA4MTYsIDMzNiwgMjQsIDI0LCAxNiwgMTM2LCA1NiksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDEwNTAsIDQwOCwgMTgsIDE4LCAzNiwgMTc1LCA2OCksXG4gICAgbmV3IFN5bWJvbEluZm8oZmFsc2UsIDEzMDQsIDQ5NiwgMjAsIDIwLCAzNiwgMTYzLCA2MiksXG4gICAgbmV3IERhdGFNYXRyaXhTeW1ib2xJbmZvMTQ0KCksXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextEncoder = void 0;\nvar C40Encoder_1 = __webpack_require__(/*! ./C40Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar TextEncoder = /** @class */ (function (_super) {\n    __extends(TextEncoder, _super);\n    function TextEncoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TextEncoder.prototype.getEncodingMode = function () {\n        return constants_1.TEXT_ENCODATION;\n    };\n    TextEncoder.prototype.encodeChar = function (c, sb) {\n        if (c === ' '.charCodeAt(0)) {\n            sb.append(3);\n            return 1;\n        }\n        if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {\n            sb.append(c - 48 + 4);\n            return 1;\n        }\n        if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n            sb.append(c - 97 + 14);\n            return 1;\n        }\n        if (c < ' '.charCodeAt(0)) {\n            sb.append(0); // Shift 1 Set\n            sb.append(c);\n            return 2;\n        }\n        if (c <= '/'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 33);\n            return 2;\n        }\n        if (c <= '@'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 58 + 15);\n            return 2;\n        }\n        if (c >= '['.charCodeAt(0) && c <= '_'.charCodeAt(0)) {\n            sb.append(1); // Shift 2 Set\n            sb.append(c - 91 + 22);\n            return 2;\n        }\n        if (c === '`'.charCodeAt(0)) {\n            sb.append(2); // Shift 3 Set\n            sb.append(0); // '`' - 96 == 0\n            return 2;\n        }\n        if (c <= 'Z'.charCodeAt(0)) {\n            sb.append(2); // Shift 3 Set\n            sb.append(c - 65 + 1);\n            return 2;\n        }\n        if (c <= 127) {\n            sb.append(2); // Shift 3 Set\n            sb.append(c - 123 + 27);\n            return 2;\n        }\n        sb.append(1 + \"\\u001E\"); // Shift 2, Upper Shift\n        var len = 2;\n        len += this.encodeChar(c - 128, sb);\n        return len;\n    };\n    return TextEncoder;\n}(C40Encoder_1.C40Encoder));\nexports.TextEncoder = TextEncoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvVGV4dEVuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsd0pBQWM7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsc0pBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL1RleHRFbmNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRFbmNvZGVyID0gdm9pZCAwO1xudmFyIEM0MEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0M0MEVuY29kZXJcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgVGV4dEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRFbmNvZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRFbmNvZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRleHRFbmNvZGVyLnByb3RvdHlwZS5nZXRFbmNvZGluZ01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNfMS5URVhUX0VOQ09EQVRJT047XG4gICAgfTtcbiAgICBUZXh0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlQ2hhciA9IGZ1bmN0aW9uIChjLCBzYikge1xuICAgICAgICBpZiAoYyA9PT0gJyAnLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgzKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID49ICcwJy5jaGFyQ29kZUF0KDApICYmIGMgPD0gJzknLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gNDggKyA0KTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID49ICdhJy5jaGFyQ29kZUF0KDApICYmIGMgPD0gJ3onLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gOTcgKyAxNCk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8ICcgJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBzYi5hcHBlbmQoMCk7IC8vIFNoaWZ0IDEgU2V0XG4gICAgICAgICAgICBzYi5hcHBlbmQoYyk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8PSAnLycuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDEpOyAvLyBTaGlmdCAyIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMgLSAzMyk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8PSAnQCcuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDEpOyAvLyBTaGlmdCAyIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMgLSA1OCArIDE1KTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID49ICdbJy5jaGFyQ29kZUF0KDApICYmIGMgPD0gJ18nLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgxKTsgLy8gU2hpZnQgMiBTZXRcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gOTEgKyAyMik7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ2AnLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgyKTsgLy8gU2hpZnQgMyBTZXRcbiAgICAgICAgICAgIHNiLmFwcGVuZCgwKTsgLy8gJ2AnIC0gOTYgPT0gMFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPD0gJ1onLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIHNiLmFwcGVuZCgyKTsgLy8gU2hpZnQgMyBTZXRcbiAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gNjUgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDw9IDEyNykge1xuICAgICAgICAgICAgc2IuYXBwZW5kKDIpOyAvLyBTaGlmdCAzIFNldFxuICAgICAgICAgICAgc2IuYXBwZW5kKGMgLSAxMjMgKyAyNyk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBzYi5hcHBlbmQoMSArIFwiXFx1MDAxRVwiKTsgLy8gU2hpZnQgMiwgVXBwZXIgU2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IDI7XG4gICAgICAgIGxlbiArPSB0aGlzLmVuY29kZUNoYXIoYyAtIDEyOCwgc2IpO1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRFbmNvZGVyO1xufShDNDBFbmNvZGVyXzEuQzQwRW5jb2RlcikpO1xuZXhwb3J0cy5UZXh0RW5jb2RlciA9IFRleHRFbmNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.X12Encoder = void 0;\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar C40Encoder_1 = __webpack_require__(/*! ./C40Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js\");\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nvar X12Encoder = /** @class */ (function (_super) {\n    __extends(X12Encoder, _super);\n    function X12Encoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    X12Encoder.prototype.getEncodingMode = function () {\n        return constants_1.X12_ENCODATION;\n    };\n    X12Encoder.prototype.encode = function (context) {\n        // step C\n        var buffer = new StringBuilder_1.default();\n        while (context.hasMoreCharacters()) {\n            var c = context.getCurrentChar();\n            context.pos++;\n            this.encodeChar(c, buffer);\n            var count = buffer.length();\n            if (count % 3 === 0) {\n                this.writeNextTriplet(context, buffer);\n                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());\n                if (newMode !== this.getEncodingMode()) {\n                    // Return to ASCII encodation, which will actually handle latch to new mode\n                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n                    break;\n                }\n            }\n        }\n        this.handleEOD(context, buffer);\n    };\n    X12Encoder.prototype.encodeChar = function (c, sb) {\n        switch (c) {\n            case 13: // CR (Carriage return)\n                sb.append(0);\n                break;\n            case '*'.charCodeAt(0):\n                sb.append(1);\n                break;\n            case '>'.charCodeAt(0):\n                sb.append(2);\n                break;\n            case ' '.charCodeAt(0):\n                sb.append(3);\n                break;\n            default:\n                if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {\n                    sb.append(c - 48 + 4);\n                }\n                else if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {\n                    sb.append(c - 65 + 14);\n                }\n                else {\n                    HighLevelEncoder_1.default.illegalCharacter(StringUtils_1.default.getCharAt(c));\n                }\n                break;\n        }\n        return 1;\n    };\n    X12Encoder.prototype.handleEOD = function (context, buffer) {\n        context.updateSymbolInfo();\n        var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();\n        var count = buffer.length();\n        context.pos -= count;\n        if (context.getRemainingCharacters() > 1 ||\n            available > 1 ||\n            context.getRemainingCharacters() !== available) {\n            context.writeCodeword(constants_1.X12_UNLATCH);\n        }\n        if (context.getNewEncoding() < 0) {\n            context.signalEncoderChange(constants_1.ASCII_ENCODATION);\n        }\n    };\n    return X12Encoder;\n}(C40Encoder_1.C40Encoder));\nexports.X12Encoder = X12Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvWDEyRW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDdEQsc0JBQXNCLG1CQUFPLENBQUMseUpBQTBCO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLHdKQUFjO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLG9LQUFvQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvWDEyRW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YMTJFbmNvZGVyID0gdm9pZCAwO1xudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgQzQwRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vQzQwRW5jb2RlclwiKTtcbnZhciBIaWdoTGV2ZWxFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9IaWdoTGV2ZWxFbmNvZGVyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIFgxMkVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFgxMkVuY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWDEyRW5jb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBYMTJFbmNvZGVyLnByb3RvdHlwZS5nZXRFbmNvZGluZ01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNfMS5YMTJfRU5DT0RBVElPTjtcbiAgICB9O1xuICAgIFgxMkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIC8vIHN0ZXAgQ1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHdoaWxlIChjb250ZXh0Lmhhc01vcmVDaGFyYWN0ZXJzKCkpIHtcbiAgICAgICAgICAgIHZhciBjID0gY29udGV4dC5nZXRDdXJyZW50Q2hhcigpO1xuICAgICAgICAgICAgY29udGV4dC5wb3MrKztcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ2hhcihjLCBidWZmZXIpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYnVmZmVyLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGNvdW50ICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVOZXh0VHJpcGxldChjb250ZXh0LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdNb2RlID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQubG9va0FoZWFkVGVzdChjb250ZXh0LmdldE1lc3NhZ2UoKSwgY29udGV4dC5wb3MsIHRoaXMuZ2V0RW5jb2RpbmdNb2RlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNb2RlICE9PSB0aGlzLmdldEVuY29kaW5nTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0byBBU0NJSSBlbmNvZGF0aW9uLCB3aGljaCB3aWxsIGFjdHVhbGx5IGhhbmRsZSBsYXRjaCB0byBuZXcgbW9kZVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVPRChjb250ZXh0LCBidWZmZXIpO1xuICAgIH07XG4gICAgWDEyRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlQ2hhciA9IGZ1bmN0aW9uIChjLCBzYikge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgMTM6IC8vIENSIChDYXJyaWFnZSByZXR1cm4pXG4gICAgICAgICAgICAgICAgc2IuYXBwZW5kKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKicuY2hhckNvZGVBdCgwKTpcbiAgICAgICAgICAgICAgICBzYi5hcHBlbmQoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+Jy5jaGFyQ29kZUF0KDApOlxuICAgICAgICAgICAgICAgIHNiLmFwcGVuZCgyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyAnLmNoYXJDb2RlQXQoMCk6XG4gICAgICAgICAgICAgICAgc2IuYXBwZW5kKDMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSAnMCcuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICc5Jy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gNDggKyA0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAnQScuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICdaJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLmFwcGVuZChjIC0gNjUgKyAxNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBIaWdoTGV2ZWxFbmNvZGVyXzEuZGVmYXVsdC5pbGxlZ2FsQ2hhcmFjdGVyKFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5nZXRDaGFyQXQoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIFgxMkVuY29kZXIucHJvdG90eXBlLmhhbmRsZUVPRCA9IGZ1bmN0aW9uIChjb250ZXh0LCBidWZmZXIpIHtcbiAgICAgICAgY29udGV4dC51cGRhdGVTeW1ib2xJbmZvKCk7XG4gICAgICAgIHZhciBhdmFpbGFibGUgPSBjb250ZXh0LmdldFN5bWJvbEluZm8oKS5nZXREYXRhQ2FwYWNpdHkoKSAtIGNvbnRleHQuZ2V0Q29kZXdvcmRDb3VudCgpO1xuICAgICAgICB2YXIgY291bnQgPSBidWZmZXIubGVuZ3RoKCk7XG4gICAgICAgIGNvbnRleHQucG9zIC09IGNvdW50O1xuICAgICAgICBpZiAoY29udGV4dC5nZXRSZW1haW5pbmdDaGFyYWN0ZXJzKCkgPiAxIHx8XG4gICAgICAgICAgICBhdmFpbGFibGUgPiAxIHx8XG4gICAgICAgICAgICBjb250ZXh0LmdldFJlbWFpbmluZ0NoYXJhY3RlcnMoKSAhPT0gYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBjb250ZXh0LndyaXRlQ29kZXdvcmQoY29uc3RhbnRzXzEuWDEyX1VOTEFUQ0gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmdldE5ld0VuY29kaW5nKCkgPCAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNpZ25hbEVuY29kZXJDaGFuZ2UoY29uc3RhbnRzXzEuQVNDSUlfRU5DT0RBVElPTik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBYMTJFbmNvZGVyO1xufShDNDBFbmNvZGVyXzEuQzQwRW5jb2RlcikpO1xuZXhwb3J0cy5YMTJFbmNvZGVyID0gWDEyRW5jb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BASE256_ENCODATION = exports.EDIFACT_ENCODATION = exports.X12_ENCODATION = exports.TEXT_ENCODATION = exports.C40_ENCODATION = exports.ASCII_ENCODATION = exports.MACRO_TRAILER = exports.MACRO_06_HEADER = exports.MACRO_05_HEADER = exports.X12_UNLATCH = exports.C40_UNLATCH = exports.LATCH_TO_EDIFACT = exports.LATCH_TO_TEXT = exports.LATCH_TO_ANSIX12 = exports.MACRO_06 = exports.MACRO_05 = exports.UPPER_SHIFT = exports.LATCH_TO_BASE256 = exports.LATCH_TO_C40 = exports.PAD = exports.SymbolShapeHint = exports.ALOG = exports.LOG = exports.MODULO_VALUE = exports.FACTORS = exports.FACTOR_SETS = void 0;\n/**\n * Lookup table which factors to use for which number of error correction codewords.\n * See FACTORS.\n */\nexports.FACTOR_SETS = [\n    5, 7, 10, 11, 12, 14, 18, 20, 24, 28, 36, 42, 48, 56, 62, 68,\n];\n/**\n * Precomputed polynomial factors for ECC 200.\n */\nexports.FACTORS = [\n    [228, 48, 15, 111, 62],\n    [23, 68, 144, 134, 240, 92, 254],\n    [28, 24, 185, 166, 223, 248, 116, 255, 110, 61],\n    [175, 138, 205, 12, 194, 168, 39, 245, 60, 97, 120],\n    [41, 153, 158, 91, 61, 42, 142, 213, 97, 178, 100, 242],\n    [156, 97, 192, 252, 95, 9, 157, 119, 138, 45, 18, 186, 83, 185],\n    [\n        83, 195, 100, 39, 188, 75, 66, 61, 241, 213, 109, 129, 94, 254, 225, 48, 90,\n        188,\n    ],\n    [\n        15, 195, 244, 9, 233, 71, 168, 2, 188, 160, 153, 145, 253, 79, 108, 82, 27,\n        174, 186, 172,\n    ],\n    [\n        52, 190, 88, 205, 109, 39, 176, 21, 155, 197, 251, 223, 155, 21, 5, 172,\n        254, 124, 12, 181, 184, 96, 50, 193,\n    ],\n    [\n        211, 231, 43, 97, 71, 96, 103, 174, 37, 151, 170, 53, 75, 34, 249, 121, 17,\n        138, 110, 213, 141, 136, 120, 151, 233, 168, 93, 255,\n    ],\n    [\n        245, 127, 242, 218, 130, 250, 162, 181, 102, 120, 84, 179, 220, 251, 80,\n        182, 229, 18, 2, 4, 68, 33, 101, 137, 95, 119, 115, 44, 175, 184, 59, 25,\n        225, 98, 81, 112,\n    ],\n    [\n        77, 193, 137, 31, 19, 38, 22, 153, 247, 105, 122, 2, 245, 133, 242, 8, 175,\n        95, 100, 9, 167, 105, 214, 111, 57, 121, 21, 1, 253, 57, 54, 101, 248, 202,\n        69, 50, 150, 177, 226, 5, 9, 5,\n    ],\n    [\n        245, 132, 172, 223, 96, 32, 117, 22, 238, 133, 238, 231, 205, 188, 237, 87,\n        191, 106, 16, 147, 118, 23, 37, 90, 170, 205, 131, 88, 120, 100, 66, 138,\n        186, 240, 82, 44, 176, 87, 187, 147, 160, 175, 69, 213, 92, 253, 225, 19,\n    ],\n    [\n        175, 9, 223, 238, 12, 17, 220, 208, 100, 29, 175, 170, 230, 192, 215, 235,\n        150, 159, 36, 223, 38, 200, 132, 54, 228, 146, 218, 234, 117, 203, 29, 232,\n        144, 238, 22, 150, 201, 117, 62, 207, 164, 13, 137, 245, 127, 67, 247, 28,\n        155, 43, 203, 107, 233, 53, 143, 46,\n    ],\n    [\n        242, 93, 169, 50, 144, 210, 39, 118, 202, 188, 201, 189, 143, 108, 196, 37,\n        185, 112, 134, 230, 245, 63, 197, 190, 250, 106, 185, 221, 175, 64, 114, 71,\n        161, 44, 147, 6, 27, 218, 51, 63, 87, 10, 40, 130, 188, 17, 163, 31, 176,\n        170, 4, 107, 232, 7, 94, 166, 224, 124, 86, 47, 11, 204,\n    ],\n    [\n        220, 228, 173, 89, 251, 149, 159, 56, 89, 33, 147, 244, 154, 36, 73, 127,\n        213, 136, 248, 180, 234, 197, 158, 177, 68, 122, 93, 213, 15, 160, 227, 236,\n        66, 139, 153, 185, 202, 167, 179, 25, 220, 232, 96, 210, 231, 136, 223, 239,\n        181, 241, 59, 52, 172, 25, 49, 232, 211, 189, 64, 54, 108, 153, 132, 63, 96,\n        103, 82, 186,\n    ],\n];\nexports.MODULO_VALUE = 0x12d;\nvar static_LOG = function (LOG, ALOG) {\n    var p = 1;\n    for (var i = 0; i < 255; i++) {\n        ALOG[i] = p;\n        LOG[p] = i;\n        p *= 2;\n        if (p >= 256) {\n            p ^= exports.MODULO_VALUE;\n        }\n    }\n    return {\n        LOG: LOG,\n        ALOG: ALOG,\n    };\n};\nexports.LOG = (_a = static_LOG([], []), _a.LOG), exports.ALOG = _a.ALOG;\nvar SymbolShapeHint;\n(function (SymbolShapeHint) {\n    SymbolShapeHint[SymbolShapeHint[\"FORCE_NONE\"] = 0] = \"FORCE_NONE\";\n    SymbolShapeHint[SymbolShapeHint[\"FORCE_SQUARE\"] = 1] = \"FORCE_SQUARE\";\n    SymbolShapeHint[SymbolShapeHint[\"FORCE_RECTANGLE\"] = 2] = \"FORCE_RECTANGLE\";\n})(SymbolShapeHint = exports.SymbolShapeHint || (exports.SymbolShapeHint = {}));\n/**\n * Padding character\n */\nexports.PAD = 129;\n/**\n * mode latch to C40 encodation mode\n */\nexports.LATCH_TO_C40 = 230;\n/**\n * mode latch to Base 256 encodation mode\n */\nexports.LATCH_TO_BASE256 = 231;\n/**\n * FNC1 Codeword\n */\n// private static FNC1 = 232;\n/**\n * Structured Append Codeword\n */\n// private static STRUCTURED_APPEND = 233;\n/**\n * Reader Programming\n */\n// private static READER_PROGRAMMING = 234;\n/**\n * Upper Shift\n */\nexports.UPPER_SHIFT = 235;\n/**\n * 05 Macro\n */\nexports.MACRO_05 = 236;\n/**\n * 06 Macro\n */\nexports.MACRO_06 = 237;\n/**\n * mode latch to ANSI X.12 encodation mode\n */\nexports.LATCH_TO_ANSIX12 = 238;\n/**\n * mode latch to Text encodation mode\n */\nexports.LATCH_TO_TEXT = 239;\n/**\n * mode latch to EDIFACT encodation mode\n */\nexports.LATCH_TO_EDIFACT = 240;\n/**\n * ECI character (Extended Channel Interpretation)\n */\n// private export const ECI = 241;\n/**\n * Unlatch from C40 encodation\n */\nexports.C40_UNLATCH = 254;\n/**\n * Unlatch from X12 encodation\n */\nexports.X12_UNLATCH = 254;\n/**\n * 05 Macro header\n */\nexports.MACRO_05_HEADER = '[)>\\u001E05\\u001D';\n/**\n * 06 Macro header\n */\nexports.MACRO_06_HEADER = '[)>\\u001E06\\u001D';\n/**\n * Macro trailer\n */\nexports.MACRO_TRAILER = '\\u001E\\u0004';\nexports.ASCII_ENCODATION = 0;\nexports.C40_ENCODATION = 1;\nexports.TEXT_ENCODATION = 2;\nexports.X12_ENCODATION = 3;\nexports.EDIFACT_ENCODATION = 4;\nexports.BASE256_ENCODATION = 5;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsV0FBVyxHQUFHLHVCQUF1QixHQUFHLFlBQVksR0FBRyxXQUFXLEdBQUcsb0JBQW9CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQjtBQUN0bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdELHVCQUF1QixLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLDBCQUEwQiIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CQVNFMjU2X0VOQ09EQVRJT04gPSBleHBvcnRzLkVESUZBQ1RfRU5DT0RBVElPTiA9IGV4cG9ydHMuWDEyX0VOQ09EQVRJT04gPSBleHBvcnRzLlRFWFRfRU5DT0RBVElPTiA9IGV4cG9ydHMuQzQwX0VOQ09EQVRJT04gPSBleHBvcnRzLkFTQ0lJX0VOQ09EQVRJT04gPSBleHBvcnRzLk1BQ1JPX1RSQUlMRVIgPSBleHBvcnRzLk1BQ1JPXzA2X0hFQURFUiA9IGV4cG9ydHMuTUFDUk9fMDVfSEVBREVSID0gZXhwb3J0cy5YMTJfVU5MQVRDSCA9IGV4cG9ydHMuQzQwX1VOTEFUQ0ggPSBleHBvcnRzLkxBVENIX1RPX0VESUZBQ1QgPSBleHBvcnRzLkxBVENIX1RPX1RFWFQgPSBleHBvcnRzLkxBVENIX1RPX0FOU0lYMTIgPSBleHBvcnRzLk1BQ1JPXzA2ID0gZXhwb3J0cy5NQUNST18wNSA9IGV4cG9ydHMuVVBQRVJfU0hJRlQgPSBleHBvcnRzLkxBVENIX1RPX0JBU0UyNTYgPSBleHBvcnRzLkxBVENIX1RPX0M0MCA9IGV4cG9ydHMuUEFEID0gZXhwb3J0cy5TeW1ib2xTaGFwZUhpbnQgPSBleHBvcnRzLkFMT0cgPSBleHBvcnRzLkxPRyA9IGV4cG9ydHMuTU9EVUxPX1ZBTFVFID0gZXhwb3J0cy5GQUNUT1JTID0gZXhwb3J0cy5GQUNUT1JfU0VUUyA9IHZvaWQgMDtcbi8qKlxuICogTG9va3VwIHRhYmxlIHdoaWNoIGZhY3RvcnMgdG8gdXNlIGZvciB3aGljaCBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG4gKiBTZWUgRkFDVE9SUy5cbiAqL1xuZXhwb3J0cy5GQUNUT1JfU0VUUyA9IFtcbiAgICA1LCA3LCAxMCwgMTEsIDEyLCAxNCwgMTgsIDIwLCAyNCwgMjgsIDM2LCA0MiwgNDgsIDU2LCA2MiwgNjgsXG5dO1xuLyoqXG4gKiBQcmVjb21wdXRlZCBwb2x5bm9taWFsIGZhY3RvcnMgZm9yIEVDQyAyMDAuXG4gKi9cbmV4cG9ydHMuRkFDVE9SUyA9IFtcbiAgICBbMjI4LCA0OCwgMTUsIDExMSwgNjJdLFxuICAgIFsyMywgNjgsIDE0NCwgMTM0LCAyNDAsIDkyLCAyNTRdLFxuICAgIFsyOCwgMjQsIDE4NSwgMTY2LCAyMjMsIDI0OCwgMTE2LCAyNTUsIDExMCwgNjFdLFxuICAgIFsxNzUsIDEzOCwgMjA1LCAxMiwgMTk0LCAxNjgsIDM5LCAyNDUsIDYwLCA5NywgMTIwXSxcbiAgICBbNDEsIDE1MywgMTU4LCA5MSwgNjEsIDQyLCAxNDIsIDIxMywgOTcsIDE3OCwgMTAwLCAyNDJdLFxuICAgIFsxNTYsIDk3LCAxOTIsIDI1MiwgOTUsIDksIDE1NywgMTE5LCAxMzgsIDQ1LCAxOCwgMTg2LCA4MywgMTg1XSxcbiAgICBbXG4gICAgICAgIDgzLCAxOTUsIDEwMCwgMzksIDE4OCwgNzUsIDY2LCA2MSwgMjQxLCAyMTMsIDEwOSwgMTI5LCA5NCwgMjU0LCAyMjUsIDQ4LCA5MCxcbiAgICAgICAgMTg4LFxuICAgIF0sXG4gICAgW1xuICAgICAgICAxNSwgMTk1LCAyNDQsIDksIDIzMywgNzEsIDE2OCwgMiwgMTg4LCAxNjAsIDE1MywgMTQ1LCAyNTMsIDc5LCAxMDgsIDgyLCAyNyxcbiAgICAgICAgMTc0LCAxODYsIDE3MixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgNTIsIDE5MCwgODgsIDIwNSwgMTA5LCAzOSwgMTc2LCAyMSwgMTU1LCAxOTcsIDI1MSwgMjIzLCAxNTUsIDIxLCA1LCAxNzIsXG4gICAgICAgIDI1NCwgMTI0LCAxMiwgMTgxLCAxODQsIDk2LCA1MCwgMTkzLFxuICAgIF0sXG4gICAgW1xuICAgICAgICAyMTEsIDIzMSwgNDMsIDk3LCA3MSwgOTYsIDEwMywgMTc0LCAzNywgMTUxLCAxNzAsIDUzLCA3NSwgMzQsIDI0OSwgMTIxLCAxNyxcbiAgICAgICAgMTM4LCAxMTAsIDIxMywgMTQxLCAxMzYsIDEyMCwgMTUxLCAyMzMsIDE2OCwgOTMsIDI1NSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgMjQ1LCAxMjcsIDI0MiwgMjE4LCAxMzAsIDI1MCwgMTYyLCAxODEsIDEwMiwgMTIwLCA4NCwgMTc5LCAyMjAsIDI1MSwgODAsXG4gICAgICAgIDE4MiwgMjI5LCAxOCwgMiwgNCwgNjgsIDMzLCAxMDEsIDEzNywgOTUsIDExOSwgMTE1LCA0NCwgMTc1LCAxODQsIDU5LCAyNSxcbiAgICAgICAgMjI1LCA5OCwgODEsIDExMixcbiAgICBdLFxuICAgIFtcbiAgICAgICAgNzcsIDE5MywgMTM3LCAzMSwgMTksIDM4LCAyMiwgMTUzLCAyNDcsIDEwNSwgMTIyLCAyLCAyNDUsIDEzMywgMjQyLCA4LCAxNzUsXG4gICAgICAgIDk1LCAxMDAsIDksIDE2NywgMTA1LCAyMTQsIDExMSwgNTcsIDEyMSwgMjEsIDEsIDI1MywgNTcsIDU0LCAxMDEsIDI0OCwgMjAyLFxuICAgICAgICA2OSwgNTAsIDE1MCwgMTc3LCAyMjYsIDUsIDksIDUsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIDI0NSwgMTMyLCAxNzIsIDIyMywgOTYsIDMyLCAxMTcsIDIyLCAyMzgsIDEzMywgMjM4LCAyMzEsIDIwNSwgMTg4LCAyMzcsIDg3LFxuICAgICAgICAxOTEsIDEwNiwgMTYsIDE0NywgMTE4LCAyMywgMzcsIDkwLCAxNzAsIDIwNSwgMTMxLCA4OCwgMTIwLCAxMDAsIDY2LCAxMzgsXG4gICAgICAgIDE4NiwgMjQwLCA4MiwgNDQsIDE3NiwgODcsIDE4NywgMTQ3LCAxNjAsIDE3NSwgNjksIDIxMywgOTIsIDI1MywgMjI1LCAxOSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgMTc1LCA5LCAyMjMsIDIzOCwgMTIsIDE3LCAyMjAsIDIwOCwgMTAwLCAyOSwgMTc1LCAxNzAsIDIzMCwgMTkyLCAyMTUsIDIzNSxcbiAgICAgICAgMTUwLCAxNTksIDM2LCAyMjMsIDM4LCAyMDAsIDEzMiwgNTQsIDIyOCwgMTQ2LCAyMTgsIDIzNCwgMTE3LCAyMDMsIDI5LCAyMzIsXG4gICAgICAgIDE0NCwgMjM4LCAyMiwgMTUwLCAyMDEsIDExNywgNjIsIDIwNywgMTY0LCAxMywgMTM3LCAyNDUsIDEyNywgNjcsIDI0NywgMjgsXG4gICAgICAgIDE1NSwgNDMsIDIwMywgMTA3LCAyMzMsIDUzLCAxNDMsIDQ2LFxuICAgIF0sXG4gICAgW1xuICAgICAgICAyNDIsIDkzLCAxNjksIDUwLCAxNDQsIDIxMCwgMzksIDExOCwgMjAyLCAxODgsIDIwMSwgMTg5LCAxNDMsIDEwOCwgMTk2LCAzNyxcbiAgICAgICAgMTg1LCAxMTIsIDEzNCwgMjMwLCAyNDUsIDYzLCAxOTcsIDE5MCwgMjUwLCAxMDYsIDE4NSwgMjIxLCAxNzUsIDY0LCAxMTQsIDcxLFxuICAgICAgICAxNjEsIDQ0LCAxNDcsIDYsIDI3LCAyMTgsIDUxLCA2MywgODcsIDEwLCA0MCwgMTMwLCAxODgsIDE3LCAxNjMsIDMxLCAxNzYsXG4gICAgICAgIDE3MCwgNCwgMTA3LCAyMzIsIDcsIDk0LCAxNjYsIDIyNCwgMTI0LCA4NiwgNDcsIDExLCAyMDQsXG4gICAgXSxcbiAgICBbXG4gICAgICAgIDIyMCwgMjI4LCAxNzMsIDg5LCAyNTEsIDE0OSwgMTU5LCA1NiwgODksIDMzLCAxNDcsIDI0NCwgMTU0LCAzNiwgNzMsIDEyNyxcbiAgICAgICAgMjEzLCAxMzYsIDI0OCwgMTgwLCAyMzQsIDE5NywgMTU4LCAxNzcsIDY4LCAxMjIsIDkzLCAyMTMsIDE1LCAxNjAsIDIyNywgMjM2LFxuICAgICAgICA2NiwgMTM5LCAxNTMsIDE4NSwgMjAyLCAxNjcsIDE3OSwgMjUsIDIyMCwgMjMyLCA5NiwgMjEwLCAyMzEsIDEzNiwgMjIzLCAyMzksXG4gICAgICAgIDE4MSwgMjQxLCA1OSwgNTIsIDE3MiwgMjUsIDQ5LCAyMzIsIDIxMSwgMTg5LCA2NCwgNTQsIDEwOCwgMTUzLCAxMzIsIDYzLCA5NixcbiAgICAgICAgMTAzLCA4MiwgMTg2LFxuICAgIF0sXG5dO1xuZXhwb3J0cy5NT0RVTE9fVkFMVUUgPSAweDEyZDtcbnZhciBzdGF0aWNfTE9HID0gZnVuY3Rpb24gKExPRywgQUxPRykge1xuICAgIHZhciBwID0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgICAgIEFMT0dbaV0gPSBwO1xuICAgICAgICBMT0dbcF0gPSBpO1xuICAgICAgICBwICo9IDI7XG4gICAgICAgIGlmIChwID49IDI1Nikge1xuICAgICAgICAgICAgcCBePSBleHBvcnRzLk1PRFVMT19WQUxVRTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBMT0c6IExPRyxcbiAgICAgICAgQUxPRzogQUxPRyxcbiAgICB9O1xufTtcbmV4cG9ydHMuTE9HID0gKF9hID0gc3RhdGljX0xPRyhbXSwgW10pLCBfYS5MT0cpLCBleHBvcnRzLkFMT0cgPSBfYS5BTE9HO1xudmFyIFN5bWJvbFNoYXBlSGludDtcbihmdW5jdGlvbiAoU3ltYm9sU2hhcGVIaW50KSB7XG4gICAgU3ltYm9sU2hhcGVIaW50W1N5bWJvbFNoYXBlSGludFtcIkZPUkNFX05PTkVcIl0gPSAwXSA9IFwiRk9SQ0VfTk9ORVwiO1xuICAgIFN5bWJvbFNoYXBlSGludFtTeW1ib2xTaGFwZUhpbnRbXCJGT1JDRV9TUVVBUkVcIl0gPSAxXSA9IFwiRk9SQ0VfU1FVQVJFXCI7XG4gICAgU3ltYm9sU2hhcGVIaW50W1N5bWJvbFNoYXBlSGludFtcIkZPUkNFX1JFQ1RBTkdMRVwiXSA9IDJdID0gXCJGT1JDRV9SRUNUQU5HTEVcIjtcbn0pKFN5bWJvbFNoYXBlSGludCA9IGV4cG9ydHMuU3ltYm9sU2hhcGVIaW50IHx8IChleHBvcnRzLlN5bWJvbFNoYXBlSGludCA9IHt9KSk7XG4vKipcbiAqIFBhZGRpbmcgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydHMuUEFEID0gMTI5O1xuLyoqXG4gKiBtb2RlIGxhdGNoIHRvIEM0MCBlbmNvZGF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0cy5MQVRDSF9UT19DNDAgPSAyMzA7XG4vKipcbiAqIG1vZGUgbGF0Y2ggdG8gQmFzZSAyNTYgZW5jb2RhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydHMuTEFUQ0hfVE9fQkFTRTI1NiA9IDIzMTtcbi8qKlxuICogRk5DMSBDb2Rld29yZFxuICovXG4vLyBwcml2YXRlIHN0YXRpYyBGTkMxID0gMjMyO1xuLyoqXG4gKiBTdHJ1Y3R1cmVkIEFwcGVuZCBDb2Rld29yZFxuICovXG4vLyBwcml2YXRlIHN0YXRpYyBTVFJVQ1RVUkVEX0FQUEVORCA9IDIzMztcbi8qKlxuICogUmVhZGVyIFByb2dyYW1taW5nXG4gKi9cbi8vIHByaXZhdGUgc3RhdGljIFJFQURFUl9QUk9HUkFNTUlORyA9IDIzNDtcbi8qKlxuICogVXBwZXIgU2hpZnRcbiAqL1xuZXhwb3J0cy5VUFBFUl9TSElGVCA9IDIzNTtcbi8qKlxuICogMDUgTWFjcm9cbiAqL1xuZXhwb3J0cy5NQUNST18wNSA9IDIzNjtcbi8qKlxuICogMDYgTWFjcm9cbiAqL1xuZXhwb3J0cy5NQUNST18wNiA9IDIzNztcbi8qKlxuICogbW9kZSBsYXRjaCB0byBBTlNJIFguMTIgZW5jb2RhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydHMuTEFUQ0hfVE9fQU5TSVgxMiA9IDIzODtcbi8qKlxuICogbW9kZSBsYXRjaCB0byBUZXh0IGVuY29kYXRpb24gbW9kZVxuICovXG5leHBvcnRzLkxBVENIX1RPX1RFWFQgPSAyMzk7XG4vKipcbiAqIG1vZGUgbGF0Y2ggdG8gRURJRkFDVCBlbmNvZGF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0cy5MQVRDSF9UT19FRElGQUNUID0gMjQwO1xuLyoqXG4gKiBFQ0kgY2hhcmFjdGVyIChFeHRlbmRlZCBDaGFubmVsIEludGVycHJldGF0aW9uKVxuICovXG4vLyBwcml2YXRlIGV4cG9ydCBjb25zdCBFQ0kgPSAyNDE7XG4vKipcbiAqIFVubGF0Y2ggZnJvbSBDNDAgZW5jb2RhdGlvblxuICovXG5leHBvcnRzLkM0MF9VTkxBVENIID0gMjU0O1xuLyoqXG4gKiBVbmxhdGNoIGZyb20gWDEyIGVuY29kYXRpb25cbiAqL1xuZXhwb3J0cy5YMTJfVU5MQVRDSCA9IDI1NDtcbi8qKlxuICogMDUgTWFjcm8gaGVhZGVyXG4gKi9cbmV4cG9ydHMuTUFDUk9fMDVfSEVBREVSID0gJ1spPlxcdTAwMUUwNVxcdTAwMUQnO1xuLyoqXG4gKiAwNiBNYWNybyBoZWFkZXJcbiAqL1xuZXhwb3J0cy5NQUNST18wNl9IRUFERVIgPSAnWyk+XFx1MDAxRTA2XFx1MDAxRCc7XG4vKipcbiAqIE1hY3JvIHRyYWlsZXJcbiAqL1xuZXhwb3J0cy5NQUNST19UUkFJTEVSID0gJ1xcdTAwMUVcXHUwMDA0JztcbmV4cG9ydHMuQVNDSUlfRU5DT0RBVElPTiA9IDA7XG5leHBvcnRzLkM0MF9FTkNPREFUSU9OID0gMTtcbmV4cG9ydHMuVEVYVF9FTkNPREFUSU9OID0gMjtcbmV4cG9ydHMuWDEyX0VOQ09EQVRJT04gPSAzO1xuZXhwb3J0cy5FRElGQUNUX0VOQ09EQVRJT04gPSA0O1xuZXhwb3J0cy5CQVNFMjU2X0VOQ09EQVRJT04gPSA1O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.X12Encoder = exports.TextEncoder = exports.SymbolInfo = exports.MinimalEncoder = exports.HighLevelEncoder = exports.DefaultPlacement = exports.ErrorCorrection = exports.EncoderContext = exports.EdifactEncoder = exports.C40Encoder = exports.Base256Encoder = exports.ASCIIEncoder = void 0;\nvar ASCIIEncoder_1 = __webpack_require__(/*! ./ASCIIEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js\");\nObject.defineProperty(exports, \"ASCIIEncoder\", ({ enumerable: true, get: function () { return ASCIIEncoder_1.ASCIIEncoder; } }));\nvar Base256Encoder_1 = __webpack_require__(/*! ./Base256Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js\");\nObject.defineProperty(exports, \"Base256Encoder\", ({ enumerable: true, get: function () { return Base256Encoder_1.Base256Encoder; } }));\nvar C40Encoder_1 = __webpack_require__(/*! ./C40Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js\");\nObject.defineProperty(exports, \"C40Encoder\", ({ enumerable: true, get: function () { return C40Encoder_1.C40Encoder; } }));\nvar DefaultPlacement_1 = __webpack_require__(/*! ./DefaultPlacement */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js\");\nexports.DefaultPlacement = DefaultPlacement_1.default;\nvar EdifactEncoder_1 = __webpack_require__(/*! ./EdifactEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js\");\nObject.defineProperty(exports, \"EdifactEncoder\", ({ enumerable: true, get: function () { return EdifactEncoder_1.EdifactEncoder; } }));\nvar EncoderContext_1 = __webpack_require__(/*! ./EncoderContext */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js\");\nObject.defineProperty(exports, \"EncoderContext\", ({ enumerable: true, get: function () { return EncoderContext_1.EncoderContext; } }));\nvar ErrorCorrection_1 = __webpack_require__(/*! ./ErrorCorrection */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js\");\nexports.ErrorCorrection = ErrorCorrection_1.default;\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nexports.HighLevelEncoder = HighLevelEncoder_1.default;\nvar MinimalEncoder_1 = __webpack_require__(/*! ./MinimalEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js\");\nObject.defineProperty(exports, \"MinimalEncoder\", ({ enumerable: true, get: function () { return MinimalEncoder_1.MinimalEncoder; } }));\nvar SymbolInfo_1 = __webpack_require__(/*! ./SymbolInfo */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js\");\nexports.SymbolInfo = SymbolInfo_1.default;\nvar TextEncoder_1 = __webpack_require__(/*! ./TextEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js\");\nObject.defineProperty(exports, \"TextEncoder\", ({ enumerable: true, get: function () { return TextEncoder_1.TextEncoder; } }));\nvar X12Encoder_1 = __webpack_require__(/*! ./X12Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js\");\nObject.defineProperty(exports, \"X12Encoder\", ({ enumerable: true, get: function () { return X12Encoder_1.X12Encoder; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9kYXRhbWF0cml4L2VuY29kZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CO0FBQzdSLHFCQUFxQixtQkFBTyxDQUFDLDRKQUFnQjtBQUM3QyxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsdUJBQXVCLG1CQUFPLENBQUMsZ0tBQWtCO0FBQ2pELGtEQUFpRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNwSSxtQkFBbUIsbUJBQU8sQ0FBQyx3SkFBYztBQUN6Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgseUJBQXlCLG1CQUFPLENBQUMsb0tBQW9CO0FBQ3JELHdCQUF3QjtBQUN4Qix1QkFBdUIsbUJBQU8sQ0FBQyxnS0FBa0I7QUFDakQsa0RBQWlELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3BJLHVCQUF1QixtQkFBTyxDQUFDLGdLQUFrQjtBQUNqRCxrREFBaUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDcEksd0JBQXdCLG1CQUFPLENBQUMsa0tBQW1CO0FBQ25ELHVCQUF1QjtBQUN2Qix5QkFBeUIsbUJBQU8sQ0FBQyxvS0FBb0I7QUFDckQsd0JBQXdCO0FBQ3hCLHVCQUF1QixtQkFBTyxDQUFDLGdLQUFrQjtBQUNqRCxrREFBaUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDcEksbUJBQW1CLG1CQUFPLENBQUMsd0pBQWM7QUFDekMsa0JBQWtCO0FBQ2xCLG9CQUFvQixtQkFBTyxDQUFDLDBKQUFlO0FBQzNDLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxtQkFBbUIsbUJBQU8sQ0FBQyx3SkFBYztBQUN6Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YMTJFbmNvZGVyID0gZXhwb3J0cy5UZXh0RW5jb2RlciA9IGV4cG9ydHMuU3ltYm9sSW5mbyA9IGV4cG9ydHMuTWluaW1hbEVuY29kZXIgPSBleHBvcnRzLkhpZ2hMZXZlbEVuY29kZXIgPSBleHBvcnRzLkRlZmF1bHRQbGFjZW1lbnQgPSBleHBvcnRzLkVycm9yQ29ycmVjdGlvbiA9IGV4cG9ydHMuRW5jb2RlckNvbnRleHQgPSBleHBvcnRzLkVkaWZhY3RFbmNvZGVyID0gZXhwb3J0cy5DNDBFbmNvZGVyID0gZXhwb3J0cy5CYXNlMjU2RW5jb2RlciA9IGV4cG9ydHMuQVNDSUlFbmNvZGVyID0gdm9pZCAwO1xudmFyIEFTQ0lJRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vQVNDSUlFbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQVNDSUlFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBU0NJSUVuY29kZXJfMS5BU0NJSUVuY29kZXI7IH0gfSk7XG52YXIgQmFzZTI1NkVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2UyNTZFbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZTI1NkVuY29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2UyNTZFbmNvZGVyXzEuQmFzZTI1NkVuY29kZXI7IH0gfSk7XG52YXIgQzQwRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vQzQwRW5jb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkM0MEVuY29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEM0MEVuY29kZXJfMS5DNDBFbmNvZGVyOyB9IH0pO1xudmFyIERlZmF1bHRQbGFjZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHRQbGFjZW1lbnRcIik7XG5leHBvcnRzLkRlZmF1bHRQbGFjZW1lbnQgPSBEZWZhdWx0UGxhY2VtZW50XzEuZGVmYXVsdDtcbnZhciBFZGlmYWN0RW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vRWRpZmFjdEVuY29kZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFZGlmYWN0RW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRWRpZmFjdEVuY29kZXJfMS5FZGlmYWN0RW5jb2RlcjsgfSB9KTtcbnZhciBFbmNvZGVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vRW5jb2RlckNvbnRleHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbmNvZGVyQ29udGV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW5jb2RlckNvbnRleHRfMS5FbmNvZGVyQ29udGV4dDsgfSB9KTtcbnZhciBFcnJvckNvcnJlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL0Vycm9yQ29ycmVjdGlvblwiKTtcbmV4cG9ydHMuRXJyb3JDb3JyZWN0aW9uID0gRXJyb3JDb3JyZWN0aW9uXzEuZGVmYXVsdDtcbnZhciBIaWdoTGV2ZWxFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9IaWdoTGV2ZWxFbmNvZGVyXCIpO1xuZXhwb3J0cy5IaWdoTGV2ZWxFbmNvZGVyID0gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQ7XG52YXIgTWluaW1hbEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL01pbmltYWxFbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWluaW1hbEVuY29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1pbmltYWxFbmNvZGVyXzEuTWluaW1hbEVuY29kZXI7IH0gfSk7XG52YXIgU3ltYm9sSW5mb18xID0gcmVxdWlyZShcIi4vU3ltYm9sSW5mb1wiKTtcbmV4cG9ydHMuU3ltYm9sSW5mbyA9IFN5bWJvbEluZm9fMS5kZWZhdWx0O1xudmFyIFRleHRFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9UZXh0RW5jb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRleHRFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBUZXh0RW5jb2Rlcl8xLlRleHRFbmNvZGVyOyB9IH0pO1xudmFyIFgxMkVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL1gxMkVuY29kZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYMTJFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBYMTJFbmNvZGVyXzEuWDEyRW5jb2RlcjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar AbstractUPCEANReader = /** @class */ (function (_super) {\n    __extends(AbstractUPCEANReader, _super);\n    function AbstractUPCEANReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.decodeRowStringBuffer = '';\n        return _this;\n    }\n    // private final UPCEANExtensionSupport extensionReader;\n    // private final EANManufacturerOrgSupport eanManSupport;\n    /*\n    protected UPCEANReader() {\n        decodeRowStringBuffer = new StringBuilder(20);\n        extensionReader = new UPCEANExtensionSupport();\n        eanManSupport = new EANManufacturerOrgSupport();\n    }\n    */\n    AbstractUPCEANReader.findStartGuardPattern = function (row) {\n        var foundStart = false;\n        var startRange;\n        var nextStart = 0;\n        var counters = Int32Array.from([0, 0, 0]);\n        while (!foundStart) {\n            counters = Int32Array.from([0, 0, 0]);\n            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n            var start = startRange[0];\n            nextStart = startRange[1];\n            var quietStart = start - (nextStart - start);\n            if (quietStart >= 0) {\n                foundStart = row.isRange(quietStart, start, false);\n            }\n        }\n        return startRange;\n    };\n    AbstractUPCEANReader.checkChecksum = function (s) {\n        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    /**\n     * @throws NotFoundException\n     */\n    AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {\n        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n    };\n    /**\n     * @param row row of black/white values to search\n     * @param rowOffset position to start search\n     * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n     * pixel counts, otherwise, it is interpreted as black/white/black/...\n     * @param pattern pattern of counts of number of black and white pixels that are being\n     * searched for as a pattern\n     * @param counters array of counters, as long as pattern, to re-use\n     * @return start/end horizontal offset of guard pattern, as an array of two ints\n     * @throws NotFoundException if pattern is not found\n     */\n    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n        var width = row.getSize();\n        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var patternLength = pattern.length;\n        var isWhite = whiteFirst;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                        return Int32Array.from([patternStart, x]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    var slice = counters.slice(2, counters.length);\n                    for (var i = 0; i < counterPosition - 1; i++) {\n                        counters[i] = slice[i];\n                    }\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n        this.recordPattern(row, rowOffset, counters);\n        var bestVariance = this.MAX_AVG_VARIANCE;\n        var bestMatch = -1;\n        var max = patterns.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = patterns[i];\n            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([3, 2, 1, 1]),\n        Int32Array.from([2, 2, 2, 1]),\n        Int32Array.from([2, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 1]),\n        Int32Array.from([1, 1, 3, 2]),\n        Int32Array.from([1, 2, 3, 1]),\n        Int32Array.from([1, 1, 1, 4]),\n        Int32Array.from([1, 3, 1, 2]),\n        Int32Array.from([1, 2, 1, 3]),\n        Int32Array.from([3, 1, 1, 2]),\n    ];\n    return AbstractUPCEANReader;\n}(OneDReader_1.default));\nexports[\"default\"] = AbstractUPCEANReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0Fic3RyYWN0VVBDRUFOUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLGdKQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9BYnN0cmFjdFVQQ0VBTlJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vT25lRFJlYWRlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxuICpcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBhbGFzZGFpckBnb29nbGUuY29tIChBbGFzZGFpciBNYWNraW50b3NoKVxuICovXG52YXIgQWJzdHJhY3RVUENFQU5SZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0VVBDRUFOUmVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0VVBDRUFOUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBmaW5hbCBVUENFQU5FeHRlbnNpb25TdXBwb3J0IGV4dGVuc2lvblJlYWRlcjtcbiAgICAvLyBwcml2YXRlIGZpbmFsIEVBTk1hbnVmYWN0dXJlck9yZ1N1cHBvcnQgZWFuTWFuU3VwcG9ydDtcbiAgICAvKlxuICAgIHByb3RlY3RlZCBVUENFQU5SZWFkZXIoKSB7XG4gICAgICAgIGRlY29kZVJvd1N0cmluZ0J1ZmZlciA9IG5ldyBTdHJpbmdCdWlsZGVyKDIwKTtcbiAgICAgICAgZXh0ZW5zaW9uUmVhZGVyID0gbmV3IFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQoKTtcbiAgICAgICAgZWFuTWFuU3VwcG9ydCA9IG5ldyBFQU5NYW51ZmFjdHVyZXJPcmdTdXBwb3J0KCk7XG4gICAgfVxuICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZFN0YXJ0R3VhcmRQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgZm91bmRTdGFydCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnRSYW5nZTtcbiAgICAgICAgdmFyIG5leHRTdGFydCA9IDA7XG4gICAgICAgIHZhciBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pO1xuICAgICAgICB3aGlsZSAoIWZvdW5kU3RhcnQpIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSk7XG4gICAgICAgICAgICBzdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIG5leHRTdGFydCwgZmFsc2UsIHRoaXMuU1RBUlRfRU5EX1BBVFRFUk4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHN0YXJ0UmFuZ2VbMF07XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgdmFyIHF1aWV0U3RhcnQgPSBzdGFydCAtIChuZXh0U3RhcnQgLSBzdGFydCk7XG4gICAgICAgICAgICBpZiAocXVpZXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IHJvdy5pc1JhbmdlKHF1aWV0U3RhcnQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0UmFuZ2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5jaGVja0NoZWNrc3VtID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNoZWNrID0gcGFyc2VJbnQocy5jaGFyQXQobGVuZ3RoIC0gMSksIDEwKTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocy5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gMSkpID09PSBjaGVjaztcbiAgICB9O1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxMDAwIC0gc3VtKSAlIDEwO1xuICAgIH07XG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRW5kID0gZnVuY3Rpb24gKHJvdywgZW5kU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgZmFsc2UsIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLCBuZXcgSW50MzJBcnJheShBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm5XaXRob3V0Q291bnRlcnMgPSBmdW5jdGlvbiAocm93LCByb3dPZmZzZXQsIHdoaXRlRmlyc3QsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgd2hpdGVGaXJzdCwgcGF0dGVybiwgbmV3IEludDMyQXJyYXkocGF0dGVybi5sZW5ndGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAqIEBwYXJhbSB3aGl0ZUZpcnN0IGlmIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBwYXR0ZXJuIHNwZWNpZmllcyB3aGl0ZS9ibGFjay93aGl0ZS8uLi5cbiAgICAgKiBwaXhlbCBjb3VudHMsIG90aGVyd2lzZSwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYmxhY2svd2hpdGUvYmxhY2svLi4uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmUgYmVpbmdcbiAgICAgKiBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIGNvdW50ZXJzIGFycmF5IG9mIGNvdW50ZXJzLCBhcyBsb25nIGFzIHBhdHRlcm4sIHRvIHJlLXVzZVxuICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4gPSBmdW5jdGlvbiAocm93LCByb3dPZmZzZXQsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHJvd09mZnNldCA9IHdoaXRlRmlyc3QgPyByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCkgOiByb3cuZ2V0TmV4dFNldChyb3dPZmZzZXQpO1xuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgdmFyIGlzV2hpdGUgPSB3aGl0ZUZpcnN0O1xuICAgICAgICBmb3IgKHZhciB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3BhdHRlcm5TdGFydCwgeF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2UgPSBjb3VudGVycy5zbGljZSgyLCBjb3VudGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ZXJQb3NpdGlvbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBzbGljZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQgPSBmdW5jdGlvbiAocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnJlY29yZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIGNvdW50ZXJzKTtcbiAgICAgICAgdmFyIGJlc3RWYXJpYW5jZSA9IHRoaXMuTUFYX0FWR19WQVJJQU5DRTtcbiAgICAgICAgdmFyIGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICB2YXIgbWF4ID0gcGF0dGVybnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGVzZSB0d28gdmFsdWVzIGFyZSBjcml0aWNhbCBmb3IgZGV0ZXJtaW5pbmcgaG93IHBlcm1pc3NpdmUgdGhlIGRlY29kaW5nIHdpbGwgYmUuXG4gICAgLy8gV2UndmUgYXJyaXZlZCBhdCB0aGVzZSB2YWx1ZXMgdGhyb3VnaCBhIGxvdCBvZiB0cmlhbCBhbmQgZXJyb3IuIFNldHRpbmcgdGhlbSBhbnkgaGlnaGVyXG4gICAgLy8gbGV0cyBmYWxzZSBwb3NpdGl2ZXMgY3JlZXAgaW4gcXVpY2tseS5cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC40ODtcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcbiAgICAvKipcbiAgICAgKiBTdGFydC9lbmQgZ3VhcmQgcGF0dGVybi5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMV0pO1xuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gbWFya2luZyB0aGUgbWlkZGxlIG9mIGEgVVBDL0VBTiBwYXR0ZXJuLCBzZXBhcmF0aW5nIHRoZSB0d28gaGFsdmVzLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSk7XG4gICAgLyoqXG4gICAgICogZW5kIGd1YXJkIHBhdHRlcm4uXG4gICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuRU5EX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDEsIDFdKTtcbiAgICAvKipcbiAgICAgKiBcIk9kZFwiLCBvciBcIkxcIiBwYXR0ZXJucyB1c2VkIHRvIGVuY29kZSBVUEMvRUFOIGRpZ2l0cy5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDJdKSxcbiAgICBdO1xuICAgIHJldHVybiBBYnN0cmFjdFVQQ0VBTlJlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * <p>Decodes CodaBar barcodes. </p>\n *\n * @author Evan @dodobelieve\n * @see CodaBarReader\n */\nvar CodaBarReader = /** @class */ (function (_super) {\n    __extends(CodaBarReader, _super);\n    function CodaBarReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.CODA_BAR_CHAR_SET = {\n            nnnnnww: '0',\n            nnnnwwn: '1',\n            nnnwnnw: '2',\n            wwnnnnn: '3',\n            nnwnnwn: '4',\n            wnnnnwn: '5',\n            nwnnnnw: '6',\n            nwnnwnn: '7',\n            nwwnnnn: '8',\n            wnnwnnn: '9',\n            nnnwwnn: '-',\n            nnwwnnn: '$',\n            wnnnwnw: ':',\n            wnwnnnw: '/',\n            wnwnwnn: '.',\n            nnwwwww: '+',\n            nnwwnwn: 'A',\n            nwnwnnw: 'B',\n            nnnwnww: 'C',\n            nnnwwwn: 'D'\n        };\n        return _this;\n    }\n    CodaBarReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var validRowData = this.getValidRowData(row);\n        if (!validRowData)\n            throw new NotFoundException_1.default();\n        var retStr = this.codaBarDecodeRow(validRowData.row);\n        if (!retStr)\n            throw new NotFoundException_1.default();\n        return new Result_1.default(retStr, null, 0, [new ResultPoint_1.default(validRowData.left, rowNumber), new ResultPoint_1.default(validRowData.right, rowNumber)], BarcodeFormat_1.default.CODABAR, new Date().getTime());\n    };\n    /**\n     * converts bit array to valid data array(lengths of black bits and white bits)\n     * @param row bit array to convert\n     */\n    CodaBarReader.prototype.getValidRowData = function (row) {\n        var booleanArr = row.toArray();\n        var startIndex = booleanArr.indexOf(true);\n        if (startIndex === -1)\n            return null;\n        var lastIndex = booleanArr.lastIndexOf(true);\n        if (lastIndex <= startIndex)\n            return null;\n        booleanArr = booleanArr.slice(startIndex, lastIndex + 1);\n        var result = [];\n        var lastBit = booleanArr[0];\n        var bitLength = 1;\n        for (var i = 1; i < booleanArr.length; i++) {\n            if (booleanArr[i] === lastBit) {\n                bitLength++;\n            }\n            else {\n                lastBit = booleanArr[i];\n                result.push(bitLength);\n                bitLength = 1;\n            }\n        }\n        result.push(bitLength);\n        // CodaBar code data valid\n        if (result.length < 23 && (result.length + 1) % 8 !== 0)\n            return null;\n        return { row: result, left: startIndex, right: lastIndex };\n    };\n    /**\n     * decode codabar code\n     * @param row row to cecode\n     */\n    CodaBarReader.prototype.codaBarDecodeRow = function (row) {\n        var code = [];\n        var barThreshold = Math.ceil(row.reduce(function (pre, item) { return (pre + item) / 2; }, 0));\n        // Read one encoded character at a time.\n        while (row.length > 0) {\n            var seg = row.splice(0, 8).splice(0, 7);\n            var key = seg.map(function (len) { return (len < barThreshold ? 'n' : 'w'); }).join('');\n            if (this.CODA_BAR_CHAR_SET[key] === undefined)\n                return null;\n            code.push(this.CODA_BAR_CHAR_SET[key]);\n        }\n        var strCode = code.join('');\n        if (this.validCodaBarString(strCode))\n            return strCode;\n        return null;\n    };\n    /**\n     * check if the string is a CodaBar string\n     * @param src string to determine\n     */\n    CodaBarReader.prototype.validCodaBarString = function (src) {\n        var reg = /^[A-D].{1,}[A-D]$/;\n        return reg.test(src);\n    };\n    return CodaBarReader;\n}(OneDReader_1.default));\nexports[\"default\"] = CodaBarReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0NvZGFCYXJSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQywwSUFBYztBQUN6QyxlQUFlLG1CQUFPLENBQUMsOEhBQVc7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsd0lBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDBCQUEwQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMENBQTBDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsR0FBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9Db2RhQmFyUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcub25lZCB7Ki9cbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0UG9pbnRcIik7XG4vKipcbiAqIDxwPkRlY29kZXMgQ29kYUJhciBiYXJjb2Rlcy4gPC9wPlxuICpcbiAqIEBhdXRob3IgRXZhbiBAZG9kb2JlbGlldmVcbiAqIEBzZWUgQ29kYUJhclJlYWRlclxuICovXG52YXIgQ29kYUJhclJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29kYUJhclJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RhQmFyUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ09EQV9CQVJfQ0hBUl9TRVQgPSB7XG4gICAgICAgICAgICBubm5ubnd3OiAnMCcsXG4gICAgICAgICAgICBubm5ud3duOiAnMScsXG4gICAgICAgICAgICBubm53bm53OiAnMicsXG4gICAgICAgICAgICB3d25ubm5uOiAnMycsXG4gICAgICAgICAgICBubndubnduOiAnNCcsXG4gICAgICAgICAgICB3bm5ubnduOiAnNScsXG4gICAgICAgICAgICBud25ubm53OiAnNicsXG4gICAgICAgICAgICBud25ud25uOiAnNycsXG4gICAgICAgICAgICBud3dubm5uOiAnOCcsXG4gICAgICAgICAgICB3bm53bm5uOiAnOScsXG4gICAgICAgICAgICBubm53d25uOiAnLScsXG4gICAgICAgICAgICBubnd3bm5uOiAnJCcsXG4gICAgICAgICAgICB3bm5ud253OiAnOicsXG4gICAgICAgICAgICB3bndubm53OiAnLycsXG4gICAgICAgICAgICB3bndud25uOiAnLicsXG4gICAgICAgICAgICBubnd3d3d3OiAnKycsXG4gICAgICAgICAgICBubnd3bnduOiAnQScsXG4gICAgICAgICAgICBud253bm53OiAnQicsXG4gICAgICAgICAgICBubm53bnd3OiAnQycsXG4gICAgICAgICAgICBubm53d3duOiAnRCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb2RhQmFyUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgIHZhciB2YWxpZFJvd0RhdGEgPSB0aGlzLmdldFZhbGlkUm93RGF0YShyb3cpO1xuICAgICAgICBpZiAoIXZhbGlkUm93RGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJldFN0ciA9IHRoaXMuY29kYUJhckRlY29kZVJvdyh2YWxpZFJvd0RhdGEucm93KTtcbiAgICAgICAgaWYgKCFyZXRTdHIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0XzEuZGVmYXVsdChyZXRTdHIsIG51bGwsIDAsIFtuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHZhbGlkUm93RGF0YS5sZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHZhbGlkUm93RGF0YS5yaWdodCwgcm93TnVtYmVyKV0sIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkNPREFCQVIsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGJpdCBhcnJheSB0byB2YWxpZCBkYXRhIGFycmF5KGxlbmd0aHMgb2YgYmxhY2sgYml0cyBhbmQgd2hpdGUgYml0cylcbiAgICAgKiBAcGFyYW0gcm93IGJpdCBhcnJheSB0byBjb252ZXJ0XG4gICAgICovXG4gICAgQ29kYUJhclJlYWRlci5wcm90b3R5cGUuZ2V0VmFsaWRSb3dEYXRhID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgYm9vbGVhbkFyciA9IHJvdy50b0FycmF5KCk7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gYm9vbGVhbkFyci5pbmRleE9mKHRydWUpO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGJvb2xlYW5BcnIubGFzdEluZGV4T2YodHJ1ZSk7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPD0gc3RhcnRJbmRleClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBib29sZWFuQXJyID0gYm9vbGVhbkFyci5zbGljZShzdGFydEluZGV4LCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgbGFzdEJpdCA9IGJvb2xlYW5BcnJbMF07XG4gICAgICAgIHZhciBiaXRMZW5ndGggPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJvb2xlYW5BcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChib29sZWFuQXJyW2ldID09PSBsYXN0Qml0KSB7XG4gICAgICAgICAgICAgICAgYml0TGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0Qml0ID0gYm9vbGVhbkFycltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaXRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJpdExlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goYml0TGVuZ3RoKTtcbiAgICAgICAgLy8gQ29kYUJhciBjb2RlIGRhdGEgdmFsaWRcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyMyAmJiAocmVzdWx0Lmxlbmd0aCArIDEpICUgOCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyByb3c6IHJlc3VsdCwgbGVmdDogc3RhcnRJbmRleCwgcmlnaHQ6IGxhc3RJbmRleCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZGVjb2RlIGNvZGFiYXIgY29kZVxuICAgICAqIEBwYXJhbSByb3cgcm93IHRvIGNlY29kZVxuICAgICAqL1xuICAgIENvZGFCYXJSZWFkZXIucHJvdG90eXBlLmNvZGFCYXJEZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBjb2RlID0gW107XG4gICAgICAgIHZhciBiYXJUaHJlc2hvbGQgPSBNYXRoLmNlaWwocm93LnJlZHVjZShmdW5jdGlvbiAocHJlLCBpdGVtKSB7IHJldHVybiAocHJlICsgaXRlbSkgLyAyOyB9LCAwKSk7XG4gICAgICAgIC8vIFJlYWQgb25lIGVuY29kZWQgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gcm93LnNwbGljZSgwLCA4KS5zcGxpY2UoMCwgNyk7XG4gICAgICAgICAgICB2YXIga2V5ID0gc2VnLm1hcChmdW5jdGlvbiAobGVuKSB7IHJldHVybiAobGVuIDwgYmFyVGhyZXNob2xkID8gJ24nIDogJ3cnKTsgfSkuam9pbignJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5DT0RBX0JBUl9DSEFSX1NFVFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb2RlLnB1c2godGhpcy5DT0RBX0JBUl9DSEFSX1NFVFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyQ29kZSA9IGNvZGUuam9pbignJyk7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkQ29kYUJhclN0cmluZyhzdHJDb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBzdHJDb2RlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYSBDb2RhQmFyIHN0cmluZ1xuICAgICAqIEBwYXJhbSBzcmMgc3RyaW5nIHRvIGRldGVybWluZVxuICAgICAqL1xuICAgIENvZGFCYXJSZWFkZXIucHJvdG90eXBlLnZhbGlkQ29kYUJhclN0cmluZyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgdmFyIHJlZyA9IC9eW0EtRF0uezEsfVtBLURdJC87XG4gICAgICAgIHJldHVybiByZWcudGVzdChzcmMpO1xuICAgIH07XG4gICAgcmV0dXJuIENvZGFCYXJSZWFkZXI7XG59KE9uZURSZWFkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2RhQmFyUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n// import Reader from '../Reader';\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\n// import ResultMetadataType from '../ResultMetadataType';\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\n/**\n * <p>Decodes Code 128 barcodes.</p>\n *\n * @author Sean Owen\n */\nvar Code128Reader = /** @class */ (function (_super) {\n    __extends(Code128Reader, _super);\n    function Code128Reader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Code128Reader.findStartPattern = function (row) {\n        var width = row.getSize();\n        var rowOffset = row.getNextSet(0);\n        var counterPosition = 0;\n        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n        var patternStart = rowOffset;\n        var isWhite = false;\n        var patternLength = 6;\n        for (var i = rowOffset; i < width; i++) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === (patternLength - 1)) {\n                    var bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n                    var bestMatch = -1;\n                    for (var startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {\n                        var variance = OneDReader_1.default.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                        if (variance < bestVariance) {\n                            bestVariance = variance;\n                            bestMatch = startCode;\n                        }\n                    }\n                    // Look for whitespace before start pattern, >= 50% of width of start pattern\n                    if (bestMatch >= 0 &&\n                        row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n                        return Int32Array.from([patternStart, i, bestMatch]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters = counters.slice(2, counters.length);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    Code128Reader.decodeCode = function (row, counters, rowOffset) {\n        OneDReader_1.default.recordPattern(row, rowOffset, counters);\n        var bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n        var bestMatch = -1;\n        for (var d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {\n            var pattern = Code128Reader.CODE_PATTERNS[d];\n            var variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = d;\n            }\n        }\n        // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    Code128Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var convertFNC1 = hints && (hints.get(DecodeHintType_1.default.ASSUME_GS1) === true);\n        var startPatternInfo = Code128Reader.findStartPattern(row);\n        var startCode = startPatternInfo[2];\n        var currentRawCodesIndex = 0;\n        var rawCodes = new Uint8Array(20);\n        rawCodes[currentRawCodesIndex++] = startCode;\n        var codeSet;\n        switch (startCode) {\n            case Code128Reader.CODE_START_A:\n                codeSet = Code128Reader.CODE_CODE_A;\n                break;\n            case Code128Reader.CODE_START_B:\n                codeSet = Code128Reader.CODE_CODE_B;\n                break;\n            case Code128Reader.CODE_START_C:\n                codeSet = Code128Reader.CODE_CODE_C;\n                break;\n            default:\n                throw new FormatException_1.default();\n        }\n        var done = false;\n        var isNextShifted = false;\n        var result = '';\n        var lastStart = startPatternInfo[0];\n        var nextStart = startPatternInfo[1];\n        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n        var lastCode = 0;\n        var code = 0;\n        var checksumTotal = startCode;\n        var multiplier = 0;\n        var lastCharacterWasPrintable = true;\n        var upperMode = false;\n        var shiftUpperMode = false;\n        while (!done) {\n            var unshift = isNextShifted;\n            isNextShifted = false;\n            // Save off last code\n            lastCode = code;\n            // Decode another code from image\n            code = Code128Reader.decodeCode(row, counters, nextStart);\n            rawCodes[currentRawCodesIndex++] = code;\n            // Remember whether the last code was printable or not (excluding CODE_STOP)\n            if (code !== Code128Reader.CODE_STOP) {\n                lastCharacterWasPrintable = true;\n            }\n            // Add to checksum computation (if not CODE_STOP of course)\n            if (code !== Code128Reader.CODE_STOP) {\n                multiplier++;\n                checksumTotal += multiplier * code;\n            }\n            // Advance to where the next code will to start\n            lastStart = nextStart;\n            nextStart += counters.reduce(function (previous, current) { return previous + current; }, 0);\n            // Take care of illegal start codes\n            switch (code) {\n                case Code128Reader.CODE_START_A:\n                case Code128Reader.CODE_START_B:\n                case Code128Reader.CODE_START_C:\n                    throw new FormatException_1.default();\n            }\n            switch (codeSet) {\n                case Code128Reader.CODE_CODE_A:\n                    if (code < 64) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code));\n                        }\n                        else {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else if (code < 96) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((code - 64));\n                        }\n                        else {\n                            result += String.fromCharCode((code + 64));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else {\n                        // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n                        // code was printable or not.\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_FNC_2:\n                            case Code128Reader.CODE_FNC_3:\n                                // do nothing?\n                                break;\n                            case Code128Reader.CODE_FNC_4_A:\n                                if (!upperMode && shiftUpperMode) {\n                                    upperMode = true;\n                                    shiftUpperMode = false;\n                                }\n                                else if (upperMode && shiftUpperMode) {\n                                    upperMode = false;\n                                    shiftUpperMode = false;\n                                }\n                                else {\n                                    shiftUpperMode = true;\n                                }\n                                break;\n                            case Code128Reader.CODE_SHIFT:\n                                isNextShifted = true;\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_CODE_B:\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_CODE_C:\n                                codeSet = Code128Reader.CODE_CODE_C;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n                case Code128Reader.CODE_CODE_B:\n                    if (code < 96) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code));\n                        }\n                        else {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else {\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_FNC_2:\n                            case Code128Reader.CODE_FNC_3:\n                                // do nothing?\n                                break;\n                            case Code128Reader.CODE_FNC_4_B:\n                                if (!upperMode && shiftUpperMode) {\n                                    upperMode = true;\n                                    shiftUpperMode = false;\n                                }\n                                else if (upperMode && shiftUpperMode) {\n                                    upperMode = false;\n                                    shiftUpperMode = false;\n                                }\n                                else {\n                                    shiftUpperMode = true;\n                                }\n                                break;\n                            case Code128Reader.CODE_SHIFT:\n                                isNextShifted = true;\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_A:\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_C:\n                                codeSet = Code128Reader.CODE_CODE_C;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n                case Code128Reader.CODE_CODE_C:\n                    if (code < 100) {\n                        if (code < 10) {\n                            result += '0';\n                        }\n                        result += code;\n                    }\n                    else {\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_CODE_A:\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_B:\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n            }\n            // Unshift back to another code set if we were shifted\n            if (unshift) {\n                codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n            }\n        }\n        var lastPatternSize = nextStart - lastStart;\n        // Check for ample whitespace following pattern, but, to do this we first need to remember that\n        // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n        // to read off. Would be slightly better to properly read. Here we just skip it:\n        nextStart = row.getNextUnset(nextStart);\n        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n            throw new NotFoundException_1.default();\n        }\n        // Pull out from sum the value of the penultimate check code\n        checksumTotal -= multiplier * lastCode;\n        // lastCode is the checksum then:\n        if (checksumTotal % 103 !== lastCode) {\n            throw new ChecksumException_1.default();\n        }\n        // Need to pull out the check digits from string\n        var resultLength = result.length;\n        if (resultLength === 0) {\n            // false positive\n            throw new NotFoundException_1.default();\n        }\n        // Only bother if the result had at least one character, and if the checksum digit happened to\n        // be a printable character. If it was just interpreted as a control code, nothing to remove.\n        if (resultLength > 0 && lastCharacterWasPrintable) {\n            if (codeSet === Code128Reader.CODE_CODE_C) {\n                result = result.substring(0, resultLength - 2);\n            }\n            else {\n                result = result.substring(0, resultLength - 1);\n            }\n        }\n        var left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n        var right = lastStart + lastPatternSize / 2.0;\n        var rawCodesSize = rawCodes.length;\n        var rawBytes = new Uint8Array(rawCodesSize);\n        for (var i = 0; i < rawCodesSize; i++) {\n            rawBytes[i] = rawCodes[i];\n        }\n        var points = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n        return new Result_1.default(result, rawBytes, 0, points, BarcodeFormat_1.default.CODE_128, new Date().getTime());\n    };\n    Code128Reader.CODE_PATTERNS = [\n        Int32Array.from([2, 1, 2, 2, 2, 2]),\n        Int32Array.from([2, 2, 2, 1, 2, 2]),\n        Int32Array.from([2, 2, 2, 2, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 2, 3]),\n        Int32Array.from([1, 2, 1, 3, 2, 2]),\n        Int32Array.from([1, 3, 1, 2, 2, 2]),\n        Int32Array.from([1, 2, 2, 2, 1, 3]),\n        Int32Array.from([1, 2, 2, 3, 1, 2]),\n        Int32Array.from([1, 3, 2, 2, 1, 2]),\n        Int32Array.from([2, 2, 1, 2, 1, 3]),\n        Int32Array.from([2, 2, 1, 3, 1, 2]),\n        Int32Array.from([2, 3, 1, 2, 1, 2]),\n        Int32Array.from([1, 1, 2, 2, 3, 2]),\n        Int32Array.from([1, 2, 2, 1, 3, 2]),\n        Int32Array.from([1, 2, 2, 2, 3, 1]),\n        Int32Array.from([1, 1, 3, 2, 2, 2]),\n        Int32Array.from([1, 2, 3, 1, 2, 2]),\n        Int32Array.from([1, 2, 3, 2, 2, 1]),\n        Int32Array.from([2, 2, 3, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 3, 2]),\n        Int32Array.from([2, 2, 1, 2, 3, 1]),\n        Int32Array.from([2, 1, 3, 2, 1, 2]),\n        Int32Array.from([2, 2, 3, 1, 1, 2]),\n        Int32Array.from([3, 1, 2, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 2, 2, 2]),\n        Int32Array.from([3, 2, 1, 1, 2, 2]),\n        Int32Array.from([3, 2, 1, 2, 2, 1]),\n        Int32Array.from([3, 1, 2, 2, 1, 2]),\n        Int32Array.from([3, 2, 2, 1, 1, 2]),\n        Int32Array.from([3, 2, 2, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 2, 3]),\n        Int32Array.from([2, 1, 2, 3, 2, 1]),\n        Int32Array.from([2, 3, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 3, 2, 3]),\n        Int32Array.from([1, 3, 1, 1, 2, 3]),\n        Int32Array.from([1, 3, 1, 3, 2, 1]),\n        Int32Array.from([1, 1, 2, 3, 1, 3]),\n        Int32Array.from([1, 3, 2, 1, 1, 3]),\n        Int32Array.from([1, 3, 2, 3, 1, 1]),\n        Int32Array.from([2, 1, 1, 3, 1, 3]),\n        Int32Array.from([2, 3, 1, 1, 1, 3]),\n        Int32Array.from([2, 3, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 3, 3]),\n        Int32Array.from([1, 1, 2, 3, 3, 1]),\n        Int32Array.from([1, 3, 2, 1, 3, 1]),\n        Int32Array.from([1, 1, 3, 1, 2, 3]),\n        Int32Array.from([1, 1, 3, 3, 2, 1]),\n        Int32Array.from([1, 3, 3, 1, 2, 1]),\n        Int32Array.from([3, 1, 3, 1, 2, 1]),\n        Int32Array.from([2, 1, 1, 3, 3, 1]),\n        Int32Array.from([2, 3, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 3, 1, 1, 3]),\n        Int32Array.from([2, 1, 3, 3, 1, 1]),\n        Int32Array.from([2, 1, 3, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 2, 3]),\n        Int32Array.from([3, 1, 1, 3, 2, 1]),\n        Int32Array.from([3, 3, 1, 1, 2, 1]),\n        Int32Array.from([3, 1, 2, 1, 1, 3]),\n        Int32Array.from([3, 1, 2, 3, 1, 1]),\n        Int32Array.from([3, 3, 2, 1, 1, 1]),\n        Int32Array.from([3, 1, 4, 1, 1, 1]),\n        Int32Array.from([2, 2, 1, 4, 1, 1]),\n        Int32Array.from([4, 3, 1, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2, 4]),\n        Int32Array.from([1, 1, 1, 4, 2, 2]),\n        Int32Array.from([1, 2, 1, 1, 2, 4]),\n        Int32Array.from([1, 2, 1, 4, 2, 1]),\n        Int32Array.from([1, 4, 1, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 2, 2, 1]),\n        Int32Array.from([1, 1, 2, 2, 1, 4]),\n        Int32Array.from([1, 1, 2, 4, 1, 2]),\n        Int32Array.from([1, 2, 2, 1, 1, 4]),\n        Int32Array.from([1, 2, 2, 4, 1, 1]),\n        Int32Array.from([1, 4, 2, 1, 1, 2]),\n        Int32Array.from([1, 4, 2, 2, 1, 1]),\n        Int32Array.from([2, 4, 1, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 1, 4]),\n        Int32Array.from([4, 1, 3, 1, 1, 1]),\n        Int32Array.from([2, 4, 1, 1, 1, 2]),\n        Int32Array.from([1, 3, 4, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 4, 2]),\n        Int32Array.from([1, 2, 1, 1, 4, 2]),\n        Int32Array.from([1, 2, 1, 2, 4, 1]),\n        Int32Array.from([1, 1, 4, 2, 1, 2]),\n        Int32Array.from([1, 2, 4, 1, 1, 2]),\n        Int32Array.from([1, 2, 4, 2, 1, 1]),\n        Int32Array.from([4, 1, 1, 2, 1, 2]),\n        Int32Array.from([4, 2, 1, 1, 1, 2]),\n        Int32Array.from([4, 2, 1, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 4, 1]),\n        Int32Array.from([2, 1, 4, 1, 2, 1]),\n        Int32Array.from([4, 1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 1, 4, 3]),\n        Int32Array.from([1, 1, 1, 3, 4, 1]),\n        Int32Array.from([1, 3, 1, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 1, 3]),\n        Int32Array.from([1, 1, 4, 3, 1, 1]),\n        Int32Array.from([4, 1, 1, 1, 1, 3]),\n        Int32Array.from([4, 1, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 4, 1]),\n        Int32Array.from([4, 1, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 1, 4, 1, 2]),\n        Int32Array.from([2, 1, 1, 2, 1, 4]),\n        Int32Array.from([2, 1, 1, 2, 3, 2]),\n        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),\n    ];\n    Code128Reader.MAX_AVG_VARIANCE = 0.25;\n    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    Code128Reader.CODE_SHIFT = 98;\n    Code128Reader.CODE_CODE_C = 99;\n    Code128Reader.CODE_CODE_B = 100;\n    Code128Reader.CODE_CODE_A = 101;\n    Code128Reader.CODE_FNC_1 = 102;\n    Code128Reader.CODE_FNC_2 = 97;\n    Code128Reader.CODE_FNC_3 = 96;\n    Code128Reader.CODE_FNC_4_A = 101;\n    Code128Reader.CODE_FNC_4_B = 100;\n    Code128Reader.CODE_START_A = 103;\n    Code128Reader.CODE_START_B = 104;\n    Code128Reader.CODE_START_C = 105;\n    Code128Reader.CODE_STOP = 106;\n    return Code128Reader;\n}(OneDReader_1.default));\nexports[\"default\"] = Code128Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0NvZGUxMjhSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQyw4SUFBbUI7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMsZ0pBQW9CO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4SEFBVztBQUNsQztBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHdJQUFnQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQywwSUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx5Q0FBeUM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsNEJBQTRCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvQ29kZTEyOFJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLm9uZWQgeyovXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLy8gaW1wb3J0IFJlYWRlciBmcm9tICcuLi9SZWFkZXInO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbi8vIGltcG9ydCBSZXN1bHRNZXRhZGF0YVR5cGUgZnJvbSAnLi4vUmVzdWx0TWV0YWRhdGFUeXBlJztcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XG4vKipcbiAqIDxwPkRlY29kZXMgQ29kZSAxMjggYmFyY29kZXMuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBDb2RlMTI4UmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlMTI4UmVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGUxMjhSZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29kZTEyOFJlYWRlci5maW5kU3RhcnRQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgdmFyIHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSA2O1xuICAgICAgICBmb3IgKHZhciBpID0gcm93T2Zmc2V0OyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAocGF0dGVybkxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZXN0VmFyaWFuY2UgPSBDb2RlMTI4UmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhcnRDb2RlID0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0E7IHN0YXJ0Q29kZSA8PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzsgc3RhcnRDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYW5jZSA9IE9uZURSZWFkZXJfMS5kZWZhdWx0LnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbc3RhcnRDb2RlXSwgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBzdGFydENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaXNSYW5nZShNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoaSAtIHBhdHRlcm5TdGFydCkgLyAyKSwgcGF0dGVyblN0YXJ0LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3BhdHRlcm5TdGFydCwgaSwgYmVzdE1hdGNoXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzID0gY291bnRlcnMuc2xpY2UoMiwgY291bnRlcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIENvZGUxMjhSZWFkZXIuZGVjb2RlQ29kZSA9IGZ1bmN0aW9uIChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQpIHtcbiAgICAgICAgT25lRFJlYWRlcl8xLmRlZmF1bHQucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xuICAgICAgICB2YXIgYmVzdFZhcmlhbmNlID0gQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcbiAgICAgICAgdmFyIGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOUy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbZF07XG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSB0aGlzLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBXZSdyZSBvdmVybG9va2luZyB0aGUgZmFjdCB0aGF0IHRoZSBTVE9QIHBhdHRlcm4gaGFzIDcgdmFsdWVzLCBub3QgNi5cbiAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlMTI4UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgIHZhciBjb252ZXJ0Rk5DMSA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkFTU1VNRV9HUzEpID09PSB0cnVlKTtcbiAgICAgICAgdmFyIHN0YXJ0UGF0dGVybkluZm8gPSBDb2RlMTI4UmVhZGVyLmZpbmRTdGFydFBhdHRlcm4ocm93KTtcbiAgICAgICAgdmFyIHN0YXJ0Q29kZSA9IHN0YXJ0UGF0dGVybkluZm9bMl07XG4gICAgICAgIHZhciBjdXJyZW50UmF3Q29kZXNJbmRleCA9IDA7XG4gICAgICAgIHZhciByYXdDb2RlcyA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgcmF3Q29kZXNbY3VycmVudFJhd0NvZGVzSW5kZXgrK10gPSBzdGFydENvZGU7XG4gICAgICAgIHZhciBjb2RlU2V0O1xuICAgICAgICBzd2l0Y2ggKHN0YXJ0Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQTpcbiAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0I6XG4gICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBpc05leHRTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGxhc3RTdGFydCA9IHN0YXJ0UGF0dGVybkluZm9bMF07XG4gICAgICAgIHZhciBuZXh0U3RhcnQgPSBzdGFydFBhdHRlcm5JbmZvWzFdO1xuICAgICAgICB2YXIgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgdmFyIGxhc3RDb2RlID0gMDtcbiAgICAgICAgdmFyIGNvZGUgPSAwO1xuICAgICAgICB2YXIgY2hlY2tzdW1Ub3RhbCA9IHN0YXJ0Q29kZTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSAwO1xuICAgICAgICB2YXIgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IHRydWU7XG4gICAgICAgIHZhciB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdmFyIHVuc2hpZnQgPSBpc05leHRTaGlmdGVkO1xuICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU2F2ZSBvZmYgbGFzdCBjb2RlXG4gICAgICAgICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICAgICAgICAvLyBEZWNvZGUgYW5vdGhlciBjb2RlIGZyb20gaW1hZ2VcbiAgICAgICAgICAgIGNvZGUgPSBDb2RlMTI4UmVhZGVyLmRlY29kZUNvZGUocm93LCBjb3VudGVycywgbmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIHJhd0NvZGVzW2N1cnJlbnRSYXdDb2Rlc0luZGV4KytdID0gY29kZTtcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXRoZXIgdGhlIGxhc3QgY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdCAoZXhjbHVkaW5nIENPREVfU1RPUClcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRvIGNoZWNrc3VtIGNvbXB1dGF0aW9uIChpZiBub3QgQ09ERV9TVE9QIG9mIGNvdXJzZSlcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICBjaGVja3N1bVRvdGFsICs9IG11bHRpcGxpZXIgKiBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB3aGVyZSB0aGUgbmV4dCBjb2RlIHdpbGwgdG8gc3RhcnRcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBjb3VudGVycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7IHJldHVybiBwcmV2aW91cyArIGN1cnJlbnQ7IH0sIDApO1xuICAgICAgICAgICAgLy8gVGFrZSBjYXJlIG9mIGlsbGVnYWwgc3RhcnQgY29kZXNcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0E6XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb2RlU2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlICsgNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBsZXQgQ09ERV9TVE9QLCB3aGljaCBhbHdheXMgYXBwZWFycywgYWZmZWN0IHdoZXRoZXIgd2hldGhlciB3ZSB0aGluayB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydEZOQzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgRk5DMSB0aGVuIHRoaXMgaXMgR1MxLTEyOC4gV2UgYWRkIHRoZSBzeW1ib2xvZ3kgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcgJy5jaGFyQ29kZUF0KDApICsgY29kZSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydEZOQzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgRk5DMSB0aGVuIHRoaXMgaXMgR1MxLTEyOC4gV2UgYWRkIHRoZSBzeW1ib2xvZ3kgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0Rk5DMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuMy43LiBhbmQgNS40LjYuNC4gSWYgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHN0YXJ0IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBGTkMxIHRoZW4gdGhpcyBpcyBHUzEtMTI4LiBXZSBhZGQgdGhlIHN5bWJvbG9neSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuc2hpZnQgYmFjayB0byBhbm90aGVyIGNvZGUgc2V0IGlmIHdlIHdlcmUgc2hpZnRlZFxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2RlU2V0ID0gY29kZVNldCA9PT0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA/IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgOiBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0UGF0dGVyblNpemUgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbXBsZSB3aGl0ZXNwYWNlIGZvbGxvd2luZyBwYXR0ZXJuLCBidXQsIHRvIGRvIHRoaXMgd2UgZmlyc3QgbmVlZCB0byByZW1lbWJlciB0aGF0XG4gICAgICAgIC8vIHdlIGZ1ZGdlZCBkZWNvZGluZyBDT0RFX1NUT1Agc2luY2UgaXQgYWN0dWFsbHkgaGFzIDcgYmFycywgbm90IDYuIFRoZXJlIGlzIGEgYmxhY2sgYmFyIGxlZnRcbiAgICAgICAgLy8gdG8gcmVhZCBvZmYuIFdvdWxkIGJlIHNsaWdodGx5IGJldHRlciB0byBwcm9wZXJseSByZWFkLiBIZXJlIHdlIGp1c3Qgc2tpcCBpdDpcbiAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRVbnNldChuZXh0U3RhcnQpO1xuICAgICAgICBpZiAoIXJvdy5pc1JhbmdlKG5leHRTdGFydCwgTWF0aC5taW4ocm93LmdldFNpemUoKSwgbmV4dFN0YXJ0ICsgKG5leHRTdGFydCAtIGxhc3RTdGFydCkgLyAyKSwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVsbCBvdXQgZnJvbSBzdW0gdGhlIHZhbHVlIG9mIHRoZSBwZW51bHRpbWF0ZSBjaGVjayBjb2RlXG4gICAgICAgIGNoZWNrc3VtVG90YWwgLT0gbXVsdGlwbGllciAqIGxhc3RDb2RlO1xuICAgICAgICAvLyBsYXN0Q29kZSBpcyB0aGUgY2hlY2tzdW0gdGhlbjpcbiAgICAgICAgaWYgKGNoZWNrc3VtVG90YWwgJSAxMDMgIT09IGxhc3RDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVlZCB0byBwdWxsIG91dCB0aGUgY2hlY2sgZGlnaXRzIGZyb20gc3RyaW5nXG4gICAgICAgIHZhciByZXN1bHRMZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgYm90aGVyIGlmIHRoZSByZXN1bHQgaGFkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGFuZCBpZiB0aGUgY2hlY2tzdW0gZGlnaXQgaGFwcGVuZWQgdG9cbiAgICAgICAgLy8gYmUgYSBwcmludGFibGUgY2hhcmFjdGVyLiBJZiBpdCB3YXMganVzdCBpbnRlcnByZXRlZCBhcyBhIGNvbnRyb2wgY29kZSwgbm90aGluZyB0byByZW1vdmUuXG4gICAgICAgIGlmIChyZXN1bHRMZW5ndGggPiAwICYmIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUpIHtcbiAgICAgICAgICAgIGlmIChjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHRMZW5ndGggLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSAoc3RhcnRQYXR0ZXJuSW5mb1sxXSArIHN0YXJ0UGF0dGVybkluZm9bMF0pIC8gMi4wO1xuICAgICAgICB2YXIgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgIHZhciByYXdDb2Rlc1NpemUgPSByYXdDb2Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciByYXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJhd0NvZGVzU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q29kZXNTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJhd0J5dGVzW2ldID0gcmF3Q29kZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50cyA9IFtuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGxlZnQsIHJvd051bWJlciksIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocmlnaHQsIHJvd051bWJlcildO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0LCByYXdCeXRlcywgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzEyOCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgIH07XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMiwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAzLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAzLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMiwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCAyLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMywgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDEsIDMsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMywgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAyLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMiwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDQsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCA0LCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMywgMSwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDIsIDIsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCA0LCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMiwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDQsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMSwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMywgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCA0LCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMiwgNCwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDEsIDQsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAyLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDQsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCA0LCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDIsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAyLCAxLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDQsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAyLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgNCwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDQsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAzLCAxLCAxLCAxLCAyXSksXG4gICAgXTtcbiAgICBDb2RlMTI4UmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjI1O1xuICAgIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUID0gOTg7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQyA9IDk5O1xuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA9IDEwMTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzEgPSAxMDI7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yID0gOTc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zID0gOTY7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0EgPSAxMDE7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0EgPSAxMDM7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0IgPSAxMDQ7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0MgPSAxMDU7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1AgPSAxMDY7XG4gICAgcmV0dXJuIENvZGUxMjhSZWFkZXI7XG59KE9uZURSZWFkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2RlMTI4UmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n *\n * @author Sean Owen\n * @see Code93Reader\n */\nvar Code39Reader = /** @class */ (function (_super) {\n    __extends(Code39Reader, _super);\n    /**\n     * Creates a reader that assumes all encoded data is data, and does not treat the final\n     * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n     */\n    // public Code39Reader() {\n    //   this(false);\n    // }\n    /**\n     * Creates a reader that can be configured to check the last character as a check digit.\n     * It will not decoded \"extended Code 39\" sequences.\n     *\n     * @param usingCheckDigit if true, treat the last data character as a check digit, not\n     * data, and verify that the checksum passes.\n     */\n    // public Code39Reader(boolean usingCheckDigit) {\n    //   this(usingCheckDigit, false);\n    // }\n    /**\n     * Creates a reader that can be configured to check the last character as a check digit,\n     * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n     * the full ASCII character set.\n     *\n     * @param usingCheckDigit if true, treat the last data character as a check digit, not\n     * data, and verify that the checksum passes.\n     * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n     * text.\n     */\n    function Code39Reader(usingCheckDigit, extendedMode) {\n        if (usingCheckDigit === void 0) { usingCheckDigit = false; }\n        if (extendedMode === void 0) { extendedMode = false; }\n        var _this = _super.call(this) || this;\n        _this.usingCheckDigit = usingCheckDigit;\n        _this.extendedMode = extendedMode;\n        _this.decodeRowResult = '';\n        _this.counters = new Int32Array(9);\n        return _this;\n    }\n    Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a, e_2, _b;\n        var theCounters = this.counters;\n        theCounters.fill(0);\n        this.decodeRowResult = '';\n        var start = Code39Reader.findAsteriskPattern(row, theCounters);\n        // Read off white space\n        var nextStart = row.getNextSet(start[1]);\n        var end = row.getSize();\n        var decodedChar;\n        var lastStart;\n        do {\n            Code39Reader.recordPattern(row, nextStart, theCounters);\n            var pattern = Code39Reader.toNarrowWidePattern(theCounters);\n            if (pattern < 0) {\n                throw new NotFoundException_1.default();\n            }\n            decodedChar = Code39Reader.patternToChar(pattern);\n            this.decodeRowResult += decodedChar;\n            lastStart = nextStart;\n            try {\n                for (var theCounters_1 = (e_1 = void 0, __values(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {\n                    var counter = theCounters_1_1.value;\n                    nextStart += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // Read off white space\n            nextStart = row.getNextSet(nextStart);\n        } while (decodedChar !== '*');\n        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n        // Look for whitespace after pattern:\n        var lastPatternSize = 0;\n        try {\n            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {\n                var counter = theCounters_2_1.value;\n                lastPatternSize += counter;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;\n        // If 50% of last pattern size, following last pattern, is not whitespace, fail\n        // (but if it's whitespace to the very end of the image, that's OK)\n        if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {\n            throw new NotFoundException_1.default();\n        }\n        if (this.usingCheckDigit) {\n            var max = this.decodeRowResult.length - 1;\n            var total = 0;\n            for (var i = 0; i < max; i++) {\n                total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n            }\n            if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n                throw new ChecksumException_1.default();\n            }\n            this.decodeRowResult = this.decodeRowResult.substring(0, max);\n        }\n        if (this.decodeRowResult.length === 0) {\n            // false positive\n            throw new NotFoundException_1.default();\n        }\n        var resultString;\n        if (this.extendedMode) {\n            resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n        }\n        else {\n            resultString = this.decodeRowResult;\n        }\n        var left = (start[1] + start[0]) / 2.0;\n        var right = lastStart + lastPatternSize / 2.0;\n        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());\n    };\n    Code39Reader.findAsteriskPattern = function (row, counters) {\n        var width = row.getSize();\n        var rowOffset = row.getNextSet(0);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var isWhite = false;\n        var patternLength = counters.length;\n        for (var i = rowOffset; i < width; i++) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    // Look for whitespace before start pattern, >= 50% of width of start pattern\n                    if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&\n                        row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n                        return [patternStart, i];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters.copyWithin(0, 2, 2 + counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n    // per image when using some of our blackbox images.\n    Code39Reader.toNarrowWidePattern = function (counters) {\n        var e_3, _a;\n        var numCounters = counters.length;\n        var maxNarrowCounter = 0;\n        var wideCounters;\n        do {\n            var minCounter = 0x7fffffff;\n            try {\n                for (var counters_1 = (e_3 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    if (counter < minCounter && counter > maxNarrowCounter) {\n                        minCounter = counter;\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            maxNarrowCounter = minCounter;\n            wideCounters = 0;\n            var totalWideCountersWidth = 0;\n            var pattern = 0;\n            for (var i = 0; i < numCounters; i++) {\n                var counter = counters[i];\n                if (counter > maxNarrowCounter) {\n                    pattern |= 1 << (numCounters - 1 - i);\n                    wideCounters++;\n                    totalWideCountersWidth += counter;\n                }\n            }\n            if (wideCounters === 3) {\n                // Found 3 wide counters, but are they close enough in width?\n                // We can perform a cheap, conservative check to see if any individual\n                // counter is more than 1.5 times the average:\n                for (var i = 0; i < numCounters && wideCounters > 0; i++) {\n                    var counter = counters[i];\n                    if (counter > maxNarrowCounter) {\n                        wideCounters--;\n                        // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n                        if ((counter * 2) >= totalWideCountersWidth) {\n                            return -1;\n                        }\n                    }\n                }\n                return pattern;\n            }\n        } while (wideCounters > 3);\n        return -1;\n    };\n    Code39Reader.patternToChar = function (pattern) {\n        for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n            if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                return Code39Reader.ALPHABET_STRING.charAt(i);\n            }\n        }\n        if (pattern === Code39Reader.ASTERISK_ENCODING) {\n            return '*';\n        }\n        throw new NotFoundException_1.default();\n    };\n    Code39Reader.decodeExtended = function (encoded) {\n        var length = encoded.length;\n        var decoded = '';\n        for (var i = 0; i < length; i++) {\n            var c = encoded.charAt(i);\n            if (c === '+' || c === '$' || c === '%' || c === '/') {\n                var next = encoded.charAt(i + 1);\n                var decodedChar = '\\0';\n                switch (c) {\n                    case '+':\n                        // +A to +Z map to a to z\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '$':\n                        // $A to $Z map to control codes SH to SB\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '%':\n                        // %A to %E map to control codes ESC to US\n                        if (next >= 'A' && next <= 'E') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                        }\n                        else if (next >= 'F' && next <= 'J') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                        }\n                        else if (next >= 'K' && next <= 'O') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                        }\n                        else if (next >= 'P' && next <= 'T') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                        }\n                        else if (next === 'U') {\n                            decodedChar = '\\0';\n                        }\n                        else if (next === 'V') {\n                            decodedChar = '@';\n                        }\n                        else if (next === 'W') {\n                            decodedChar = '`';\n                        }\n                        else if (next === 'X' || next === 'Y' || next === 'Z') {\n                            decodedChar = '\\x7f';\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '/':\n                        // /A to /O map to ! to , and /Z maps to :\n                        if (next >= 'A' && next <= 'O') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                        }\n                        else if (next === 'Z') {\n                            decodedChar = ':';\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n                decoded += decodedChar;\n                // bump up i again since we read two characters\n                i++;\n            }\n            else {\n                decoded += c;\n            }\n        }\n        return decoded;\n    };\n    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n     * with 1s representing \"wide\" and 0s representing narrow.\n     */\n    Code39Reader.CHARACTER_ENCODINGS = [\n        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,\n        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,\n        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,\n        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,\n        0x0A2, 0x08A, 0x02A // /-%\n    ];\n    Code39Reader.ASTERISK_ENCODING = 0x094;\n    return Code39Reader;\n}(OneDReader_1.default));\nexports[\"default\"] = Code39Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0NvZGUzOVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLGdKQUFvQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLHdJQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILHVCQUF1QjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLHVCQUF1QjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsb0JBQW9CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0NvZGUzOVJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLm9uZWQgeyovXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Gb3JtYXRFeGNlcHRpb25cIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9PbmVEUmVhZGVyXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xuLyoqXG4gKiA8cD5EZWNvZGVzIENvZGUgMzkgYmFyY29kZXMuIFN1cHBvcnRzIFwiRnVsbCBBU0NJSSBDb2RlIDM5XCIgaWYgVVNFX0NPREVfMzlfRVhURU5ERURfTU9ERSBpcyBzZXQuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAc2VlIENvZGU5M1JlYWRlclxuICovXG52YXIgQ29kZTM5UmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlMzlSZWFkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGFzc3VtZXMgYWxsIGVuY29kZWQgZGF0YSBpcyBkYXRhLCBhbmQgZG9lcyBub3QgdHJlYXQgdGhlIGZpbmFsXG4gICAgICogY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQuIEl0IHdpbGwgbm90IGRlY29kZWQgXCJleHRlbmRlZCBDb2RlIDM5XCIgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIC8vIHB1YmxpYyBDb2RlMzlSZWFkZXIoKSB7XG4gICAgLy8gICB0aGlzKGZhbHNlKTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LlxuICAgICAqIEl0IHdpbGwgbm90IGRlY29kZWQgXCJleHRlbmRlZCBDb2RlIDM5XCIgc2VxdWVuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgKiBkYXRhLCBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNoZWNrc3VtIHBhc3Nlcy5cbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgQ29kZTM5UmVhZGVyKGJvb2xlYW4gdXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgLy8gICB0aGlzKHVzaW5nQ2hlY2tEaWdpdCwgZmFsc2UpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVhZGVyIHRoYXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gY2hlY2sgdGhlIGxhc3QgY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQsXG4gICAgICogb3Igb3B0aW9uYWxseSBhdHRlbXB0IHRvIGRlY29kZSBcImV4dGVuZGVkIENvZGUgMzlcIiBzZXF1ZW5jZXMgdGhhdCBhcmUgdXNlZCB0byBlbmNvZGVcbiAgICAgKiB0aGUgZnVsbCBBU0NJSSBjaGFyYWN0ZXIgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgKiBkYXRhLCBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNoZWNrc3VtIHBhc3Nlcy5cbiAgICAgKiBAcGFyYW0gZXh0ZW5kZWRNb2RlIGlmIHRydWUsIHdpbGwgYXR0ZW1wdCB0byBkZWNvZGUgZXh0ZW5kZWQgQ29kZSAzOSBzZXF1ZW5jZXMgaW4gdGhlXG4gICAgICogdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb2RlMzlSZWFkZXIodXNpbmdDaGVja0RpZ2l0LCBleHRlbmRlZE1vZGUpIHtcbiAgICAgICAgaWYgKHVzaW5nQ2hlY2tEaWdpdCA9PT0gdm9pZCAwKSB7IHVzaW5nQ2hlY2tEaWdpdCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChleHRlbmRlZE1vZGUgPT09IHZvaWQgMCkgeyBleHRlbmRlZE1vZGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51c2luZ0NoZWNrRGlnaXQgPSB1c2luZ0NoZWNrRGlnaXQ7XG4gICAgICAgIF90aGlzLmV4dGVuZGVkTW9kZSA9IGV4dGVuZGVkTW9kZTtcbiAgICAgICAgX3RoaXMuZGVjb2RlUm93UmVzdWx0ID0gJyc7XG4gICAgICAgIF90aGlzLmNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoOSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICB2YXIgdGhlQ291bnRlcnMgPSB0aGlzLmNvdW50ZXJzO1xuICAgICAgICB0aGVDb3VudGVycy5maWxsKDApO1xuICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgc3RhcnQgPSBDb2RlMzlSZWFkZXIuZmluZEFzdGVyaXNrUGF0dGVybihyb3csIHRoZUNvdW50ZXJzKTtcbiAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgdmFyIG5leHRTdGFydCA9IHJvdy5nZXROZXh0U2V0KHN0YXJ0WzFdKTtcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHZhciBkZWNvZGVkQ2hhcjtcbiAgICAgICAgdmFyIGxhc3RTdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgQ29kZTM5UmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBuZXh0U3RhcnQsIHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gQ29kZTM5UmVhZGVyLnRvTmFycm93V2lkZVBhdHRlcm4odGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBDb2RlMzlSZWFkZXIucGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ICs9IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aGVDb3VudGVyc18xID0gKGVfMSA9IHZvaWQgMCwgX192YWx1ZXModGhlQ291bnRlcnMpKSwgdGhlQ291bnRlcnNfMV8xID0gdGhlQ291bnRlcnNfMS5uZXh0KCk7ICF0aGVDb3VudGVyc18xXzEuZG9uZTsgdGhlQ291bnRlcnNfMV8xID0gdGhlQ291bnRlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGVDb3VudGVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGFydCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlQ291bnRlcnNfMV8xICYmICF0aGVDb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSB0aGVDb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwodGhlQ291bnRlcnNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlYWQgb2ZmIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSB0aGlzLmRlY29kZVJvd1Jlc3VsdC5zdWJzdHJpbmcoMCwgdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSBhc3Rlcmlza1xuICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGFmdGVyIHBhdHRlcm46XG4gICAgICAgIHZhciBsYXN0UGF0dGVyblNpemUgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgdGhlQ291bnRlcnNfMiA9IF9fdmFsdWVzKHRoZUNvdW50ZXJzKSwgdGhlQ291bnRlcnNfMl8xID0gdGhlQ291bnRlcnNfMi5uZXh0KCk7ICF0aGVDb3VudGVyc18yXzEuZG9uZTsgdGhlQ291bnRlcnNfMl8xID0gdGhlQ291bnRlcnNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoZUNvdW50ZXJzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsYXN0UGF0dGVyblNpemUgKz0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoZUNvdW50ZXJzXzJfMSAmJiAhdGhlQ291bnRlcnNfMl8xLmRvbmUgJiYgKF9iID0gdGhlQ291bnRlcnNfMi5yZXR1cm4pKSBfYi5jYWxsKHRoZUNvdW50ZXJzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB3aGl0ZVNwYWNlQWZ0ZXJFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBsYXN0UGF0dGVyblNpemU7XG4gICAgICAgIC8vIElmIDUwJSBvZiBsYXN0IHBhdHRlcm4gc2l6ZSwgZm9sbG93aW5nIGxhc3QgcGF0dGVybiwgaXMgbm90IHdoaXRlc3BhY2UsIGZhaWxcbiAgICAgICAgLy8gKGJ1dCBpZiBpdCdzIHdoaXRlc3BhY2UgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSBpbWFnZSwgdGhhdCdzIE9LKVxuICAgICAgICBpZiAobmV4dFN0YXJ0ICE9PSBlbmQgJiYgKHdoaXRlU3BhY2VBZnRlckVuZCAqIDIpIDwgbGFzdFBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5pbmRleE9mKHRoaXMuZGVjb2RlUm93UmVzdWx0LmNoYXJBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQuY2hhckF0KG1heCkgIT09IENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcuY2hhckF0KHRvdGFsICUgNDMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSB0aGlzLmRlY29kZVJvd1Jlc3VsdC5zdWJzdHJpbmcoMCwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRTdHJpbmc7XG4gICAgICAgIGlmICh0aGlzLmV4dGVuZGVkTW9kZSkge1xuICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gQ29kZTM5UmVhZGVyLmRlY29kZUV4dGVuZGVkKHRoaXMuZGVjb2RlUm93UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IHRoaXMuZGVjb2RlUm93UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0ID0gKHN0YXJ0WzFdICsgc3RhcnRbMF0pIC8gMi4wO1xuICAgICAgICB2YXIgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0XzEuZGVmYXVsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIFtuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGxlZnQsIHJvd051bWJlciksIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocmlnaHQsIHJvd051bWJlcildLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzM5LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgfTtcbiAgICBDb2RlMzlSZWFkZXIuZmluZEFzdGVyaXNrUGF0dGVybiA9IGZ1bmN0aW9uIChyb3csIGNvdW50ZXJzKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHZhciByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgdmFyIGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gcm93T2Zmc2V0OyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b05hcnJvd1dpZGVQYXR0ZXJuKGNvdW50ZXJzKSA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaXNSYW5nZShNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSBNYXRoLmZsb29yKChpIC0gcGF0dGVyblN0YXJ0KSAvIDIpKSwgcGF0dGVyblN0YXJ0LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGF0dGVyblN0YXJ0LCBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnMuY29weVdpdGhpbigwLCAyLCAyICsgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvLyBGb3IgZWZmaWNpZW5jeSwgcmV0dXJucyAtMSBvbiBmYWlsdXJlLiBOb3QgdGhyb3dpbmcgaGVyZSBzYXZlZCBhcyBtYW55IGFzIDcwMCBleGNlcHRpb25zXG4gICAgLy8gcGVyIGltYWdlIHdoZW4gdXNpbmcgc29tZSBvZiBvdXIgYmxhY2tib3ggaW1hZ2VzLlxuICAgIENvZGUzOVJlYWRlci50b05hcnJvd1dpZGVQYXR0ZXJuID0gZnVuY3Rpb24gKGNvdW50ZXJzKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIHZhciBtYXhOYXJyb3dDb3VudGVyID0gMDtcbiAgICAgICAgdmFyIHdpZGVDb3VudGVycztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG1pbkNvdW50ZXIgPSAweDdmZmZmZmZmO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gKGVfMyA9IHZvaWQgMCwgX192YWx1ZXMoY291bnRlcnMpKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluQ291bnRlciAmJiBjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXhOYXJyb3dDb3VudGVyID0gbWluQ291bnRlcjtcbiAgICAgICAgICAgIHdpZGVDb3VudGVycyA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDA7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgdG90YWxXaWRlQ291bnRlcnNXaWR0aCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWRlQ291bnRlcnMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCAzIHdpZGUgY291bnRlcnMsIGJ1dCBhcmUgdGhleSBjbG9zZSBlbm91Z2ggaW4gd2lkdGg/XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHBlcmZvcm0gYSBjaGVhcCwgY29uc2VydmF0aXZlIGNoZWNrIHRvIHNlZSBpZiBhbnkgaW5kaXZpZHVhbFxuICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgaXMgbW9yZSB0aGFuIDEuNSB0aW1lcyB0aGUgYXZlcmFnZTpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIHdpZGVDb3VudGVycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVDb3VudGVycy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDMgKiBhdmVyYWdlLCBzbyB0aGlzIGNoZWNrcyBpZiBjb3VudGVyID49IDMvMiAqIGF2ZXJhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlciAqIDIpID49IHRvdGFsV2lkZUNvdW50ZXJzV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHdpZGVDb3VudGVycyA+IDMpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBDb2RlMzlSZWFkZXIucGF0dGVyblRvQ2hhciA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ29kZTM5UmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybiA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HKSB7XG4gICAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIENvZGUzOVJlYWRlci5kZWNvZGVFeHRlbmRlZCA9IGZ1bmN0aW9uIChlbmNvZGVkKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlY29kZWQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBlbmNvZGVkLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAnKycgfHwgYyA9PT0gJyQnIHx8IGMgPT09ICclJyB8fCBjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGVuY29kZWQuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlZENoYXIgPSAnXFwwJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArQSB0byArWiBtYXAgdG8gYSB0byB6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRBIHRvICRaIG1hcCB0byBjb250cm9sIGNvZGVzIFNIIHRvIFNCXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICVBIHRvICVFIG1hcCB0byBjb250cm9sIGNvZGVzIEVTQyB0byBVU1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gJ0EnICYmIG5leHQgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDM4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0YnICYmIG5leHQgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0snICYmIG5leHQgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ1AnICYmIG5leHQgPD0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdAJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdXJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ2AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1gnIHx8IG5leHQgPT09ICdZJyB8fCBuZXh0ID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdcXHg3Zic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gL0EgdG8gL08gbWFwIHRvICEgdG8gLCBhbmQgL1ogbWFwcyB0byA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgLy8gYnVtcCB1cCBpIGFnYWluIHNpbmNlIHdlIHJlYWQgdHdvIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfTtcbiAgICBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyUnO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZW5jb2RpbmdzIG9mIGNoYXJhY3RlcnMsIGFzIHBhdHRlcm5zIG9mIHdpZGUgYW5kIG5hcnJvdyBiYXJzLlxuICAgICAqIFRoZSA5IGxlYXN0LXNpZ25pZmljYW50IGJpdHMgb2YgZWFjaCBpbnQgY29ycmVzcG9uZCB0byB0aGUgcGF0dGVybiBvZiB3aWRlIGFuZCBuYXJyb3csXG4gICAgICogd2l0aCAxcyByZXByZXNlbnRpbmcgXCJ3aWRlXCIgYW5kIDBzIHJlcHJlc2VudGluZyBuYXJyb3cuXG4gICAgICovXG4gICAgQ29kZTM5UmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MgPSBbXG4gICAgICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LFxuICAgICAgICAweDEwOSwgMHgwNDksIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQyxcbiAgICAgICAgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LCAweDA0NiwgMHgwMTYsXG4gICAgICAgIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MEE4LFxuICAgICAgICAweDBBMiwgMHgwOEEsIDB4MDJBIC8vIC8tJVxuICAgIF07XG4gICAgQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HID0gMHgwOTQ7XG4gICAgcmV0dXJuIENvZGUzOVJlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvZGUzOVJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\n//import com.google.zxing.ResultMetadataType;\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * <p>Decodes Code 93 barcodes.</p>\n *\n * @author Sean Owen\n * @see Code39Reader\n */\nvar Code93Reader = /** @class */ (function (_super) {\n    __extends(Code93Reader, _super);\n    //public Code93Reader() {\n    //  decodeRowResult = new StringBuilder(20);\n    //  counters = new int[6];\n    //}\n    function Code93Reader() {\n        var _this = _super.call(this) || this;\n        _this.decodeRowResult = '';\n        _this.counters = new Int32Array(6);\n        return _this;\n    }\n    Code93Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a, e_2, _b;\n        var start = this.findAsteriskPattern(row);\n        // Read off white space\n        var nextStart = row.getNextSet(start[1]);\n        var end = row.getSize();\n        var theCounters = this.counters;\n        theCounters.fill(0);\n        this.decodeRowResult = '';\n        var decodedChar;\n        var lastStart;\n        do {\n            Code93Reader.recordPattern(row, nextStart, theCounters);\n            var pattern = this.toPattern(theCounters);\n            if (pattern < 0) {\n                throw new NotFoundException_1.default();\n            }\n            decodedChar = this.patternToChar(pattern);\n            this.decodeRowResult += decodedChar;\n            lastStart = nextStart;\n            try {\n                for (var theCounters_1 = (e_1 = void 0, __values(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {\n                    var counter = theCounters_1_1.value;\n                    nextStart += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // Read off white space\n            nextStart = row.getNextSet(nextStart);\n        } while (decodedChar !== '*');\n        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n        var lastPatternSize = 0;\n        try {\n            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {\n                var counter = theCounters_2_1.value;\n                lastPatternSize += counter;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // Should be at least one more black module\n        if (nextStart === end || !row.get(nextStart)) {\n            throw new NotFoundException_1.default();\n        }\n        if (this.decodeRowResult.length < 2) {\n            // false positive -- need at least 2 checksum digits\n            throw new NotFoundException_1.default();\n        }\n        this.checkChecksums(this.decodeRowResult);\n        // Remove checksum digits\n        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 2);\n        var resultString = this.decodeExtended(this.decodeRowResult);\n        var left = (start[1] + start[0]) / 2.0;\n        var right = lastStart + lastPatternSize / 2.0;\n        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_93, new Date().getTime());\n    };\n    Code93Reader.prototype.findAsteriskPattern = function (row) {\n        var width = row.getSize();\n        var rowOffset = row.getNextSet(0);\n        this.counters.fill(0);\n        var theCounters = this.counters;\n        var patternStart = rowOffset;\n        var isWhite = false;\n        var patternLength = theCounters.length;\n        var counterPosition = 0;\n        for (var i = rowOffset; i < width; i++) {\n            if (row.get(i) !== isWhite) {\n                theCounters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (this.toPattern(theCounters) === Code93Reader.ASTERISK_ENCODING) {\n                        return new Int32Array([patternStart, i]);\n                    }\n                    patternStart += theCounters[0] + theCounters[1];\n                    theCounters.copyWithin(0, 2, 2 + counterPosition - 1);\n                    theCounters[counterPosition - 1] = 0;\n                    theCounters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                theCounters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default;\n    };\n    Code93Reader.prototype.toPattern = function (counters) {\n        var e_3, _a;\n        var sum = 0;\n        try {\n            for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                var counter = counters_1_1.value;\n                sum += counter;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        var pattern = 0;\n        var max = counters.length;\n        for (var i = 0; i < max; i++) {\n            var scaled = Math.round(counters[i] * 9.0 / sum);\n            if (scaled < 1 || scaled > 4) {\n                return -1;\n            }\n            if ((i & 0x01) === 0) {\n                for (var j = 0; j < scaled; j++) {\n                    pattern = (pattern << 1) | 0x01;\n                }\n            }\n            else {\n                pattern <<= scaled;\n            }\n        }\n        return pattern;\n    };\n    Code93Reader.prototype.patternToChar = function (pattern) {\n        for (var i = 0; i < Code93Reader.CHARACTER_ENCODINGS.length; i++) {\n            if (Code93Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                return Code93Reader.ALPHABET_STRING.charAt(i);\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    Code93Reader.prototype.decodeExtended = function (encoded) {\n        var length = encoded.length;\n        var decoded = '';\n        for (var i = 0; i < length; i++) {\n            var c = encoded.charAt(i);\n            if (c >= 'a' && c <= 'd') {\n                if (i >= length - 1) {\n                    throw new FormatException_1.default();\n                }\n                var next = encoded.charAt(i + 1);\n                var decodedChar = '\\0';\n                switch (c) {\n                    case 'd':\n                        // +A to +Z map to a to z\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 'a':\n                        // $A to $Z map to control codes SH to SB\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 'b':\n                        if (next >= 'A' && next <= 'E') {\n                            // %A to %E map to control codes ESC to USep\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                        }\n                        else if (next >= 'F' && next <= 'J') {\n                            // %F to %J map to ; < = > ?\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                        }\n                        else if (next >= 'K' && next <= 'O') {\n                            // %K to %O map to [ \\ ] ^ _\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                        }\n                        else if (next >= 'P' && next <= 'T') {\n                            // %P to %T map to { | } ~ DEL\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                        }\n                        else if (next === 'U') {\n                            // %U map to NUL\n                            decodedChar = '\\0';\n                        }\n                        else if (next === 'V') {\n                            // %V map to @\n                            decodedChar = '@';\n                        }\n                        else if (next === 'W') {\n                            // %W map to `\n                            decodedChar = '`';\n                        }\n                        else if (next >= 'X' && next <= 'Z') {\n                            // %X to %Z all map to DEL (127)\n                            decodedChar = String.fromCharCode(127);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 'c':\n                        // /A to /O map to ! to , and /Z maps to :\n                        if (next >= 'A' && next <= 'O') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                        }\n                        else if (next === 'Z') {\n                            decodedChar = ':';\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n                decoded += decodedChar;\n                // bump up i again since we read two characters\n                i++;\n            }\n            else {\n                decoded += c;\n            }\n        }\n        return decoded;\n    };\n    Code93Reader.prototype.checkChecksums = function (result) {\n        var length = result.length;\n        this.checkOneChecksum(result, length - 2, 20);\n        this.checkOneChecksum(result, length - 1, 15);\n    };\n    Code93Reader.prototype.checkOneChecksum = function (result, checkPosition, weightMax) {\n        var weight = 1;\n        var total = 0;\n        for (var i = checkPosition - 1; i >= 0; i--) {\n            total += weight * Code93Reader.ALPHABET_STRING.indexOf(result.charAt(i));\n            if (++weight > weightMax) {\n                weight = 1;\n            }\n        }\n        if (result.charAt(checkPosition) !== Code93Reader.ALPHABET_STRING[total % 47]) {\n            throw new ChecksumException_1.default;\n        }\n    };\n    // Note that 'abcd' are dummy characters in place of control characters.\n    Code93Reader.ALPHABET_STRING = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*\";\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow.\n     */\n    Code93Reader.CHARACTER_ENCODINGS = [\n        0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A,\n        0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134,\n        0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6,\n        0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A,\n        0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE,\n        0x126, 0x1DA, 0x1D6, 0x132, 0x15E,\n    ];\n    Code93Reader.ASTERISK_ENCODING = Code93Reader.CHARACTER_ENCODINGS[47];\n    return Code93Reader;\n}(OneDReader_1.default));\nexports[\"default\"] = Code93Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0NvZGU5M1JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLGdKQUFvQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0lBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCx1QkFBdUI7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQSxvR0FBb0csdUJBQXVCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixvQkFBb0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9Db2RlOTNSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5vbmVkIHsqL1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xudmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vQ2hlY2tzdW1FeGNlcHRpb25cIik7XG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgT25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vT25lRFJlYWRlclwiKTtcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XG4vL2ltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLlJlc3VsdE1ldGFkYXRhVHlwZTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xuLyoqXG4gKiA8cD5EZWNvZGVzIENvZGUgOTMgYmFyY29kZXMuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAc2VlIENvZGUzOVJlYWRlclxuICovXG52YXIgQ29kZTkzUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlOTNSZWFkZXIsIF9zdXBlcik7XG4gICAgLy9wdWJsaWMgQ29kZTkzUmVhZGVyKCkge1xuICAgIC8vICBkZWNvZGVSb3dSZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigyMCk7XG4gICAgLy8gIGNvdW50ZXJzID0gbmV3IGludFs2XTtcbiAgICAvL31cbiAgICBmdW5jdGlvbiBDb2RlOTNSZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICBfdGhpcy5jb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDYpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvZGU5M1JlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5maW5kQXN0ZXJpc2tQYXR0ZXJuKHJvdyk7XG4gICAgICAgIC8vIFJlYWQgb2ZmIHdoaXRlIHNwYWNlXG4gICAgICAgIHZhciBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChzdGFydFsxXSk7XG4gICAgICAgIHZhciBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgdGhlQ291bnRlcnMgPSB0aGlzLmNvdW50ZXJzO1xuICAgICAgICB0aGVDb3VudGVycy5maWxsKDApO1xuICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgZGVjb2RlZENoYXI7XG4gICAgICAgIHZhciBsYXN0U3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIENvZGU5M1JlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgbmV4dFN0YXJ0LCB0aGVDb3VudGVycyk7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMudG9QYXR0ZXJuKHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRoZUNvdW50ZXJzXzEgPSAoZV8xID0gdm9pZCAwLCBfX3ZhbHVlcyh0aGVDb3VudGVycykpLCB0aGVDb3VudGVyc18xXzEgPSB0aGVDb3VudGVyc18xLm5leHQoKTsgIXRoZUNvdW50ZXJzXzFfMS5kb25lOyB0aGVDb3VudGVyc18xXzEgPSB0aGVDb3VudGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoZUNvdW50ZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVDb3VudGVyc18xXzEgJiYgIXRoZUNvdW50ZXJzXzFfMS5kb25lICYmIChfYSA9IHRoZUNvdW50ZXJzXzEucmV0dXJuKSkgX2EuY2FsbCh0aGVDb3VudGVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHJvdy5nZXROZXh0U2V0KG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCB0aGlzLmRlY29kZVJvd1Jlc3VsdC5sZW5ndGggLSAxKTsgLy8gcmVtb3ZlIGFzdGVyaXNrXG4gICAgICAgIHZhciBsYXN0UGF0dGVyblNpemUgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgdGhlQ291bnRlcnNfMiA9IF9fdmFsdWVzKHRoZUNvdW50ZXJzKSwgdGhlQ291bnRlcnNfMl8xID0gdGhlQ291bnRlcnNfMi5uZXh0KCk7ICF0aGVDb3VudGVyc18yXzEuZG9uZTsgdGhlQ291bnRlcnNfMl8xID0gdGhlQ291bnRlcnNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoZUNvdW50ZXJzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsYXN0UGF0dGVyblNpemUgKz0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoZUNvdW50ZXJzXzJfMSAmJiAhdGhlQ291bnRlcnNfMl8xLmRvbmUgJiYgKF9iID0gdGhlQ291bnRlcnNfMi5yZXR1cm4pKSBfYi5jYWxsKHRoZUNvdW50ZXJzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBiZSBhdCBsZWFzdCBvbmUgbW9yZSBibGFjayBtb2R1bGVcbiAgICAgICAgaWYgKG5leHRTdGFydCA9PT0gZW5kIHx8ICFyb3cuZ2V0KG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmUgLS0gbmVlZCBhdCBsZWFzdCAyIGNoZWNrc3VtIGRpZ2l0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tDaGVja3N1bXModGhpcy5kZWNvZGVSb3dSZXN1bHQpO1xuICAgICAgICAvLyBSZW1vdmUgY2hlY2tzdW0gZGlnaXRzXG4gICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQuc3Vic3RyaW5nKDAsIHRoaXMuZGVjb2RlUm93UmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nID0gdGhpcy5kZWNvZGVFeHRlbmRlZCh0aGlzLmRlY29kZVJvd1Jlc3VsdCk7XG4gICAgICAgIHZhciBsZWZ0ID0gKHN0YXJ0WzFdICsgc3RhcnRbMF0pIC8gMi4wO1xuICAgICAgICB2YXIgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0XzEuZGVmYXVsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIFtuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGxlZnQsIHJvd051bWJlciksIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocmlnaHQsIHJvd051bWJlcildLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzkzLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgfTtcbiAgICBDb2RlOTNSZWFkZXIucHJvdG90eXBlLmZpbmRBc3Rlcmlza1BhdHRlcm4gPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHZhciByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldCgwKTtcbiAgICAgICAgdGhpcy5jb3VudGVycy5maWxsKDApO1xuICAgICAgICB2YXIgdGhlQ291bnRlcnMgPSB0aGlzLmNvdW50ZXJzO1xuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICB2YXIgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IHRoZUNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSByb3dPZmZzZXQ7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgIHRoZUNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvUGF0dGVybih0aGVDb3VudGVycykgPT09IENvZGU5M1JlYWRlci5BU1RFUklTS19FTkNPRElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIGldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gdGhlQ291bnRlcnNbMF0gKyB0aGVDb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhlQ291bnRlcnMuY29weVdpdGhpbigwLCAyLCAyICsgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoZUNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhlQ291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoZUNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0O1xuICAgIH07XG4gICAgQ29kZTkzUmVhZGVyLnByb3RvdHlwZS50b1BhdHRlcm4gPSBmdW5jdGlvbiAoY291bnRlcnMpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgY291bnRlcnNfMSA9IF9fdmFsdWVzKGNvdW50ZXJzKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuID0gMDtcbiAgICAgICAgdmFyIG1heCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5LjAgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKHNjYWxlZCA8IDEgfHwgc2NhbGVkID4gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSAmIDB4MDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzY2FsZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAweDAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPDw9IHNjYWxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuICAgIENvZGU5M1JlYWRlci5wcm90b3R5cGUucGF0dGVyblRvQ2hhciA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ29kZTkzUmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDb2RlOTNSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlOTNSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDb2RlOTNSZWFkZXIucHJvdG90eXBlLmRlY29kZUV4dGVuZGVkID0gZnVuY3Rpb24gKGVuY29kZWQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICB2YXIgZGVjb2RlZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGVuY29kZWQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ2QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGVuY29kZWQuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlZENoYXIgPSAnXFwwJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArQSB0byArWiBtYXAgdG8gYSB0byB6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRBIHRvICRaIG1hcCB0byBjb250cm9sIGNvZGVzIFNIIHRvIFNCXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVBIHRvICVFIG1hcCB0byBjb250cm9sIGNvZGVzIEVTQyB0byBVU2VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDM4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ0YnICYmIG5leHQgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJUYgdG8gJUogbWFwIHRvIDsgPCA9ID4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdLJyAmJiBuZXh0IDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVLIHRvICVPIG1hcCB0byBbIFxcIF0gXiBfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gJ1AnICYmIG5leHQgPD0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJVAgdG8gJVQgbWFwIHRvIHsgfCB9IH4gREVMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVVIG1hcCB0byBOVUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJVYgbWFwIHRvIEBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdAJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdXJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVXIG1hcCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnYCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdYJyAmJiBuZXh0IDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVYIHRvICVaIGFsbCBtYXAgdG8gREVMICgxMjcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gL0EgdG8gL08gbWFwIHRvICEgdG8gLCBhbmQgL1ogbWFwcyB0byA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgLy8gYnVtcCB1cCBpIGFnYWluIHNpbmNlIHdlIHJlYWQgdHdvIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfTtcbiAgICBDb2RlOTNSZWFkZXIucHJvdG90eXBlLmNoZWNrQ2hlY2tzdW1zID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5jaGVja09uZUNoZWNrc3VtKHJlc3VsdCwgbGVuZ3RoIC0gMiwgMjApO1xuICAgICAgICB0aGlzLmNoZWNrT25lQ2hlY2tzdW0ocmVzdWx0LCBsZW5ndGggLSAxLCAxNSk7XG4gICAgfTtcbiAgICBDb2RlOTNSZWFkZXIucHJvdG90eXBlLmNoZWNrT25lQ2hlY2tzdW0gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGVja1Bvc2l0aW9uLCB3ZWlnaHRNYXgpIHtcbiAgICAgICAgdmFyIHdlaWdodCA9IDE7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBjaGVja1Bvc2l0aW9uIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHdlaWdodCAqIENvZGU5M1JlYWRlci5BTFBIQUJFVF9TVFJJTkcuaW5kZXhPZihyZXN1bHQuY2hhckF0KGkpKTtcbiAgICAgICAgICAgIGlmICgrK3dlaWdodCA+IHdlaWdodE1heCkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5jaGFyQXQoY2hlY2tQb3NpdGlvbikgIT09IENvZGU5M1JlYWRlci5BTFBIQUJFVF9TVFJJTkdbdG90YWwgJSA0N10pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIE5vdGUgdGhhdCAnYWJjZCcgYXJlIGR1bW15IGNoYXJhY3RlcnMgaW4gcGxhY2Ugb2YgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgIENvZGU5M1JlYWRlci5BTFBIQUJFVF9TVFJJTkcgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyVhYmNkKlwiO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZW5jb2RpbmdzIG9mIGNoYXJhY3RlcnMsIGFzIHBhdHRlcm5zIG9mIHdpZGUgYW5kIG5hcnJvdyBiYXJzLlxuICAgICAqIFRoZSA5IGxlYXN0LXNpZ25pZmljYW50IGJpdHMgb2YgZWFjaCBpbnQgY29ycmVzcG9uZCB0byB0aGUgcGF0dGVybiBvZiB3aWRlIGFuZCBuYXJyb3cuXG4gICAgICovXG4gICAgQ29kZTkzUmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1MgPSBbXG4gICAgICAgIDB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLFxuICAgICAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcbiAgICAgICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgICAgIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsXG4gICAgICAgIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLCAweDE2RSwgMHgxNzYsIDB4MUFFLFxuICAgICAgICAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXG4gICAgXTtcbiAgICBDb2RlOTNSZWFkZXIuQVNURVJJU0tfRU5DT0RJTkcgPSBDb2RlOTNSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HU1s0N107XG4gICAgcmV0dXJuIENvZGU5M1JlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvZGU5M1JlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * <p>Implements decoding of the EAN-13 format.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar EAN13Reader = /** @class */ (function (_super) {\n    __extends(EAN13Reader, _super);\n    function EAN13Reader() {\n        var _this = _super.call(this) || this;\n        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        return _this;\n    }\n    EAN13Reader.prototype.decodeMiddle = function (row, startRange, resultString) {\n        var e_1, _a, e_2, _b;\n        var counters = this.decodeMiddleCounters;\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var end = row.getSize();\n        var rowOffset = startRange[1];\n        var lgPatternFound = 0;\n        for (var x = 0; x < 6 && rowOffset < end; x++) {\n            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_AND_G_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n            try {\n                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (bestMatch >= 10) {\n                lgPatternFound |= 1 << (5 - x);\n            }\n        }\n        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);\n        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));\n        rowOffset = middleRange[1];\n        for (var x = 0; x < 6 && rowOffset < end; x++) {\n            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n            try {\n                for (var counters_2 = (e_2 = void 0, __values(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {\n                    var counter = counters_2_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        return { rowOffset: rowOffset, resultString: resultString };\n    };\n    EAN13Reader.prototype.getBarcodeFormat = function () {\n        return BarcodeFormat_1.default.EAN_13;\n    };\n    EAN13Reader.determineFirstDigit = function (resultString, lgPatternFound) {\n        for (var d = 0; d < 10; d++) {\n            if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {\n                resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;\n                return resultString;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];\n    return EAN13Reader;\n}(UPCEANReader_1.default));\nexports[\"default\"] = EAN13Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0VBTjEzUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELHFCQUFxQixtQkFBTyxDQUFDLDhJQUFnQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsb0JBQW9CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLG9CQUFvQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0VBTjEzUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBVUENFQU5SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL1VQQ0VBTlJlYWRlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBFQU4tMTMgZm9ybWF0LjwvcD5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcbiAqL1xudmFyIEVBTjEzUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFQU4xM1JlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFQU4xM1JlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFQU4xM1JlYWRlci5wcm90b3R5cGUuZGVjb2RlTWlkZGxlID0gZnVuY3Rpb24gKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICB2YXIgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgIHZhciBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgdmFyIGxnUGF0dGVybkZvdW5kID0gMDtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA2ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gKGVfMSA9IHZvaWQgMCwgX192YWx1ZXMoY291bnRlcnMpKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMV8xICYmICFjb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSBjb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwoY291bnRlcnNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICBsZ1BhdHRlcm5Gb3VuZCB8PSAxIDw8ICg1IC0geCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0U3RyaW5nID0gRUFOMTNSZWFkZXIuZGV0ZXJtaW5lRmlyc3REaWdpdChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKTtcbiAgICAgICAgdmFyIG1pZGRsZVJhbmdlID0gVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5maW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB0cnVlLCBVUENFQU5SZWFkZXJfMS5kZWZhdWx0Lk1JRERMRV9QQVRURVJOLCBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXJfMS5kZWZhdWx0Lk1JRERMRV9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgIHJvd09mZnNldCA9IG1pZGRsZVJhbmdlWzFdO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18yID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXMoY291bnRlcnMpKSwgY291bnRlcnNfMl8xID0gY291bnRlcnNfMi5uZXh0KCk7ICFjb3VudGVyc18yXzEuZG9uZTsgY291bnRlcnNfMl8xID0gY291bnRlcnNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMl8xICYmICFjb3VudGVyc18yXzEuZG9uZSAmJiAoX2IgPSBjb3VudGVyc18yLnJldHVybikpIF9iLmNhbGwoY291bnRlcnNfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByb3dPZmZzZXQ6IHJvd09mZnNldCwgcmVzdWx0U3RyaW5nOiByZXN1bHRTdHJpbmcgfTtcbiAgICB9O1xuICAgIEVBTjEzUmVhZGVyLnByb3RvdHlwZS5nZXRCYXJjb2RlRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzEzO1xuICAgIH07XG4gICAgRUFOMTNSZWFkZXIuZGV0ZXJtaW5lRmlyc3REaWdpdCA9IGZ1bmN0aW9uIChyZXN1bHRTdHJpbmcsIGxnUGF0dGVybkZvdW5kKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgMTA7IGQrKykge1xuICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLkZJUlNUX0RJR0lUX0VOQ09ESU5HU1tkXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgZCkpICsgcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgRUFOMTNSZWFkZXIuRklSU1RfRElHSVRfRU5DT0RJTkdTID0gWzB4MDAsIDB4MEIsIDB4MEQsIDB4RSwgMHgxMywgMHgxOSwgMHgxQywgMHgxNSwgMHgxNiwgMHgxQV07XG4gICAgcmV0dXJuIEVBTjEzUmVhZGVyO1xufShVUENFQU5SZWFkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFQU4xM1JlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js\");\n/**\n * <p>Implements decoding of the EAN-8 format.</p>\n *\n * @author Sean Owen\n */\nvar EAN8Reader = /** @class */ (function (_super) {\n    __extends(EAN8Reader, _super);\n    function EAN8Reader() {\n        var _this = _super.call(this) || this;\n        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        return _this;\n    }\n    EAN8Reader.prototype.decodeMiddle = function (row, startRange, resultString) {\n        var e_1, _a, e_2, _b;\n        var counters = this.decodeMiddleCounters;\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var end = row.getSize();\n        var rowOffset = startRange[1];\n        for (var x = 0; x < 4 && rowOffset < end; x++) {\n            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n            try {\n                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));\n        rowOffset = middleRange[1];\n        for (var x = 0; x < 4 && rowOffset < end; x++) {\n            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n            try {\n                for (var counters_2 = (e_2 = void 0, __values(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {\n                    var counter = counters_2_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        return { rowOffset: rowOffset, resultString: resultString };\n    };\n    EAN8Reader.prototype.getBarcodeFormat = function () {\n        return BarcodeFormat_1.default.EAN_8;\n    };\n    return EAN8Reader;\n}(UPCEANReader_1.default));\nexports[\"default\"] = EAN8Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0VBTjhSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsOElBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLG9CQUFvQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsb0JBQW9CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvRUFOOFJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgVVBDRUFOUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9VUENFQU5SZWFkZXJcIik7XG4vKipcbiAqIDxwPkltcGxlbWVudHMgZGVjb2Rpbmcgb2YgdGhlIEVBTi04IGZvcm1hdC48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIEVBTjhSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVBTjhSZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRUFOOFJlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFQU44UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVNaWRkbGUgPSBmdW5jdGlvbiAocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHZhciByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDQgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gKGVfMSA9IHZvaWQgMCwgX192YWx1ZXMoY291bnRlcnMpKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMV8xICYmICFjb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSBjb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwoY291bnRlcnNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkZGxlUmFuZ2UgPSBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LmZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIHRydWUsIFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTUlERExFX1BBVFRFUk4sIG5ldyBJbnQzMkFycmF5KFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTUlERExFX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgcm93T2Zmc2V0ID0gbWlkZGxlUmFuZ2VbMV07XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNCAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LkxfUEFUVEVSTlMpO1xuICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzIgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyhjb3VudGVycykpLCBjb3VudGVyc18yXzEgPSBjb3VudGVyc18yLm5leHQoKTsgIWNvdW50ZXJzXzJfMS5kb25lOyBjb3VudGVyc18yXzEgPSBjb3VudGVyc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc18yXzEgJiYgIWNvdW50ZXJzXzJfMS5kb25lICYmIChfYiA9IGNvdW50ZXJzXzIucmV0dXJuKSkgX2IuY2FsbChjb3VudGVyc18yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJvd09mZnNldDogcm93T2Zmc2V0LCByZXN1bHRTdHJpbmc6IHJlc3VsdFN0cmluZyB9O1xuICAgIH07XG4gICAgRUFOOFJlYWRlci5wcm90b3R5cGUuZ2V0QmFyY29kZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl84O1xuICAgIH07XG4gICAgcmV0dXJuIEVBTjhSZWFkZXI7XG59KFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVBTjhSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/ITFReader.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/ITFReader.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar System_1 = __webpack_require__(/*! ../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\nvar ITFReader = /** @class */ (function (_super) {\n    __extends(ITFReader, _super);\n    function ITFReader() {\n        // private static W = 3; // Pixel width of a 3x wide line\n        // private static w = 2; // Pixel width of a 2x wide line\n        // private static N = 1; // Pixed width of a narrow line\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // Stores the actual narrow line width of the image being decoded.\n        _this.narrowLineWidth = -1;\n        return _this;\n    }\n    // See ITFWriter.PATTERNS\n    /*\n  \n    /!**\n     * Patterns of Wide / Narrow lines to indicate each digit\n     *!/\n    */\n    ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a;\n        // Find out where the Middle section (payload) starts & ends\n        var startRange = this.decodeStart(row);\n        var endRange = this.decodeEnd(row);\n        var result = new StringBuilder_1.default();\n        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n        var resultString = result.toString();\n        var allowedLengths = null;\n        if (hints != null) {\n            allowedLengths = hints.get(DecodeHintType_1.default.ALLOWED_LENGTHS);\n        }\n        if (allowedLengths == null) {\n            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n        }\n        // To avoid false positives with 2D barcodes (and other patterns), make\n        // an assumption that the decoded string must be a 'standard' length if it's short\n        var length = resultString.length;\n        var lengthOK = false;\n        var maxAllowedLength = 0;\n        try {\n            for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n                var value = allowedLengths_1_1.value;\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!lengthOK && length > maxAllowedLength) {\n            lengthOK = true;\n        }\n        if (!lengthOK) {\n            throw new FormatException_1.default();\n        }\n        var points = [new ResultPoint_1.default(startRange[1], rowNumber), new ResultPoint_1.default(endRange[0], rowNumber)];\n        var resultReturn = new Result_1.default(resultString, null, // no natural byte representation for these barcodes\n        0, points, BarcodeFormat_1.default.ITF, new Date().getTime());\n        return resultReturn;\n    };\n    /*\n    /!**\n     * @param row          row of black/white values to search\n     * @param payloadStart offset of start pattern\n     * @param resultString {@link StringBuilder} to append decoded chars to\n     * @throws NotFoundException if decoding could not complete successfully\n     *!/*/\n    ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n        // Digits are interleaved in pairs - 5 black lines for one digit, and the\n        // 5\n        // interleaved white lines for the second digit.\n        // Therefore, need to scan 10 lines and then\n        // split these into two arrays\n        var counterDigitPair = new Int32Array(10); // 10\n        var counterBlack = new Int32Array(5); // 5\n        var counterWhite = new Int32Array(5); // 5\n        counterDigitPair.fill(0);\n        counterBlack.fill(0);\n        counterWhite.fill(0);\n        while (payloadStart < payloadEnd) {\n            // Get 10 runs of black/white.\n            OneDReader_1.default.recordPattern(row, payloadStart, counterDigitPair);\n            // Split them into each array\n            for (var k = 0; k < 5; k++) {\n                var twoK = 2 * k;\n                counterBlack[k] = counterDigitPair[twoK];\n                counterWhite[k] = counterDigitPair[twoK + 1];\n            }\n            var bestMatch = ITFReader.decodeDigit(counterBlack);\n            resultString.append(bestMatch.toString());\n            bestMatch = this.decodeDigit(counterWhite);\n            resultString.append(bestMatch.toString());\n            counterDigitPair.forEach(function (counterDigit) {\n                payloadStart += counterDigit;\n            });\n        }\n    };\n    /*/!**\n     * Identify where the start of the middle / payload section starts.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'start block' and end of\n     *         'start block'\n     *!/*/\n    ITFReader.prototype.decodeStart = function (row) {\n        var endStart = ITFReader.skipWhiteSpace(row);\n        var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n        // Determine the width of a narrow line in pixels. We can do this by\n        // getting the width of the start pattern and dividing by 4 because its\n        // made up of 4 narrow lines.\n        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n        this.validateQuietZone(row, startPattern[0]);\n        return startPattern;\n    };\n    /*/!**\n     * The start & end patterns must be pre/post fixed by a quiet zone. This\n     * zone must be at least 10 times the width of a narrow line.  Scan back until\n     * we either get to the start of the barcode or match the necessary number of\n     * quiet zone pixels.\n     *\n     * Note: Its assumed the row is reversed when using this method to find\n     * quiet zone after the end pattern.\n     *\n     * ref: http://www.barcode-1.net/i25code.html\n     *\n     * @param row bit array representing the scanned barcode.\n     * @param startPattern index into row of the start or end pattern.\n     * @throws NotFoundException if the quiet zone cannot be found\n     *!/*/\n    ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n        var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n        // if there are not so many pixel at all let's try as many as possible\n        quietCount = quietCount < startPattern ? quietCount : startPattern;\n        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n            if (row.get(i)) {\n                break;\n            }\n            quietCount--;\n        }\n        if (quietCount !== 0) {\n            // Unable to find the necessary number of quiet zone pixels.\n            throw new NotFoundException_1.default();\n        }\n    };\n    /*\n    /!**\n     * Skip all whitespace until we get to the first black line.\n     *\n     * @param row row of black/white values to search\n     * @return index of the first black line.\n     * @throws NotFoundException Throws exception if no black lines are found in the row\n     *!/*/\n    ITFReader.skipWhiteSpace = function (row) {\n        var width = row.getSize();\n        var endStart = row.getNextSet(0);\n        if (endStart === width) {\n            throw new NotFoundException_1.default();\n        }\n        return endStart;\n    };\n    /*/!**\n     * Identify where the end of the middle / payload section ends.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'end block' and end of 'end\n     *         block'\n     *!/*/\n    ITFReader.prototype.decodeEnd = function (row) {\n        // For convenience, reverse the row and then\n        // search from 'the start' for the end block\n        row.reverse();\n        try {\n            var endStart = ITFReader.skipWhiteSpace(row);\n            var endPattern = void 0;\n            try {\n                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n            }\n            catch (error) {\n                if (error instanceof NotFoundException_1.default) {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                }\n            }\n            // The start & end patterns must be pre/post fixed by a quiet zone. This\n            // zone must be at least 10 times the width of a narrow line.\n            // ref: http://www.barcode-1.net/i25code.html\n            this.validateQuietZone(row, endPattern[0]);\n            // Now recalculate the indices of where the 'endblock' starts & stops to\n            // accommodate\n            // the reversed nature of the search\n            var temp = endPattern[0];\n            endPattern[0] = row.getSize() - endPattern[1];\n            endPattern[1] = row.getSize() - temp;\n            return endPattern;\n        }\n        finally {\n            // Put the row back the right way.\n            row.reverse();\n        }\n    };\n    /*\n    /!**\n     * @param row       row of black/white values to search\n     * @param rowOffset position to start search\n     * @param pattern   pattern of counts of number of black and white pixels that are\n     *                  being searched for as a pattern\n     * @return start/end horizontal offset of guard pattern, as an array of two\n     *         ints\n     * @throws NotFoundException if pattern is not found\n     *!/*/\n    ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n        var patternLength = pattern.length;\n        var counters = new Int32Array(patternLength);\n        var width = row.getSize();\n        var isWhite = false;\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        counters.fill(0);\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                        return [patternStart, x];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /*/!**\n     * Attempts to decode a sequence of ITF black/white lines into single\n     * digit.\n     *\n     * @param counters the counts of runs of observed black/white/black/... values\n     * @return The decoded digit\n     * @throws NotFoundException if digit cannot be decoded\n     *!/*/\n    ITFReader.decodeDigit = function (counters) {\n        var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n        var bestMatch = -1;\n        var max = ITFReader.PATTERNS.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = ITFReader.PATTERNS[i];\n            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n            else if (variance === bestVariance) {\n                // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                bestMatch = -1;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch % 10;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    ITFReader.PATTERNS = [\n        Int32Array.from([1, 1, 2, 2, 1]),\n        Int32Array.from([2, 1, 1, 1, 2]),\n        Int32Array.from([1, 2, 1, 1, 2]),\n        Int32Array.from([2, 2, 1, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 2]),\n        Int32Array.from([2, 1, 2, 1, 1]),\n        Int32Array.from([1, 2, 2, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2]),\n        Int32Array.from([2, 1, 1, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 3, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 3]),\n        Int32Array.from([1, 3, 1, 1, 3]),\n        Int32Array.from([3, 3, 1, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 3]),\n        Int32Array.from([3, 1, 3, 1, 1]),\n        Int32Array.from([1, 3, 3, 1, 1]),\n        Int32Array.from([1, 1, 1, 3, 3]),\n        Int32Array.from([3, 1, 1, 3, 1]),\n        Int32Array.from([1, 3, 1, 3, 1]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/\n    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([1, 1, 2]),\n        Int32Array.from([1, 1, 3]) // 3x\n    ];\n    return ITFReader;\n}(OneDReader_1.default));\nexports[\"default\"] = ITFReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL0lURlJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsOElBQW1CO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLGdKQUFvQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLHdJQUFnQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxzSkFBdUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLHdJQUFnQjtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQywwSUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILDBCQUEwQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvSVRGUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcub25lZCB7Ki9cbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TeXN0ZW1cIik7XG52YXIgT25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vT25lRFJlYWRlclwiKTtcbi8qKlxuICogPHA+RGVjb2RlcyBJVEYgYmFyY29kZXMuPC9wPlxuICpcbiAqIEBhdXRob3IgVGppZWNvXG4gKi9cbnZhciBJVEZSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElURlJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJVEZSZWFkZXIoKSB7XG4gICAgICAgIC8vIHByaXZhdGUgc3RhdGljIFcgPSAzOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDN4IHdpZGUgbGluZVxuICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyB3ID0gMjsgLy8gUGl4ZWwgd2lkdGggb2YgYSAyeCB3aWRlIGxpbmVcbiAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgTiA9IDE7IC8vIFBpeGVkIHdpZHRoIG9mIGEgbmFycm93IGxpbmVcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIFN0b3JlcyB0aGUgYWN0dWFsIG5hcnJvdyBsaW5lIHdpZHRoIG9mIHRoZSBpbWFnZSBiZWluZyBkZWNvZGVkLlxuICAgICAgICBfdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAtMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBTZWUgSVRGV3JpdGVyLlBBVFRFUk5TXG4gICAgLypcbiAgXG4gICAgLyEqKlxuICAgICAqIFBhdHRlcm5zIG9mIFdpZGUgLyBOYXJyb3cgbGluZXMgdG8gaW5kaWNhdGUgZWFjaCBkaWdpdFxuICAgICAqIS9cbiAgICAqL1xuICAgIElURlJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgLy8gRmluZCBvdXQgd2hlcmUgdGhlIE1pZGRsZSBzZWN0aW9uIChwYXlsb2FkKSBzdGFydHMgJiBlbmRzXG4gICAgICAgIHZhciBzdGFydFJhbmdlID0gdGhpcy5kZWNvZGVTdGFydChyb3cpO1xuICAgICAgICB2YXIgZW5kUmFuZ2UgPSB0aGlzLmRlY29kZUVuZChyb3cpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlWzFdLCBlbmRSYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB2YXIgYWxsb3dlZExlbmd0aHMgPSBudWxsO1xuICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkFMTE9XRURfTEVOR1RIUyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93ZWRMZW5ndGhzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFsbG93ZWRMZW5ndGhzID0gSVRGUmVhZGVyLkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyB3aXRoIDJEIGJhcmNvZGVzIChhbmQgb3RoZXIgcGF0dGVybnMpLCBtYWtlXG4gICAgICAgIC8vIGFuIGFzc3VtcHRpb24gdGhhdCB0aGUgZGVjb2RlZCBzdHJpbmcgbXVzdCBiZSBhICdzdGFuZGFyZCcgbGVuZ3RoIGlmIGl0J3Mgc2hvcnRcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJlc3VsdFN0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGhPSyA9IGZhbHNlO1xuICAgICAgICB2YXIgbWF4QWxsb3dlZExlbmd0aCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhbGxvd2VkTGVuZ3Roc18xID0gX192YWx1ZXMoYWxsb3dlZExlbmd0aHMpLCBhbGxvd2VkTGVuZ3Roc18xXzEgPSBhbGxvd2VkTGVuZ3Roc18xLm5leHQoKTsgIWFsbG93ZWRMZW5ndGhzXzFfMS5kb25lOyBhbGxvd2VkTGVuZ3Roc18xXzEgPSBhbGxvd2VkTGVuZ3Roc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFsbG93ZWRMZW5ndGhzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEFsbG93ZWRMZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Roc18xXzEgJiYgIWFsbG93ZWRMZW5ndGhzXzFfMS5kb25lICYmIChfYSA9IGFsbG93ZWRMZW5ndGhzXzEucmV0dXJuKSkgX2EuY2FsbChhbGxvd2VkTGVuZ3Roc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxlbmd0aE9LICYmIGxlbmd0aCA+IG1heEFsbG93ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aE9LID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxlbmd0aE9LKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2ludHMgPSBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChzdGFydFJhbmdlWzFdLCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZFJhbmdlWzBdLCByb3dOdW1iZXIpXTtcbiAgICAgICAgdmFyIHJlc3VsdFJldHVybiA9IG5ldyBSZXN1bHRfMS5kZWZhdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgLy8gbm8gbmF0dXJhbCBieXRlIHJlcHJlc2VudGF0aW9uIGZvciB0aGVzZSBiYXJjb2Rlc1xuICAgICAgICAwLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LklURiwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0UmV0dXJuO1xuICAgIH07XG4gICAgLypcbiAgICAvISoqXG4gICAgICogQHBhcmFtIHJvdyAgICAgICAgICByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAqIEBwYXJhbSBwYXlsb2FkU3RhcnQgb2Zmc2V0IG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gcmVzdWx0U3RyaW5nIHtAbGluayBTdHJpbmdCdWlsZGVyfSB0byBhcHBlbmQgZGVjb2RlZCBjaGFycyB0b1xuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGVjb2RpbmcgY291bGQgbm90IGNvbXBsZXRlIHN1Y2Nlc3NmdWxseVxuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUgPSBmdW5jdGlvbiAocm93LCBwYXlsb2FkU3RhcnQsIHBheWxvYWRFbmQsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAvLyBEaWdpdHMgYXJlIGludGVybGVhdmVkIGluIHBhaXJzIC0gNSBibGFjayBsaW5lcyBmb3Igb25lIGRpZ2l0LCBhbmQgdGhlXG4gICAgICAgIC8vIDVcbiAgICAgICAgLy8gaW50ZXJsZWF2ZWQgd2hpdGUgbGluZXMgZm9yIHRoZSBzZWNvbmQgZGlnaXQuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgbmVlZCB0byBzY2FuIDEwIGxpbmVzIGFuZCB0aGVuXG4gICAgICAgIC8vIHNwbGl0IHRoZXNlIGludG8gdHdvIGFycmF5c1xuICAgICAgICB2YXIgY291bnRlckRpZ2l0UGFpciA9IG5ldyBJbnQzMkFycmF5KDEwKTsgLy8gMTBcbiAgICAgICAgdmFyIGNvdW50ZXJCbGFjayA9IG5ldyBJbnQzMkFycmF5KDUpOyAvLyA1XG4gICAgICAgIHZhciBjb3VudGVyV2hpdGUgPSBuZXcgSW50MzJBcnJheSg1KTsgLy8gNVxuICAgICAgICBjb3VudGVyRGlnaXRQYWlyLmZpbGwoMCk7XG4gICAgICAgIGNvdW50ZXJCbGFjay5maWxsKDApO1xuICAgICAgICBjb3VudGVyV2hpdGUuZmlsbCgwKTtcbiAgICAgICAgd2hpbGUgKHBheWxvYWRTdGFydCA8IHBheWxvYWRFbmQpIHtcbiAgICAgICAgICAgIC8vIEdldCAxMCBydW5zIG9mIGJsYWNrL3doaXRlLlxuICAgICAgICAgICAgT25lRFJlYWRlcl8xLmRlZmF1bHQucmVjb3JkUGF0dGVybihyb3csIHBheWxvYWRTdGFydCwgY291bnRlckRpZ2l0UGFpcik7XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGVtIGludG8gZWFjaCBhcnJheVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA1OyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHdvSyA9IDIgKiBrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJCbGFja1trXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvS107XG4gICAgICAgICAgICAgICAgY291bnRlcldoaXRlW2tdID0gY291bnRlckRpZ2l0UGFpclt0d29LICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmVzdE1hdGNoID0gSVRGUmVhZGVyLmRlY29kZURpZ2l0KGNvdW50ZXJCbGFjayk7XG4gICAgICAgICAgICByZXN1bHRTdHJpbmcuYXBwZW5kKGJlc3RNYXRjaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGJlc3RNYXRjaCA9IHRoaXMuZGVjb2RlRGlnaXQoY291bnRlcldoaXRlKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY291bnRlckRpZ2l0UGFpci5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudGVyRGlnaXQpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU3RhcnQgKz0gY291bnRlckRpZ2l0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qLyEqKlxuICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBzdGFydCBvZiB0aGUgbWlkZGxlIC8gcGF5bG9hZCBzZWN0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIEFycmF5LCBjb250YWluaW5nIGluZGV4IG9mIHN0YXJ0IG9mICdzdGFydCBibG9jaycgYW5kIGVuZCBvZlxuICAgICAqICAgICAgICAgJ3N0YXJ0IGJsb2NrJ1xuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5wcm90b3R5cGUuZGVjb2RlU3RhcnQgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBlbmRTdGFydCA9IElURlJlYWRlci5za2lwV2hpdGVTcGFjZShyb3cpO1xuICAgICAgICB2YXIgc3RhcnRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4pO1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHdpZHRoIG9mIGEgbmFycm93IGxpbmUgaW4gcGl4ZWxzLiBXZSBjYW4gZG8gdGhpcyBieVxuICAgICAgICAvLyBnZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgc3RhcnQgcGF0dGVybiBhbmQgZGl2aWRpbmcgYnkgNCBiZWNhdXNlIGl0c1xuICAgICAgICAvLyBtYWRlIHVwIG9mIDQgbmFycm93IGxpbmVzLlxuICAgICAgICB0aGlzLm5hcnJvd0xpbmVXaWR0aCA9IChzdGFydFBhdHRlcm5bMV0gLSBzdGFydFBhdHRlcm5bMF0pIC8gNDtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVF1aWV0Wm9uZShyb3csIHN0YXJ0UGF0dGVyblswXSk7XG4gICAgICAgIHJldHVybiBzdGFydFBhdHRlcm47XG4gICAgfTtcbiAgICAvKi8hKipcbiAgICAgKiBUaGUgc3RhcnQgJiBlbmQgcGF0dGVybnMgbXVzdCBiZSBwcmUvcG9zdCBmaXhlZCBieSBhIHF1aWV0IHpvbmUuIFRoaXNcbiAgICAgKiB6b25lIG11c3QgYmUgYXQgbGVhc3QgMTAgdGltZXMgdGhlIHdpZHRoIG9mIGEgbmFycm93IGxpbmUuICBTY2FuIGJhY2sgdW50aWxcbiAgICAgKiB3ZSBlaXRoZXIgZ2V0IHRvIHRoZSBzdGFydCBvZiB0aGUgYmFyY29kZSBvciBtYXRjaCB0aGUgbmVjZXNzYXJ5IG51bWJlciBvZlxuICAgICAqIHF1aWV0IHpvbmUgcGl4ZWxzLlxuICAgICAqXG4gICAgICogTm90ZTogSXRzIGFzc3VtZWQgdGhlIHJvdyBpcyByZXZlcnNlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kIHRvIGZpbmRcbiAgICAgKiBxdWlldCB6b25lIGFmdGVyIHRoZSBlbmQgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIHJlZjogaHR0cDovL3d3dy5iYXJjb2RlLTEubmV0L2kyNWNvZGUuaHRtbFxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdyBiaXQgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBzY2FubmVkIGJhcmNvZGUuXG4gICAgICogQHBhcmFtIHN0YXJ0UGF0dGVybiBpbmRleCBpbnRvIHJvdyBvZiB0aGUgc3RhcnQgb3IgZW5kIHBhdHRlcm4uXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiB0aGUgcXVpZXQgem9uZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgKiEvKi9cbiAgICBJVEZSZWFkZXIucHJvdG90eXBlLnZhbGlkYXRlUXVpZXRab25lID0gZnVuY3Rpb24gKHJvdywgc3RhcnRQYXR0ZXJuKSB7XG4gICAgICAgIHZhciBxdWlldENvdW50ID0gdGhpcy5uYXJyb3dMaW5lV2lkdGggKiAxMDsgLy8gZXhwZWN0IHRvIGZpbmQgdGhpcyBtYW55IHBpeGVscyBvZiBxdWlldCB6b25lXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBub3Qgc28gbWFueSBwaXhlbCBhdCBhbGwgbGV0J3MgdHJ5IGFzIG1hbnkgYXMgcG9zc2libGVcbiAgICAgICAgcXVpZXRDb3VudCA9IHF1aWV0Q291bnQgPCBzdGFydFBhdHRlcm4gPyBxdWlldENvdW50IDogc3RhcnRQYXR0ZXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRQYXR0ZXJuIC0gMTsgcXVpZXRDb3VudCA+IDAgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWlldENvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1aWV0Q291bnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFVuYWJsZSB0byBmaW5kIHRoZSBuZWNlc3NhcnkgbnVtYmVyIG9mIHF1aWV0IHpvbmUgcGl4ZWxzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgIC8hKipcbiAgICAgKiBTa2lwIGFsbCB3aGl0ZXNwYWNlIHVudGlsIHdlIGdldCB0byB0aGUgZmlyc3QgYmxhY2sgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIGluZGV4IG9mIHRoZSBmaXJzdCBibGFjayBsaW5lLlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gVGhyb3dzIGV4Y2VwdGlvbiBpZiBubyBibGFjayBsaW5lcyBhcmUgZm91bmQgaW4gdGhlIHJvd1xuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5za2lwV2hpdGVTcGFjZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgdmFyIGVuZFN0YXJ0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgIGlmIChlbmRTdGFydCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kU3RhcnQ7XG4gICAgfTtcbiAgICAvKi8hKipcbiAgICAgKiBJZGVudGlmeSB3aGVyZSB0aGUgZW5kIG9mIHRoZSBtaWRkbGUgLyBwYXlsb2FkIHNlY3Rpb24gZW5kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIEFycmF5LCBjb250YWluaW5nIGluZGV4IG9mIHN0YXJ0IG9mICdlbmQgYmxvY2snIGFuZCBlbmQgb2YgJ2VuZFxuICAgICAqICAgICAgICAgYmxvY2snXG4gICAgICohLyovXG4gICAgSVRGUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVFbmQgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIC8vIEZvciBjb252ZW5pZW5jZSwgcmV2ZXJzZSB0aGUgcm93IGFuZCB0aGVuXG4gICAgICAgIC8vIHNlYXJjaCBmcm9tICd0aGUgc3RhcnQnIGZvciB0aGUgZW5kIGJsb2NrXG4gICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZW5kU3RhcnQgPSBJVEZSZWFkZXIuc2tpcFdoaXRlU3BhY2Uocm93KTtcbiAgICAgICAgICAgIHZhciBlbmRQYXR0ZXJuID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbmRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgc3RhcnQgJiBlbmQgcGF0dGVybnMgbXVzdCBiZSBwcmUvcG9zdCBmaXhlZCBieSBhIHF1aWV0IHpvbmUuIFRoaXNcbiAgICAgICAgICAgIC8vIHpvbmUgbXVzdCBiZSBhdCBsZWFzdCAxMCB0aW1lcyB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZS5cbiAgICAgICAgICAgIC8vIHJlZjogaHR0cDovL3d3dy5iYXJjb2RlLTEubmV0L2kyNWNvZGUuaHRtbFxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVF1aWV0Wm9uZShyb3csIGVuZFBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgLy8gTm93IHJlY2FsY3VsYXRlIHRoZSBpbmRpY2VzIG9mIHdoZXJlIHRoZSAnZW5kYmxvY2snIHN0YXJ0cyAmIHN0b3BzIHRvXG4gICAgICAgICAgICAvLyBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHJldmVyc2VkIG5hdHVyZSBvZiB0aGUgc2VhcmNoXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGVuZFBhdHRlcm5bMF07XG4gICAgICAgICAgICBlbmRQYXR0ZXJuWzBdID0gcm93LmdldFNpemUoKSAtIGVuZFBhdHRlcm5bMV07XG4gICAgICAgICAgICBlbmRQYXR0ZXJuWzFdID0gcm93LmdldFNpemUoKSAtIHRlbXA7XG4gICAgICAgICAgICByZXR1cm4gZW5kUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgcm93IGJhY2sgdGhlIHJpZ2h0IHdheS5cbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgLyEqKlxuICAgICAqIEBwYXJhbSByb3cgICAgICAgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAqIEBwYXJhbSBwYXR0ZXJuICAgcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJlaW5nIHNlYXJjaGVkIGZvciBhcyBhIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHN0YXJ0L2VuZCBob3Jpem9udGFsIG9mZnNldCBvZiBndWFyZCBwYXR0ZXJuLCBhcyBhbiBhcnJheSBvZiB0d29cbiAgICAgKiAgICAgICAgIGludHNcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHBhdHRlcm4gaXMgbm90IGZvdW5kXG4gICAgICohLyovXG4gICAgSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4gPSBmdW5jdGlvbiAocm93LCByb3dPZmZzZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkocGF0dGVybkxlbmd0aCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICBjb3VudGVycy5maWxsKDApO1xuICAgICAgICBmb3IgKHZhciB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBJVEZSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb3VudGVycywgMiwgY291bnRlcnMsIDAsIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyovISoqXG4gICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgc2VxdWVuY2Ugb2YgSVRGIGJsYWNrL3doaXRlIGxpbmVzIGludG8gc2luZ2xlXG4gICAgICogZGlnaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY291bnRlcnMgdGhlIGNvdW50cyBvZiBydW5zIG9mIG9ic2VydmVkIGJsYWNrL3doaXRlL2JsYWNrLy4uLiB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIFRoZSBkZWNvZGVkIGRpZ2l0XG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBkaWdpdCBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5kZWNvZGVEaWdpdCA9IGZ1bmN0aW9uIChjb3VudGVycykge1xuICAgICAgICB2YXIgYmVzdFZhcmlhbmNlID0gSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0U7IC8vIHdvcnN0IHZhcmlhbmNlIHdlJ2xsIGFjY2VwdFxuICAgICAgICB2YXIgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgIHZhciBtYXggPSBJVEZSZWFkZXIuUEFUVEVSTlMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IElURlJlYWRlci5QQVRURVJOU1tpXTtcbiAgICAgICAgICAgIHZhciB2YXJpYW5jZSA9IE9uZURSZWFkZXJfMS5kZWZhdWx0LnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xuICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhbmNlID09PSBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgc2Vjb25kICdiZXN0IG1hdGNoJyB3aXRoIHRoZSBzYW1lIHZhcmlhbmNlLCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJlcG9ydCB0byBoYXZlIGEgc3VpdGFibGUgbWF0Y2hcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2ggJSAxMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSVRGUmVhZGVyLlBBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAzLCAxXSkgLy8gOVxuICAgIF07XG4gICAgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjM4O1xuICAgIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNTtcbiAgICAvKiAvISoqIFZhbGlkIElURiBsZW5ndGhzLiBBbnl0aGluZyBsb25nZXIgdGhhbiB0aGUgbGFyZ2VzdCB2YWx1ZSBpcyBhbHNvIGFsbG93ZWQuICohLyovXG4gICAgSVRGUmVhZGVyLkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTID0gWzYsIDgsIDEwLCAxMiwgMTRdO1xuICAgIC8qLyEqKlxuICAgICAqIFN0YXJ0L2VuZCBndWFyZCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIGVuZCBwYXR0ZXJuIGlzIHJldmVyc2VkIGJlY2F1c2UgdGhlIHJvdyBpcyByZXZlcnNlZCBiZWZvcmVcbiAgICAgKiBzZWFyY2hpbmcgZm9yIHRoZSBFTkRfUEFUVEVSTlxuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxXSk7XG4gICAgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzXSkgLy8gM3hcbiAgICBdO1xuICAgIHJldHVybiBJVEZSZWFkZXI7XG59KE9uZURSZWFkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJVEZSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/ITFReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar Code128Reader_1 = __webpack_require__(/*! ./Code128Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js\");\nvar Code39Reader_1 = __webpack_require__(/*! ./Code39Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js\");\nvar Code93Reader_1 = __webpack_require__(/*! ./Code93Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js\");\nvar ITFReader_1 = __webpack_require__(/*! ./ITFReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/ITFReader.js\");\nvar MultiFormatUPCEANReader_1 = __webpack_require__(/*! ./MultiFormatUPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar CodaBarReader_1 = __webpack_require__(/*! ./CodaBarReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js\");\nvar RSSExpandedReader_1 = __webpack_require__(/*! ./rss/expanded/RSSExpandedReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js\");\nvar RSS14Reader_1 = __webpack_require__(/*! ./rss/RSS14Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js\");\n/**\n * @author Daniel Switkin <dswitkin@google.com>\n * @author Sean Owen\n */\nvar MultiFormatOneDReader = /** @class */ (function (_super) {\n    __extends(MultiFormatOneDReader, _super);\n    function MultiFormatOneDReader(hints) {\n        var _this = _super.call(this) || this;\n        _this.readers = [];\n        var possibleFormats = !hints ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\n        var useCode39CheckDigit = hints && hints.get(DecodeHintType_1.default.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;\n        var useCode39ExtendedMode = hints && hints.get(DecodeHintType_1.default.ENABLE_CODE_39_EXTENDED_MODE) !== undefined;\n        if (possibleFormats) {\n            if (possibleFormats.includes(BarcodeFormat_1.default.EAN_13) ||\n                possibleFormats.includes(BarcodeFormat_1.default.UPC_A) ||\n                possibleFormats.includes(BarcodeFormat_1.default.EAN_8) ||\n                possibleFormats.includes(BarcodeFormat_1.default.UPC_E)) {\n                _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_39)) {\n                _this.readers.push(new Code39Reader_1.default(useCode39CheckDigit, useCode39ExtendedMode));\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_93)) {\n                _this.readers.push(new Code93Reader_1.default());\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_128)) {\n                _this.readers.push(new Code128Reader_1.default());\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.ITF)) {\n                _this.readers.push(new ITFReader_1.default());\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.CODABAR)) {\n                _this.readers.push(new CodaBarReader_1.default());\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.RSS_14)) {\n                _this.readers.push(new RSS14Reader_1.default());\n            }\n            if (possibleFormats.includes(BarcodeFormat_1.default.RSS_EXPANDED)) {\n                console.warn('RSS Expanded reader IS NOT ready for production yet! use at your own risk.');\n                _this.readers.push(new RSSExpandedReader_1.default());\n            }\n        }\n        if (_this.readers.length === 0) {\n            _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));\n            _this.readers.push(new Code39Reader_1.default());\n            // this.readers.push(new CodaBarReader());\n            _this.readers.push(new Code93Reader_1.default());\n            _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));\n            _this.readers.push(new Code128Reader_1.default());\n            _this.readers.push(new ITFReader_1.default());\n            _this.readers.push(new RSS14Reader_1.default());\n            // this.readers.push(new RSSExpandedReader());\n        }\n        return _this;\n    }\n    // @Override\n    MultiFormatOneDReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        for (var i = 0; i < this.readers.length; i++) {\n            try {\n                return this.readers[i].decodeRow(rowNumber, row, hints);\n            }\n            catch (re) {\n                // continue\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    // @Override\n    MultiFormatOneDReader.prototype.reset = function () {\n        this.readers.forEach(function (reader) { return reader.reset(); });\n    };\n    return MultiFormatOneDReader;\n}(OneDReader_1.default));\nexports[\"default\"] = MultiFormatOneDReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL011bHRpRm9ybWF0T25lRFJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsOElBQW1CO0FBQ2xELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQyxnSkFBaUI7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsOElBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLDhJQUFnQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyx3SUFBYTtBQUN2QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxvS0FBMkI7QUFDbkUsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsZ0pBQWlCO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLGtMQUFrQztBQUNwRSxvQkFBb0IsbUJBQU8sQ0FBQyxvSkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvTXVsdGlGb3JtYXRPbmVEUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcub25lZCB7Ki9cbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgQ29kZTEyOFJlYWRlcl8xID0gcmVxdWlyZShcIi4vQ29kZTEyOFJlYWRlclwiKTtcbnZhciBDb2RlMzlSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0NvZGUzOVJlYWRlclwiKTtcbnZhciBDb2RlOTNSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0NvZGU5M1JlYWRlclwiKTtcbnZhciBJVEZSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0lURlJlYWRlclwiKTtcbnZhciBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vTXVsdGlGb3JtYXRVUENFQU5SZWFkZXJcIik7XG52YXIgT25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vT25lRFJlYWRlclwiKTtcbnZhciBDb2RhQmFyUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9Db2RhQmFyUmVhZGVyXCIpO1xudmFyIFJTU0V4cGFuZGVkUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9yc3MvZXhwYW5kZWQvUlNTRXhwYW5kZWRSZWFkZXJcIik7XG52YXIgUlNTMTRSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL3Jzcy9SU1MxNFJlYWRlclwiKTtcbi8qKlxuICogQGF1dGhvciBEYW5pZWwgU3dpdGtpbiA8ZHN3aXRraW5AZ29vZ2xlLmNvbT5cbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBNdWx0aUZvcm1hdE9uZURSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpRm9ybWF0T25lRFJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVhZGVycyA9IFtdO1xuICAgICAgICB2YXIgcG9zc2libGVGb3JtYXRzID0gIWhpbnRzID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgIHZhciB1c2VDb2RlMzlDaGVja0RpZ2l0ID0gaGludHMgJiYgaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5BU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVCkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVzZUNvZGUzOUV4dGVuZGVkTW9kZSA9IGhpbnRzICYmIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRU5BQkxFX0NPREVfMzlfRVhURU5ERURfTU9ERSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cykge1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fMTMpIHx8XG4gICAgICAgICAgICAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BKSB8fFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fOCkgfHxcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuVVBDX0UpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQoaGludHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09ERV8zOSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcl8xLmRlZmF1bHQodXNlQ29kZTM5Q2hlY2tEaWdpdCwgdXNlQ29kZTM5RXh0ZW5kZWRNb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkNPREVfOTMpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlOTNSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzEyOCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5JVEYpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBJVEZSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RBQkFSKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kYUJhclJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlJTU18xNCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTUzE0UmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUlNTX0VYUEFOREVEKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUlNTIEV4cGFuZGVkIHJlYWRlciBJUyBOT1QgcmVhZHkgZm9yIHByb2R1Y3Rpb24geWV0ISB1c2UgYXQgeW91ciBvd24gcmlzay4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTU0V4cGFuZGVkUmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMucmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXJfMS5kZWZhdWx0KGhpbnRzKSk7XG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kYUJhclJlYWRlcigpKTtcbiAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXJfMS5kZWZhdWx0KGhpbnRzKSk7XG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBJVEZSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBSU1MxNFJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTRXhwYW5kZWRSZWFkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBNdWx0aUZvcm1hdE9uZURSZWFkZXIucHJvdG90eXBlLmRlY29kZVJvdyA9IGZ1bmN0aW9uIChyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyc1tpXS5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChyZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLy8gQE92ZXJyaWRlXG4gICAgTXVsdGlGb3JtYXRPbmVEUmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlYWRlcikgeyByZXR1cm4gcmVhZGVyLnJlc2V0KCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpRm9ybWF0T25lRFJlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpRm9ybWF0T25lRFJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar OneDReader_1 = __webpack_require__(/*! ./OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar EAN13Reader_1 = __webpack_require__(/*! ./EAN13Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js\");\nvar EAN8Reader_1 = __webpack_require__(/*! ./EAN8Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js\");\nvar UPCAReader_1 = __webpack_require__(/*! ./UPCAReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar UPCEReader_1 = __webpack_require__(/*! ./UPCEReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js\");\n/**\n * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\n * read all such formats, it is most efficient to use this implementation rather than invoke\n * individual readers.</p>\n *\n * @author Sean Owen\n */\nvar MultiFormatUPCEANReader = /** @class */ (function (_super) {\n    __extends(MultiFormatUPCEANReader, _super);\n    function MultiFormatUPCEANReader(hints) {\n        var _this = _super.call(this) || this;\n        var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\n        var readers = [];\n        if (possibleFormats != null) {\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_13) > -1) {\n                readers.push(new EAN13Reader_1.default());\n            }\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.UPC_A) > -1) {\n                readers.push(new UPCAReader_1.default());\n            }\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_8) > -1) {\n                readers.push(new EAN8Reader_1.default());\n            }\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.UPC_E) > -1) {\n                readers.push(new UPCEReader_1.default());\n            }\n        }\n        if (readers.length === 0) {\n            readers.push(new EAN13Reader_1.default());\n            readers.push(new UPCAReader_1.default());\n            readers.push(new EAN8Reader_1.default());\n            readers.push(new UPCEReader_1.default());\n        }\n        _this.readers = readers;\n        return _this;\n    }\n    MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var reader = _c.value;\n                try {\n                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);\n                    var result = reader.decodeRow(rowNumber, row, hints);\n                    // Special case: a 12-digit code encoded in UPC-A is identical to a \"0\"\n                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,\n                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with \"0\".\n                    // Individually these are correct and their readers will both read such a code\n                    // and correctly call it EAN-13, or UPC-A, respectively.\n                    //\n                    // In this case, if we've been looking for both types, we'd like to call it\n                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read\n                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A\n                    // result if appropriate.\n                    //\n                    // But, don't return UPC-A if UPC-A was not a requested format!\n                    var ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat_1.default.EAN_13 &&\n                        result.getText().charAt(0) === '0';\n                    // @SuppressWarnings(\"unchecked\")\n                    var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\n                    var canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat_1.default.UPC_A);\n                    if (ean13MayBeUPCA && canReturnUPCA) {\n                        var rawBytes = result.getRawBytes();\n                        // Transfer the metadata across\n                        var resultUPCA = new Result_1.default(result.getText().substring(1), rawBytes, (rawBytes ? rawBytes.length : null), result.getResultPoints(), BarcodeFormat_1.default.UPC_A);\n                        resultUPCA.putAllMetadata(result.getResultMetadata());\n                        return resultUPCA;\n                    }\n                    return result;\n                }\n                catch (err) {\n                    // continue;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        throw new NotFoundException_1.default();\n    };\n    MultiFormatUPCEANReader.prototype.reset = function () {\n        var e_2, _a;\n        try {\n            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var reader = _c.value;\n                reader.reset();\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    return MultiFormatUPCEANReader;\n}(OneDReader_1.default));\nexports[\"default\"] = MultiFormatUPCEANReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL011bHRpRm9ybWF0VVBDRUFOUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLDhJQUFtQjtBQUNsRCxlQUFlLG1CQUFPLENBQUMsOEhBQVc7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsNElBQWU7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsMElBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLDBJQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL011bHRpRm9ybWF0VVBDRUFOUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9PbmVEUmVhZGVyXCIpO1xudmFyIEVBTjEzUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9FQU4xM1JlYWRlclwiKTtcbnZhciBFQU44UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9FQU44UmVhZGVyXCIpO1xudmFyIFVQQ0FSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL1VQQ0FSZWFkZXJcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBVUENFUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9VUENFUmVhZGVyXCIpO1xuLyoqXG4gKiA8cD5BIHJlYWRlciB0aGF0IGNhbiByZWFkIGFsbCBhdmFpbGFibGUgVVBDL0VBTiBmb3JtYXRzLiBJZiBhIGNhbGxlciB3YW50cyB0byB0cnkgdG9cbiAqIHJlYWQgYWxsIHN1Y2ggZm9ybWF0cywgaXQgaXMgbW9zdCBlZmZpY2llbnQgdG8gdXNlIHRoaXMgaW1wbGVtZW50YXRpb24gcmF0aGVyIHRoYW4gaW52b2tlXG4gKiBpbmRpdmlkdWFsIHJlYWRlcnMuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIoaGludHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgdmFyIHBvc3NpYmxlRm9ybWF0cyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgdmFyIHJlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzEzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuVVBDX0EpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0FSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl84KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU44UmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5VUENfRSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDRVJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjEzUmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDQVJlYWRlcl8xLmRlZmF1bHQoKSk7XG4gICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjhSZWFkZXJfMS5kZWZhdWx0KCkpO1xuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENFUmVhZGVyXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZWFkZXJzID0gcmVhZGVycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5yZWFkZXJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCByZXN1bHQ6IFJlc3VsdCA9IHJlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIHN0YXJ0R3VhcmRQYXR0ZXJuLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogYSAxMi1kaWdpdCBjb2RlIGVuY29kZWQgaW4gVVBDLUEgaXMgaWRlbnRpY2FsIHRvIGEgXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhvc2UgMTIgZGlnaXRzIGVuY29kZWQgYXMgRUFOLTEzLiBFYWNoIHdpbGwgcmVjb2duaXplIHN1Y2ggYSBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAvLyBVUEMtQSBhcyBhIDEyLWRpZ2l0IHN0cmluZyBhbmQgRUFOLTEzIGFzIGEgMTMtZGlnaXQgc3RyaW5nIHN0YXJ0aW5nIHdpdGggXCIwXCIuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGl2aWR1YWxseSB0aGVzZSBhcmUgY29ycmVjdCBhbmQgdGhlaXIgcmVhZGVycyB3aWxsIGJvdGggcmVhZCBzdWNoIGEgY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29ycmVjdGx5IGNhbGwgaXQgRUFOLTEzLCBvciBVUEMtQSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGlmIHdlJ3ZlIGJlZW4gbG9va2luZyBmb3IgYm90aCB0eXBlcywgd2UnZCBsaWtlIHRvIGNhbGwgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBVUEMtQSBjb2RlLiBCdXQgZm9yIGVmZmljaWVuY3kgd2Ugb25seSBydW4gdGhlIEVBTi0xMyBkZWNvZGVyIHRvIGFsc28gcmVhZFxuICAgICAgICAgICAgICAgICAgICAvLyBVUEMtQS4gU28gd2Ugc3BlY2lhbCBjYXNlIGl0IGhlcmUsIGFuZCBjb252ZXJ0IGFuIEVBTi0xMyByZXN1bHQgdG8gYSBVUEMtQVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCwgZG9uJ3QgcmV0dXJuIFVQQy1BIGlmIFVQQy1BIHdhcyBub3QgYSByZXF1ZXN0ZWQgZm9ybWF0IVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWFuMTNNYXlCZVVQQ0EgPSByZXN1bHQuZ2V0QmFyY29kZUZvcm1hdCgpID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fMTMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRUZXh0KCkuY2hhckF0KDApID09PSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBTdXBwcmVzc1dhcm5pbmdzKFwidW5jaGVja2VkXCIpXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUZvcm1hdHMgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5SZXR1cm5VUENBID0gcG9zc2libGVGb3JtYXRzID09IG51bGwgfHwgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhbjEzTWF5QmVVUENBICYmIGNhblJldHVyblVQQ0EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdCeXRlcyA9IHJlc3VsdC5nZXRSYXdCeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmZXIgdGhlIG1ldGFkYXRhIGFjcm9zc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdFVQQ0EgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdChyZXN1bHQuZ2V0VGV4dCgpLnN1YnN0cmluZygxKSwgcmF3Qnl0ZXMsIChyYXdCeXRlcyA/IHJhd0J5dGVzLmxlbmd0aCA6IG51bGwpLCByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCksIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFVQQ0EucHV0QWxsTWV0YWRhdGEocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFVQQ0E7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnJlYWRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BitArray_1 = __webpack_require__(/*! ../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */ (function () {\n    function OneDReader() {\n    }\n    /*\n    @Override\n    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n      return decode(image, null);\n    }\n    */\n    // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n    // @Override\n    OneDReader.prototype.decode = function (image, hints) {\n        try {\n            return this.doDecode(image, hints);\n        }\n        catch (nfe) {\n            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n            if (tryHarder && image.isRotateSupported()) {\n                var rotatedImage = image.rotateCounterClockwise();\n                var result = this.doDecode(rotatedImage, hints);\n                // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                var metadata = result.getResultMetadata();\n                var orientation_1 = 270;\n                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {\n                    // But if we found it reversed in doDecode(), add in that result here:\n                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);\n                }\n                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n                // Update result points\n                var points = result.getResultPoints();\n                if (points !== null) {\n                    var height = rotatedImage.getHeight();\n                    for (var i = 0; i < points.length; i++) {\n                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n                    }\n                }\n                return result;\n            }\n            else {\n                throw new NotFoundException_1.default();\n            }\n        }\n    };\n    // @Override\n    OneDReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * We're going to examine rows from the middle outward, searching alternately above and below the\n     * middle, and farther out each time. rowStep is the number of rows between each successive\n     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n     * middle + rowStep, then middle - (2 * rowStep), etc.\n     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n     * image if \"trying harder\".\n     *\n     * @param image The image to decode\n     * @param hints Any hints that were requested\n     * @return The contents of the decoded barcode\n     * @throws NotFoundException Any spontaneous errors which occur\n     */\n    OneDReader.prototype.doDecode = function (image, hints) {\n        var width = image.getWidth();\n        var height = image.getHeight();\n        var row = new BitArray_1.default(width);\n        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n        var maxLines;\n        if (tryHarder) {\n            maxLines = height; // Look at the whole image, not just the center\n        }\n        else {\n            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n        }\n        var middle = Math.trunc(height / 2);\n        for (var x = 0; x < maxLines; x++) {\n            // Scanning from the middle out. Determine which row we're looking at next:\n            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n            var isAbove = (x & 0x01) === 0; // i.e. is x even?\n            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n            if (rowNumber < 0 || rowNumber >= height) {\n                // Oops, if we run off the top or bottom, stop\n                break;\n            }\n            // Estimate black point for this row and load it:\n            try {\n                row = image.getBlackRow(rowNumber, row);\n            }\n            catch (ignored) {\n                continue;\n            }\n            var _loop_1 = function (attempt) {\n                if (attempt === 1) { // trying again?\n                    row.reverse(); // reverse the row and continue\n                    // This means we will only ever draw result points *once* in the life of this method\n                    // since we want to avoid drawing the wrong points after flipping the row, and,\n                    // don't want to clutter with noise from every single row scan -- just the scans\n                    // that start on the center line.\n                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {\n                        var newHints_1 = new Map();\n                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });\n                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n                        hints = newHints_1;\n                    }\n                }\n                try {\n                    // Look for a barcode\n                    var result = this_1.decodeRow(rowNumber, row, hints);\n                    // We found our barcode\n                    if (attempt === 1) {\n                        // But it was upside down, so note that\n                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n                        // And remember to flip the result points horizontally.\n                        var points = result.getResultPoints();\n                        if (points !== null) {\n                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n                        }\n                    }\n                    return { value: result };\n                }\n                catch (re) {\n                    // continue -- just couldn't decode this row\n                }\n            };\n            var this_1 = this;\n            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n            // handle decoding upside down barcodes.\n            for (var attempt = 0; attempt < 2; attempt++) {\n                var state_1 = _loop_1(attempt);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n     * The values are recorded in the given array, and the number of runs recorded is equal to the size\n     * of the array. If the row starts on a white pixel at the given start point, then the first count\n     * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n     * of black pixels if the row begin on a black pixels at that point.\n     *\n     * @param row row to count from\n     * @param start offset into row to start at\n     * @param counters array into which to record counts\n     * @throws NotFoundException if counters cannot be filled entirely from row before running out\n     *  of pixels\n     */\n    OneDReader.recordPattern = function (row, start, counters) {\n        var numCounters = counters.length;\n        for (var index = 0; index < numCounters; index++)\n            counters[index] = 0;\n        var end = row.getSize();\n        if (start >= end) {\n            throw new NotFoundException_1.default();\n        }\n        var isWhite = !row.get(start);\n        var counterPosition = 0;\n        var i = start;\n        while (i < end) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (++counterPosition === numCounters) {\n                    break;\n                }\n                else {\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            i++;\n        }\n        // If we read fully the last section of pixels and filled up our counters -- or filled\n        // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n            throw new NotFoundException_1.default();\n        }\n    };\n    OneDReader.recordPatternInReverse = function (row, start, counters) {\n        // This could be more efficient I guess\n        var numTransitionsLeft = counters.length;\n        var last = row.get(start);\n        while (start > 0 && numTransitionsLeft >= 0) {\n            if (row.get(--start) !== last) {\n                numTransitionsLeft--;\n                last = !last;\n            }\n        }\n        if (numTransitionsLeft >= 0) {\n            throw new NotFoundException_1.default();\n        }\n        OneDReader.recordPattern(row, start + 1, counters);\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white values matches a given\n     * target pattern. This is reported as the ratio of the total variance from the expected pattern\n     * proportions across all pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this is too small\n            // to reliably match, so fail:\n            return Number.POSITIVE_INFINITY;\n        }\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return Number.POSITIVE_INFINITY;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    return OneDReader;\n}());\nexports[\"default\"] = OneDReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL09uZURSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsZ0pBQW9CO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLDhJQUFtQjtBQUNsRCwyQkFBMkIsbUJBQU8sQ0FBQyxzSkFBdUI7QUFDMUQsb0JBQW9CLG1CQUFPLENBQUMsd0lBQWdCO0FBQzVDLDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQ0FBbUM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL09uZURSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCaXRBcnJheV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CaXRBcnJheVwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBmdW5jdGlvbmFsaXR5IGFuZCBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGNvbW1vbiB0byBhbGwgZmFtaWxpZXNcbiAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIE9uZURSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT25lRFJlYWRlcigpIHtcbiAgICB9XG4gICAgLypcbiAgICBAT3ZlcnJpZGVcbiAgICBwdWJsaWMgUmVzdWx0IGRlY29kZShCaW5hcnlCaXRtYXAgaW1hZ2UpIHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCB0cnkgcm90YXRpb24gd2l0aG91dCB0aGUgdHJ5IGhhcmRlciBmbGFnLCBldmVuIGlmIHJvdGF0aW9uIHdhcyBzdXBwb3J0ZWQuXG4gICAgLy8gQE92ZXJyaWRlXG4gICAgT25lRFJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9EZWNvZGUoaW1hZ2UsIGhpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAobmZlKSB7XG4gICAgICAgICAgICB2YXIgdHJ5SGFyZGVyID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuVFJZX0hBUkRFUikgPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKHRyeUhhcmRlciAmJiBpbWFnZS5pc1JvdGF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZWRJbWFnZSA9IGltYWdlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kb0RlY29kZShyb3RhdGVkSW1hZ2UsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhhdCB3ZSBmb3VuZCBpdCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXIC8gMjcwIGRlZ3JlZXMgQ1dcbiAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSByZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb25fMSA9IDI3MDtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwgJiYgKG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0Lk9SSUVOVEFUSU9OKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGlmIHdlIGZvdW5kIGl0IHJldmVyc2VkIGluIGRvRGVjb2RlKCksIGFkZCBpbiB0aGF0IHJlc3VsdCBoZXJlOlxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbl8xID0gKG9yaWVudGF0aW9uXzEgKyBtZXRhZGF0YS5nZXQoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5PUklFTlRBVElPTikgJSAzNjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5PUklFTlRBVElPTiwgb3JpZW50YXRpb25fMSk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHJlc3VsdCBwb2ludHNcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gcmVzdWx0LmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvdGF0ZWRJbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoaGVpZ2h0IC0gcG9pbnRzW2ldLmdldFkoKSAtIDEsIHBvaW50c1tpXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEBPdmVycmlkZVxuICAgIE9uZURSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXZSdyZSBnb2luZyB0byBleGFtaW5lIHJvd3MgZnJvbSB0aGUgbWlkZGxlIG91dHdhcmQsIHNlYXJjaGluZyBhbHRlcm5hdGVseSBhYm92ZSBhbmQgYmVsb3cgdGhlXG4gICAgICogbWlkZGxlLCBhbmQgZmFydGhlciBvdXQgZWFjaCB0aW1lLiByb3dTdGVwIGlzIHRoZSBudW1iZXIgb2Ygcm93cyBiZXR3ZWVuIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGF0dGVtcHQgYWJvdmUgYW5kIGJlbG93IHRoZSBtaWRkbGUuIFNvIHdlJ2Qgc2NhbiByb3cgbWlkZGxlLCB0aGVuIG1pZGRsZSAtIHJvd1N0ZXAsIHRoZW5cbiAgICAgKiBtaWRkbGUgKyByb3dTdGVwLCB0aGVuIG1pZGRsZSAtICgyICogcm93U3RlcCksIGV0Yy5cbiAgICAgKiByb3dTdGVwIGlzIGJpZ2dlciBhcyB0aGUgaW1hZ2UgaXMgdGFsbGVyLCBidXQgaXMgYWx3YXlzIGF0IGxlYXN0IDEuIFdlJ3ZlIHNvbWV3aGF0IGFyYml0cmFyaWx5XG4gICAgICogZGVjaWRlZCB0aGF0IG1vdmluZyB1cCBhbmQgZG93biBieSBhYm91dCAxLzE2IG9mIHRoZSBpbWFnZSBpcyBwcmV0dHkgZ29vZDsgd2UgdHJ5IG1vcmUgb2YgdGhlXG4gICAgICogaW1hZ2UgaWYgXCJ0cnlpbmcgaGFyZGVyXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIGltYWdlIHRvIGRlY29kZVxuICAgICAqIEBwYXJhbSBoaW50cyBBbnkgaGludHMgdGhhdCB3ZXJlIHJlcXVlc3RlZFxuICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBkZWNvZGVkIGJhcmNvZGVcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBzcG9udGFuZW91cyBlcnJvcnMgd2hpY2ggb2NjdXJcbiAgICAgKi9cbiAgICBPbmVEUmVhZGVyLnByb3RvdHlwZS5kb0RlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgcm93ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCh3aWR0aCk7XG4gICAgICAgIHZhciB0cnlIYXJkZXIgPSBoaW50cyAmJiAoaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5UUllfSEFSREVSKSA9PT0gdHJ1ZSk7XG4gICAgICAgIHZhciByb3dTdGVwID0gTWF0aC5tYXgoMSwgaGVpZ2h0ID4+ICh0cnlIYXJkZXIgPyA4IDogNSkpO1xuICAgICAgICB2YXIgbWF4TGluZXM7XG4gICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgIG1heExpbmVzID0gaGVpZ2h0OyAvLyBMb29rIGF0IHRoZSB3aG9sZSBpbWFnZSwgbm90IGp1c3QgdGhlIGNlbnRlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4TGluZXMgPSAxNTsgLy8gMTUgcm93cyBzcGFjZWQgMS8zMiBhcGFydCBpcyByb3VnaGx5IHRoZSBtaWRkbGUgaGFsZiBvZiB0aGUgaW1hZ2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkZGxlID0gTWF0aC50cnVuYyhoZWlnaHQgLyAyKTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXhMaW5lczsgeCsrKSB7XG4gICAgICAgICAgICAvLyBTY2FubmluZyBmcm9tIHRoZSBtaWRkbGUgb3V0LiBEZXRlcm1pbmUgd2hpY2ggcm93IHdlJ3JlIGxvb2tpbmcgYXQgbmV4dDpcbiAgICAgICAgICAgIHZhciByb3dTdGVwc0Fib3ZlT3JCZWxvdyA9IE1hdGgudHJ1bmMoKHggKyAxKSAvIDIpO1xuICAgICAgICAgICAgdmFyIGlzQWJvdmUgPSAoeCAmIDB4MDEpID09PSAwOyAvLyBpLmUuIGlzIHggZXZlbj9cbiAgICAgICAgICAgIHZhciByb3dOdW1iZXIgPSBtaWRkbGUgKyByb3dTdGVwICogKGlzQWJvdmUgPyByb3dTdGVwc0Fib3ZlT3JCZWxvdyA6IC1yb3dTdGVwc0Fib3ZlT3JCZWxvdyk7XG4gICAgICAgICAgICBpZiAocm93TnVtYmVyIDwgMCB8fCByb3dOdW1iZXIgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gT29wcywgaWYgd2UgcnVuIG9mZiB0aGUgdG9wIG9yIGJvdHRvbSwgc3RvcFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXN0aW1hdGUgYmxhY2sgcG9pbnQgZm9yIHRoaXMgcm93IGFuZCBsb2FkIGl0OlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByb3cgPSBpbWFnZS5nZXRCbGFja1Jvdyhyb3dOdW1iZXIsIHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7IC8vIHRyeWluZyBhZ2Fpbj9cbiAgICAgICAgICAgICAgICAgICAgcm93LnJldmVyc2UoKTsgLy8gcmV2ZXJzZSB0aGUgcm93IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIHdpbGwgb25seSBldmVyIGRyYXcgcmVzdWx0IHBvaW50cyAqb25jZSogaW4gdGhlIGxpZmUgb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBkcmF3aW5nIHRoZSB3cm9uZyBwb2ludHMgYWZ0ZXIgZmxpcHBpbmcgdGhlIHJvdywgYW5kLFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB3YW50IHRvIGNsdXR0ZXIgd2l0aCBub2lzZSBmcm9tIGV2ZXJ5IHNpbmdsZSByb3cgc2NhbiAtLSBqdXN0IHRoZSBzY2Fuc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHN0YXJ0IG9uIHRoZSBjZW50ZXIgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0Lk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdIaW50c18xID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGludHMuZm9yRWFjaChmdW5jdGlvbiAoaGludCwga2V5KSB7IHJldHVybiBuZXdIaW50c18xLnNldChrZXksIGhpbnQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hpbnRzXzEuZGVsZXRlKERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50cyA9IG5ld0hpbnRzXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzXzEuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIG91ciBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaXQgd2FzIHVwc2lkZSBkb3duLCBzbyBub3RlIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0Lk9SSUVOVEFUSU9OLCAxODApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlbWVtYmVyIHRvIGZsaXAgdGhlIHJlc3VsdCBwb2ludHMgaG9yaXpvbnRhbGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHdpZHRoIC0gcG9pbnRzWzBdLmdldFgoKSAtIDEsIHBvaW50c1swXS5nZXRZKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQod2lkdGggLSBwb2ludHNbMV0uZ2V0WCgpIC0gMSwgcG9pbnRzWzFdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgLS0ganVzdCBjb3VsZG4ndCBkZWNvZGUgdGhpcyByb3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSBoYXZlIHRoZSBpbWFnZSBkYXRhIGluIGEgQml0QXJyYXksIGl0J3MgZmFpcmx5IGNoZWFwIHRvIHJldmVyc2UgaXQgaW4gcGxhY2UgdG9cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWNvZGluZyB1cHNpZGUgZG93biBiYXJjb2Rlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgMjsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyB0aGUgc2l6ZSBvZiBzdWNjZXNzaXZlIHJ1bnMgb2Ygd2hpdGUgYW5kIGJsYWNrIHBpeGVscyBpbiBhIHJvdywgc3RhcnRpbmcgYXQgYSBnaXZlbiBwb2ludC5cbiAgICAgKiBUaGUgdmFsdWVzIGFyZSByZWNvcmRlZCBpbiB0aGUgZ2l2ZW4gYXJyYXksIGFuZCB0aGUgbnVtYmVyIG9mIHJ1bnMgcmVjb3JkZWQgaXMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgKiBvZiB0aGUgYXJyYXkuIElmIHRoZSByb3cgc3RhcnRzIG9uIGEgd2hpdGUgcGl4ZWwgYXQgdGhlIGdpdmVuIHN0YXJ0IHBvaW50LCB0aGVuIHRoZSBmaXJzdCBjb3VudFxuICAgICAqIHJlY29yZGVkIGlzIHRoZSBydW4gb2Ygd2hpdGUgcGl4ZWxzIHN0YXJ0aW5nIGZyb20gdGhhdCBwb2ludDsgbGlrZXdpc2UgaXQgaXMgdGhlIGNvdW50IG9mIGEgcnVuXG4gICAgICogb2YgYmxhY2sgcGl4ZWxzIGlmIHRoZSByb3cgYmVnaW4gb24gYSBibGFjayBwaXhlbHMgYXQgdGhhdCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgcm93IHRvIGNvdW50IGZyb21cbiAgICAgKiBAcGFyYW0gc3RhcnQgb2Zmc2V0IGludG8gcm93IHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIGNvdW50ZXJzIGFycmF5IGludG8gd2hpY2ggdG8gcmVjb3JkIGNvdW50c1xuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgY291bnRlcnMgY2Fubm90IGJlIGZpbGxlZCBlbnRpcmVseSBmcm9tIHJvdyBiZWZvcmUgcnVubmluZyBvdXRcbiAgICAgKiAgb2YgcGl4ZWxzXG4gICAgICovXG4gICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgc3RhcnQsIGNvdW50ZXJzKSB7XG4gICAgICAgIHZhciBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG51bUNvdW50ZXJzOyBpbmRleCsrKVxuICAgICAgICAgICAgY291bnRlcnNbaW5kZXhdID0gMDtcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNXaGl0ZSA9ICFyb3cuZ2V0KHN0YXJ0KTtcbiAgICAgICAgdmFyIGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSByZWFkIGZ1bGx5IHRoZSBsYXN0IHNlY3Rpb24gb2YgcGl4ZWxzIGFuZCBmaWxsZWQgdXAgb3VyIGNvdW50ZXJzIC0tIG9yIGZpbGxlZFxuICAgICAgICAvLyB0aGUgbGFzdCBjb3VudGVyIGJ1dCByYW4gb2ZmIHRoZSBzaWRlIG9mIHRoZSBpbWFnZSwgT0suIE90aGVyd2lzZSwgYSBwcm9ibGVtLlxuICAgICAgICBpZiAoIShjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIHx8IChjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIC0gMSAmJiBpID09PSBlbmQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm5JblJldmVyc2UgPSBmdW5jdGlvbiAocm93LCBzdGFydCwgY291bnRlcnMpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBJIGd1ZXNzXG4gICAgICAgIHZhciBudW1UcmFuc2l0aW9uc0xlZnQgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0ID0gcm93LmdldChzdGFydCk7XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgbnVtVHJhbnNpdGlvbnNMZWZ0ID49IDApIHtcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KC0tc3RhcnQpICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgbnVtVHJhbnNpdGlvbnNMZWZ0LS07XG4gICAgICAgICAgICAgICAgbGFzdCA9ICFsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1UcmFuc2l0aW9uc0xlZnQgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHN0YXJ0ICsgMSwgY291bnRlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuXG4gICAgICogdGFyZ2V0IHBhdHRlcm4uIFRoaXMgaXMgcmVwb3J0ZWQgYXMgdGhlIHJhdGlvIG9mIHRoZSB0b3RhbCB2YXJpYW5jZSBmcm9tIHRoZSBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICogcHJvcG9ydGlvbnMgYWNyb3NzIGFsbCBwYXR0ZXJuIGVsZW1lbnRzLCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvdW50ZXJzIG9ic2VydmVkIGNvdW50ZXJzXG4gICAgICogQHBhcmFtIHBhdHRlcm4gZXhwZWN0ZWQgcGF0dGVyblxuICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxuICAgICAqIEByZXR1cm4gcmF0aW8gb2YgdG90YWwgdmFyaWFuY2UgYmV0d2VlbiBjb3VudGVycyBhbmQgcGF0dGVybiBjb21wYXJlZCB0byB0b3RhbCBwYXR0ZXJuIHNpemVcbiAgICAgKi9cbiAgICBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlID0gZnVuY3Rpb24gKGNvdW50ZXJzLCBwYXR0ZXJuLCBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcbiAgICAgICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdGFsIDwgcGF0dGVybkxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzIGlzIHRvbyBzbWFsbFxuICAgICAgICAgICAgLy8gdG8gcmVsaWFibHkgbWF0Y2gsIHNvIGZhaWw6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XG4gICAgICAgIG1heEluZGl2aWR1YWxWYXJpYW5jZSAqPSB1bml0QmFyV2lkdGg7XG4gICAgICAgIHZhciB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNbeF07XG4gICAgICAgICAgICB2YXIgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XG4gICAgICAgICAgICBpZiAodmFyaWFuY2UgPiBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxWYXJpYW5jZSArPSB2YXJpYW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xuICAgIH07XG4gICAgcmV0dXJuIE9uZURSZWFkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gT25lRFJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar EAN13Reader_1 = __webpack_require__(/*! ./EAN13Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js\");\nvar UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author sam2332 (Sam Rudloff)\n *\n * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java\n *\n * @experimental\n */\nvar UPCAReader = /** @class */ (function (_super) {\n    __extends(UPCAReader, _super);\n    function UPCAReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.ean13Reader = new EAN13Reader_1.default();\n        return _this;\n    }\n    // @Override\n    UPCAReader.prototype.getBarcodeFormat = function () {\n        return BarcodeFormat_1.default.UPC_A;\n    };\n    // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n    // @Override\n    UPCAReader.prototype.decode = function (image, hints) {\n        return this.maybeReturnResult(this.ean13Reader.decode(image));\n    };\n    // @Override\n    UPCAReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));\n    };\n    // @Override\n    UPCAReader.prototype.decodeMiddle = function (row, startRange, resultString) {\n        return this.ean13Reader.decodeMiddle(row, startRange, resultString);\n    };\n    UPCAReader.prototype.maybeReturnResult = function (result) {\n        var text = result.getText();\n        if (text.charAt(0) === '0') {\n            var upcaResult = new Result_1.default(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat_1.default.UPC_A);\n            if (result.getResultMetadata() != null) {\n                upcaResult.putAllMetadata(result.getResultMetadata());\n            }\n            return upcaResult;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    UPCAReader.prototype.reset = function () {\n        this.ean13Reader.reset();\n    };\n    return UPCAReader;\n}(UPCEANReader_1.default));\nexports[\"default\"] = UPCAReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0FSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsNElBQWtCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyw4SEFBVztBQUNsQywwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMsNElBQWU7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsOElBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9VUENBUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcub25lZCB7Ki9cbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBFQU4xM1JlYWRlcl8xID0gcmVxdWlyZShcIi4vRUFOMTNSZWFkZXJcIik7XG52YXIgVVBDRUFOUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9VUENFQU5SZWFkZXJcIik7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBmdW5jdGlvbmFsaXR5IGFuZCBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGNvbW1vbiB0byBhbGwgZmFtaWxpZXNcbiAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqIEBhdXRob3Igc2FtMjMzMiAoU2FtIFJ1ZGxvZmYpXG4gKlxuICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi8zYzk2OTIzMjc2ZGQ1Nzg1ZDU4ZWI5NzBiNmJhM2Y4MGQzNmE5NTA1L2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL29uZWQvVVBDQVJlYWRlci5qYXZhXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG52YXIgVVBDQVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVVBDQVJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUENBUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWFuMTNSZWFkZXIgPSBuZXcgRUFOMTNSZWFkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gQE92ZXJyaWRlXG4gICAgVVBDQVJlYWRlci5wcm90b3R5cGUuZ2V0QmFyY29kZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BO1xuICAgIH07XG4gICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBVUENBUmVhZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlKGltYWdlKSk7XG4gICAgfTtcbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBVUENBUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heWJlUmV0dXJuUmVzdWx0KHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykpO1xuICAgIH07XG4gICAgLy8gQE92ZXJyaWRlXG4gICAgVVBDQVJlYWRlci5wcm90b3R5cGUuZGVjb2RlTWlkZGxlID0gZnVuY3Rpb24gKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhbjEzUmVhZGVyLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZyk7XG4gICAgfTtcbiAgICBVUENBUmVhZGVyLnByb3RvdHlwZS5tYXliZVJldHVyblJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIHRleHQgPSByZXN1bHQuZ2V0VGV4dCgpO1xuICAgICAgICBpZiAodGV4dC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgdmFyIHVwY2FSZXN1bHQgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdCh0ZXh0LnN1YnN0cmluZygxKSwgbnVsbCwgbnVsbCwgcmVzdWx0LmdldFJlc3VsdFBvaW50cygpLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5VUENfQSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHVwY2FSZXN1bHQucHV0QWxsTWV0YWRhdGEocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwY2FSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVQQ0FSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVhbjEzUmVhZGVyLnJlc2V0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVVBDQVJlYWRlcjtcbn0oVVBDRUFOUmVhZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVVBDQVJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright (C) 2012 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * @see UPCEANExtension5Support\n */\nvar UPCEANExtension2Support = /** @class */ (function () {\n    function UPCEANExtension2Support() {\n        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        this.decodeRowStringBuffer = '';\n    }\n    UPCEANExtension2Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {\n        var result = this.decodeRowStringBuffer;\n        var end = this.decodeMiddle(row, extensionStartRange, result);\n        var resultString = result.toString();\n        var extensionData = UPCEANExtension2Support.parseExtensionString(resultString);\n        var resultPoints = [\n            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n            new ResultPoint_1.default(end, rowNumber)\n        ];\n        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());\n        if (extensionData != null) {\n            extensionResult.putAllMetadata(extensionData);\n        }\n        return extensionResult;\n    };\n    UPCEANExtension2Support.prototype.decodeMiddle = function (row, startRange, resultString) {\n        var e_1, _a;\n        var counters = this.decodeMiddleCounters;\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var end = row.getSize();\n        var rowOffset = startRange[1];\n        var checkParity = 0;\n        for (var x = 0; x < 2 && rowOffset < end; x++) {\n            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n            try {\n                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (bestMatch >= 10) {\n                checkParity |= 1 << (1 - x);\n            }\n            if (x !== 1) {\n                // Read off separator if not last\n                rowOffset = row.getNextSet(rowOffset);\n                rowOffset = row.getNextUnset(rowOffset);\n            }\n        }\n        if (resultString.length !== 2) {\n            throw new NotFoundException_1.default();\n        }\n        if (parseInt(resultString.toString()) % 4 !== checkParity) {\n            throw new NotFoundException_1.default();\n        }\n        return rowOffset;\n    };\n    UPCEANExtension2Support.parseExtensionString = function (raw) {\n        if (raw.length !== 2) {\n            return null;\n        }\n        return new Map([[ResultMetadataType_1.default.ISSUE_NUMBER, parseInt(raw)]]);\n    };\n    return UPCEANExtension2Support;\n}());\nexports[\"default\"] = UPCEANExtension2Support;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDRJQUFrQjtBQUNoRCw2QkFBNkIsbUJBQU8sQ0FBQyw4SkFBd0I7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLHdJQUFnQjtBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyxzSkFBdUI7QUFDMUQsMEJBQTBCLG1CQUFPLENBQUMsb0pBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLG9CQUFvQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDEyIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgQWJzdHJhY3RVUENFQU5SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0VVBDRUFOUmVhZGVyXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBAc2VlIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XG4gKi9cbnZhciBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCgpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgIH1cbiAgICBVUENFQU5FeHRlbnNpb24yU3VwcG9ydC5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSwgcmVzdWx0KTtcbiAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uRGF0YSA9IFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJlc3VsdFN0cmluZyk7XG4gICAgICAgIHZhciByZXN1bHRQb2ludHMgPSBbXG4gICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KChleHRlbnNpb25TdGFydFJhbmdlWzBdICsgZXh0ZW5zaW9uU3RhcnRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlciksXG4gICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZCwgcm93TnVtYmVyKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIGlmIChleHRlbnNpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUmVzdWx0O1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucHJvdG90eXBlLmRlY29kZU1pZGRsZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICB2YXIgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgIHZhciBjaGVja1Bhcml0eSA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgMiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzEgPSAoZV8xID0gdm9pZCAwLCBfX3ZhbHVlcyhjb3VudGVycykpLCBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKTsgIWNvdW50ZXJzXzFfMS5kb25lOyBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc18xXzEgJiYgIWNvdW50ZXJzXzFfMS5kb25lICYmIChfYSA9IGNvdW50ZXJzXzEucmV0dXJuKSkgX2EuY2FsbChjb3VudGVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgIGNoZWNrUGFyaXR5IHw9IDEgPDwgKDEgLSB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VJbnQocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICUgNCAhPT0gY2hlY2tQYXJpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucGFyc2VFeHRlbnNpb25TdHJpbmcgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuSVNTVUVfTlVNQkVSLCBwYXJzZUludChyYXcpXV0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\n// import UPCEANReader from './UPCEANReader';\nvar AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/**\n * @see UPCEANExtension2Support\n */\nvar UPCEANExtension5Support = /** @class */ (function () {\n    function UPCEANExtension5Support() {\n        this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];\n        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        this.decodeRowStringBuffer = '';\n    }\n    UPCEANExtension5Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {\n        var result = this.decodeRowStringBuffer;\n        var end = this.decodeMiddle(row, extensionStartRange, result);\n        var resultString = result.toString();\n        var extensionData = UPCEANExtension5Support.parseExtensionString(resultString);\n        var resultPoints = [\n            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n            new ResultPoint_1.default(end, rowNumber)\n        ];\n        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());\n        if (extensionData != null) {\n            extensionResult.putAllMetadata(extensionData);\n        }\n        return extensionResult;\n    };\n    UPCEANExtension5Support.prototype.decodeMiddle = function (row, startRange, resultString) {\n        var e_1, _a;\n        var counters = this.decodeMiddleCounters;\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var end = row.getSize();\n        var rowOffset = startRange[1];\n        var lgPatternFound = 0;\n        for (var x = 0; x < 5 && rowOffset < end; x++) {\n            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);\n            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n            try {\n                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (bestMatch >= 10) {\n                lgPatternFound |= 1 << (4 - x);\n            }\n            if (x !== 4) {\n                // Read off separator if not last\n                rowOffset = row.getNextSet(rowOffset);\n                rowOffset = row.getNextUnset(rowOffset);\n            }\n        }\n        if (resultString.length !== 5) {\n            throw new NotFoundException_1.default();\n        }\n        var checkDigit = this.determineCheckDigit(lgPatternFound);\n        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {\n            throw new NotFoundException_1.default();\n        }\n        return rowOffset;\n    };\n    UPCEANExtension5Support.extensionChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n        }\n        sum *= 3;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n        }\n        sum *= 3;\n        return sum % 10;\n    };\n    UPCEANExtension5Support.prototype.determineCheckDigit = function (lgPatternFound) {\n        for (var d = 0; d < 10; d++) {\n            if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {\n                return d;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    UPCEANExtension5Support.parseExtensionString = function (raw) {\n        if (raw.length !== 5) {\n            return null;\n        }\n        var value = UPCEANExtension5Support.parseExtension5String(raw);\n        if (value == null) {\n            return null;\n        }\n        return new Map([[ResultMetadataType_1.default.SUGGESTED_PRICE, value]]);\n    };\n    UPCEANExtension5Support.parseExtension5String = function (raw) {\n        var currency;\n        switch (raw.charAt(0)) {\n            case '0':\n                currency = '£';\n                break;\n            case '5':\n                currency = '$';\n                break;\n            case '9':\n                // Reference: http://www.jollytech.com\n                switch (raw) {\n                    case '90000':\n                        // No suggested retail price\n                        return null;\n                    case '99991':\n                        // Complementary\n                        return '0.00';\n                    case '99990':\n                        return 'Used';\n                }\n                // Otherwise... unknown currency?\n                currency = '';\n                break;\n            default:\n                currency = '';\n                break;\n        }\n        var rawAmount = parseInt(raw.substring(1));\n        var unitsString = (rawAmount / 100).toString();\n        var hundredths = rawAmount % 100;\n        var hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme\n        return currency + unitsString + '.' + hundredthsString;\n    };\n    return UPCEANExtension5Support;\n}());\nexports[\"default\"] = UPCEANExtension5Support;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDRJQUFrQjtBQUNoRDtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLDhKQUF3QjtBQUM3RCxlQUFlLG1CQUFPLENBQUMsOEhBQVc7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsd0lBQWdCO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLHNKQUF1QjtBQUMxRCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxvQkFBb0I7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDEwIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG4vLyBpbXBvcnQgVVBDRUFOUmVhZGVyIGZyb20gJy4vVVBDRUFOUmVhZGVyJztcbnZhciBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RVUENFQU5SZWFkZXJcIik7XG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0UG9pbnRcIik7XG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG4vKipcbiAqIEBzZWUgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnRcbiAqL1xudmFyIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0KCkge1xuICAgICAgICB0aGlzLkNIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsweDE4LCAweDE0LCAweDEyLCAweDExLCAweDBDLCAweDA2LCAweDAzLCAweDBBLCAweDA5LCAweDA1XTtcbiAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlciA9ICcnO1xuICAgIH1cbiAgICBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSwgcmVzdWx0KTtcbiAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uRGF0YSA9IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJlc3VsdFN0cmluZyk7XG4gICAgICAgIHZhciByZXN1bHRQb2ludHMgPSBbXG4gICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KChleHRlbnNpb25TdGFydFJhbmdlWzBdICsgZXh0ZW5zaW9uU3RhcnRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlciksXG4gICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZCwgcm93TnVtYmVyKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIGlmIChleHRlbnNpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUmVzdWx0O1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucHJvdG90eXBlLmRlY29kZU1pZGRsZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICB2YXIgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgIHZhciBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNSAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzEgPSAoZV8xID0gdm9pZCAwLCBfX3ZhbHVlcyhjb3VudGVycykpLCBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKTsgIWNvdW50ZXJzXzFfMS5kb25lOyBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc18xXzEgJiYgIWNvdW50ZXJzXzFfMS5kb25lICYmIChfYSA9IGNvdW50ZXJzXzEucmV0dXJuKSkgX2EuY2FsbChjb3VudGVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9IDEgPDwgKDQgLSB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tEaWdpdCA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tEaWdpdChsZ1BhdHRlcm5Gb3VuZCk7XG4gICAgICAgIGlmIChVUENFQU5FeHRlbnNpb241U3VwcG9ydC5leHRlbnNpb25DaGVja3N1bShyZXN1bHRTdHJpbmcudG9TdHJpbmcoKSkgIT09IGNoZWNrRGlnaXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuZXh0ZW5zaW9uQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtICo9IDM7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwO1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucHJvdG90eXBlLmRldGVybWluZUNoZWNrRGlnaXQgPSBmdW5jdGlvbiAobGdQYXR0ZXJuRm91bmQpIHtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XG4gICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2RdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucGFyc2VFeHRlbnNpb25TdHJpbmcgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvbjVTdHJpbmcocmF3KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFtbUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5TVUdHRVNURURfUFJJQ0UsIHZhbHVlXV0pO1xuICAgIH07XG4gICAgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucGFyc2VFeHRlbnNpb241U3RyaW5nID0gZnVuY3Rpb24gKHJhdykge1xuICAgICAgICB2YXIgY3VycmVuY3k7XG4gICAgICAgIHN3aXRjaCAocmF3LmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnwqMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnJCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2U6IGh0dHA6Ly93d3cuam9sbHl0ZWNoLmNvbVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzkwMDAwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHN1Z2dlc3RlZCByZXRhaWwgcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc5OTk5MSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGVtZW50YXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzAuMDAnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc5OTk5MCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1VzZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UuLi4gdW5rbm93biBjdXJyZW5jeT9cbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXdBbW91bnQgPSBwYXJzZUludChyYXcuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgdmFyIHVuaXRzU3RyaW5nID0gKHJhd0Ftb3VudCAvIDEwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGh1bmRyZWR0aHMgPSByYXdBbW91bnQgJSAxMDA7XG4gICAgICAgIHZhciBodW5kcmVkdGhzU3RyaW5nID0gaHVuZHJlZHRocyA8IDEwID8gJzAnICsgaHVuZHJlZHRocyA6IGh1bmRyZWR0aHMudG9TdHJpbmcoKTsgLy8gZml4bWVcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5ICsgdW5pdHNTdHJpbmcgKyAnLicgKyBodW5kcmVkdGhzU3RyaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js\");\nvar UPCEANExtension5Support_1 = __webpack_require__(/*! ./UPCEANExtension5Support */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js\");\nvar UPCEANExtension2Support_1 = __webpack_require__(/*! ./UPCEANExtension2Support */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js\");\nvar UPCEANExtensionSupport = /** @class */ (function () {\n    function UPCEANExtensionSupport() {\n    }\n    UPCEANExtensionSupport.decodeRow = function (rowNumber, row, rowOffset) {\n        var extensionStartRange = AbstractUPCEANReader_1.default.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));\n        try {\n            // return null;\n            var fiveSupport = new UPCEANExtension5Support_1.default();\n            return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);\n        }\n        catch (err) {\n            // return null;\n            var twoSupport = new UPCEANExtension2Support_1.default();\n            return twoSupport.decodeRow(rowNumber, row, extensionStartRange);\n        }\n    };\n    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);\n    return UPCEANExtensionSupport;\n}());\nexports[\"default\"] = UPCEANExtensionSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VBTkV4dGVuc2lvblN1cHBvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLG1CQUFPLENBQUMsOEpBQXdCO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLG9LQUEyQjtBQUNuRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxvS0FBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RVUENFQU5SZWFkZXJcIik7XG52YXIgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnRfMSA9IHJlcXVpcmUoXCIuL1VQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XCIpO1xudmFyIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0XzEgPSByZXF1aXJlKFwiLi9VUENFQU5FeHRlbnNpb24yU3VwcG9ydFwiKTtcbnZhciBVUENFQU5FeHRlbnNpb25TdXBwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQoKSB7XG4gICAgfVxuICAgIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCByb3dPZmZzZXQpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvblN0YXJ0UmFuZ2UgPSBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgZmFsc2UsIHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIG5ldyBJbnQzMkFycmF5KHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGZpdmVTdXBwb3J0ID0gbmV3IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpdmVTdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHdvU3VwcG9ydCA9IG5ldyBVUENFQU5FeHRlbnNpb24yU3VwcG9ydF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0d29TdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDJdKTtcbiAgICByZXR1cm4gVVBDRUFORXh0ZW5zaW9uU3VwcG9ydDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVUENFQU5FeHRlbnNpb25TdXBwb3J0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar UPCEANExtensionSupport_1 = __webpack_require__(/*! ./UPCEANExtensionSupport */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js\");\nvar AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar UPCEANReader = /** @class */ (function (_super) {\n    __extends(UPCEANReader, _super);\n    function UPCEANReader() {\n        var _this = _super.call(this) || this;\n        _this.decodeRowStringBuffer = '';\n        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) { return Int32Array.from(arr); });\n        for (var i = 10; i < 20; i++) {\n            var widths = UPCEANReader.L_PATTERNS[i - 10];\n            var reversedWidths = new Int32Array(widths.length);\n            for (var j = 0; j < widths.length; j++) {\n                reversedWidths[j] = widths[widths.length - j - 1];\n            }\n            UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n        }\n        return _this;\n    }\n    UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        if (resultPointCallback != null) {\n            var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n        }\n        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n        var endStart = budello.rowOffset;\n        var result = budello.resultString;\n        if (resultPointCallback != null) {\n            var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n        }\n        var endRange = UPCEANReader.decodeEnd(row, endStart);\n        if (resultPointCallback != null) {\n            var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n        }\n        // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n        // spec might want more whitespace, but in practice this is the maximum we can count on.\n        var end = endRange[1];\n        var quietEnd = end + (end - endRange[0]);\n        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n            throw new NotFoundException_1.default();\n        }\n        var resultString = result.toString();\n        // UPC/EAN should never be less than 8 chars anyway\n        if (resultString.length < 8) {\n            throw new FormatException_1.default();\n        }\n        if (!UPCEANReader.checkChecksum(resultString)) {\n            throw new ChecksumException_1.default();\n        }\n        var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n        var right = (endRange[1] + endRange[0]) / 2.0;\n        var format = this.getBarcodeFormat();\n        var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n        var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());\n        var extensionLength = 0;\n        try {\n            var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);\n            decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());\n            decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n            decodeResult.addResultPoints(extensionResult.getResultPoints());\n            extensionLength = extensionResult.getText().length;\n        }\n        catch (err) {\n        }\n        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);\n        if (allowedExtensions != null) {\n            var valid = false;\n            for (var length_1 in allowedExtensions) {\n                if (extensionLength.toString() === length_1) { // check me\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                throw new NotFoundException_1.default();\n            }\n        }\n        if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {\n            // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n            // if (countryID != null) {\n            //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n            // }\n        }\n        return decodeResult;\n    };\n    UPCEANReader.checkChecksum = function (s) {\n        return UPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    UPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    UPCEANReader.decodeEnd = function (row, endStart) {\n        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    return UPCEANReader;\n}(AbstractUPCEANReader_1.default));\nexports[\"default\"] = UPCEANReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VBTlJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDRJQUFrQjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyw4SUFBbUI7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDLDJCQUEyQixtQkFBTyxDQUFDLHNKQUF1QjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyx3SUFBZ0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsa0tBQTBCO0FBQ2pFLDZCQUE2QixtQkFBTyxDQUFDLDhKQUF3QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsd0JBQXdCLG1CQUFPLENBQUMsZ0pBQW9CO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiw4QkFBOEI7QUFDbkgseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VBTlJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0UG9pbnRcIik7XG52YXIgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydF8xID0gcmVxdWlyZShcIi4vVVBDRUFORXh0ZW5zaW9uU3VwcG9ydFwiKTtcbnZhciBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RVUENFQU5SZWFkZXJcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Gb3JtYXRFeGNlcHRpb25cIik7XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxuICpcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBhbGFzZGFpckBnb29nbGUuY29tIChBbGFzZGFpciBNYWNraW50b3NoKVxuICovXG52YXIgVVBDRUFOUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUENFQU5SZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVBDRUFOUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMgPSBVUENFQU5SZWFkZXIuTF9QQVRURVJOUy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gSW50MzJBcnJheS5mcm9tKGFycik7IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMTA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGhzID0gVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlNbaSAtIDEwXTtcbiAgICAgICAgICAgIHZhciByZXZlcnNlZFdpZHRocyA9IG5ldyBJbnQzMkFycmF5KHdpZHRocy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlZFdpZHRoc1tqXSA9IHdpZHRoc1t3aWR0aHMubGVuZ3RoIC0gaiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlNbaV0gPSByZXZlcnNlZFdpZHRocztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVQQ0VBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICB2YXIgc3RhcnRHdWFyZFJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRTdGFydEd1YXJkUGF0dGVybihyb3cpO1xuICAgICAgICB2YXIgcmVzdWx0UG9pbnRDYWxsYmFjayA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRQb2ludF8xID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCgoc3RhcnRHdWFyZFJhbmdlWzBdICsgc3RhcnRHdWFyZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50XzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWRlbGxvID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBzdGFydEd1YXJkUmFuZ2UsIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyKTtcbiAgICAgICAgdmFyIGVuZFN0YXJ0ID0gYnVkZWxsby5yb3dPZmZzZXQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBidWRlbGxvLnJlc3VsdFN0cmluZztcbiAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdFBvaW50XzIgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZFN0YXJ0LCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnRfMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZFJhbmdlID0gVVBDRUFOUmVhZGVyLmRlY29kZUVuZChyb3csIGVuZFN0YXJ0KTtcbiAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdFBvaW50XzMgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KChlbmRSYW5nZVswXSArIGVuZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50XzMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIHF1aWV0IHpvbmUgYXQgbGVhc3QgYXMgYmlnIGFzIHRoZSBlbmQgcGF0dGVybiBhZnRlciB0aGUgYmFyY29kZS4gVGhlXG4gICAgICAgIC8vIHNwZWMgbWlnaHQgd2FudCBtb3JlIHdoaXRlc3BhY2UsIGJ1dCBpbiBwcmFjdGljZSB0aGlzIGlzIHRoZSBtYXhpbXVtIHdlIGNhbiBjb3VudCBvbi5cbiAgICAgICAgdmFyIGVuZCA9IGVuZFJhbmdlWzFdO1xuICAgICAgICB2YXIgcXVpZXRFbmQgPSBlbmQgKyAoZW5kIC0gZW5kUmFuZ2VbMF0pO1xuICAgICAgICBpZiAocXVpZXRFbmQgPj0gcm93LmdldFNpemUoKSB8fCAhcm93LmlzUmFuZ2UoZW5kLCBxdWlldEVuZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAvLyBVUEMvRUFOIHNob3VsZCBuZXZlciBiZSBsZXNzIHRoYW4gOCBjaGFycyBhbnl3YXlcbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0ocmVzdWx0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0ID0gKHN0YXJ0R3VhcmRSYW5nZVsxXSArIHN0YXJ0R3VhcmRSYW5nZVswXSkgLyAyLjA7XG4gICAgICAgIHZhciByaWdodCA9IChlbmRSYW5nZVsxXSArIGVuZFJhbmdlWzBdKSAvIDIuMDtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuZ2V0QmFyY29kZUZvcm1hdCgpO1xuICAgICAgICB2YXIgcmVzdWx0UG9pbnQgPSBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHJpZ2h0LCByb3dOdW1iZXIpXTtcbiAgICAgICAgdmFyIGRlY29kZVJlc3VsdCA9IG5ldyBSZXN1bHRfMS5kZWZhdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgcmVzdWx0UG9pbnQsIGZvcm1hdCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uTGVuZ3RoID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb25SZXN1bHQgPSBVUENFQU5FeHRlbnNpb25TdXBwb3J0XzEuZGVmYXVsdC5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGVuZFJhbmdlWzFdKTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LlVQQ19FQU5fRVhURU5TSU9OLCBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25SZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQuYWRkUmVzdWx0UG9pbnRzKGV4dGVuc2lvblJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKSk7XG4gICAgICAgICAgICBleHRlbnNpb25MZW5ndGggPSBleHRlbnNpb25SZXN1bHQuZ2V0VGV4dCgpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbG93ZWRFeHRlbnNpb25zID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkFMTE9XRURfRUFOX0VYVEVOU0lPTlMpO1xuICAgICAgICBpZiAoYWxsb3dlZEV4dGVuc2lvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBsZW5ndGhfMSBpbiBhbGxvd2VkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25MZW5ndGgudG9TdHJpbmcoKSA9PT0gbGVuZ3RoXzEpIHsgLy8gY2hlY2sgbWVcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl8xMyB8fCBmb3JtYXQgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BKSB7XG4gICAgICAgICAgICAvLyBsZXQgY291bnRyeUlEID0gZWFuTWFuU3VwcG9ydC5sb29rdXBDb250cnlJZGVudGlmaWVyKHJlc3VsdFN0cmluZyk7IHRvZG9cbiAgICAgICAgICAgIC8vIGlmIChjb3VudHJ5SUQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gICAgIGRlY29kZVJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUuUE9TU0lCTEVfQ09VTlRSWSwgY291bnRyeUlEKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlUmVzdWx0O1xuICAgIH07XG4gICAgVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKTtcbiAgICB9O1xuICAgIFVQQ0VBTlJlYWRlci5jaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaGVjayA9IHBhcnNlSW50KHMuY2hhckF0KGxlbmd0aCAtIDEpLCAxMCk7XG4gICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKSkgPT09IGNoZWNrO1xuICAgIH07XG4gICAgVVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxMDAwIC0gc3VtKSAlIDEwO1xuICAgIH07XG4gICAgVVBDRUFOUmVhZGVyLmRlY29kZUVuZCA9IGZ1bmN0aW9uIChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBmYWxzZSwgVVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLCBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICB9O1xuICAgIHJldHVybiBVUENFQU5SZWFkZXI7XG59KEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVVBDRUFOUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\n// package com.google.zxing.oned;\n// import com.google.zxing.BarcodeFormat;\n// import com.google.zxing.FormatException;\n// import com.google.zxing.NotFoundException;\n// import com.google.zxing.common.BitArray;\n/**\n * <p>Implements decoding of the UPC-E format.</p>\n * <p><a href=\"http://www.barcodeisland.com/upce.phtml\">This</a> is a great reference for\n * UPC-E information.</p>\n *\n * @author Sean Owen\n *\n * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java\n *\n * @experimental\n */\nvar UPCEReader = /** @class */ (function (_super) {\n    __extends(UPCEReader, _super);\n    function UPCEReader() {\n        var _this = _super.call(this) || this;\n        _this.decodeMiddleCounters = new Int32Array(4);\n        return _this;\n    }\n    /**\n     * @throws NotFoundException\n     */\n    // @Override\n    UPCEReader.prototype.decodeMiddle = function (row, startRange, result) {\n        var e_1, _a;\n        var counters = this.decodeMiddleCounters.map(function (x) { return x; });\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var end = row.getSize();\n        var rowOffset = startRange[1];\n        var lgPatternFound = 0;\n        for (var x = 0; x < 6 && rowOffset < end; x++) {\n            var bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);\n            result += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n            try {\n                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    rowOffset += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (bestMatch >= 10) {\n                lgPatternFound |= 1 << (5 - x);\n            }\n        }\n        UPCEReader.determineNumSysAndCheckDigit(new StringBuilder_1.default(result), lgPatternFound);\n        return rowOffset;\n    };\n    /**\n     * @throws NotFoundException\n     */\n    // @Override\n    UPCEReader.prototype.decodeEnd = function (row, endStart) {\n        return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);\n    };\n    /**\n     * @throws FormatException\n     */\n    // @Override\n    UPCEReader.prototype.checkChecksum = function (s) {\n        return UPCEANReader_1.default.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));\n    };\n    /**\n     * @throws NotFoundException\n     */\n    UPCEReader.determineNumSysAndCheckDigit = function (resultString, lgPatternFound) {\n        for (var numSys = 0; numSys <= 1; numSys++) {\n            for (var d = 0; d < 10; d++) {\n                if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {\n                    resultString.insert(0, /*(char)*/ ('0' + numSys));\n                    resultString.append(/*(char)*/ ('0' + d));\n                    return;\n                }\n            }\n        }\n        throw NotFoundException_1.default.getNotFoundInstance();\n    };\n    // @Override\n    UPCEReader.prototype.getBarcodeFormat = function () {\n        return BarcodeFormat_1.default.UPC_E;\n    };\n    /**\n     * Expands a UPC-E value back into its full, equivalent UPC-A code value.\n     *\n     * @param upce UPC-E code as string of digits\n     * @return equivalent UPC-A code as string of digits\n     */\n    UPCEReader.convertUPCEtoUPCA = function (upce) {\n        // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);\n        var upceChars = upce.slice(1, 7).split('').map(function (x) { return x.charCodeAt(0); });\n        var result = new StringBuilder_1.default( /*12*/);\n        result.append(upce.charAt(0));\n        var lastChar = upceChars[5];\n        switch (lastChar) {\n            case 0:\n            case 1:\n            case 2:\n                result.appendChars(upceChars, 0, 2);\n                result.append(lastChar);\n                result.append('0000');\n                result.appendChars(upceChars, 2, 3);\n                break;\n            case 3:\n                result.appendChars(upceChars, 0, 3);\n                result.append('00000');\n                result.appendChars(upceChars, 3, 2);\n                break;\n            case 4:\n                result.appendChars(upceChars, 0, 4);\n                result.append('00000');\n                result.append(upceChars[4]);\n                break;\n            default:\n                result.appendChars(upceChars, 0, 5);\n                result.append('0000');\n                result.append(lastChar);\n                break;\n        }\n        // Only append check digit in conversion if supplied\n        if (upce.length >= 8) {\n            result.append(upce.charAt(7));\n        }\n        return result.toString();\n    };\n    /**\n     * The pattern that marks the middle, and end, of a UPC-E pattern.\n     * There is no \"second half\" to a UPC-E barcode.\n     */\n    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    // For an UPC-E barcode, the final digit is represented by the parities used\n    // to encode the middle six digits, according to the table below.\n    //\n    //                Parity of next 6 digits\n    //    Digit   0     1     2     3     4     5\n    //       0    Even   Even  Even Odd  Odd   Odd\n    //       1    Even   Even  Odd  Even Odd   Odd\n    //       2    Even   Even  Odd  Odd  Even  Odd\n    //       3    Even   Even  Odd  Odd  Odd   Even\n    //       4    Even   Odd   Even Even Odd   Odd\n    //       5    Even   Odd   Odd  Even Even  Odd\n    //       6    Even   Odd   Odd  Odd  Even  Even\n    //       7    Even   Odd   Even Odd  Even  Odd\n    //       8    Even   Odd   Even Odd  Odd   Even\n    //       9    Even   Odd   Odd  Even Odd   Even\n    //\n    // The encoding is represented by the following array, which is a bit pattern\n    // using Odd = 0 and Even = 1. For example, 5 is represented by:\n    //\n    //              Odd Even Even Odd Odd Even\n    // in binary:\n    //                0    1    1   0   0    1   == 0x19\n    //\n    /**\n     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of\n     * even-odd parity encodings of digits that imply both the number system (0 or 1)\n     * used, and the check digit.\n     */\n    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [\n        Int32Array.from([0x38, 0x34, 0x32, 0x31, 0x2C, 0x26, 0x23, 0x2A, 0x29, 0x25]),\n        Int32Array.from([0x07, 0x0B, 0x0D, 0x0E, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1]),\n    ];\n    return UPCEReader;\n}(UPCEANReader_1.default));\nexports[\"default\"] = UPCEReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw4SUFBZ0I7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsc0pBQXVCO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLG9KQUFzQjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsb0JBQW9CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx5QkFBeUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL1VQQ0VSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vVVBDRUFOUmVhZGVyXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5vbmVkO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuQmFyY29kZUZvcm1hdDtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkZvcm1hdEV4Y2VwdGlvbjtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLk5vdEZvdW5kRXhjZXB0aW9uO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkJpdEFycmF5O1xuLyoqXG4gKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBVUEMtRSBmb3JtYXQuPC9wPlxuICogPHA+PGEgaHJlZj1cImh0dHA6Ly93d3cuYmFyY29kZWlzbGFuZC5jb20vdXBjZS5waHRtbFwiPlRoaXM8L2E+IGlzIGEgZ3JlYXQgcmVmZXJlbmNlIGZvclxuICogVVBDLUUgaW5mb3JtYXRpb24uPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKlxuICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi8zYzk2OTIzMjc2ZGQ1Nzg1ZDU4ZWI5NzBiNmJhM2Y4MGQzNmE5NTA1L2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL29uZWQvVVBDRVJlYWRlci5qYXZhXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG52YXIgVVBDRVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVVBDRVJlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUENFUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgKi9cbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBVUENFUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVNaWRkbGUgPSBmdW5jdGlvbiAocm93LCBzdGFydFJhbmdlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICB2YXIgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgIHZhciBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IFVQQ0VSZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnRlcnNfMSA9IChlXzEgPSB2b2lkIDAsIF9fdmFsdWVzKGNvdW50ZXJzKSksIGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpOyAhY291bnRlcnNfMV8xLmRvbmU7IGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gMSA8PCAoNSAtIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFVQQ0VSZWFkZXIuZGV0ZXJtaW5lTnVtU3lzQW5kQ2hlY2tEaWdpdChuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQocmVzdWx0KSwgbGdQYXR0ZXJuRm91bmQpO1xuICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAqL1xuICAgIC8vIEBPdmVycmlkZVxuICAgIFVQQ0VSZWFkZXIucHJvdG90eXBlLmRlY29kZUVuZCA9IGZ1bmN0aW9uIChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBVUENFUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm5XaXRob3V0Q291bnRlcnMocm93LCBlbmRTdGFydCwgdHJ1ZSwgVVBDRVJlYWRlci5NSURETEVfRU5EX1BBVFRFUk4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgKi9cbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBVUENFUmVhZGVyLnByb3RvdHlwZS5jaGVja0NoZWNrc3VtID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuY2hlY2tDaGVja3N1bShVUENFUmVhZGVyLmNvbnZlcnRVUENFdG9VUENBKHMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgKi9cbiAgICBVUENFUmVhZGVyLmRldGVybWluZU51bVN5c0FuZENoZWNrRGlnaXQgPSBmdW5jdGlvbiAocmVzdWx0U3RyaW5nLCBsZ1BhdHRlcm5Gb3VuZCkge1xuICAgICAgICBmb3IgKHZhciBudW1TeXMgPSAwOyBudW1TeXMgPD0gMTsgbnVtU3lzKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgMTA7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZ1BhdHRlcm5Gb3VuZCA9PT0gdGhpcy5OVU1TWVNfQU5EX0NIRUNLX0RJR0lUX1BBVFRFUk5TW251bVN5c11bZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nLmluc2VydCgwLCAvKihjaGFyKSovICgnMCcgKyBudW1TeXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nLmFwcGVuZCgvKihjaGFyKSovICgnMCcgKyBkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0LmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIC8vIEBPdmVycmlkZVxuICAgIFVQQ0VSZWFkZXIucHJvdG90eXBlLmdldEJhcmNvZGVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5VUENfRTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBVUEMtRSB2YWx1ZSBiYWNrIGludG8gaXRzIGZ1bGwsIGVxdWl2YWxlbnQgVVBDLUEgY29kZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cGNlIFVQQy1FIGNvZGUgYXMgc3RyaW5nIG9mIGRpZ2l0c1xuICAgICAqIEByZXR1cm4gZXF1aXZhbGVudCBVUEMtQSBjb2RlIGFzIHN0cmluZyBvZiBkaWdpdHNcbiAgICAgKi9cbiAgICBVUENFUmVhZGVyLmNvbnZlcnRVUENFdG9VUENBID0gZnVuY3Rpb24gKHVwY2UpIHtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIGVxdWl2YWxlbnQgdG8gdXBjZS5nZXRDaGFycygxLCA3LCB1cGNlQ2hhcnMsIDApO1xuICAgICAgICB2YXIgdXBjZUNoYXJzID0gdXBjZS5zbGljZSgxLCA3KS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmNoYXJDb2RlQXQoMCk7IH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCAvKjEyKi8pO1xuICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2UuY2hhckF0KDApKTtcbiAgICAgICAgdmFyIGxhc3RDaGFyID0gdXBjZUNoYXJzWzVdO1xuICAgICAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgMik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsYXN0Q2hhcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDIsIDMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAwJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMywgMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgNCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMDAnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2VDaGFyc1s0XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxhc3RDaGFyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGFwcGVuZCBjaGVjayBkaWdpdCBpbiBjb252ZXJzaW9uIGlmIHN1cHBsaWVkXG4gICAgICAgIGlmICh1cGNlLmxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2UuY2hhckF0KDcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiB0aGF0IG1hcmtzIHRoZSBtaWRkbGUsIGFuZCBlbmQsIG9mIGEgVVBDLUUgcGF0dGVybi5cbiAgICAgKiBUaGVyZSBpcyBubyBcInNlY29uZCBoYWxmXCIgdG8gYSBVUEMtRSBiYXJjb2RlLlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTUlERExFX0VORF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxXSk7XG4gICAgLy8gRm9yIGFuIFVQQy1FIGJhcmNvZGUsIHRoZSBmaW5hbCBkaWdpdCBpcyByZXByZXNlbnRlZCBieSB0aGUgcGFyaXRpZXMgdXNlZFxuICAgIC8vIHRvIGVuY29kZSB0aGUgbWlkZGxlIHNpeCBkaWdpdHMsIGFjY29yZGluZyB0byB0aGUgdGFibGUgYmVsb3cuXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICBQYXJpdHkgb2YgbmV4dCA2IGRpZ2l0c1xuICAgIC8vICAgIERpZ2l0ICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNVxuICAgIC8vICAgICAgIDAgICAgRXZlbiAgIEV2ZW4gIEV2ZW4gT2RkICBPZGQgICBPZGRcbiAgICAvLyAgICAgICAxICAgIEV2ZW4gICBFdmVuICBPZGQgIEV2ZW4gT2RkICAgT2RkXG4gICAgLy8gICAgICAgMiAgICBFdmVuICAgRXZlbiAgT2RkICBPZGQgIEV2ZW4gIE9kZFxuICAgIC8vICAgICAgIDMgICAgRXZlbiAgIEV2ZW4gIE9kZCAgT2RkICBPZGQgICBFdmVuXG4gICAgLy8gICAgICAgNCAgICBFdmVuICAgT2RkICAgRXZlbiBFdmVuIE9kZCAgIE9kZFxuICAgIC8vICAgICAgIDUgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBFdmVuICBPZGRcbiAgICAvLyAgICAgICA2ICAgIEV2ZW4gICBPZGQgICBPZGQgIE9kZCAgRXZlbiAgRXZlblxuICAgIC8vICAgICAgIDcgICAgRXZlbiAgIE9kZCAgIEV2ZW4gT2RkICBFdmVuICBPZGRcbiAgICAvLyAgICAgICA4ICAgIEV2ZW4gICBPZGQgICBFdmVuIE9kZCAgT2RkICAgRXZlblxuICAgIC8vICAgICAgIDkgICAgRXZlbiAgIE9kZCAgIE9kZCAgRXZlbiBPZGQgICBFdmVuXG4gICAgLy9cbiAgICAvLyBUaGUgZW5jb2RpbmcgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhcnJheSwgd2hpY2ggaXMgYSBiaXQgcGF0dGVyblxuICAgIC8vIHVzaW5nIE9kZCA9IDAgYW5kIEV2ZW4gPSAxLiBGb3IgZXhhbXBsZSwgNSBpcyByZXByZXNlbnRlZCBieTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBPZGQgRXZlbiBFdmVuIE9kZCBPZGQgRXZlblxuICAgIC8vIGluIGJpbmFyeTpcbiAgICAvLyAgICAgICAgICAgICAgICAwICAgIDEgICAgMSAgIDAgICAwICAgIDEgICA9PSAweDE5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rICNMX0FORF9HX1BBVFRFUk5TfTsgdGhlc2UgdmFsdWVzIHNpbWlsYXJseSByZXByZXNlbnQgcGF0dGVybnMgb2ZcbiAgICAgKiBldmVuLW9kZCBwYXJpdHkgZW5jb2RpbmdzIG9mIGRpZ2l0cyB0aGF0IGltcGx5IGJvdGggdGhlIG51bWJlciBzeXN0ZW0gKDAgb3IgMSlcbiAgICAgKiB1c2VkLCBhbmQgdGhlIGNoZWNrIGRpZ2l0LlxuICAgICAqL1xuICAgIFVQQ0VSZWFkZXIuTlVNU1lTX0FORF9DSEVDS19ESUdJVF9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDM4LCAweDM0LCAweDMyLCAweDMxLCAweDJDLCAweDI2LCAweDIzLCAweDJBLCAweDI5LCAweDI1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwNywgMHgwQiwgMHgwRCwgMHgwRSwgMHgxMywgMHgxOSwgMHgxQywgMHgxNSwgMHgxNiwgMHgxXSksXG4gICAgXTtcbiAgICByZXR1cm4gVVBDRVJlYWRlcjtcbn0oVVBDRUFOUmVhZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVVBDRVJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar OneDReader_1 = __webpack_require__(/*! ../OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\n// import Integer from '../../util/Integer';\n// import Float from '../../util/Float';\nvar AbstractRSSReader = /** @class */ (function (_super) {\n    __extends(AbstractRSSReader, _super);\n    function AbstractRSSReader() {\n        var _this = _super.call(this) || this;\n        _this.decodeFinderCounters = new Int32Array(4);\n        _this.dataCharacterCounters = new Int32Array(8);\n        _this.oddRoundingErrors = new Array(4);\n        _this.evenRoundingErrors = new Array(4);\n        _this.oddCounts = new Array(_this.dataCharacterCounters.length / 2);\n        _this.evenCounts = new Array(_this.dataCharacterCounters.length / 2);\n        return _this;\n    }\n    AbstractRSSReader.prototype.getDecodeFinderCounters = function () {\n        return this.decodeFinderCounters;\n    };\n    AbstractRSSReader.prototype.getDataCharacterCounters = function () {\n        return this.dataCharacterCounters;\n    };\n    AbstractRSSReader.prototype.getOddRoundingErrors = function () {\n        return this.oddRoundingErrors;\n    };\n    AbstractRSSReader.prototype.getEvenRoundingErrors = function () {\n        return this.evenRoundingErrors;\n    };\n    AbstractRSSReader.prototype.getOddCounts = function () {\n        return this.oddCounts;\n    };\n    AbstractRSSReader.prototype.getEvenCounts = function () {\n        return this.evenCounts;\n    };\n    AbstractRSSReader.prototype.parseFinderValue = function (counters, finderPatterns) {\n        for (var value = 0; value < finderPatterns.length; value++) {\n            if (OneDReader_1.default.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {\n                return value;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * @param array values to sum\n     * @return sum of values\n     * @deprecated call {@link MathUtils#sum(int[])}\n     */\n    AbstractRSSReader.count = function (array) {\n        return MathUtils_1.default.sum(new Int32Array(array));\n    };\n    AbstractRSSReader.increment = function (array, errors) {\n        var index = 0;\n        var biggestError = errors[0];\n        for (var i = 1; i < array.length; i++) {\n            if (errors[i] > biggestError) {\n                biggestError = errors[i];\n                index = i;\n            }\n        }\n        array[index]++;\n    };\n    AbstractRSSReader.decrement = function (array, errors) {\n        var index = 0;\n        var biggestError = errors[0];\n        for (var i = 1; i < array.length; i++) {\n            if (errors[i] < biggestError) {\n                biggestError = errors[i];\n                index = i;\n            }\n        }\n        array[index]--;\n    };\n    AbstractRSSReader.isFinderPattern = function (counters) {\n        var e_1, _a;\n        var firstTwoSum = counters[0] + counters[1];\n        var sum = firstTwoSum + counters[2] + counters[3];\n        var ratio = firstTwoSum / sum;\n        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {\n            // passes ratio test in spec, but see if the counts are unreasonable\n            var minCounter = Number.MAX_SAFE_INTEGER;\n            var maxCounter = Number.MIN_SAFE_INTEGER;\n            try {\n                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    if (counter > maxCounter) {\n                        maxCounter = counter;\n                    }\n                    if (counter < minCounter) {\n                        minCounter = counter;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return maxCounter < 10 * minCounter;\n        }\n        return false;\n    };\n    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;\n    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;\n    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;\n    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;\n    return AbstractRSSReader;\n}(OneDReader_1.default));\nexports[\"default\"] = AbstractRSSReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9BYnN0cmFjdFJTU1JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHVLQUFpQztBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyx1SkFBeUI7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsMklBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG9CQUFvQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9BYnN0cmFjdFJTU1JlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1hdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vT25lRFJlYWRlclwiKTtcbi8vIGltcG9ydCBJbnRlZ2VyIGZyb20gJy4uLy4uL3V0aWwvSW50ZWdlcic7XG4vLyBpbXBvcnQgRmxvYXQgZnJvbSAnLi4vLi4vdXRpbC9GbG9hdCc7XG52YXIgQWJzdHJhY3RSU1NSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0UlNTUmVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UlNTUmVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICBfdGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgX3RoaXMub2RkUm91bmRpbmdFcnJvcnMgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgIF90aGlzLmV2ZW5Sb3VuZGluZ0Vycm9ycyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgX3RoaXMub2RkQ291bnRzID0gbmV3IEFycmF5KF90aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycy5sZW5ndGggLyAyKTtcbiAgICAgICAgX3RoaXMuZXZlbkNvdW50cyA9IG5ldyBBcnJheShfdGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMubGVuZ3RoIC8gMik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIucHJvdG90eXBlLmdldERlY29kZUZpbmRlckNvdW50ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycztcbiAgICB9O1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLnByb3RvdHlwZS5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycztcbiAgICB9O1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLnByb3RvdHlwZS5nZXRPZGRSb3VuZGluZ0Vycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2RkUm91bmRpbmdFcnJvcnM7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUuZ2V0RXZlblJvdW5kaW5nRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVuUm91bmRpbmdFcnJvcnM7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUuZ2V0T2RkQ291bnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZGRDb3VudHM7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUuZ2V0RXZlbkNvdW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbkNvdW50cztcbiAgICB9O1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLnByb3RvdHlwZS5wYXJzZUZpbmRlclZhbHVlID0gZnVuY3Rpb24gKGNvdW50ZXJzLCBmaW5kZXJQYXR0ZXJucykge1xuICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IDA7IHZhbHVlIDwgZmluZGVyUGF0dGVybnMubGVuZ3RoOyB2YWx1ZSsrKSB7XG4gICAgICAgICAgICBpZiAoT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIGZpbmRlclBhdHRlcm5zW3ZhbHVlXSwgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bVxuICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlc1xuICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rIE1hdGhVdGlscyNzdW0oaW50W10pfVxuICAgICAqL1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLmNvdW50ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShuZXcgSW50MzJBcnJheShhcnJheSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuaW5jcmVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJpZ2dlc3RFcnJvciA9IGVycm9yc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVycm9yc1tpXSA+IGJpZ2dlc3RFcnJvcikge1xuICAgICAgICAgICAgICAgIGJpZ2dlc3RFcnJvciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbaW5kZXhdKys7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5kZWNyZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIGVycm9ycykge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYmlnZ2VzdEVycm9yID0gZXJyb3JzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JzW2ldIDwgYmlnZ2VzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmlnZ2VzdEVycm9yID0gZXJyb3JzW2ldO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcnJheVtpbmRleF0tLTtcbiAgICB9O1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLmlzRmluZGVyUGF0dGVybiA9IGZ1bmN0aW9uIChjb3VudGVycykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGZpcnN0VHdvU3VtID0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgdmFyIHN1bSA9IGZpcnN0VHdvU3VtICsgY291bnRlcnNbMl0gKyBjb3VudGVyc1szXTtcbiAgICAgICAgdmFyIHJhdGlvID0gZmlyc3RUd29TdW0gLyBzdW07XG4gICAgICAgIGlmIChyYXRpbyA+PSBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gJiYgcmF0aW8gPD0gQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0ZJTkRFUl9QQVRURVJOX1JBVElPKSB7XG4gICAgICAgICAgICAvLyBwYXNzZXMgcmF0aW8gdGVzdCBpbiBzcGVjLCBidXQgc2VlIGlmIHRoZSBjb3VudHMgYXJlIHVucmVhc29uYWJsZVxuICAgICAgICAgICAgdmFyIG1pbkNvdW50ZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIHZhciBtYXhDb3VudGVyID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzEgPSBfX3ZhbHVlcyhjb3VudGVycyksIGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpOyAhY291bnRlcnNfMV8xLmRvbmU7IGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENvdW50ZXIgPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluQ291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4Q291bnRlciA8IDEwICogbWluQ291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC4yO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC40NTtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gPSA5LjUgLyAxMi4wO1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9GSU5ERVJfUEFUVEVSTl9SQVRJTyA9IDEyLjUgLyAxNC4wO1xuICAgIHJldHVybiBBYnN0cmFjdFJTU1JlYWRlcjtcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UlNTUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DataCharacter = /** @class */ (function () {\n    function DataCharacter(value, checksumPortion) {\n        this.value = value;\n        this.checksumPortion = checksumPortion;\n    }\n    DataCharacter.prototype.getValue = function () {\n        return this.value;\n    };\n    DataCharacter.prototype.getChecksumPortion = function () {\n        return this.checksumPortion;\n    };\n    DataCharacter.prototype.toString = function () {\n        return this.value + '(' + this.checksumPortion + ')';\n    };\n    DataCharacter.prototype.equals = function (o) {\n        if (!(o instanceof DataCharacter)) {\n            return false;\n        }\n        var that = o;\n        return this.value === that.value && this.checksumPortion === that.checksumPortion;\n    };\n    DataCharacter.prototype.hashCode = function () {\n        return this.value ^ this.checksumPortion;\n    };\n    return DataCharacter;\n}());\nexports[\"default\"] = DataCharacter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9EYXRhQ2hhcmFjdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL0RhdGFDaGFyYWN0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YUNoYXJhY3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhQ2hhcmFjdGVyKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoZWNrc3VtUG9ydGlvbiA9IGNoZWNrc3VtUG9ydGlvbjtcbiAgICB9XG4gICAgRGF0YUNoYXJhY3Rlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgRGF0YUNoYXJhY3Rlci5wcm90b3R5cGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bVBvcnRpb247XG4gICAgfTtcbiAgICBEYXRhQ2hhcmFjdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyAnKCcgKyB0aGlzLmNoZWNrc3VtUG9ydGlvbiArICcpJztcbiAgICB9O1xuICAgIERhdGFDaGFyYWN0ZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBEYXRhQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0ID0gbztcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoYXQudmFsdWUgJiYgdGhpcy5jaGVja3N1bVBvcnRpb24gPT09IHRoYXQuY2hlY2tzdW1Qb3J0aW9uO1xuICAgIH07XG4gICAgRGF0YUNoYXJhY3Rlci5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlIF4gdGhpcy5jaGVja3N1bVBvcnRpb247XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUNoYXJhY3Rlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhQ2hhcmFjdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar FinderPattern = /** @class */ (function () {\n    function FinderPattern(value, startEnd, start, end, rowNumber) {\n        this.value = value;\n        this.startEnd = startEnd;\n        this.value = value;\n        this.startEnd = startEnd;\n        this.resultPoints = new Array();\n        this.resultPoints.push(new ResultPoint_1.default(start, rowNumber));\n        this.resultPoints.push(new ResultPoint_1.default(end, rowNumber));\n    }\n    FinderPattern.prototype.getValue = function () {\n        return this.value;\n    };\n    FinderPattern.prototype.getStartEnd = function () {\n        return this.startEnd;\n    };\n    FinderPattern.prototype.getResultPoints = function () {\n        return this.resultPoints;\n    };\n    FinderPattern.prototype.equals = function (o) {\n        if (!(o instanceof FinderPattern)) {\n            return false;\n        }\n        var that = o;\n        return this.value === that.value;\n    };\n    FinderPattern.prototype.hashCode = function () {\n        return this.value;\n    };\n    return FinderPattern;\n}());\nexports[\"default\"] = FinderPattern;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9GaW5kZXJQYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDJJQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvRmluZGVyUGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIEZpbmRlclBhdHRlcm4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmluZGVyUGF0dGVybih2YWx1ZSwgc3RhcnRFbmQsIHN0YXJ0LCBlbmQsIHJvd051bWJlcikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnRFbmQgPSBzdGFydEVuZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzLnB1c2gobmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChzdGFydCwgcm93TnVtYmVyKSk7XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzLnB1c2gobmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChlbmQsIHJvd051bWJlcikpO1xuICAgIH1cbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRTdGFydEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFbmQ7XG4gICAgfTtcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRSZXN1bHRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50cztcbiAgICB9O1xuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBGaW5kZXJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0ID0gbztcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoYXQudmFsdWU7XG4gICAgfTtcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gRmluZGVyUGF0dGVybjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DataCharacter_1 = __webpack_require__(/*! ./DataCharacter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js\");\nvar Pair = /** @class */ (function (_super) {\n    __extends(Pair, _super);\n    function Pair(value, checksumPortion, finderPattern) {\n        var _this = _super.call(this, value, checksumPortion) || this;\n        _this.count = 0;\n        _this.finderPattern = finderPattern;\n        return _this;\n    }\n    Pair.prototype.getFinderPattern = function () {\n        return this.finderPattern;\n    };\n    Pair.prototype.getCount = function () {\n        return this.count;\n    };\n    Pair.prototype.incrementCount = function () {\n        this.count++;\n    };\n    return Pair;\n}(DataCharacter_1.default));\nexports[\"default\"] = Pair;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9QYWlyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsb0pBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9QYWlyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YUNoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4vRGF0YUNoYXJhY3RlclwiKTtcbnZhciBQYWlyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWlyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXIodmFsdWUsIGNoZWNrc3VtUG9ydGlvbiwgZmluZGVyUGF0dGVybikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmZpbmRlclBhdHRlcm4gPSBmaW5kZXJQYXR0ZXJuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBhaXIucHJvdG90eXBlLmdldEZpbmRlclBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRlclBhdHRlcm47XG4gICAgfTtcbiAgICBQYWlyLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgfTtcbiAgICBQYWlyLnByb3RvdHlwZS5pbmNyZW1lbnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXI7XG59KERhdGFDaGFyYWN0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQYWlyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AbstractRSSReader_1 = __webpack_require__(/*! ./AbstractRSSReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js\");\nvar Pair_1 = __webpack_require__(/*! ./Pair */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js\");\nvar Result_1 = __webpack_require__(/*! ../../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar BarcodeFormat_1 = __webpack_require__(/*! ../../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar FinderPattern_1 = __webpack_require__(/*! ./FinderPattern */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js\");\nvar DataCharacter_1 = __webpack_require__(/*! ./DataCharacter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js\");\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar RSSUtils_1 = __webpack_require__(/*! ./RSSUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js\");\nvar System_1 = __webpack_require__(/*! ../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar OneDReader_1 = __webpack_require__(/*! ../OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nvar RSS14Reader = /** @class */ (function (_super) {\n    __extends(RSS14Reader, _super);\n    function RSS14Reader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.possibleLeftPairs = [];\n        _this.possibleRightPairs = [];\n        return _this;\n    }\n    RSS14Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a, e_2, _b;\n        var leftPair = this.decodePair(row, false, rowNumber, hints);\n        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);\n        row.reverse();\n        var rightPair = this.decodePair(row, true, rowNumber, hints);\n        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);\n        row.reverse();\n        try {\n            for (var _c = __values(this.possibleLeftPairs), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var left = _d.value;\n                if (left.getCount() > 1) {\n                    try {\n                        for (var _e = (e_2 = void 0, __values(this.possibleRightPairs)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var right = _f.value;\n                            if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {\n                                return RSS14Reader.constructResult(left, right);\n                            }\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        throw new NotFoundException_1.default();\n    };\n    RSS14Reader.addOrTally = function (possiblePairs, pair) {\n        var e_3, _a;\n        if (pair == null) {\n            return;\n        }\n        var found = false;\n        try {\n            for (var possiblePairs_1 = __values(possiblePairs), possiblePairs_1_1 = possiblePairs_1.next(); !possiblePairs_1_1.done; possiblePairs_1_1 = possiblePairs_1.next()) {\n                var other = possiblePairs_1_1.value;\n                if (other.getValue() === pair.getValue()) {\n                    other.incrementCount();\n                    found = true;\n                    break;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (possiblePairs_1_1 && !possiblePairs_1_1.done && (_a = possiblePairs_1.return)) _a.call(possiblePairs_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        if (!found) {\n            possiblePairs.push(pair);\n        }\n    };\n    RSS14Reader.prototype.reset = function () {\n        this.possibleLeftPairs.length = 0;\n        this.possibleRightPairs.length = 0;\n    };\n    RSS14Reader.constructResult = function (leftPair, rightPair) {\n        var symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();\n        var text = new String(symbolValue).toString();\n        var buffer = new StringBuilder_1.default();\n        for (var i = 13 - text.length; i > 0; i--) {\n            buffer.append('0');\n        }\n        buffer.append(text);\n        var checkDigit = 0;\n        for (var i = 0; i < 13; i++) {\n            var digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;\n        }\n        checkDigit = 10 - (checkDigit % 10);\n        if (checkDigit === 10) {\n            checkDigit = 0;\n        }\n        buffer.append(checkDigit.toString());\n        var leftPoints = leftPair.getFinderPattern().getResultPoints();\n        var rightPoints = rightPair.getFinderPattern().getResultPoints();\n        return new Result_1.default(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat_1.default.RSS_14, new Date().getTime());\n    };\n    RSS14Reader.checkChecksum = function (leftPair, rightPair) {\n        var checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;\n        var targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();\n        if (targetCheckValue > 72) {\n            targetCheckValue--;\n        }\n        if (targetCheckValue > 8) {\n            targetCheckValue--;\n        }\n        return checkValue === targetCheckValue;\n    };\n    RSS14Reader.prototype.decodePair = function (row, right, rowNumber, hints) {\n        try {\n            var startEnd = this.findFinderPattern(row, right);\n            var pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);\n            var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            if (resultPointCallback != null) {\n                var center = (startEnd[0] + startEnd[1]) / 2.0;\n                if (right) {\n                    // row is actually reversed\n                    center = row.getSize() - 1 - center;\n                }\n                resultPointCallback.foundPossibleResultPoint(new ResultPoint_1.default(center, rowNumber));\n            }\n            var outside = this.decodeDataCharacter(row, pattern, true);\n            var inside = this.decodeDataCharacter(row, pattern, false);\n            return new Pair_1.default(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);\n        }\n        catch (err) {\n            return null;\n        }\n    };\n    RSS14Reader.prototype.decodeDataCharacter = function (row, pattern, outsideChar) {\n        var counters = this.getDataCharacterCounters();\n        for (var x = 0; x < counters.length; x++) {\n            counters[x] = 0;\n        }\n        if (outsideChar) {\n            OneDReader_1.default.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n        }\n        else {\n            OneDReader_1.default.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);\n            // reverse it\n            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {\n                var temp = counters[i];\n                counters[i] = counters[j];\n                counters[j] = temp;\n            }\n        }\n        var numModules = outsideChar ? 16 : 15;\n        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;\n        var oddCounts = this.getOddCounts();\n        var evenCounts = this.getEvenCounts();\n        var oddRoundingErrors = this.getOddRoundingErrors();\n        var evenRoundingErrors = this.getEvenRoundingErrors();\n        for (var i = 0; i < counters.length; i++) {\n            var value = counters[i] / elementWidth;\n            var count = Math.floor(value + 0.5);\n            if (count < 1) {\n                count = 1;\n            }\n            else if (count > 8) {\n                count = 8;\n            }\n            var offset = Math.floor(i / 2);\n            if ((i & 0x01) === 0) {\n                oddCounts[offset] = count;\n                oddRoundingErrors[offset] = value - count;\n            }\n            else {\n                evenCounts[offset] = count;\n                evenRoundingErrors[offset] = value - count;\n            }\n        }\n        this.adjustOddEvenCounts(outsideChar, numModules);\n        var oddSum = 0;\n        var oddChecksumPortion = 0;\n        for (var i = oddCounts.length - 1; i >= 0; i--) {\n            oddChecksumPortion *= 9;\n            oddChecksumPortion += oddCounts[i];\n            oddSum += oddCounts[i];\n        }\n        var evenChecksumPortion = 0;\n        var evenSum = 0;\n        for (var i = evenCounts.length - 1; i >= 0; i--) {\n            evenChecksumPortion *= 9;\n            evenChecksumPortion += evenCounts[i];\n            evenSum += evenCounts[i];\n        }\n        var checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;\n        if (outsideChar) {\n            if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {\n                throw new NotFoundException_1.default();\n            }\n            var group = (12 - oddSum) / 2;\n            var oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];\n            var evenWidest = 9 - oddWidest;\n            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, false);\n            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, true);\n            var tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];\n            var gSum = RSS14Reader.OUTSIDE_GSUM[group];\n            return new DataCharacter_1.default(vOdd * tEven + vEven + gSum, checksumPortion);\n        }\n        else {\n            if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {\n                throw new NotFoundException_1.default();\n            }\n            var group = (10 - evenSum) / 2;\n            var oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];\n            var evenWidest = 9 - oddWidest;\n            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);\n            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);\n            var tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];\n            var gSum = RSS14Reader.INSIDE_GSUM[group];\n            return new DataCharacter_1.default(vEven * tOdd + vOdd + gSum, checksumPortion);\n        }\n    };\n    RSS14Reader.prototype.findFinderPattern = function (row, rightFinderPattern) {\n        var counters = this.getDecodeFinderCounters();\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var width = row.getSize();\n        var isWhite = false;\n        var rowOffset = 0;\n        while (rowOffset < width) {\n            isWhite = !row.get(rowOffset);\n            if (rightFinderPattern === isWhite) {\n                // Will encounter white first when searching for right finder pattern\n                break;\n            }\n            rowOffset++;\n        }\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === 3) {\n                    if (AbstractRSSReader_1.default.isFinderPattern(counters)) {\n                        return [patternStart, x];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters[0] = counters[2];\n                    counters[1] = counters[3];\n                    counters[2] = 0;\n                    counters[3] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    RSS14Reader.prototype.parseFoundFinderPattern = function (row, rowNumber, right, startEnd) {\n        // Actually we found elements 2-5\n        var firstIsBlack = row.get(startEnd[0]);\n        var firstElementStart = startEnd[0] - 1;\n        // Locate element 1\n        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {\n            firstElementStart--;\n        }\n        firstElementStart++;\n        var firstCounter = startEnd[0] - firstElementStart;\n        // Make 'counters' hold 1-4\n        var counters = this.getDecodeFinderCounters();\n        var copy = new Int32Array(counters.length);\n        System_1.default.arraycopy(counters, 0, copy, 1, counters.length - 1);\n        copy[0] = firstCounter;\n        var value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);\n        var start = firstElementStart;\n        var end = startEnd[1];\n        if (right) {\n            // row is actually reversed\n            start = row.getSize() - 1 - start;\n            end = row.getSize() - 1 - end;\n        }\n        return new FinderPattern_1.default(value, [firstElementStart, startEnd[1]], start, end, rowNumber);\n    };\n    RSS14Reader.prototype.adjustOddEvenCounts = function (outsideChar, numModules) {\n        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));\n        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));\n        var incrementOdd = false;\n        var decrementOdd = false;\n        var incrementEven = false;\n        var decrementEven = false;\n        if (outsideChar) {\n            if (oddSum > 12) {\n                decrementOdd = true;\n            }\n            else if (oddSum < 4) {\n                incrementOdd = true;\n            }\n            if (evenSum > 12) {\n                decrementEven = true;\n            }\n            else if (evenSum < 4) {\n                incrementEven = true;\n            }\n        }\n        else {\n            if (oddSum > 11) {\n                decrementOdd = true;\n            }\n            else if (oddSum < 5) {\n                incrementOdd = true;\n            }\n            if (evenSum > 10) {\n                decrementEven = true;\n            }\n            else if (evenSum < 4) {\n                incrementEven = true;\n            }\n        }\n        var mismatch = oddSum + evenSum - numModules;\n        var oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);\n        var evenParityBad = (evenSum & 0x01) === 1;\n        if (mismatch === 1) {\n            if (oddParityBad) {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                decrementOdd = true;\n            }\n            else {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                decrementEven = true;\n            }\n        }\n        else if (mismatch === -1) {\n            if (oddParityBad) {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                incrementOdd = true;\n            }\n            else {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                incrementEven = true;\n            }\n        }\n        else if (mismatch === 0) {\n            if (oddParityBad) {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                // Both bad\n                if (oddSum < evenSum) {\n                    incrementOdd = true;\n                    decrementEven = true;\n                }\n                else {\n                    decrementOdd = true;\n                    incrementEven = true;\n                }\n            }\n            else {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                // Nothing to do!\n            }\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n        if (incrementOdd) {\n            if (decrementOdd) {\n                throw new NotFoundException_1.default();\n            }\n            AbstractRSSReader_1.default.increment(this.getOddCounts(), this.getOddRoundingErrors());\n        }\n        if (decrementOdd) {\n            AbstractRSSReader_1.default.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n        }\n        if (incrementEven) {\n            if (decrementEven) {\n                throw new NotFoundException_1.default();\n            }\n            AbstractRSSReader_1.default.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n        }\n        if (decrementEven) {\n            AbstractRSSReader_1.default.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n        }\n    };\n    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];\n    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];\n    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];\n    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];\n    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];\n    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];\n    RSS14Reader.FINDER_PATTERNS = [\n        Int32Array.from([3, 8, 2, 1]),\n        Int32Array.from([3, 5, 5, 1]),\n        Int32Array.from([3, 3, 7, 1]),\n        Int32Array.from([3, 1, 9, 1]),\n        Int32Array.from([2, 7, 4, 1]),\n        Int32Array.from([2, 5, 6, 1]),\n        Int32Array.from([2, 3, 8, 1]),\n        Int32Array.from([1, 5, 7, 1]),\n        Int32Array.from([1, 3, 9, 1]),\n    ];\n    return RSS14Reader;\n}(AbstractRSSReader_1.default));\nexports[\"default\"] = RSS14Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9SU1MxNFJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixtQkFBTyxDQUFDLDRKQUFxQjtBQUN2RCxhQUFhLG1CQUFPLENBQUMsa0lBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLGlJQUFjO0FBQ3JDLHVCQUF1QixtQkFBTyxDQUFDLGlKQUFzQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyx1SkFBeUI7QUFDM0Qsc0JBQXNCLG1CQUFPLENBQUMseUpBQTBCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLCtJQUFxQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQywySUFBbUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsb0pBQWlCO0FBQy9DLHNCQUFzQixtQkFBTyxDQUFDLG9KQUFpQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyx1S0FBaUM7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsMElBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDJJQUFtQjtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQywySUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFVBQVU7QUFDdEY7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFVBQVU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryx5QkFBeUI7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9SU1MxNFJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFic3RyYWN0UlNTUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFJTU1JlYWRlclwiKTtcbnZhciBQYWlyXzEgPSByZXF1aXJlKFwiLi9QYWlyXCIpO1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xudmFyIEZpbmRlclBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuL0ZpbmRlclBhdHRlcm5cIik7XG52YXIgRGF0YUNoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4vRGF0YUNoYXJhY3RlclwiKTtcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzXCIpO1xudmFyIFJTU1V0aWxzXzEgPSByZXF1aXJlKFwiLi9SU1NVdGlsc1wiKTtcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N5c3RlbVwiKTtcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vT25lRFJlYWRlclwiKTtcbnZhciBSU1MxNFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUlNTMTRSZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUlNTMTRSZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wb3NzaWJsZUxlZnRQYWlycyA9IFtdO1xuICAgICAgICBfdGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIGxlZnRQYWlyID0gdGhpcy5kZWNvZGVQYWlyKHJvdywgZmFsc2UsIHJvd051bWJlciwgaGludHMpO1xuICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVMZWZ0UGFpcnMsIGxlZnRQYWlyKTtcbiAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgdmFyIHJpZ2h0UGFpciA9IHRoaXMuZGVjb2RlUGFpcihyb3csIHRydWUsIHJvd051bWJlciwgaGludHMpO1xuICAgICAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5KHRoaXMucG9zc2libGVSaWdodFBhaXJzLCByaWdodFBhaXIpO1xuICAgICAgICByb3cucmV2ZXJzZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlTGVmdFBhaXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuZ2V0Q291bnQoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXModGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodC5nZXRDb3VudCgpID4gMSAmJiBSU1MxNFJlYWRlci5jaGVja0NoZWNrc3VtKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUlNTMTRSZWFkZXIuY29uc3RydWN0UmVzdWx0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIFJTUzE0UmVhZGVyLmFkZE9yVGFsbHkgPSBmdW5jdGlvbiAocG9zc2libGVQYWlycywgcGFpcikge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgaWYgKHBhaXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcG9zc2libGVQYWlyc18xID0gX192YWx1ZXMocG9zc2libGVQYWlycyksIHBvc3NpYmxlUGFpcnNfMV8xID0gcG9zc2libGVQYWlyc18xLm5leHQoKTsgIXBvc3NpYmxlUGFpcnNfMV8xLmRvbmU7IHBvc3NpYmxlUGFpcnNfMV8xID0gcG9zc2libGVQYWlyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IHBvc3NpYmxlUGFpcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlci5nZXRWYWx1ZSgpID09PSBwYWlyLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuaW5jcmVtZW50Q291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVBhaXJzXzFfMSAmJiAhcG9zc2libGVQYWlyc18xXzEuZG9uZSAmJiAoX2EgPSBwb3NzaWJsZVBhaXJzXzEucmV0dXJuKSkgX2EuY2FsbChwb3NzaWJsZVBhaXJzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHBvc3NpYmxlUGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUlNTMTRSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvc3NpYmxlTGVmdFBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zc2libGVSaWdodFBhaXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBSU1MxNFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQgPSBmdW5jdGlvbiAobGVmdFBhaXIsIHJpZ2h0UGFpcikge1xuICAgICAgICB2YXIgc3ltYm9sVmFsdWUgPSA0NTM3MDc3ICogbGVmdFBhaXIuZ2V0VmFsdWUoKSArIHJpZ2h0UGFpci5nZXRWYWx1ZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBTdHJpbmcoc3ltYm9sVmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEzIC0gdGV4dC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuYXBwZW5kKHRleHQpO1xuICAgICAgICB2YXIgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gYnVmZmVyLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBjaGVja0RpZ2l0ICs9ICgoaSAmIDB4MDEpID09PSAwKSA/IDMgKiBkaWdpdCA6IGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRGlnaXQgPSAxMCAtIChjaGVja0RpZ2l0ICUgMTApO1xuICAgICAgICBpZiAoY2hlY2tEaWdpdCA9PT0gMTApIHtcbiAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5hcHBlbmQoY2hlY2tEaWdpdC50b1N0cmluZygpKTtcbiAgICAgICAgdmFyIGxlZnRQb2ludHMgPSBsZWZ0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgIHZhciByaWdodFBvaW50cyA9IHJpZ2h0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0XzEuZGVmYXVsdChidWZmZXIudG9TdHJpbmcoKSwgbnVsbCwgMCwgW2xlZnRQb2ludHNbMF0sIGxlZnRQb2ludHNbMV0sIHJpZ2h0UG9pbnRzWzBdLCByaWdodFBvaW50c1sxXV0sIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlJTU18xNCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgIH07XG4gICAgUlNTMTRSZWFkZXIuY2hlY2tDaGVja3N1bSA9IGZ1bmN0aW9uIChsZWZ0UGFpciwgcmlnaHRQYWlyKSB7XG4gICAgICAgIHZhciBjaGVja1ZhbHVlID0gKGxlZnRQYWlyLmdldENoZWNrc3VtUG9ydGlvbigpICsgMTYgKiByaWdodFBhaXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkpICUgNzk7XG4gICAgICAgIHZhciB0YXJnZXRDaGVja1ZhbHVlID0gOSAqIGxlZnRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpICsgcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAodGFyZ2V0Q2hlY2tWYWx1ZSA+IDcyKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldENoZWNrVmFsdWUgPiA4KSB7XG4gICAgICAgICAgICB0YXJnZXRDaGVja1ZhbHVlLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWUgPT09IHRhcmdldENoZWNrVmFsdWU7XG4gICAgfTtcbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZGVjb2RlUGFpciA9IGZ1bmN0aW9uIChyb3csIHJpZ2h0LCByb3dOdW1iZXIsIGhpbnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbmQgPSB0aGlzLmZpbmRGaW5kZXJQYXR0ZXJuKHJvdywgcmlnaHQpO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCByaWdodCwgc3RhcnRFbmQpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFBvaW50Q2FsbGJhY2sgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSAoc3RhcnRFbmRbMF0gKyBzdGFydEVuZFsxXSkgLyAyLjA7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdyBpcyBhY3R1YWxseSByZXZlcnNlZFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGNlbnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQobmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChjZW50ZXIsIHJvd051bWJlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHNpZGUgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhaXJfMS5kZWZhdWx0KDE1OTcgKiBvdXRzaWRlLmdldFZhbHVlKCkgKyBpbnNpZGUuZ2V0VmFsdWUoKSwgb3V0c2lkZS5nZXRDaGVja3N1bVBvcnRpb24oKSArIDQgKiBpbnNpZGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCksIHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZGVjb2RlRGF0YUNoYXJhY3RlciA9IGZ1bmN0aW9uIChyb3csIHBhdHRlcm4sIG91dHNpZGVDaGFyKSB7XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY291bnRlcnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJzW3hdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgIE9uZURSZWFkZXJfMS5kZWZhdWx0LnJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0sIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9uZURSZWFkZXJfMS5kZWZhdWx0LnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gKyAxLCBjb3VudGVycyk7XG4gICAgICAgICAgICAvLyByZXZlcnNlIGl0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvdW50ZXJzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tqXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bU1vZHVsZXMgPSBvdXRzaWRlQ2hhciA/IDE2IDogMTU7XG4gICAgICAgIHZhciBlbGVtZW50V2lkdGggPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShuZXcgSW50MzJBcnJheShjb3VudGVycykpIC8gbnVtTW9kdWxlcztcbiAgICAgICAgdmFyIG9kZENvdW50cyA9IHRoaXMuZ2V0T2RkQ291bnRzKCk7XG4gICAgICAgIHZhciBldmVuQ291bnRzID0gdGhpcy5nZXRFdmVuQ291bnRzKCk7XG4gICAgICAgIHZhciBvZGRSb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgdmFyIGV2ZW5Sb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5mbG9vcih2YWx1ZSArIDAuNSk7XG4gICAgICAgICAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiA4KSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IE1hdGguZmxvb3IoaSAvIDIpO1xuICAgICAgICAgICAgaWYgKChpICYgMHgwMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBvZGRDb3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgIG9kZFJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbkNvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgZXZlblJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhvdXRzaWRlQ2hhciwgbnVtTW9kdWxlcyk7XG4gICAgICAgIHZhciBvZGRTdW0gPSAwO1xuICAgICAgICB2YXIgb2RkQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9kZENvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XG4gICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKz0gb2RkQ291bnRzW2ldO1xuICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbkNoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgIHZhciBldmVuU3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGV2ZW5Db3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKj0gOTtcbiAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgICAgIGV2ZW5TdW0gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgMyAqIGV2ZW5DaGVja3N1bVBvcnRpb247XG4gICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgaWYgKChvZGRTdW0gJiAweDAxKSAhPT0gMCB8fCBvZGRTdW0gPiAxMiB8fCBvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwID0gKDEyIC0gb2RkU3VtKSAvIDI7XG4gICAgICAgICAgICB2YXIgb2RkV2lkZXN0ID0gUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgIHZhciBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgIHZhciB2T2RkID0gUlNTVXRpbHNfMS5kZWZhdWx0LmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgdkV2ZW4gPSBSU1NVdGlsc18xLmRlZmF1bHQuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdEV2ZW4gPSBSU1MxNFJlYWRlci5PVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgIHZhciBnU3VtID0gUlNTMTRSZWFkZXIuT1VUU0lERV9HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcl8xLmRlZmF1bHQodk9kZCAqIHRFdmVuICsgdkV2ZW4gKyBnU3VtLCBjaGVja3N1bVBvcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChldmVuU3VtICYgMHgwMSkgIT09IDAgfHwgZXZlblN1bSA+IDEwIHx8IGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwID0gKDEwIC0gZXZlblN1bSkgLyAyO1xuICAgICAgICAgICAgdmFyIG9kZFdpZGVzdCA9IFJTUzE0UmVhZGVyLklOU0lERV9PRERfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgIHZhciBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgIHZhciB2T2RkID0gUlNTVXRpbHNfMS5kZWZhdWx0LmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2RXZlbiA9IFJTU1V0aWxzXzEuZGVmYXVsdC5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgdE9kZCA9IFJTUzE0UmVhZGVyLklOU0lERV9PRERfVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgIHZhciBnU3VtID0gUlNTMTRSZWFkZXIuSU5TSURFX0dTVU1bZ3JvdXBdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyXzEuZGVmYXVsdCh2RXZlbiAqIHRPZGQgKyB2T2RkICsgZ1N1bSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUlNTMTRSZWFkZXIucHJvdG90eXBlLmZpbmRGaW5kZXJQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgcmlnaHRGaW5kZXJQYXR0ZXJuKSB7XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICB2YXIgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcm93T2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHJvd09mZnNldCA8IHdpZHRoKSB7XG4gICAgICAgICAgICBpc1doaXRlID0gIXJvdy5nZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyaWdodEZpbmRlclBhdHRlcm4gPT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXaWxsIGVuY291bnRlciB3aGl0ZSBmaXJzdCB3aGVuIHNlYXJjaGluZyBmb3IgcmlnaHQgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd09mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICBmb3IgKHZhciB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBYnN0cmFjdFJTU1JlYWRlcl8xLmRlZmF1bHQuaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1sxXSA9IGNvdW50ZXJzWzNdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5wYXJzZUZvdW5kRmluZGVyUGF0dGVybiA9IGZ1bmN0aW9uIChyb3csIHJvd051bWJlciwgcmlnaHQsIHN0YXJ0RW5kKSB7XG4gICAgICAgIC8vIEFjdHVhbGx5IHdlIGZvdW5kIGVsZW1lbnRzIDItNVxuICAgICAgICB2YXIgZmlyc3RJc0JsYWNrID0gcm93LmdldChzdGFydEVuZFswXSk7XG4gICAgICAgIHZhciBmaXJzdEVsZW1lbnRTdGFydCA9IHN0YXJ0RW5kWzBdIC0gMTtcbiAgICAgICAgLy8gTG9jYXRlIGVsZW1lbnQgMVxuICAgICAgICB3aGlsZSAoZmlyc3RFbGVtZW50U3RhcnQgPj0gMCAmJiBmaXJzdElzQmxhY2sgIT09IHJvdy5nZXQoZmlyc3RFbGVtZW50U3RhcnQpKSB7XG4gICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0Kys7XG4gICAgICAgIHZhciBmaXJzdENvdW50ZXIgPSBzdGFydEVuZFswXSAtIGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAvLyBNYWtlICdjb3VudGVycycgaG9sZCAxLTRcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICB2YXIgY29weSA9IG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzLmxlbmd0aCk7XG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KGNvdW50ZXJzLCAwLCBjb3B5LCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgY29weVswXSA9IGZpcnN0Q291bnRlcjtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUZpbmRlclZhbHVlKGNvcHksIFJTUzE0UmVhZGVyLkZJTkRFUl9QQVRURVJOUyk7XG4gICAgICAgIHZhciBzdGFydCA9IGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gc3RhcnRFbmRbMV07XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgLy8gcm93IGlzIGFjdHVhbGx5IHJldmVyc2VkXG4gICAgICAgICAgICBzdGFydCA9IHJvdy5nZXRTaXplKCkgLSAxIC0gc3RhcnQ7XG4gICAgICAgICAgICBlbmQgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm5fMS5kZWZhdWx0KHZhbHVlLCBbZmlyc3RFbGVtZW50U3RhcnQsIHN0YXJ0RW5kWzFdXSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKTtcbiAgICB9O1xuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5hZGp1c3RPZGRFdmVuQ291bnRzID0gZnVuY3Rpb24gKG91dHNpZGVDaGFyLCBudW1Nb2R1bGVzKSB7XG4gICAgICAgIHZhciBvZGRTdW0gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldE9kZENvdW50cygpKSk7XG4gICAgICAgIHZhciBldmVuU3VtID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRFdmVuQ291bnRzKCkpKTtcbiAgICAgICAgdmFyIGluY3JlbWVudE9kZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGVjcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgIHZhciBpbmNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDEyKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMikge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvZGRTdW0gPiAxMSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA1KSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVuU3VtID4gMTApIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pc21hdGNoID0gb2RkU3VtICsgZXZlblN1bSAtIG51bU1vZHVsZXM7XG4gICAgICAgIHZhciBvZGRQYXJpdHlCYWQgPSAob2RkU3VtICYgMHgwMSkgPT09IChvdXRzaWRlQ2hhciA/IDEgOiAwKTtcbiAgICAgICAgdmFyIGV2ZW5QYXJpdHlCYWQgPSAoZXZlblN1bSAmIDB4MDEpID09PSAxO1xuICAgICAgICBpZiAobWlzbWF0Y2ggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJvdGggYmFkXG4gICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA8IGV2ZW5TdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyXzEuZGVmYXVsdC5pbmNyZW1lbnQodGhpcy5nZXRPZGRDb3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlcl8xLmRlZmF1bHQuZGVjcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXJfMS5kZWZhdWx0LmluY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXJfMS5kZWZhdWx0LmRlY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfRVZFTl9UT1RBTF9TVUJTRVQgPSBbMSwgMTAsIDM0LCA3MCwgMTI2XTtcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVCA9IFs0LCAyMCwgNDgsIDgxXTtcbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX0dTVU0gPSBbMCwgMTYxLCA5NjEsIDIwMTUsIDI3MTVdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9HU1VNID0gWzAsIDMzNiwgMTAzNiwgMTUxNl07XG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUID0gWzgsIDYsIDQsIDMsIDFdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9PRERfV0lERVNUID0gWzIsIDQsIDYsIDhdO1xuICAgIFJTUzE0UmVhZGVyLkZJTkRFUl9QQVRURVJOUyA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA4LCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNSwgNSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDMsIDcsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCA5LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNywgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDUsIDYsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCA4LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNSwgNywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDksIDFdKSxcbiAgICBdO1xuICAgIHJldHVybiBSU1MxNFJlYWRlcjtcbn0oQWJzdHJhY3RSU1NSZWFkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSU1MxNFJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * RSS util functions.\n */\nvar RSSUtils = /** @class */ (function () {\n    function RSSUtils() {\n    }\n    RSSUtils.getRSSvalue = function (widths, maxWidth, noNarrow) {\n        var e_1, _a;\n        var n = 0;\n        try {\n            for (var widths_1 = __values(widths), widths_1_1 = widths_1.next(); !widths_1_1.done; widths_1_1 = widths_1.next()) {\n                var width = widths_1_1.value;\n                n += width;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (widths_1_1 && !widths_1_1.done && (_a = widths_1.return)) _a.call(widths_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var val = 0;\n        var narrowMask = 0;\n        var elements = widths.length;\n        for (var bar = 0; bar < elements - 1; bar++) {\n            var elmWidth = void 0;\n            for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {\n                var subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);\n                if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {\n                    subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);\n                }\n                if (elements - bar - 1 > 1) {\n                    var lessVal = 0;\n                    for (var mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {\n                        lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);\n                    }\n                    subVal -= lessVal * (elements - 1 - bar);\n                }\n                else if (n - elmWidth > maxWidth) {\n                    subVal--;\n                }\n                val += subVal;\n            }\n            n -= elmWidth;\n        }\n        return val;\n    };\n    RSSUtils.combins = function (n, r) {\n        var maxDenom;\n        var minDenom;\n        if (n - r > r) {\n            minDenom = r;\n            maxDenom = n - r;\n        }\n        else {\n            minDenom = n - r;\n            maxDenom = r;\n        }\n        var val = 1;\n        var j = 1;\n        for (var i = n; i > maxDenom; i--) {\n            val *= i;\n            if (j <= minDenom) {\n                val /= j;\n                j++;\n            }\n        }\n        while ((j <= minDenom)) {\n            val /= j;\n            j++;\n        }\n        return val;\n    };\n    return RSSUtils;\n}());\nexports[\"default\"] = RSSUtils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9SU1NVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixrQkFBa0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSx1QkFBdUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL1JTU1V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSU1MgdXRpbCBmdW5jdGlvbnMuXG4gKi9cbnZhciBSU1NVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSU1NVdGlscygpIHtcbiAgICB9XG4gICAgUlNTVXRpbHMuZ2V0UlNTdmFsdWUgPSBmdW5jdGlvbiAod2lkdGhzLCBtYXhXaWR0aCwgbm9OYXJyb3cpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHdpZHRoc18xID0gX192YWx1ZXMod2lkdGhzKSwgd2lkdGhzXzFfMSA9IHdpZHRoc18xLm5leHQoKTsgIXdpZHRoc18xXzEuZG9uZTsgd2lkdGhzXzFfMSA9IHdpZHRoc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHdpZHRoc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgbiArPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoc18xXzEgJiYgIXdpZHRoc18xXzEuZG9uZSAmJiAoX2EgPSB3aWR0aHNfMS5yZXR1cm4pKSBfYS5jYWxsKHdpZHRoc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gMDtcbiAgICAgICAgdmFyIG5hcnJvd01hc2sgPSAwO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB3aWR0aHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBiYXIgPSAwOyBiYXIgPCBlbGVtZW50cyAtIDE7IGJhcisrKSB7XG4gICAgICAgICAgICB2YXIgZWxtV2lkdGggPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKGVsbVdpZHRoID0gMSwgbmFycm93TWFzayB8PSAxIDw8IGJhcjsgZWxtV2lkdGggPCB3aWR0aHNbYmFyXTsgZWxtV2lkdGgrKywgbmFycm93TWFzayAmPSB+KDEgPDwgYmFyKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJWYWwgPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMik7XG4gICAgICAgICAgICAgICAgaWYgKG5vTmFycm93ICYmIChuYXJyb3dNYXNrID09PSAwKSAmJiAobiAtIGVsbVdpZHRoIC0gKGVsZW1lbnRzIC0gYmFyIC0gMSkgPj0gZWxlbWVudHMgLSBiYXIgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIpLCBlbGVtZW50cyAtIGJhciAtIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMgLSBiYXIgLSAxID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc1ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG14d0VsZW1lbnQgPSBuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIgLSAyKTsgbXh3RWxlbWVudCA+IG1heFdpZHRoOyBteHdFbGVtZW50LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NWYWwgKz0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSBteHdFbGVtZW50IC0gMSwgZWxlbWVudHMgLSBiYXIgLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gbGVzc1ZhbCAqIChlbGVtZW50cyAtIDEgLSBiYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuIC0gZWxtV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJWYWwtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsICs9IHN1YlZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gLT0gZWxtV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICAgIFJTU1V0aWxzLmNvbWJpbnMgPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICB2YXIgbWF4RGVub207XG4gICAgICAgIHZhciBtaW5EZW5vbTtcbiAgICAgICAgaWYgKG4gLSByID4gcikge1xuICAgICAgICAgICAgbWluRGVub20gPSByO1xuICAgICAgICAgICAgbWF4RGVub20gPSBuIC0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbkRlbm9tID0gbiAtIHI7XG4gICAgICAgICAgICBtYXhEZW5vbSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IDE7XG4gICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiBtYXhEZW5vbTsgaS0tKSB7XG4gICAgICAgICAgICB2YWwgKj0gaTtcbiAgICAgICAgICAgIGlmIChqIDw9IG1pbkRlbm9tKSB7XG4gICAgICAgICAgICAgICAgdmFsIC89IGo7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgoaiA8PSBtaW5EZW5vbSkpIHtcbiAgICAgICAgICAgIHZhbCAvPSBqO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICByZXR1cm4gUlNTVXRpbHM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUlNTVXRpbHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BitArray_1 = __webpack_require__(/*! ../../../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar BitArrayBuilder = /** @class */ (function () {\n    function BitArrayBuilder() {\n    }\n    BitArrayBuilder.buildBitArray = function (pairs) {\n        var charNumber = pairs.length * 2 - 1;\n        if (pairs[pairs.length - 1].getRightChar() == null) {\n            charNumber -= 1;\n        }\n        var size = 12 * charNumber;\n        var binary = new BitArray_1.default(size);\n        var accPos = 0;\n        var firstPair = pairs[0];\n        var firstValue = firstPair.getRightChar().getValue();\n        for (var i = 11; i >= 0; --i) {\n            if ((firstValue & (1 << i)) !== 0) {\n                binary.set(accPos);\n            }\n            accPos++;\n        }\n        for (var i = 1; i < pairs.length; ++i) {\n            var currentPair = pairs[i];\n            var leftValue = currentPair.getLeftChar().getValue();\n            for (var j = 11; j >= 0; --j) {\n                if ((leftValue & (1 << j)) !== 0) {\n                    binary.set(accPos);\n                }\n                accPos++;\n            }\n            if (currentPair.getRightChar() !== null) {\n                var rightValue = currentPair.getRightChar().getValue();\n                for (var j = 11; j >= 0; --j) {\n                    if ((rightValue & (1 << j)) !== 0) {\n                        binary.set(accPos);\n                    }\n                    accPos++;\n                }\n            }\n        }\n        return binary;\n    };\n    return BitArrayBuilder;\n}());\nexports[\"default\"] = BitArrayBuilder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9CaXRBcnJheUJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsc0pBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvQml0QXJyYXlCdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJpdEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL0JpdEFycmF5XCIpO1xudmFyIEJpdEFycmF5QnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaXRBcnJheUJ1aWxkZXIoKSB7XG4gICAgfVxuICAgIEJpdEFycmF5QnVpbGRlci5idWlsZEJpdEFycmF5ID0gZnVuY3Rpb24gKHBhaXJzKSB7XG4gICAgICAgIHZhciBjaGFyTnVtYmVyID0gcGFpcnMubGVuZ3RoICogMiAtIDE7XG4gICAgICAgIGlmIChwYWlyc1twYWlycy5sZW5ndGggLSAxXS5nZXRSaWdodENoYXIoKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGFyTnVtYmVyIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSAxMiAqIGNoYXJOdW1iZXI7XG4gICAgICAgIHZhciBiaW5hcnkgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KHNpemUpO1xuICAgICAgICB2YXIgYWNjUG9zID0gMDtcbiAgICAgICAgdmFyIGZpcnN0UGFpciA9IHBhaXJzWzBdO1xuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGZpcnN0UGFpci5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoKGZpcnN0VmFsdWUgJiAoMSA8PCBpKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIHZhciBsZWZ0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsZWZ0VmFsdWUgJiAoMSA8PCBqKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5LnNldChhY2NQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByaWdodFZhbHVlID0gY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmlnaHRWYWx1ZSAmICgxIDw8IGopKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5LnNldChhY2NQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY1BvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluYXJ5O1xuICAgIH07XG4gICAgcmV0dXJuIEJpdEFycmF5QnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCaXRBcnJheUJ1aWxkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ExpandedPair = /** @class */ (function () {\n    function ExpandedPair(leftChar, rightChar, finderPatter, mayBeLast) {\n        this.leftchar = leftChar;\n        this.rightchar = rightChar;\n        this.finderpattern = finderPatter;\n        this.maybeLast = mayBeLast;\n    }\n    ExpandedPair.prototype.mayBeLast = function () {\n        return this.maybeLast;\n    };\n    ExpandedPair.prototype.getLeftChar = function () {\n        return this.leftchar;\n    };\n    ExpandedPair.prototype.getRightChar = function () {\n        return this.rightchar;\n    };\n    ExpandedPair.prototype.getFinderPattern = function () {\n        return this.finderpattern;\n    };\n    ExpandedPair.prototype.mustBeLast = function () {\n        return this.rightchar == null;\n    };\n    ExpandedPair.prototype.toString = function () {\n        return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) + ' ]';\n    };\n    ExpandedPair.equals = function (o1, o2) {\n        if (!(o1 instanceof ExpandedPair)) {\n            return false;\n        }\n        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&\n            ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&\n            ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);\n    };\n    ExpandedPair.equalsOrNull = function (o1, o2) {\n        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);\n    };\n    ExpandedPair.prototype.hashCode = function () {\n        // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);\n        var value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();\n        return value;\n    };\n    return ExpandedPair;\n}());\nexports[\"default\"] = ExpandedPair;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9FeHBhbmRlZFBhaXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL0V4cGFuZGVkUGFpci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeHBhbmRlZFBhaXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5kZWRQYWlyKGxlZnRDaGFyLCByaWdodENoYXIsIGZpbmRlclBhdHRlciwgbWF5QmVMYXN0KSB7XG4gICAgICAgIHRoaXMubGVmdGNoYXIgPSBsZWZ0Q2hhcjtcbiAgICAgICAgdGhpcy5yaWdodGNoYXIgPSByaWdodENoYXI7XG4gICAgICAgIHRoaXMuZmluZGVycGF0dGVybiA9IGZpbmRlclBhdHRlcjtcbiAgICAgICAgdGhpcy5tYXliZUxhc3QgPSBtYXlCZUxhc3Q7XG4gICAgfVxuICAgIEV4cGFuZGVkUGFpci5wcm90b3R5cGUubWF5QmVMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXliZUxhc3Q7XG4gICAgfTtcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLmdldExlZnRDaGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Y2hhcjtcbiAgICB9O1xuICAgIEV4cGFuZGVkUGFpci5wcm90b3R5cGUuZ2V0UmlnaHRDaGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodGNoYXI7XG4gICAgfTtcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLmdldEZpbmRlclBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRlcnBhdHRlcm47XG4gICAgfTtcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLm11c3RCZUxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Y2hhciA9PSBudWxsO1xuICAgIH07XG4gICAgRXhwYW5kZWRQYWlyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdbICcgKyB0aGlzLmxlZnRjaGFyICsgJywgJyArIHRoaXMucmlnaHRjaGFyICsgJyA6ICcgKyAodGhpcy5maW5kZXJwYXR0ZXJuID09IG51bGwgPyAnbnVsbCcgOiB0aGlzLmZpbmRlcnBhdHRlcm4uZ2V0VmFsdWUoKSkgKyAnIF0nO1xuICAgIH07XG4gICAgRXhwYW5kZWRQYWlyLmVxdWFscyA9IGZ1bmN0aW9uIChvMSwgbzIpIHtcbiAgICAgICAgaWYgKCEobzEgaW5zdGFuY2VvZiBFeHBhbmRlZFBhaXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEubGVmdGNoYXIsIG8yLmxlZnRjaGFyKSAmJlxuICAgICAgICAgICAgRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5yaWdodGNoYXIsIG8yLnJpZ2h0Y2hhcikgJiZcbiAgICAgICAgICAgIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEuZmluZGVycGF0dGVybiwgbzIuZmluZGVycGF0dGVybik7XG4gICAgfTtcbiAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsID0gZnVuY3Rpb24gKG8xLCBvMikge1xuICAgICAgICByZXR1cm4gbzEgPT09IG51bGwgPyBvMiA9PT0gbnVsbCA6IEV4cGFuZGVkUGFpci5lcXVhbHMobzEsIG8yKTtcbiAgICB9O1xuICAgIEV4cGFuZGVkUGFpci5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiBFeHBhbmRlZFBhaXIuaGFzaE5vdE51bGwobGVmdENoYXIpIF4gaGFzaE5vdE51bGwocmlnaHRDaGFyKSBeIGhhc2hOb3ROdWxsKGZpbmRlclBhdHRlcm4pO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxlZnRjaGFyLmdldFZhbHVlKCkgXiB0aGlzLnJpZ2h0Y2hhci5nZXRWYWx1ZSgpIF4gdGhpcy5maW5kZXJwYXR0ZXJuLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRlZFBhaXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXhwYW5kZWRQYWlyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ExpandedRow = /** @class */ (function () {\n    function ExpandedRow(pairs, rowNumber, wasReversed) {\n        this.pairs = pairs;\n        this.rowNumber = rowNumber;\n        this.wasReversed = wasReversed;\n    }\n    ExpandedRow.prototype.getPairs = function () {\n        return this.pairs;\n    };\n    ExpandedRow.prototype.getRowNumber = function () {\n        return this.rowNumber;\n    };\n    ExpandedRow.prototype.isReversed = function () {\n        return this.wasReversed;\n    };\n    // check implementation\n    ExpandedRow.prototype.isEquivalent = function (otherPairs) {\n        return this.checkEqualitity(this, otherPairs);\n    };\n    // @Override\n    ExpandedRow.prototype.toString = function () {\n        return '{ ' + this.pairs + ' }';\n    };\n    /**\n     * Two rows are equal if they contain the same pairs in the same order.\n     */\n    // @Override\n    // check implementation\n    ExpandedRow.prototype.equals = function (o1, o2) {\n        if (!(o1 instanceof ExpandedRow)) {\n            return false;\n        }\n        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;\n    };\n    ExpandedRow.prototype.checkEqualitity = function (pair1, pair2) {\n        if (!pair1 || !pair2)\n            return;\n        var result;\n        pair1.forEach(function (e1, i) {\n            pair2.forEach(function (e2) {\n                if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {\n                    result = true;\n                }\n            });\n        });\n        return result;\n    };\n    return ExpandedRow;\n}());\nexports[\"default\"] = ExpandedRow;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9FeHBhbmRlZFJvdy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL0V4cGFuZGVkUm93LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV4cGFuZGVkUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cGFuZGVkUm93KHBhaXJzLCByb3dOdW1iZXIsIHdhc1JldmVyc2VkKSB7XG4gICAgICAgIHRoaXMucGFpcnMgPSBwYWlycztcbiAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgICAgIHRoaXMud2FzUmV2ZXJzZWQgPSB3YXNSZXZlcnNlZDtcbiAgICB9XG4gICAgRXhwYW5kZWRSb3cucHJvdG90eXBlLmdldFBhaXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcbiAgICB9O1xuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS5nZXRSb3dOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlcjtcbiAgICB9O1xuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS5pc1JldmVyc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YXNSZXZlcnNlZDtcbiAgICB9O1xuICAgIC8vIGNoZWNrIGltcGxlbWVudGF0aW9uXG4gICAgRXhwYW5kZWRSb3cucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChvdGhlclBhaXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXF1YWxpdGl0eSh0aGlzLCBvdGhlclBhaXJzKTtcbiAgICB9O1xuICAgIC8vIEBPdmVycmlkZVxuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICd7ICcgKyB0aGlzLnBhaXJzICsgJyB9JztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR3byByb3dzIGFyZSBlcXVhbCBpZiB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgcGFpcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICovXG4gICAgLy8gQE92ZXJyaWRlXG4gICAgLy8gY2hlY2sgaW1wbGVtZW50YXRpb25cbiAgICBFeHBhbmRlZFJvdy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8xLCBvMikge1xuICAgICAgICBpZiAoIShvMSBpbnN0YW5jZW9mIEV4cGFuZGVkUm93KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXF1YWxpdGl0eShvMSwgbzIpICYmIG8xLndhc1JldmVyc2VkID09PSBvMi53YXNSZXZlcnNlZDtcbiAgICB9O1xuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS5jaGVja0VxdWFsaXRpdHkgPSBmdW5jdGlvbiAocGFpcjEsIHBhaXIyKSB7XG4gICAgICAgIGlmICghcGFpcjEgfHwgIXBhaXIyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBwYWlyMS5mb3JFYWNoKGZ1bmN0aW9uIChlMSwgaSkge1xuICAgICAgICAgICAgcGFpcjIuZm9yRWFjaChmdW5jdGlvbiAoZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZTEuZ2V0TGVmdENoYXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCkgJiYgZTEuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKSAmJiBlMS5nZXRGaW5kZXJQYXR0ZXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRGaW5kZXJQYXR0ZXIoKS5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEV4cGFuZGVkUm93O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEV4cGFuZGVkUm93O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js ***!
  \*******************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BarcodeFormat_1 = __webpack_require__(/*! ../../../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar MathUtils_1 = __webpack_require__(/*! ../../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\n// import FormatException from '../../../FormatException';\nvar NotFoundException_1 = __webpack_require__(/*! ../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar Result_1 = __webpack_require__(/*! ../../../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar System_1 = __webpack_require__(/*! ../../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar AbstractRSSReader_1 = __webpack_require__(/*! ../../rss/AbstractRSSReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js\");\nvar DataCharacter_1 = __webpack_require__(/*! ../../rss/DataCharacter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js\");\nvar FinderPattern_1 = __webpack_require__(/*! ../../rss/FinderPattern */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js\");\nvar RSSUtils_1 = __webpack_require__(/*! ../../rss/RSSUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js\");\nvar BitArrayBuilder_1 = __webpack_require__(/*! ./BitArrayBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js\");\nvar AbstractExpandedDecoderComplement_1 = __webpack_require__(/*! ./decoders/AbstractExpandedDecoderComplement */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js\");\nvar ExpandedPair_1 = __webpack_require__(/*! ./ExpandedPair */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js\");\nvar ExpandedRow_1 = __webpack_require__(/*! ./ExpandedRow */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js\");\n// import java.util.ArrayList;\n// import java.util.Iterator;\n// import java.util.List;\n// import java.util.Map;\n// import java.util.Collections;\n/** @experimental */\nvar RSSExpandedReader = /** @class */ (function (_super) {\n    __extends(RSSExpandedReader, _super);\n    function RSSExpandedReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);\n        _this.rows = new Array();\n        _this.startEnd = [2];\n        return _this;\n    }\n    RSSExpandedReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        // Rows can start with even pattern in case in prev rows there where odd number of patters.\n        // So lets try twice\n        // this.pairs.clear();\n        this.pairs.length = 0;\n        this.startFromEven = false;\n        try {\n            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n        }\n        catch (e) {\n            // OK\n            // console.log(e);\n        }\n        this.pairs.length = 0;\n        this.startFromEven = true;\n        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n    };\n    RSSExpandedReader.prototype.reset = function () {\n        this.pairs.length = 0;\n        this.rows.length = 0;\n    };\n    // Not private for testing\n    RSSExpandedReader.prototype.decodeRow2pairs = function (rowNumber, row) {\n        var done = false;\n        while (!done) {\n            try {\n                this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));\n            }\n            catch (error) {\n                if (error instanceof NotFoundException_1.default) {\n                    if (!this.pairs.length) {\n                        throw new NotFoundException_1.default();\n                    }\n                    // exit this loop when retrieveNextPair() fails and throws\n                    done = true;\n                }\n            }\n        }\n        // TODO: verify sequence of finder patterns as in checkPairSequence()\n        if (this.checkChecksum()) {\n            return this.pairs;\n        }\n        var tryStackedDecode;\n        if (this.rows.length) {\n            tryStackedDecode = true;\n        }\n        else {\n            tryStackedDecode = false;\n        }\n        // let tryStackedDecode = !this.rows.isEmpty();\n        this.storeRow(rowNumber, false); // TODO: deal with reversed rows\n        if (tryStackedDecode) {\n            // When the image is 180-rotated, then rows are sorted in wrong direction.\n            // Try twice with both the directions.\n            var ps = this.checkRowsBoolean(false);\n            if (ps != null) {\n                return ps;\n            }\n            ps = this.checkRowsBoolean(true);\n            if (ps != null) {\n                return ps;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    // Need to Verify\n    RSSExpandedReader.prototype.checkRowsBoolean = function (reverse) {\n        // Limit number of rows we are checking\n        // We use recursive algorithm with pure complexity and don't want it to take forever\n        // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough\n        if (this.rows.length > 25) {\n            this.rows.length = 0; // We will never have a chance to get result, so clear it\n            return null;\n        }\n        this.pairs.length = 0;\n        if (reverse) {\n            this.rows = this.rows.reverse();\n            // Collections.reverse(this.rows);\n        }\n        var ps = null;\n        try {\n            ps = this.checkRows(new Array(), 0);\n        }\n        catch (e) {\n            // OK\n            console.log(e);\n        }\n        if (reverse) {\n            this.rows = this.rows.reverse();\n            // Collections.reverse(this.rows);\n        }\n        return ps;\n    };\n    // Try to construct a valid rows sequence\n    // Recursion is used to implement backtracking\n    RSSExpandedReader.prototype.checkRows = function (collectedRows, currentRow) {\n        var e_1, _a;\n        for (var i = currentRow; i < this.rows.length; i++) {\n            var row = this.rows[i];\n            this.pairs.length = 0;\n            try {\n                for (var collectedRows_1 = (e_1 = void 0, __values(collectedRows)), collectedRows_1_1 = collectedRows_1.next(); !collectedRows_1_1.done; collectedRows_1_1 = collectedRows_1.next()) {\n                    var collectedRow = collectedRows_1_1.value;\n                    this.pairs.push(collectedRow.getPairs());\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (collectedRows_1_1 && !collectedRows_1_1.done && (_a = collectedRows_1.return)) _a.call(collectedRows_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.pairs.push(row.getPairs());\n            if (!RSSExpandedReader.isValidSequence(this.pairs)) {\n                continue;\n            }\n            if (this.checkChecksum()) {\n                return this.pairs;\n            }\n            var rs = new Array(collectedRows);\n            rs.push(row);\n            try {\n                // Recursion: try to add more rows\n                return this.checkRows(rs, i + 1);\n            }\n            catch (e) {\n                // We failed, try the next candidate\n                console.log(e);\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    // Whether the pairs form a valid find pattern sequence,\n    // either complete or a prefix\n    RSSExpandedReader.isValidSequence = function (pairs) {\n        var e_2, _a;\n        try {\n            for (var _b = __values(RSSExpandedReader.FINDER_PATTERN_SEQUENCES), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var sequence = _c.value;\n                if (pairs.length > sequence.length) {\n                    continue;\n                }\n                var stop_1 = true;\n                for (var j = 0; j < pairs.length; j++) {\n                    if (pairs[j].getFinderPattern().getValue() !== sequence[j]) {\n                        stop_1 = false;\n                        break;\n                    }\n                }\n                if (stop_1) {\n                    return true;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return false;\n    };\n    RSSExpandedReader.prototype.storeRow = function (rowNumber, wasReversed) {\n        // Discard if duplicate above or below; otherwise insert in order by row number.\n        var insertPos = 0;\n        var prevIsSame = false;\n        var nextIsSame = false;\n        while (insertPos < this.rows.length) {\n            var erow = this.rows[insertPos];\n            if (erow.getRowNumber() > rowNumber) {\n                nextIsSame = erow.isEquivalent(this.pairs);\n                break;\n            }\n            prevIsSame = erow.isEquivalent(this.pairs);\n            insertPos++;\n        }\n        if (nextIsSame || prevIsSame) {\n            return;\n        }\n        // When the row was partially decoded (e.g. 2 pairs found instead of 3),\n        // it will prevent us from detecting the barcode.\n        // Try to merge partial rows\n        // Check whether the row is part of an allready detected row\n        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {\n            return;\n        }\n        this.rows.push(insertPos, new ExpandedRow_1.default(this.pairs, rowNumber, wasReversed));\n        this.removePartialRows(this.pairs, this.rows);\n    };\n    // Remove all the rows that contains only specified pairs\n    RSSExpandedReader.prototype.removePartialRows = function (pairs, rows) {\n        var e_3, _a, e_4, _b, e_5, _c;\n        try {\n            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {\n            //   ExpandedRow r = iterator.next();\n            //   if (r.getPairs().size() == pairs.size()) {\n            //     continue;\n            //   }\n            //   boolean allFound = true;\n            //   for (ExpandedPair p : r.getPairs()) {\n            //     boolean found = false;\n            //     for (ExpandedPair pp : pairs) {\n            //       if (p.equals(pp)) {\n            //         found = true;\n            //         break;\n            //       }\n            //     }\n            //     if (!found) {\n            //       allFound = false;\n            //       break;\n            //     }\n            //   }\n            //   if (allFound) {\n            //     // 'pairs' contains all the pairs from the row 'r'\n            //     iterator.remove();\n            //   }\n            // }\n            for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {\n                var row = rows_1_1.value;\n                if (row.getPairs().length === pairs.length) {\n                    continue;\n                }\n                var allFound = true;\n                try {\n                    for (var _d = (e_4 = void 0, __values(row.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var p = _e.value;\n                        var found = false;\n                        try {\n                            for (var pairs_1 = (e_5 = void 0, __values(pairs)), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {\n                                var pp = pairs_1_1.value;\n                                if (ExpandedPair_1.default.equals(p, pp)) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                        finally {\n                            try {\n                                if (pairs_1_1 && !pairs_1_1.done && (_c = pairs_1.return)) _c.call(pairs_1);\n                            }\n                            finally { if (e_5) throw e_5.error; }\n                        }\n                        if (!found) {\n                            allFound = false;\n                        }\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    };\n    // Returns true when one of the rows already contains all the pairs\n    RSSExpandedReader.isPartialRow = function (pairs, rows) {\n        var e_6, _a, e_7, _b, e_8, _c;\n        try {\n            for (var rows_2 = __values(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {\n                var r = rows_2_1.value;\n                var allFound = true;\n                try {\n                    for (var pairs_2 = (e_7 = void 0, __values(pairs)), pairs_2_1 = pairs_2.next(); !pairs_2_1.done; pairs_2_1 = pairs_2.next()) {\n                        var p = pairs_2_1.value;\n                        var found = false;\n                        try {\n                            for (var _d = (e_8 = void 0, __values(r.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {\n                                var pp = _e.value;\n                                if (p.equals(pp)) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n                        finally {\n                            try {\n                                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n                            }\n                            finally { if (e_8) throw e_8.error; }\n                        }\n                        if (!found) {\n                            allFound = false;\n                            break;\n                        }\n                    }\n                }\n                catch (e_7_1) { e_7 = { error: e_7_1 }; }\n                finally {\n                    try {\n                        if (pairs_2_1 && !pairs_2_1.done && (_b = pairs_2.return)) _b.call(pairs_2);\n                    }\n                    finally { if (e_7) throw e_7.error; }\n                }\n                if (allFound) {\n                    // the row 'r' contain all the pairs from 'pairs'\n                    return true;\n                }\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (rows_2_1 && !rows_2_1.done && (_a = rows_2.return)) _a.call(rows_2);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        return false;\n    };\n    // Only used for unit testing\n    RSSExpandedReader.prototype.getRows = function () {\n        return this.rows;\n    };\n    // Not private for unit testing\n    RSSExpandedReader.constructResult = function (pairs) {\n        var binary = BitArrayBuilder_1.default.buildBitArray(pairs);\n        var decoder = AbstractExpandedDecoderComplement_1.createDecoder(binary);\n        var resultingString = decoder.parseInformation();\n        var firstPoints = pairs[0].getFinderPattern().getResultPoints();\n        var lastPoints = pairs[pairs.length - 1]\n            .getFinderPattern()\n            .getResultPoints();\n        var points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];\n        return new Result_1.default(resultingString, null, null, points, BarcodeFormat_1.default.RSS_EXPANDED, null);\n    };\n    RSSExpandedReader.prototype.checkChecksum = function () {\n        var firstPair = this.pairs.get(0);\n        var checkCharacter = firstPair.getLeftChar();\n        var firstCharacter = firstPair.getRightChar();\n        if (firstCharacter === null) {\n            return false;\n        }\n        var checksum = firstCharacter.getChecksumPortion();\n        var s = 2;\n        for (var i = 1; i < this.pairs.size(); ++i) {\n            var currentPair = this.pairs.get(i);\n            checksum += currentPair.getLeftChar().getChecksumPortion();\n            s++;\n            var currentRightChar = currentPair.getRightChar();\n            if (currentRightChar != null) {\n                checksum += currentRightChar.getChecksumPortion();\n                s++;\n            }\n        }\n        checksum %= 211;\n        var checkCharacterValue = 211 * (s - 4) + checksum;\n        return checkCharacterValue === checkCharacter.getValue();\n    };\n    RSSExpandedReader.getNextSecondBar = function (row, initialPos) {\n        var currentPos;\n        if (row.get(initialPos)) {\n            currentPos = row.getNextUnset(initialPos);\n            currentPos = row.getNextSet(currentPos);\n        }\n        else {\n            currentPos = row.getNextSet(initialPos);\n            currentPos = row.getNextUnset(currentPos);\n        }\n        return currentPos;\n    };\n    // not private for testing\n    RSSExpandedReader.prototype.retrieveNextPair = function (row, previousPairs, rowNumber) {\n        var isOddPattern = previousPairs.length % 2 === 0;\n        if (this.startFromEven) {\n            isOddPattern = !isOddPattern;\n        }\n        var pattern;\n        var keepFinding = true;\n        var forcedOffset = -1;\n        do {\n            this.findNextPair(row, previousPairs, forcedOffset);\n            pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);\n            if (pattern === null) {\n                forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);\n            }\n            else {\n                keepFinding = false;\n            }\n        } while (keepFinding);\n        // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.\n        // boolean mayBeLast = checkPairSequence(previousPairs, pattern);\n        var leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);\n        if (!this.isEmptyPair(previousPairs) &&\n            previousPairs[previousPairs.length - 1].mustBeLast()) {\n            throw new NotFoundException_1.default();\n        }\n        var rightChar;\n        try {\n            rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);\n        }\n        catch (e) {\n            rightChar = null;\n            console.log(e);\n        }\n        return new ExpandedPair_1.default(leftChar, rightChar, pattern, true);\n    };\n    RSSExpandedReader.prototype.isEmptyPair = function (pairs) {\n        if (pairs.length === 0) {\n            return true;\n        }\n        return false;\n    };\n    RSSExpandedReader.prototype.findNextPair = function (row, previousPairs, forcedOffset) {\n        var counters = this.getDecodeFinderCounters();\n        counters[0] = 0;\n        counters[1] = 0;\n        counters[2] = 0;\n        counters[3] = 0;\n        var width = row.getSize();\n        var rowOffset;\n        if (forcedOffset >= 0) {\n            rowOffset = forcedOffset;\n        }\n        else if (this.isEmptyPair(previousPairs)) {\n            rowOffset = 0;\n        }\n        else {\n            var lastPair = previousPairs[previousPairs.length - 1];\n            rowOffset = lastPair.getFinderPattern().getStartEnd()[1];\n        }\n        var searchingEvenPair = previousPairs.length % 2 !== 0;\n        if (this.startFromEven) {\n            searchingEvenPair = !searchingEvenPair;\n        }\n        var isWhite = false;\n        while (rowOffset < width) {\n            isWhite = !row.get(rowOffset);\n            if (!isWhite) {\n                break;\n            }\n            rowOffset++;\n        }\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === 3) {\n                    if (searchingEvenPair) {\n                        RSSExpandedReader.reverseCounters(counters);\n                    }\n                    if (RSSExpandedReader.isFinderPattern(counters)) {\n                        this.startEnd[0] = patternStart;\n                        this.startEnd[1] = x;\n                        return;\n                    }\n                    if (searchingEvenPair) {\n                        RSSExpandedReader.reverseCounters(counters);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters[0] = counters[2];\n                    counters[1] = counters[3];\n                    counters[2] = 0;\n                    counters[3] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    RSSExpandedReader.reverseCounters = function (counters) {\n        var length = counters.length;\n        for (var i = 0; i < length / 2; ++i) {\n            var tmp = counters[i];\n            counters[i] = counters[length - i - 1];\n            counters[length - i - 1] = tmp;\n        }\n    };\n    RSSExpandedReader.prototype.parseFoundFinderPattern = function (row, rowNumber, oddPattern) {\n        // Actually we found elements 2-5.\n        var firstCounter;\n        var start;\n        var end;\n        if (oddPattern) {\n            // If pattern number is odd, we need to locate element 1 *before* the current block.\n            var firstElementStart = this.startEnd[0] - 1;\n            // Locate element 1\n            while (firstElementStart >= 0 && !row.get(firstElementStart)) {\n                firstElementStart--;\n            }\n            firstElementStart++;\n            firstCounter = this.startEnd[0] - firstElementStart;\n            start = firstElementStart;\n            end = this.startEnd[1];\n        }\n        else {\n            // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.\n            start = this.startEnd[0];\n            end = row.getNextUnset(this.startEnd[1] + 1);\n            firstCounter = end - this.startEnd[1];\n        }\n        // Make 'counters' hold 1-4\n        var counters = this.getDecodeFinderCounters();\n        System_1.default.arraycopy(counters, 0, counters, 1, counters.length - 1);\n        counters[0] = firstCounter;\n        var value;\n        try {\n            value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);\n        }\n        catch (e) {\n            return null;\n        }\n        // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});\n        return new FinderPattern_1.default(value, [start, end], start, end, rowNumber);\n    };\n    RSSExpandedReader.prototype.decodeDataCharacter = function (row, pattern, isOddPattern, leftChar) {\n        var counters = this.getDataCharacterCounters();\n        for (var x = 0; x < counters.length; x++) {\n            counters[x] = 0;\n        }\n        if (leftChar) {\n            RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n        }\n        else {\n            RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);\n            // reverse it\n            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {\n                var temp = counters[i];\n                counters[i] = counters[j];\n                counters[j] = temp;\n            }\n        } // counters[] has the pixels of the module\n        var numModules = 17; // left and right data characters have all the same length\n        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;\n        // Sanity check: element width for pattern and the character should match\n        var expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;\n        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth >\n            0.3) {\n            throw new NotFoundException_1.default();\n        }\n        var oddCounts = this.getOddCounts();\n        var evenCounts = this.getEvenCounts();\n        var oddRoundingErrors = this.getOddRoundingErrors();\n        var evenRoundingErrors = this.getEvenRoundingErrors();\n        for (var i = 0; i < counters.length; i++) {\n            var value_1 = (1.0 * counters[i]) / elementWidth;\n            var count = value_1 + 0.5; // Round\n            if (count < 1) {\n                if (value_1 < 0.3) {\n                    throw new NotFoundException_1.default();\n                }\n                count = 1;\n            }\n            else if (count > 8) {\n                if (value_1 > 8.7) {\n                    throw new NotFoundException_1.default();\n                }\n                count = 8;\n            }\n            var offset = i / 2;\n            if ((i & 0x01) === 0) {\n                oddCounts[offset] = count;\n                oddRoundingErrors[offset] = value_1 - count;\n            }\n            else {\n                evenCounts[offset] = count;\n                evenRoundingErrors[offset] = value_1 - count;\n            }\n        }\n        this.adjustOddEvenCounts(numModules);\n        var weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;\n        var oddSum = 0;\n        var oddChecksumPortion = 0;\n        for (var i = oddCounts.length - 1; i >= 0; i--) {\n            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];\n                oddChecksumPortion += oddCounts[i] * weight;\n            }\n            oddSum += oddCounts[i];\n        }\n        var evenChecksumPortion = 0;\n        // int evenSum = 0;\n        for (var i = evenCounts.length - 1; i >= 0; i--) {\n            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];\n                evenChecksumPortion += evenCounts[i] * weight;\n            }\n            // evenSum += evenCounts[i];\n        }\n        var checksumPortion = oddChecksumPortion + evenChecksumPortion;\n        if ((oddSum & 0x01) !== 0 || oddSum > 13 || oddSum < 4) {\n            throw new NotFoundException_1.default();\n        }\n        var group = (13 - oddSum) / 2;\n        var oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];\n        var evenWidest = 9 - oddWidest;\n        var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);\n        var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);\n        var tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];\n        var gSum = RSSExpandedReader.GSUM[group];\n        var value = vOdd * tEven + vEven + gSum;\n        return new DataCharacter_1.default(value, checksumPortion);\n    };\n    RSSExpandedReader.isNotA1left = function (pattern, isOddPattern, leftChar) {\n        // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char\n        return !(pattern.getValue() === 0 && isOddPattern && leftChar);\n    };\n    RSSExpandedReader.prototype.adjustOddEvenCounts = function (numModules) {\n        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));\n        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));\n        var incrementOdd = false;\n        var decrementOdd = false;\n        if (oddSum > 13) {\n            decrementOdd = true;\n        }\n        else if (oddSum < 4) {\n            incrementOdd = true;\n        }\n        var incrementEven = false;\n        var decrementEven = false;\n        if (evenSum > 13) {\n            decrementEven = true;\n        }\n        else if (evenSum < 4) {\n            incrementEven = true;\n        }\n        var mismatch = oddSum + evenSum - numModules;\n        var oddParityBad = (oddSum & 0x01) === 1;\n        var evenParityBad = (evenSum & 0x01) === 0;\n        if (mismatch === 1) {\n            if (oddParityBad) {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                decrementOdd = true;\n            }\n            else {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                decrementEven = true;\n            }\n        }\n        else if (mismatch === -1) {\n            if (oddParityBad) {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                incrementOdd = true;\n            }\n            else {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                incrementEven = true;\n            }\n        }\n        else if (mismatch === 0) {\n            if (oddParityBad) {\n                if (!evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                // Both bad\n                if (oddSum < evenSum) {\n                    incrementOdd = true;\n                    decrementEven = true;\n                }\n                else {\n                    decrementOdd = true;\n                    incrementEven = true;\n                }\n            }\n            else {\n                if (evenParityBad) {\n                    throw new NotFoundException_1.default();\n                }\n                // Nothing to do!\n            }\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n        if (incrementOdd) {\n            if (decrementOdd) {\n                throw new NotFoundException_1.default();\n            }\n            RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n        }\n        if (decrementOdd) {\n            RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n        }\n        if (incrementEven) {\n            if (decrementEven) {\n                throw new NotFoundException_1.default();\n            }\n            RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n        }\n        if (decrementEven) {\n            RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n        }\n    };\n    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];\n    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];\n    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];\n    RSSExpandedReader.FINDER_PATTERNS = [\n        Int32Array.from([1, 8, 4, 1]),\n        Int32Array.from([3, 6, 4, 1]),\n        Int32Array.from([3, 4, 6, 1]),\n        Int32Array.from([3, 2, 8, 1]),\n        Int32Array.from([2, 6, 5, 1]),\n        Int32Array.from([2, 2, 9, 1]),\n    ];\n    RSSExpandedReader.WEIGHTS = [\n        [1, 3, 9, 27, 81, 32, 96, 77],\n        [20, 60, 180, 118, 143, 7, 21, 63],\n        [189, 145, 13, 39, 117, 140, 209, 205],\n        [193, 157, 49, 147, 19, 57, 171, 91],\n        [62, 186, 136, 197, 169, 85, 44, 132],\n        [185, 133, 188, 142, 4, 12, 36, 108],\n        [113, 128, 173, 97, 80, 29, 87, 50],\n        [150, 28, 84, 41, 123, 158, 52, 156],\n        [46, 138, 203, 187, 139, 206, 196, 166],\n        [76, 17, 51, 153, 37, 111, 122, 155],\n        [43, 129, 176, 106, 107, 110, 119, 146],\n        [16, 48, 144, 10, 30, 90, 59, 177],\n        [109, 116, 137, 200, 178, 112, 125, 164],\n        [70, 210, 208, 202, 184, 130, 179, 115],\n        [134, 191, 151, 31, 93, 68, 204, 190],\n        [148, 22, 66, 198, 172, 94, 71, 2],\n        [6, 18, 54, 162, 64, 192, 154, 40],\n        [120, 149, 25, 75, 14, 42, 126, 167],\n        [79, 26, 78, 23, 69, 207, 199, 175],\n        [103, 98, 83, 38, 114, 131, 182, 124],\n        [161, 61, 183, 127, 170, 88, 53, 159],\n        [55, 165, 73, 8, 24, 72, 5, 15],\n        [45, 135, 194, 160, 58, 174, 100, 89],\n    ];\n    RSSExpandedReader.FINDER_PAT_A = 0;\n    RSSExpandedReader.FINDER_PAT_B = 1;\n    RSSExpandedReader.FINDER_PAT_C = 2;\n    RSSExpandedReader.FINDER_PAT_D = 3;\n    RSSExpandedReader.FINDER_PAT_E = 4;\n    RSSExpandedReader.FINDER_PAT_F = 5;\n    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_C,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_F,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_E,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F,\n        ],\n        [\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_A,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_B,\n            RSSExpandedReader.FINDER_PAT_C,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_D,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_E,\n            RSSExpandedReader.FINDER_PAT_F,\n            RSSExpandedReader.FINDER_PAT_F,\n        ],\n    ];\n    RSSExpandedReader.MAX_PAIRS = 11;\n    return RSSExpandedReader;\n}(AbstractRSSReader_1.default));\nexports[\"default\"] = RSSExpandedReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9SU1NFeHBhbmRlZFJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLGtKQUF3QjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQywwS0FBb0M7QUFDOUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywwSkFBNEI7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLG9JQUFpQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsOElBQXNCO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG9LQUE2QjtBQUMvRCxzQkFBc0IsbUJBQU8sQ0FBQyw0SkFBeUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsNEpBQXlCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGtKQUFvQjtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQyxpS0FBbUI7QUFDbkQsMENBQTBDLG1CQUFPLENBQUMsdU5BQThDO0FBQ2hHLHFCQUFxQixtQkFBTyxDQUFDLDJKQUFnQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSx5QkFBeUI7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLFVBQVU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1CQUFtQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGdCQUFnQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsaUJBQWlCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGdCQUFnQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxVQUFVO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWSx3QkFBd0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvUlNTRXhwYW5kZWRSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vQmFyY29kZUZvcm1hdFwiKTtcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzXCIpO1xuLy8gaW1wb3J0IEZvcm1hdEV4Y2VwdGlvbiBmcm9tICcuLi8uLi8uLi9Gb3JtYXRFeGNlcHRpb24nO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vUmVzdWx0XCIpO1xudmFyIFN5c3RlbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvU3lzdGVtXCIpO1xudmFyIEFic3RyYWN0UlNTUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcnNzL0Fic3RyYWN0UlNTUmVhZGVyXCIpO1xudmFyIERhdGFDaGFyYWN0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yc3MvRGF0YUNoYXJhY3RlclwiKTtcbnZhciBGaW5kZXJQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi4vLi4vcnNzL0ZpbmRlclBhdHRlcm5cIik7XG52YXIgUlNTVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9yc3MvUlNTVXRpbHNcIik7XG52YXIgQml0QXJyYXlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9CaXRBcnJheUJ1aWxkZXJcIik7XG52YXIgQWJzdHJhY3RFeHBhbmRlZERlY29kZXJDb21wbGVtZW50XzEgPSByZXF1aXJlKFwiLi9kZWNvZGVycy9BYnN0cmFjdEV4cGFuZGVkRGVjb2RlckNvbXBsZW1lbnRcIik7XG52YXIgRXhwYW5kZWRQYWlyXzEgPSByZXF1aXJlKFwiLi9FeHBhbmRlZFBhaXJcIik7XG52YXIgRXhwYW5kZWRSb3dfMSA9IHJlcXVpcmUoXCIuL0V4cGFuZGVkUm93XCIpO1xuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4vLyBpbXBvcnQgamF2YS51dGlsLkl0ZXJhdG9yO1xuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4vLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb25zO1xuLyoqIEBleHBlcmltZW50YWwgKi9cbnZhciBSU1NFeHBhbmRlZFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUlNTRXhwYW5kZWRSZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUlNTRXhwYW5kZWRSZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYWlycyA9IG5ldyBBcnJheShSU1NFeHBhbmRlZFJlYWRlci5NQVhfUEFJUlMpO1xuICAgICAgICBfdGhpcy5yb3dzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIF90aGlzLnN0YXJ0RW5kID0gWzJdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgIC8vIFJvd3MgY2FuIHN0YXJ0IHdpdGggZXZlbiBwYXR0ZXJuIGluIGNhc2UgaW4gcHJldiByb3dzIHRoZXJlIHdoZXJlIG9kZCBudW1iZXIgb2YgcGF0dGVycy5cbiAgICAgICAgLy8gU28gbGV0cyB0cnkgdHdpY2VcbiAgICAgICAgLy8gdGhpcy5wYWlycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRGcm9tRXZlbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFJTU0V4cGFuZGVkUmVhZGVyLmNvbnN0cnVjdFJlc3VsdCh0aGlzLmRlY29kZVJvdzJwYWlycyhyb3dOdW1iZXIsIHJvdykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBPS1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0RnJvbUV2ZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gUlNTRXhwYW5kZWRSZWFkZXIuY29uc3RydWN0UmVzdWx0KHRoaXMuZGVjb2RlUm93MnBhaXJzKHJvd051bWJlciwgcm93KSk7XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5yb3dzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cycGFpcnMgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3cpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaCh0aGlzLnJldHJpZXZlTmV4dFBhaXIocm93LCB0aGlzLnBhaXJzLCByb3dOdW1iZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpdCB0aGlzIGxvb3Agd2hlbiByZXRyaWV2ZU5leHRQYWlyKCkgZmFpbHMgYW5kIHRocm93c1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdmVyaWZ5IHNlcXVlbmNlIG9mIGZpbmRlciBwYXR0ZXJucyBhcyBpbiBjaGVja1BhaXJTZXF1ZW5jZSgpXG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyeVN0YWNrZWREZWNvZGU7XG4gICAgICAgIGlmICh0aGlzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cnlTdGFja2VkRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeVN0YWNrZWREZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZXQgdHJ5U3RhY2tlZERlY29kZSA9ICF0aGlzLnJvd3MuaXNFbXB0eSgpO1xuICAgICAgICB0aGlzLnN0b3JlUm93KHJvd051bWJlciwgZmFsc2UpOyAvLyBUT0RPOiBkZWFsIHdpdGggcmV2ZXJzZWQgcm93c1xuICAgICAgICBpZiAodHJ5U3RhY2tlZERlY29kZSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaW1hZ2UgaXMgMTgwLXJvdGF0ZWQsIHRoZW4gcm93cyBhcmUgc29ydGVkIGluIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vIFRyeSB0d2ljZSB3aXRoIGJvdGggdGhlIGRpcmVjdGlvbnMuXG4gICAgICAgICAgICB2YXIgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4oZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzQm9vbGVhbih0cnVlKTtcbiAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIC8vIE5lZWQgdG8gVmVyaWZ5XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmNoZWNrUm93c0Jvb2xlYW4gPSBmdW5jdGlvbiAocmV2ZXJzZSkge1xuICAgICAgICAvLyBMaW1pdCBudW1iZXIgb2Ygcm93cyB3ZSBhcmUgY2hlY2tpbmdcbiAgICAgICAgLy8gV2UgdXNlIHJlY3Vyc2l2ZSBhbGdvcml0aG0gd2l0aCBwdXJlIGNvbXBsZXhpdHkgYW5kIGRvbid0IHdhbnQgaXQgdG8gdGFrZSBmb3JldmVyXG4gICAgICAgIC8vIFN0YWNrZWQgYmFyY29kZSBjYW4gaGF2ZSB1cCB0byAxMSByb3dzLCBzbyAyNSBzZWVtcyByZWFzb25hYmxlIGVub3VnaFxuICAgICAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCA+IDI1KSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MubGVuZ3RoID0gMDsgLy8gV2Ugd2lsbCBuZXZlciBoYXZlIGEgY2hhbmNlIHRvIGdldCByZXN1bHQsIHNvIGNsZWFyIGl0XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgLy8gQ29sbGVjdGlvbnMucmV2ZXJzZSh0aGlzLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzKG5ldyBBcnJheSgpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gT0tcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgLy8gQ29sbGVjdGlvbnMucmV2ZXJzZSh0aGlzLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcztcbiAgICB9O1xuICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYSB2YWxpZCByb3dzIHNlcXVlbmNlXG4gICAgLy8gUmVjdXJzaW9uIGlzIHVzZWQgdG8gaW1wbGVtZW50IGJhY2t0cmFja2luZ1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5jaGVja1Jvd3MgPSBmdW5jdGlvbiAoY29sbGVjdGVkUm93cywgY3VycmVudFJvdykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRSb3c7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbaV07XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbGxlY3RlZFJvd3NfMSA9IChlXzEgPSB2b2lkIDAsIF9fdmFsdWVzKGNvbGxlY3RlZFJvd3MpKSwgY29sbGVjdGVkUm93c18xXzEgPSBjb2xsZWN0ZWRSb3dzXzEubmV4dCgpOyAhY29sbGVjdGVkUm93c18xXzEuZG9uZTsgY29sbGVjdGVkUm93c18xXzEgPSBjb2xsZWN0ZWRSb3dzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0ZWRSb3cgPSBjb2xsZWN0ZWRSb3dzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKGNvbGxlY3RlZFJvdy5nZXRQYWlycygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZFJvd3NfMV8xICYmICFjb2xsZWN0ZWRSb3dzXzFfMS5kb25lICYmIChfYSA9IGNvbGxlY3RlZFJvd3NfMS5yZXR1cm4pKSBfYS5jYWxsKGNvbGxlY3RlZFJvd3NfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaChyb3cuZ2V0UGFpcnMoKSk7XG4gICAgICAgICAgICBpZiAoIVJTU0V4cGFuZGVkUmVhZGVyLmlzVmFsaWRTZXF1ZW5jZSh0aGlzLnBhaXJzKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDaGVja3N1bSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcnMgPSBuZXcgQXJyYXkoY29sbGVjdGVkUm93cyk7XG4gICAgICAgICAgICBycy5wdXNoKHJvdyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2lvbjogdHJ5IHRvIGFkZCBtb3JlIHJvd3NcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Jvd3MocnMsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZmFpbGVkLCB0cnkgdGhlIG5leHQgY2FuZGlkYXRlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLy8gV2hldGhlciB0aGUgcGFpcnMgZm9ybSBhIHZhbGlkIGZpbmQgcGF0dGVybiBzZXF1ZW5jZSxcbiAgICAvLyBlaXRoZXIgY29tcGxldGUgb3IgYSBwcmVmaXhcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5pc1ZhbGlkU2VxdWVuY2UgPSBmdW5jdGlvbiAocGFpcnMpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOX1NFUVVFTkNFUyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFpcnMubGVuZ3RoID4gc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RvcF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhaXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc1tqXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSAhPT0gc2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BfMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUuc3RvcmVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCB3YXNSZXZlcnNlZCkge1xuICAgICAgICAvLyBEaXNjYXJkIGlmIGR1cGxpY2F0ZSBhYm92ZSBvciBiZWxvdzsgb3RoZXJ3aXNlIGluc2VydCBpbiBvcmRlciBieSByb3cgbnVtYmVyLlxuICAgICAgICB2YXIgaW5zZXJ0UG9zID0gMDtcbiAgICAgICAgdmFyIHByZXZJc1NhbWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5leHRJc1NhbWUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGluc2VydFBvcyA8IHRoaXMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlcm93ID0gdGhpcy5yb3dzW2luc2VydFBvc107XG4gICAgICAgICAgICBpZiAoZXJvdy5nZXRSb3dOdW1iZXIoKSA+IHJvd051bWJlcikge1xuICAgICAgICAgICAgICAgIG5leHRJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZJc1NhbWUgPSBlcm93LmlzRXF1aXZhbGVudCh0aGlzLnBhaXJzKTtcbiAgICAgICAgICAgIGluc2VydFBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0SXNTYW1lIHx8IHByZXZJc1NhbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSByb3cgd2FzIHBhcnRpYWxseSBkZWNvZGVkIChlLmcuIDIgcGFpcnMgZm91bmQgaW5zdGVhZCBvZiAzKSxcbiAgICAgICAgLy8gaXQgd2lsbCBwcmV2ZW50IHVzIGZyb20gZGV0ZWN0aW5nIHRoZSBiYXJjb2RlLlxuICAgICAgICAvLyBUcnkgdG8gbWVyZ2UgcGFydGlhbCByb3dzXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJvdyBpcyBwYXJ0IG9mIGFuIGFsbHJlYWR5IGRldGVjdGVkIHJvd1xuICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNQYXJ0aWFsUm93KHRoaXMucGFpcnMsIHRoaXMucm93cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd3MucHVzaChpbnNlcnRQb3MsIG5ldyBFeHBhbmRlZFJvd18xLmRlZmF1bHQodGhpcy5wYWlycywgcm93TnVtYmVyLCB3YXNSZXZlcnNlZCkpO1xuICAgICAgICB0aGlzLnJlbW92ZVBhcnRpYWxSb3dzKHRoaXMucGFpcnMsIHRoaXMucm93cyk7XG4gICAgfTtcbiAgICAvLyBSZW1vdmUgYWxsIHRoZSByb3dzIHRoYXQgY29udGFpbnMgb25seSBzcGVjaWZpZWQgcGFpcnNcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUucmVtb3ZlUGFydGlhbFJvd3MgPSBmdW5jdGlvbiAocGFpcnMsIHJvd3MpIHtcbiAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2IsIGVfNSwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBmb3IgKEl0ZXJhdG9yPEV4cGFuZGVkUm93PiBpdGVyYXRvciA9IHJvd3MuaXRlcmF0b3IoKTsgaXRlcmF0b3IuaGFzTmV4dCgpOykge1xuICAgICAgICAgICAgLy8gICBFeHBhbmRlZFJvdyByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgLy8gICBpZiAoci5nZXRQYWlycygpLnNpemUoKSA9PSBwYWlycy5zaXplKCkpIHtcbiAgICAgICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gICBib29sZWFuIGFsbEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vICAgZm9yIChFeHBhbmRlZFBhaXIgcCA6IHIuZ2V0UGFpcnMoKSkge1xuICAgICAgICAgICAgLy8gICAgIGJvb2xlYW4gZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICBmb3IgKEV4cGFuZGVkUGFpciBwcCA6IHBhaXJzKSB7XG4gICAgICAgICAgICAvLyAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIC8vICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vICAgaWYgKGFsbEZvdW5kKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gJ3BhaXJzJyBjb250YWlucyBhbGwgdGhlIHBhaXJzIGZyb20gdGhlIHJvdyAncidcbiAgICAgICAgICAgIC8vICAgICBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgZm9yICh2YXIgcm93c18xID0gX192YWx1ZXMocm93cyksIHJvd3NfMV8xID0gcm93c18xLm5leHQoKTsgIXJvd3NfMV8xLmRvbmU7IHJvd3NfMV8xID0gcm93c18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSByb3dzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldFBhaXJzKCkubGVuZ3RoID09PSBwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAoZV80ID0gdm9pZCAwLCBfX3ZhbHVlcyhyb3cuZ2V0UGFpcnMoKSkpLCBfZSA9IF9kLm5leHQoKTsgIV9lLmRvbmU7IF9lID0gX2QubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBhaXJzXzEgPSAoZV81ID0gdm9pZCAwLCBfX3ZhbHVlcyhwYWlycykpLCBwYWlyc18xXzEgPSBwYWlyc18xLm5leHQoKTsgIXBhaXJzXzFfMS5kb25lOyBwYWlyc18xXzEgPSBwYWlyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHAgPSBwYWlyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHBhbmRlZFBhaXJfMS5kZWZhdWx0LmVxdWFscyhwLCBwcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc18xXzEgJiYgIXBhaXJzXzFfMS5kb25lICYmIChfYyA9IHBhaXJzXzEucmV0dXJuKSkgX2MuY2FsbChwYWlyc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZSAmJiAhX2UuZG9uZSAmJiAoX2IgPSBfZC5yZXR1cm4pKSBfYi5jYWxsKF9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm93c18xXzEgJiYgIXJvd3NfMV8xLmRvbmUgJiYgKF9hID0gcm93c18xLnJldHVybikpIF9hLmNhbGwocm93c18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUmV0dXJucyB0cnVlIHdoZW4gb25lIG9mIHRoZSByb3dzIGFscmVhZHkgY29udGFpbnMgYWxsIHRoZSBwYWlyc1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLmlzUGFydGlhbFJvdyA9IGZ1bmN0aW9uIChwYWlycywgcm93cykge1xuICAgICAgICB2YXIgZV82LCBfYSwgZV83LCBfYiwgZV84LCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHJvd3NfMiA9IF9fdmFsdWVzKHJvd3MpLCByb3dzXzJfMSA9IHJvd3NfMi5uZXh0KCk7ICFyb3dzXzJfMS5kb25lOyByb3dzXzJfMSA9IHJvd3NfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJvd3NfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBhbGxGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcGFpcnNfMiA9IChlXzcgPSB2b2lkIDAsIF9fdmFsdWVzKHBhaXJzKSksIHBhaXJzXzJfMSA9IHBhaXJzXzIubmV4dCgpOyAhcGFpcnNfMl8xLmRvbmU7IHBhaXJzXzJfMSA9IHBhaXJzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IChlXzggPSB2b2lkIDAsIF9fdmFsdWVzKHIuZ2V0UGFpcnMoKSkpLCBfZSA9IF9kLm5leHQoKTsgIV9lLmRvbmU7IF9lID0gX2QubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcCA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzhfMSkgeyBlXzggPSB7IGVycm9yOiBlXzhfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9jID0gX2QucmV0dXJuKSkgX2MuY2FsbChfZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV84KSB0aHJvdyBlXzguZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpcnNfMl8xICYmICFwYWlyc18yXzEuZG9uZSAmJiAoX2IgPSBwYWlyc18yLnJldHVybikpIF9iLmNhbGwocGFpcnNfMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJvdyAncicgY29udGFpbiBhbGwgdGhlIHBhaXJzIGZyb20gJ3BhaXJzJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNl8xKSB7IGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dzXzJfMSAmJiAhcm93c18yXzEuZG9uZSAmJiAoX2EgPSByb3dzXzIucmV0dXJuKSkgX2EuY2FsbChyb3dzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIE9ubHkgdXNlZCBmb3IgdW5pdCB0ZXN0aW5nXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgfTtcbiAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdW5pdCB0ZXN0aW5nXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuY29uc3RydWN0UmVzdWx0ID0gZnVuY3Rpb24gKHBhaXJzKSB7XG4gICAgICAgIHZhciBiaW5hcnkgPSBCaXRBcnJheUJ1aWxkZXJfMS5kZWZhdWx0LmJ1aWxkQml0QXJyYXkocGFpcnMpO1xuICAgICAgICB2YXIgZGVjb2RlciA9IEFic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudF8xLmNyZWF0ZURlY29kZXIoYmluYXJ5KTtcbiAgICAgICAgdmFyIHJlc3VsdGluZ1N0cmluZyA9IGRlY29kZXIucGFyc2VJbmZvcm1hdGlvbigpO1xuICAgICAgICB2YXIgZmlyc3RQb2ludHMgPSBwYWlyc1swXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgIHZhciBsYXN0UG9pbnRzID0gcGFpcnNbcGFpcnMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIC5nZXRGaW5kZXJQYXR0ZXJuKClcbiAgICAgICAgICAgIC5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtmaXJzdFBvaW50c1swXSwgZmlyc3RQb2ludHNbMV0sIGxhc3RQb2ludHNbMF0sIGxhc3RQb2ludHNbMV1dO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0aW5nU3RyaW5nLCBudWxsLCBudWxsLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlJTU19FWFBBTkRFRCwgbnVsbCk7XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUuY2hlY2tDaGVja3N1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcnN0UGFpciA9IHRoaXMucGFpcnMuZ2V0KDApO1xuICAgICAgICB2YXIgY2hlY2tDaGFyYWN0ZXIgPSBmaXJzdFBhaXIuZ2V0TGVmdENoYXIoKTtcbiAgICAgICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gZmlyc3RQYWlyLmdldFJpZ2h0Q2hhcigpO1xuICAgICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tzdW0gPSBmaXJzdENoYXJhY3Rlci5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgdmFyIHMgPSAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucGFpcnMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGFpciA9IHRoaXMucGFpcnMuZ2V0KGkpO1xuICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFBhaXIuZ2V0TGVmdENoYXIoKS5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgIHZhciBjdXJyZW50UmlnaHRDaGFyID0gY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJpZ2h0Q2hhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFJpZ2h0Q2hhci5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgICAgICBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tzdW0gJT0gMjExO1xuICAgICAgICB2YXIgY2hlY2tDaGFyYWN0ZXJWYWx1ZSA9IDIxMSAqIChzIC0gNCkgKyBjaGVja3N1bTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhcmFjdGVyVmFsdWUgPT09IGNoZWNrQ2hhcmFjdGVyLmdldFZhbHVlKCk7XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5nZXROZXh0U2Vjb25kQmFyID0gZnVuY3Rpb24gKHJvdywgaW5pdGlhbFBvcykge1xuICAgICAgICB2YXIgY3VycmVudFBvcztcbiAgICAgICAgaWYgKHJvdy5nZXQoaW5pdGlhbFBvcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGluaXRpYWxQb3MpO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGN1cnJlbnRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0U2V0KGluaXRpYWxQb3MpO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0VW5zZXQoY3VycmVudFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3M7XG4gICAgfTtcbiAgICAvLyBub3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5yZXRyaWV2ZU5leHRQYWlyID0gZnVuY3Rpb24gKHJvdywgcHJldmlvdXNQYWlycywgcm93TnVtYmVyKSB7XG4gICAgICAgIHZhciBpc09kZFBhdHRlcm4gPSBwcmV2aW91c1BhaXJzLmxlbmd0aCAlIDIgPT09IDA7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RnJvbUV2ZW4pIHtcbiAgICAgICAgICAgIGlzT2RkUGF0dGVybiA9ICFpc09kZFBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgIHZhciBrZWVwRmluZGluZyA9IHRydWU7XG4gICAgICAgIHZhciBmb3JjZWRPZmZzZXQgPSAtMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCBmb3JjZWRPZmZzZXQpO1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIGlzT2RkUGF0dGVybik7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvcmNlZE9mZnNldCA9IFJTU0V4cGFuZGVkUmVhZGVyLmdldE5leHRTZWNvbmRCYXIocm93LCB0aGlzLnN0YXJ0RW5kWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtlZXBGaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGtlZXBGaW5kaW5nKTtcbiAgICAgICAgLy8gV2hlbiBzdGFja2VkIHN5bWJvbCBpcyBzcGxpdCBvdmVyIG11bHRpcGxlIHJvd3MsIHRoZXJlJ3Mgbm8gd2F5IHRvIGd1ZXNzIGlmIHRoaXMgcGFpciBjYW4gYmUgbGFzdCBvciBub3QuXG4gICAgICAgIC8vIGJvb2xlYW4gbWF5QmVMYXN0ID0gY2hlY2tQYWlyU2VxdWVuY2UocHJldmlvdXNQYWlycywgcGF0dGVybik7XG4gICAgICAgIHZhciBsZWZ0Q2hhciA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgdHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5UGFpcihwcmV2aW91c1BhaXJzKSAmJlxuICAgICAgICAgICAgcHJldmlvdXNQYWlyc1twcmV2aW91c1BhaXJzLmxlbmd0aCAtIDFdLm11c3RCZUxhc3QoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodENoYXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByaWdodENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmlnaHRDaGFyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXhwYW5kZWRQYWlyXzEuZGVmYXVsdChsZWZ0Q2hhciwgcmlnaHRDaGFyLCBwYXR0ZXJuLCB0cnVlKTtcbiAgICB9O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5pc0VtcHR5UGFpciA9IGZ1bmN0aW9uIChwYWlycykge1xuICAgICAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUuZmluZE5leHRQYWlyID0gZnVuY3Rpb24gKHJvdywgcHJldmlvdXNQYWlycywgZm9yY2VkT2Zmc2V0KSB7XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICB2YXIgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgcm93T2Zmc2V0O1xuICAgICAgICBpZiAoZm9yY2VkT2Zmc2V0ID49IDApIHtcbiAgICAgICAgICAgIHJvd09mZnNldCA9IGZvcmNlZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRW1wdHlQYWlyKHByZXZpb3VzUGFpcnMpKSB7XG4gICAgICAgICAgICByb3dPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhc3RQYWlyID0gcHJldmlvdXNQYWlyc1twcmV2aW91c1BhaXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcm93T2Zmc2V0ID0gbGFzdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFN0YXJ0RW5kKClbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlYXJjaGluZ0V2ZW5QYWlyID0gcHJldmlvdXNQYWlycy5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICBpZiAodGhpcy5zdGFydEZyb21FdmVuKSB7XG4gICAgICAgICAgICBzZWFyY2hpbmdFdmVuUGFpciA9ICFzZWFyY2hpbmdFdmVuUGFpcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhcm93LmdldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgZm9yICh2YXIgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJldmVyc2VDb3VudGVycyhjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzRmluZGVyUGF0dGVybihjb3VudGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFbmRbMF0gPSBwYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzFdID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJldmVyc2VDb3VudGVycyhjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gY291bnRlcnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gY291bnRlcnNbM107XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucmV2ZXJzZUNvdW50ZXJzID0gZnVuY3Rpb24gKGNvdW50ZXJzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC8gMjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICBjb3VudGVyc1tpXSA9IGNvdW50ZXJzW2xlbmd0aCAtIGkgLSAxXTtcbiAgICAgICAgICAgIGNvdW50ZXJzW2xlbmd0aCAtIGkgLSAxXSA9IHRtcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgcm93TnVtYmVyLCBvZGRQYXR0ZXJuKSB7XG4gICAgICAgIC8vIEFjdHVhbGx5IHdlIGZvdW5kIGVsZW1lbnRzIDItNS5cbiAgICAgICAgdmFyIGZpcnN0Q291bnRlcjtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICBpZiAob2RkUGF0dGVybikge1xuICAgICAgICAgICAgLy8gSWYgcGF0dGVybiBudW1iZXIgaXMgb2RkLCB3ZSBuZWVkIHRvIGxvY2F0ZSBlbGVtZW50IDEgKmJlZm9yZSogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICB2YXIgZmlyc3RFbGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0RW5kWzBdIC0gMTtcbiAgICAgICAgICAgIC8vIExvY2F0ZSBlbGVtZW50IDFcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmICFyb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xuICAgICAgICAgICAgZmlyc3RDb3VudGVyID0gdGhpcy5zdGFydEVuZFswXSAtIGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBwYXR0ZXJuIG51bWJlciBpcyBldmVuLCB0aGUgcGF0dGVybiBpcyByZXZlcnNlZCwgc28gd2UgbmVlZCB0byBsb2NhdGUgZWxlbWVudCAxICphZnRlciogdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc3RhcnRFbmRbMF07XG4gICAgICAgICAgICBlbmQgPSByb3cuZ2V0TmV4dFVuc2V0KHRoaXMuc3RhcnRFbmRbMV0gKyAxKTtcbiAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IGVuZCAtIHRoaXMuc3RhcnRFbmRbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSAnY291bnRlcnMnIGhvbGQgMS00XG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoY291bnRlcnMsIDAsIGNvdW50ZXJzLCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgY291bnRlcnNbMF0gPSBmaXJzdENvdW50ZXI7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUZpbmRlclZhbHVlKGNvdW50ZXJzLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTlMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4odmFsdWUsIG5ldyBpbnRbXSB7IHN0YXJ0LCBlbmQgfSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyfSk7XG4gICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybl8xLmRlZmF1bHQodmFsdWUsIFtzdGFydCwgZW5kXSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKTtcbiAgICB9O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVEYXRhQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHJvdywgcGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xuICAgICAgICB2YXIgY291bnRlcnMgPSB0aGlzLmdldERhdGFDaGFyYWN0ZXJDb3VudGVycygpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb3VudGVyc1t4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRDaGFyKSB7XG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdLCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzFdLCBjb3VudGVycyk7XG4gICAgICAgICAgICAvLyByZXZlcnNlIGl0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvdW50ZXJzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tqXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tqXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gY291bnRlcnNbXSBoYXMgdGhlIHBpeGVscyBvZiB0aGUgbW9kdWxlXG4gICAgICAgIHZhciBudW1Nb2R1bGVzID0gMTc7IC8vIGxlZnQgYW5kIHJpZ2h0IGRhdGEgY2hhcmFjdGVycyBoYXZlIGFsbCB0aGUgc2FtZSBsZW5ndGhcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzKSkgLyBudW1Nb2R1bGVzO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IGVsZW1lbnQgd2lkdGggZm9yIHBhdHRlcm4gYW5kIHRoZSBjaGFyYWN0ZXIgc2hvdWxkIG1hdGNoXG4gICAgICAgIHZhciBleHBlY3RlZEVsZW1lbnRXaWR0aCA9IChwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gLSBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0pIC8gMTUuMDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVsZW1lbnRXaWR0aCAtIGV4cGVjdGVkRWxlbWVudFdpZHRoKSAvIGV4cGVjdGVkRWxlbWVudFdpZHRoID5cbiAgICAgICAgICAgIDAuMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZGRDb3VudHMgPSB0aGlzLmdldE9kZENvdW50cygpO1xuICAgICAgICB2YXIgZXZlbkNvdW50cyA9IHRoaXMuZ2V0RXZlbkNvdW50cygpO1xuICAgICAgICB2YXIgb2RkUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgIHZhciBldmVuUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9ICgxLjAgKiBjb3VudGVyc1tpXSkgLyBlbGVtZW50V2lkdGg7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB2YWx1ZV8xICsgMC41OyAvLyBSb3VuZFxuICAgICAgICAgICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xIDwgMC4zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiA4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlXzEgPiA4LjcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudCA9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAvIDI7XG4gICAgICAgICAgICBpZiAoKGkgJiAweDAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9kZENvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgb2RkUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlXzEgLSBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW5Db3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgIGV2ZW5Sb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWVfMSAtIGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhudW1Nb2R1bGVzKTtcbiAgICAgICAgdmFyIHdlaWdodFJvd051bWJlciA9IDQgKiBwYXR0ZXJuLmdldFZhbHVlKCkgKyAoaXNPZGRQYXR0ZXJuID8gMCA6IDIpICsgKGxlZnRDaGFyID8gMCA6IDEpIC0gMTtcbiAgICAgICAgdmFyIG9kZFN1bSA9IDA7XG4gICAgICAgIHZhciBvZGRDaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2RkQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNOb3RBMWxlZnQocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUU1t3ZWlnaHRSb3dOdW1iZXJdWzIgKiBpXTtcbiAgICAgICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKz0gb2RkQ291bnRzW2ldICogd2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbkNoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgIC8vIGludCBldmVuU3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGV2ZW5Db3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSkge1xuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTW3dlaWdodFJvd051bWJlcl1bMiAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICs9IGV2ZW5Db3VudHNbaV0gKiB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBldmVuU3VtICs9IGV2ZW5Db3VudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoZWNrc3VtUG9ydGlvbiA9IG9kZENoZWNrc3VtUG9ydGlvbiArIGV2ZW5DaGVja3N1bVBvcnRpb247XG4gICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT09IDAgfHwgb2RkU3VtID4gMTMgfHwgb2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cCA9ICgxMyAtIG9kZFN1bSkgLyAyO1xuICAgICAgICB2YXIgb2RkV2lkZXN0ID0gUlNTRXhwYW5kZWRSZWFkZXIuU1lNQk9MX1dJREVTVFtncm91cF07XG4gICAgICAgIHZhciBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgdmFyIHZPZGQgPSBSU1NVdGlsc18xLmRlZmF1bHQuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xuICAgICAgICB2YXIgdkV2ZW4gPSBSU1NVdGlsc18xLmRlZmF1bHQuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgZmFsc2UpO1xuICAgICAgICB2YXIgdEV2ZW4gPSBSU1NFeHBhbmRlZFJlYWRlci5FVkVOX1RPVEFMX1NVQlNFVFtncm91cF07XG4gICAgICAgIHZhciBnU3VtID0gUlNTRXhwYW5kZWRSZWFkZXIuR1NVTVtncm91cF07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZPZGQgKiB0RXZlbiArIHZFdmVuICsgZ1N1bTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyXzEuZGVmYXVsdCh2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICB9O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLmlzTm90QTFsZWZ0ID0gZnVuY3Rpb24gKHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpIHtcbiAgICAgICAgLy8gQTE6IHBhdHRlcm4uZ2V0VmFsdWUgaXMgMCAoQSksIGFuZCBpdCdzIGFuIG9kZFBhdHRlcm4sIGFuZCBpdCBpcyBhIGxlZnQgY2hhclxuICAgICAgICByZXR1cm4gIShwYXR0ZXJuLmdldFZhbHVlKCkgPT09IDAgJiYgaXNPZGRQYXR0ZXJuICYmIGxlZnRDaGFyKTtcbiAgICB9O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5hZGp1c3RPZGRFdmVuQ291bnRzID0gZnVuY3Rpb24gKG51bU1vZHVsZXMpIHtcbiAgICAgICAgdmFyIG9kZFN1bSA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcbiAgICAgICAgdmFyIGV2ZW5TdW0gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldEV2ZW5Db3VudHMoKSkpO1xuICAgICAgICB2YXIgaW5jcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWNyZW1lbnRPZGQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9kZFN1bSA+IDEzKSB7XG4gICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMykge1xuICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IG9kZFN1bSArIGV2ZW5TdW0gLSBudW1Nb2R1bGVzO1xuICAgICAgICB2YXIgb2RkUGFyaXR5QmFkID0gKG9kZFN1bSAmIDB4MDEpID09PSAxO1xuICAgICAgICB2YXIgZXZlblBhcml0eUJhZCA9IChldmVuU3VtICYgMHgwMSkgPT09IDA7XG4gICAgICAgIGlmIChtaXNtYXRjaCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQm90aCBiYWRcbiAgICAgICAgICAgICAgICBpZiAob2RkU3VtIDwgZXZlblN1bSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jcmVtZW50T2RkKSB7XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUID0gWzcsIDUsIDQsIDMsIDFdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkVWRU5fVE9UQUxfU1VCU0VUID0gWzQsIDIwLCA1MiwgMTA0LCAyMDRdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkdTVU0gPSBbMCwgMzQ4LCAxMzg4LCAyOTQ4LCAzOTg4XTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOCwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDYsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA0LCA2LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDYsIDUsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCA5LCAxXSksXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTID0gW1xuICAgICAgICBbMSwgMywgOSwgMjcsIDgxLCAzMiwgOTYsIDc3XSxcbiAgICAgICAgWzIwLCA2MCwgMTgwLCAxMTgsIDE0MywgNywgMjEsIDYzXSxcbiAgICAgICAgWzE4OSwgMTQ1LCAxMywgMzksIDExNywgMTQwLCAyMDksIDIwNV0sXG4gICAgICAgIFsxOTMsIDE1NywgNDksIDE0NywgMTksIDU3LCAxNzEsIDkxXSxcbiAgICAgICAgWzYyLCAxODYsIDEzNiwgMTk3LCAxNjksIDg1LCA0NCwgMTMyXSxcbiAgICAgICAgWzE4NSwgMTMzLCAxODgsIDE0MiwgNCwgMTIsIDM2LCAxMDhdLFxuICAgICAgICBbMTEzLCAxMjgsIDE3MywgOTcsIDgwLCAyOSwgODcsIDUwXSxcbiAgICAgICAgWzE1MCwgMjgsIDg0LCA0MSwgMTIzLCAxNTgsIDUyLCAxNTZdLFxuICAgICAgICBbNDYsIDEzOCwgMjAzLCAxODcsIDEzOSwgMjA2LCAxOTYsIDE2Nl0sXG4gICAgICAgIFs3NiwgMTcsIDUxLCAxNTMsIDM3LCAxMTEsIDEyMiwgMTU1XSxcbiAgICAgICAgWzQzLCAxMjksIDE3NiwgMTA2LCAxMDcsIDExMCwgMTE5LCAxNDZdLFxuICAgICAgICBbMTYsIDQ4LCAxNDQsIDEwLCAzMCwgOTAsIDU5LCAxNzddLFxuICAgICAgICBbMTA5LCAxMTYsIDEzNywgMjAwLCAxNzgsIDExMiwgMTI1LCAxNjRdLFxuICAgICAgICBbNzAsIDIxMCwgMjA4LCAyMDIsIDE4NCwgMTMwLCAxNzksIDExNV0sXG4gICAgICAgIFsxMzQsIDE5MSwgMTUxLCAzMSwgOTMsIDY4LCAyMDQsIDE5MF0sXG4gICAgICAgIFsxNDgsIDIyLCA2NiwgMTk4LCAxNzIsIDk0LCA3MSwgMl0sXG4gICAgICAgIFs2LCAxOCwgNTQsIDE2MiwgNjQsIDE5MiwgMTU0LCA0MF0sXG4gICAgICAgIFsxMjAsIDE0OSwgMjUsIDc1LCAxNCwgNDIsIDEyNiwgMTY3XSxcbiAgICAgICAgWzc5LCAyNiwgNzgsIDIzLCA2OSwgMjA3LCAxOTksIDE3NV0sXG4gICAgICAgIFsxMDMsIDk4LCA4MywgMzgsIDExNCwgMTMxLCAxODIsIDEyNF0sXG4gICAgICAgIFsxNjEsIDYxLCAxODMsIDEyNywgMTcwLCA4OCwgNTMsIDE1OV0sXG4gICAgICAgIFs1NSwgMTY1LCA3MywgOCwgMjQsIDcyLCA1LCAxNV0sXG4gICAgICAgIFs0NSwgMTM1LCAxOTQsIDE2MCwgNTgsIDE3NCwgMTAwLCA4OV0sXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EgPSAwO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiA9IDE7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DID0gMjtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QgPSAzO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSA9IDQ7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GID0gNTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMgPSBbXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQV0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQixcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQixcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQixcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQixcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQyxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQyxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSxcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLFxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsXG4gICAgICAgIF0sXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5NQVhfUEFJUlMgPSAxMTtcbiAgICByZXR1cm4gUlNTRXhwYW5kZWRSZWFkZXI7XG59KEFic3RyYWN0UlNTUmVhZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUlNTRXhwYW5kZWRSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI013x0xDecoder_1 = __webpack_require__(/*! ./AI013x0xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js\");\nvar AI013103decoder = /** @class */ (function (_super) {\n    __extends(AI013103decoder, _super);\n    function AI013103decoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI013103decoder.prototype.addWeightCode = function (buf, weight) {\n        buf.append('(3103)');\n    };\n    AI013103decoder.prototype.checkWeight = function (weight) {\n        return weight;\n    };\n    return AI013103decoder;\n}(AI013x0xDecoder_1.default));\nexports[\"default\"] = AI013103decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzEwM2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQywwS0FBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzMTAzZGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDEzeDB4RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTN4MHhEZWNvZGVyXCIpO1xudmFyIEFJMDEzMTAzZGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQUkwMTMxMDNkZWNvZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFJMDEzMTAzZGVjb2RlcihpbmZvcm1hdGlvbikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5mb3JtYXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIEFJMDEzMTAzZGVjb2Rlci5wcm90b3R5cGUuYWRkV2VpZ2h0Q29kZSA9IGZ1bmN0aW9uIChidWYsIHdlaWdodCkge1xuICAgICAgICBidWYuYXBwZW5kKCcoMzEwMyknKTtcbiAgICB9O1xuICAgIEFJMDEzMTAzZGVjb2Rlci5wcm90b3R5cGUuY2hlY2tXZWlnaHQgPSBmdW5jdGlvbiAod2VpZ2h0KSB7XG4gICAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQUkwMTMxMDNkZWNvZGVyO1xufShBSTAxM3gweERlY29kZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxMzEwM2RlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI013x0xDecoder_1 = __webpack_require__(/*! ./AI013x0xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js\");\nvar AI01320xDecoder = /** @class */ (function (_super) {\n    __extends(AI01320xDecoder, _super);\n    function AI01320xDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01320xDecoder.prototype.addWeightCode = function (buf, weight) {\n        if (weight < 10000) {\n            buf.append('(3202)');\n        }\n        else {\n            buf.append('(3203)');\n        }\n    };\n    AI01320xDecoder.prototype.checkWeight = function (weight) {\n        if (weight < 10000) {\n            return weight;\n        }\n        return weight - 10000;\n    };\n    return AI01320xDecoder;\n}(AI013x0xDecoder_1.default));\nexports[\"default\"] = AI01320xDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzIweERlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQywwS0FBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzIweERlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBSTAxM3gweERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0FJMDEzeDB4RGVjb2RlclwiKTtcbnZhciBBSTAxMzIweERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFJMDEzMjB4RGVjb2RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBSTAxMzIweERlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBSTAxMzIweERlY29kZXIucHJvdG90eXBlLmFkZFdlaWdodENvZGUgPSBmdW5jdGlvbiAoYnVmLCB3ZWlnaHQpIHtcbiAgICAgICAgaWYgKHdlaWdodCA8IDEwMDAwKSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMzIwMiknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzMjAzKScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBSTAxMzIweERlY29kZXIucHJvdG90eXBlLmNoZWNrV2VpZ2h0ID0gZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICBpZiAod2VpZ2h0IDwgMTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlaWdodCAtIDEwMDAwO1xuICAgIH07XG4gICAgcmV0dXJuIEFJMDEzMjB4RGVjb2Rlcjtcbn0oQUkwMTN4MHhEZWNvZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMTMyMHhEZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar AI01392xDecoder = /** @class */ (function (_super) {\n    __extends(AI01392xDecoder, _super);\n    function AI01392xDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01392xDecoder.prototype.parseInformation = function () {\n        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {\n            throw new NotFoundException_1.default();\n        }\n        var buf = new StringBuilder_1.default();\n        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);\n        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);\n        buf.append('(392');\n        buf.append(lastAIdigit);\n        buf.append(')');\n        var decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);\n        buf.append(decodedInformation.getNewString());\n        return buf.toString();\n    };\n    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01392xDecoder.LAST_DIGIT_SIZE = 2;\n    return AI01392xDecoder;\n}(AI01decoder_1.default));\nexports[\"default\"] = AI01392xDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzkyeERlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxrS0FBZTtBQUMzQywwQkFBMEIsbUJBQU8sQ0FBQyw2SkFBK0I7QUFDakUsc0JBQXNCLG1CQUFPLENBQUMsK0pBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzOTJ4RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgQUkwMTM5MnhEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBSTAxMzkyeERlY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQUkwMTM5MnhEZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgQUkwMTM5MnhEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSA8IEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICB2YXIgbGFzdEFJZGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFLCBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFKTtcbiAgICAgICAgYnVmLmFwcGVuZCgnKDM5MicpO1xuICAgICAgICBidWYuYXBwZW5kKGxhc3RBSWRpZ2l0KTtcbiAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICB2YXIgZGVjb2RlZEluZm9ybWF0aW9uID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSArIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUsIG51bGwpO1xuICAgICAgICBidWYuYXBwZW5kKGRlY29kZWRJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcbiAgICBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcbiAgICByZXR1cm4gQUkwMTM5MnhEZWNvZGVyO1xufShBSTAxZGVjb2Rlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDEzOTJ4RGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar AI01393xDecoder = /** @class */ (function (_super) {\n    __extends(AI01393xDecoder, _super);\n    function AI01393xDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01393xDecoder.prototype.parseInformation = function () {\n        if (this.getInformation().getSize() <\n            AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {\n            throw new NotFoundException_1.default();\n        }\n        var buf = new StringBuilder_1.default();\n        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);\n        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);\n        buf.append('(393');\n        buf.append(lastAIdigit);\n        buf.append(')');\n        var firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE +\n            AI01decoder_1.default.GTIN_SIZE +\n            AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);\n        if (firstThreeDigits / 100 === 0) {\n            buf.append('0');\n        }\n        if (firstThreeDigits / 10 === 0) {\n            buf.append('0');\n        }\n        buf.append(firstThreeDigits);\n        var generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE +\n            AI01decoder_1.default.GTIN_SIZE +\n            AI01393xDecoder.LAST_DIGIT_SIZE +\n            AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);\n        buf.append(generalInformation.getNewString());\n        return buf.toString();\n    };\n    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01393xDecoder.LAST_DIGIT_SIZE = 2;\n    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;\n    return AI01393xDecoder;\n}(AI01decoder_1.default));\nexports[\"default\"] = AI01393xDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzkzeERlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxrS0FBZTtBQUMzQywwQkFBMEIsbUJBQU8sQ0FBQyw2SkFBK0I7QUFDakUsc0JBQXNCLG1CQUFPLENBQUMsK0pBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzOTN4RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgQUkwMTM5M3hEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBSTAxMzkzeERlY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQUkwMTM5M3hEZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgQUkwMTM5M3hEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSA8XG4gICAgICAgICAgICBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgdmFyIGxhc3RBSWRpZ2l0ID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSwgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSk7XG4gICAgICAgIGJ1Zi5hcHBlbmQoJygzOTMnKTtcbiAgICAgICAgYnVmLmFwcGVuZChsYXN0QUlkaWdpdCk7XG4gICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgdmFyIGZpcnN0VGhyZWVEaWdpdHMgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgK1xuICAgICAgICAgICAgQUkwMWRlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSArXG4gICAgICAgICAgICBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFLCBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUpO1xuICAgICAgICBpZiAoZmlyc3RUaHJlZURpZ2l0cyAvIDEwMCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRocmVlRGlnaXRzIC8gMTAgPT09IDApIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBidWYuYXBwZW5kKGZpcnN0VGhyZWVEaWdpdHMpO1xuICAgICAgICB2YXIgZ2VuZXJhbEluZm9ybWF0aW9uID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICtcbiAgICAgICAgICAgIEFJMDFkZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUgK1xuICAgICAgICAgICAgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSArXG4gICAgICAgICAgICBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUsIG51bGwpO1xuICAgICAgICBidWYuYXBwZW5kKGdlbmVyYWxJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcbiAgICBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcbiAgICBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUgPSAxMDtcbiAgICByZXR1cm4gQUkwMTM5M3hEZWNvZGVyO1xufShBSTAxZGVjb2Rlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDEzOTN4RGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js":
/*!****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01weightDecoder_1 = __webpack_require__(/*! ./AI01weightDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar AI013x0x1xDecoder = /** @class */ (function (_super) {\n    __extends(AI013x0x1xDecoder, _super);\n    function AI013x0x1xDecoder(information, firstAIdigits, dateCode) {\n        var _this = _super.call(this, information) || this;\n        _this.dateCode = dateCode;\n        _this.firstAIdigits = firstAIdigits;\n        return _this;\n    }\n    AI013x0x1xDecoder.prototype.parseInformation = function () {\n        if (this.getInformation().getSize() !==\n            AI013x0x1xDecoder.HEADER_SIZE +\n                AI013x0x1xDecoder.GTIN_SIZE +\n                AI013x0x1xDecoder.WEIGHT_SIZE +\n                AI013x0x1xDecoder.DATE_SIZE) {\n            throw new NotFoundException_1.default();\n        }\n        var buf = new StringBuilder_1.default();\n        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);\n        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);\n        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE +\n            AI013x0x1xDecoder.GTIN_SIZE +\n            AI013x0x1xDecoder.WEIGHT_SIZE);\n        return buf.toString();\n    };\n    AI013x0x1xDecoder.prototype.encodeCompressedDate = function (buf, currentPos) {\n        var numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);\n        if (numericDate === 38400) {\n            return;\n        }\n        buf.append('(');\n        buf.append(this.dateCode);\n        buf.append(')');\n        var day = numericDate % 32;\n        numericDate /= 32;\n        var month = (numericDate % 12) + 1;\n        numericDate /= 12;\n        var year = numericDate;\n        if (year / 10 === 0) {\n            buf.append('0');\n        }\n        buf.append(year);\n        if (month / 10 === 0) {\n            buf.append('0');\n        }\n        buf.append(month);\n        if (day / 10 === 0) {\n            buf.append('0');\n        }\n        buf.append(day);\n    };\n    AI013x0x1xDecoder.prototype.addWeightCode = function (buf, weight) {\n        buf.append('(');\n        buf.append(this.firstAIdigits);\n        buf.append(weight / 100000);\n        buf.append(')');\n    };\n    AI013x0x1xDecoder.prototype.checkWeight = function (weight) {\n        return weight % 100000;\n    };\n    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;\n    AI013x0x1xDecoder.WEIGHT_SIZE = 20;\n    AI013x0x1xDecoder.DATE_SIZE = 16;\n    return AI013x0x1xDecoder;\n}(AI01weightDecoder_1.default));\nexports[\"default\"] = AI013x0x1xDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxM3gweDF4RGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixtQkFBTyxDQUFDLDhLQUFxQjtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyw2SkFBK0I7QUFDakUsc0JBQXNCLG1CQUFPLENBQUMsK0pBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxM3gweDF4RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDF3ZWlnaHREZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxd2VpZ2h0RGVjb2RlclwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG52YXIgQUkwMTN4MHgxeERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFJMDEzeDB4MXhEZWNvZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCBmaXJzdEFJZGlnaXRzLCBkYXRlQ29kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0ZUNvZGUgPSBkYXRlQ29kZTtcbiAgICAgICAgX3RoaXMuZmlyc3RBSWRpZ2l0cyA9IGZpcnN0QUlkaWdpdHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQUkwMTN4MHgxeERlY29kZXIucHJvdG90eXBlLnBhcnNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpICE9PVxuICAgICAgICAgICAgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgK1xuICAgICAgICAgICAgICAgIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSArXG4gICAgICAgICAgICAgICAgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUgK1xuICAgICAgICAgICAgICAgIEFJMDEzeDB4MXhEZWNvZGVyLkRBVEVfU0laRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkRGF0ZShidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICtcbiAgICAgICAgICAgIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSArXG4gICAgICAgICAgICBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEFJMDEzeDB4MXhEZWNvZGVyLnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkRGF0ZSA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgdmFyIG51bWVyaWNEYXRlID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcywgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFKTtcbiAgICAgICAgaWYgKG51bWVyaWNEYXRlID09PSAzODQwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJ1Zi5hcHBlbmQoJygnKTtcbiAgICAgICAgYnVmLmFwcGVuZCh0aGlzLmRhdGVDb2RlKTtcbiAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICB2YXIgZGF5ID0gbnVtZXJpY0RhdGUgJSAzMjtcbiAgICAgICAgbnVtZXJpY0RhdGUgLz0gMzI7XG4gICAgICAgIHZhciBtb250aCA9IChudW1lcmljRGF0ZSAlIDEyKSArIDE7XG4gICAgICAgIG51bWVyaWNEYXRlIC89IDEyO1xuICAgICAgICB2YXIgeWVhciA9IG51bWVyaWNEYXRlO1xuICAgICAgICBpZiAoeWVhciAvIDEwID09PSAwKSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLmFwcGVuZCh5ZWFyKTtcbiAgICAgICAgaWYgKG1vbnRoIC8gMTAgPT09IDApIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBidWYuYXBwZW5kKG1vbnRoKTtcbiAgICAgICAgaWYgKGRheSAvIDEwID09PSAwKSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLmFwcGVuZChkYXkpO1xuICAgIH07XG4gICAgQUkwMTN4MHgxeERlY29kZXIucHJvdG90eXBlLmFkZFdlaWdodENvZGUgPSBmdW5jdGlvbiAoYnVmLCB3ZWlnaHQpIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnKCcpO1xuICAgICAgICBidWYuYXBwZW5kKHRoaXMuZmlyc3RBSWRpZ2l0cyk7XG4gICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0IC8gMTAwMDAwKTtcbiAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgIH07XG4gICAgQUkwMTN4MHgxeERlY29kZXIucHJvdG90eXBlLmNoZWNrV2VpZ2h0ID0gZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICByZXR1cm4gd2VpZ2h0ICUgMTAwMDAwO1xuICAgIH07XG4gICAgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgPSA3ICsgMTtcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSA9IDIwO1xuICAgIEFJMDEzeDB4MXhEZWNvZGVyLkRBVEVfU0laRSA9IDE2O1xuICAgIHJldHVybiBBSTAxM3gweDF4RGVjb2Rlcjtcbn0oQUkwMXdlaWdodERlY29kZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxM3gweDF4RGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01weightDecoder_1 = __webpack_require__(/*! ./AI01weightDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar AI013x0xDecoder = /** @class */ (function (_super) {\n    __extends(AI013x0xDecoder, _super);\n    function AI013x0xDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI013x0xDecoder.prototype.parseInformation = function () {\n        if (this.getInformation().getSize() !==\n            AI013x0xDecoder.HEADER_SIZE +\n                AI01weightDecoder_1.default.GTIN_SIZE +\n                AI013x0xDecoder.WEIGHT_SIZE) {\n            throw new NotFoundException_1.default();\n        }\n        var buf = new StringBuilder_1.default();\n        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);\n        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder_1.default.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);\n        return buf.toString();\n    };\n    AI013x0xDecoder.HEADER_SIZE = 4 + 1;\n    AI013x0xDecoder.WEIGHT_SIZE = 15;\n    return AI013x0xDecoder;\n}(AI01weightDecoder_1.default));\nexports[\"default\"] = AI013x0xDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxM3gweERlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyw4S0FBcUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsK0pBQWdDO0FBQzlELDBCQUEwQixtQkFBTyxDQUFDLDZKQUErQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzeDB4RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDF3ZWlnaHREZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxd2VpZ2h0RGVjb2RlclwiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgQUkwMTN4MHhEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBSTAxM3gweERlY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQUkwMTN4MHhEZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgQUkwMTN4MHhEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSAhPT1cbiAgICAgICAgICAgIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArXG4gICAgICAgICAgICAgICAgQUkwMXdlaWdodERlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSArXG4gICAgICAgICAgICAgICAgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMXdlaWdodERlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSwgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgIH07XG4gICAgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFID0gNCArIDE7XG4gICAgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFID0gMTU7XG4gICAgcmV0dXJuIEFJMDEzeDB4RGVjb2Rlcjtcbn0oQUkwMXdlaWdodERlY29kZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxM3gweERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar AI01AndOtherAIs = /** @class */ (function (_super) {\n    __extends(AI01AndOtherAIs, _super);\n    // the second one is the encodation method, and the other two are for the variable length\n    function AI01AndOtherAIs(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01AndOtherAIs.prototype.parseInformation = function () {\n        var buff = new StringBuilder_1.default();\n        buff.append('(01)');\n        var initialGtinPosition = buff.length();\n        var firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);\n        buff.append(firstGtinDigit);\n        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);\n        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);\n    };\n    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,\n    return AI01AndOtherAIs;\n}(AI01decoder_1.default));\nexports[\"default\"] = AI01AndOtherAIs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxQW5kT3RoZXJBSXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxrS0FBZTtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQywrSkFBZ0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDFBbmRPdGhlckFJcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIEFJMDFBbmRPdGhlckFJcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQUkwMUFuZE90aGVyQUlzLCBfc3VwZXIpO1xuICAgIC8vIHRoZSBzZWNvbmQgb25lIGlzIHRoZSBlbmNvZGF0aW9uIG1ldGhvZCwgYW5kIHRoZSBvdGhlciB0d28gYXJlIGZvciB0aGUgdmFyaWFibGUgbGVuZ3RoXG4gICAgZnVuY3Rpb24gQUkwMUFuZE90aGVyQUlzKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgQUkwMUFuZE90aGVyQUlzLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBidWZmLmFwcGVuZCgnKDAxKScpO1xuICAgICAgICB2YXIgaW5pdGlhbEd0aW5Qb3NpdGlvbiA9IGJ1ZmYubGVuZ3RoKCk7XG4gICAgICAgIHZhciBmaXJzdEd0aW5EaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSwgNCk7XG4gICAgICAgIGJ1ZmYuYXBwZW5kKGZpcnN0R3RpbkRpZ2l0KTtcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSShidWZmLCBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgKyA0LCBpbml0aWFsR3RpblBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVBbGxDb2RlcyhidWZmLCBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgKyA0NCk7XG4gICAgfTtcbiAgICBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgPSAxICsgMSArIDI7IC8vIGZpcnN0IGJpdCBlbmNvZGVzIHRoZSBsaW5rYWdlIGZsYWcsXG4gICAgcmV0dXJuIEFJMDFBbmRPdGhlckFJcztcbn0oQUkwMWRlY29kZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxQW5kT3RoZXJBSXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AbstractExpandedDecoder_1 = __webpack_require__(/*! ./AbstractExpandedDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js\");\nvar AI01decoder = /** @class */ (function (_super) {\n    __extends(AI01decoder, _super);\n    function AI01decoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01decoder.prototype.encodeCompressedGtin = function (buf, currentPos) {\n        buf.append('(01)');\n        var initialPosition = buf.length();\n        buf.append('9');\n        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);\n    };\n    AI01decoder.prototype.encodeCompressedGtinWithoutAI = function (buf, currentPos, initialBufferPosition) {\n        for (var i = 0; i < 4; ++i) {\n            var currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);\n            if (currentBlock / 100 === 0) {\n                buf.append('0');\n            }\n            if (currentBlock / 10 === 0) {\n                buf.append('0');\n            }\n            buf.append(currentBlock);\n        }\n        AI01decoder.appendCheckDigit(buf, initialBufferPosition);\n    };\n    AI01decoder.appendCheckDigit = function (buf, currentPos) {\n        var checkDigit = 0;\n        for (var i = 0; i < 13; i++) {\n            // let digit = buf.charAt(i + currentPos) - '0';\n            // To be checked\n            var digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);\n            checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;\n        }\n        checkDigit = 10 - (checkDigit % 10);\n        if (checkDigit === 10) {\n            checkDigit = 0;\n        }\n        buf.append(checkDigit);\n    };\n    AI01decoder.GTIN_SIZE = 40;\n    return AI01decoder;\n}(AbstractExpandedDecoder_1.default));\nexports[\"default\"] = AI01decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLDBMQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDFkZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQWJzdHJhY3RFeHBhbmRlZERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyXCIpO1xudmFyIEFJMDFkZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBSTAxZGVjb2RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBSTAxZGVjb2RlcihpbmZvcm1hdGlvbikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5mb3JtYXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIEFJMDFkZWNvZGVyLnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkR3RpbiA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnKDAxKScpO1xuICAgICAgICB2YXIgaW5pdGlhbFBvc2l0aW9uID0gYnVmLmxlbmd0aCgpO1xuICAgICAgICBidWYuYXBwZW5kKCc5Jyk7XG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkoYnVmLCBjdXJyZW50UG9zLCBpbml0aWFsUG9zaXRpb24pO1xuICAgIH07XG4gICAgQUkwMWRlY29kZXIucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJID0gZnVuY3Rpb24gKGJ1ZiwgY3VycmVudFBvcywgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEJsb2NrID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcyArIDEwICogaSwgMTApO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9jayAvIDEwMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoY3VycmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBBSTAxZGVjb2Rlci5hcHBlbmRDaGVja0RpZ2l0KGJ1ZiwgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEFJMDFkZWNvZGVyLmFwcGVuZENoZWNrRGlnaXQgPSBmdW5jdGlvbiAoYnVmLCBjdXJyZW50UG9zKSB7XG4gICAgICAgIHZhciBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBsZXQgZGlnaXQgPSBidWYuY2hhckF0KGkgKyBjdXJyZW50UG9zKSAtICcwJztcbiAgICAgICAgICAgIC8vIFRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGJ1Zi5jaGFyQXQoaSArIGN1cnJlbnRQb3MpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGNoZWNrRGlnaXQgKz0gKGkgJiAweDAxKSA9PT0gMCA/IDMgKiBkaWdpdCA6IGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRGlnaXQgPSAxMCAtIChjaGVja0RpZ2l0ICUgMTApO1xuICAgICAgICBpZiAoY2hlY2tEaWdpdCA9PT0gMTApIHtcbiAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJ1Zi5hcHBlbmQoY2hlY2tEaWdpdCk7XG4gICAgfTtcbiAgICBBSTAxZGVjb2Rlci5HVElOX1NJWkUgPSA0MDtcbiAgICByZXR1cm4gQUkwMWRlY29kZXI7XG59KEFic3RyYWN0RXhwYW5kZWREZWNvZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMWRlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js":
/*!****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js\");\nvar AI01weightDecoder = /** @class */ (function (_super) {\n    __extends(AI01weightDecoder, _super);\n    function AI01weightDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AI01weightDecoder.prototype.encodeCompressedWeight = function (buf, currentPos, weightSize) {\n        var originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);\n        this.addWeightCode(buf, originalWeightNumeric);\n        var weightNumeric = this.checkWeight(originalWeightNumeric);\n        var currentDivisor = 100000;\n        for (var i = 0; i < 5; ++i) {\n            if (weightNumeric / currentDivisor === 0) {\n                buf.append('0');\n            }\n            currentDivisor /= 10;\n        }\n        buf.append(weightNumeric);\n    };\n    return AI01weightDecoder;\n}(AI01decoder_1.default));\nexports[\"default\"] = AI01weightDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxd2VpZ2h0RGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLGtLQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxd2VpZ2h0RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcbnZhciBBSTAxd2VpZ2h0RGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQUkwMXdlaWdodERlY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQUkwMXdlaWdodERlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBSTAxd2VpZ2h0RGVjb2Rlci5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZFdlaWdodCA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MsIHdlaWdodFNpemUpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsV2VpZ2h0TnVtZXJpYyA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGN1cnJlbnRQb3MsIHdlaWdodFNpemUpO1xuICAgICAgICB0aGlzLmFkZFdlaWdodENvZGUoYnVmLCBvcmlnaW5hbFdlaWdodE51bWVyaWMpO1xuICAgICAgICB2YXIgd2VpZ2h0TnVtZXJpYyA9IHRoaXMuY2hlY2tXZWlnaHQob3JpZ2luYWxXZWlnaHROdW1lcmljKTtcbiAgICAgICAgdmFyIGN1cnJlbnREaXZpc29yID0gMTAwMDAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgaWYgKHdlaWdodE51bWVyaWMgLyBjdXJyZW50RGl2aXNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnREaXZpc29yIC89IDEwO1xuICAgICAgICB9XG4gICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0TnVtZXJpYyk7XG4gICAgfTtcbiAgICByZXR1cm4gQUkwMXdlaWdodERlY29kZXI7XG59KEFJMDFkZWNvZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMXdlaWdodERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar GeneralAppIdDecoder_1 = __webpack_require__(/*! ./GeneralAppIdDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js\");\nvar AbstractExpandedDecoder = /** @class */ (function () {\n    function AbstractExpandedDecoder(information) {\n        this.information = information;\n        this.generalDecoder = new GeneralAppIdDecoder_1.default(information);\n    }\n    AbstractExpandedDecoder.prototype.getInformation = function () {\n        return this.information;\n    };\n    AbstractExpandedDecoder.prototype.getGeneralDecoder = function () {\n        return this.generalDecoder;\n    };\n    return AbstractExpandedDecoder;\n}());\nexports[\"default\"] = AbstractExpandedDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BYnN0cmFjdEV4cGFuZGVkRGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsbUJBQU8sQ0FBQyxrTEFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEdlbmVyYWxBcHBJZERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0dlbmVyYWxBcHBJZERlY29kZXJcIik7XG52YXIgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RFeHBhbmRlZERlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xuICAgICAgICB0aGlzLmdlbmVyYWxEZWNvZGVyID0gbmV3IEdlbmVyYWxBcHBJZERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uKTtcbiAgICB9XG4gICAgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIucHJvdG90eXBlLmdldEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvcm1hdGlvbjtcbiAgICB9O1xuICAgIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyLnByb3RvdHlwZS5nZXRHZW5lcmFsRGVjb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhbERlY29kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RFeHBhbmRlZERlY29kZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RFeHBhbmRlZERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js":
/*!********************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDecoder = void 0;\nvar IllegalStateException_1 = __webpack_require__(/*! ../../../../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\nvar GeneralAppIdDecoder_1 = __webpack_require__(/*! ./GeneralAppIdDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js\");\nvar AI01AndOtherAIs_1 = __webpack_require__(/*! ./AI01AndOtherAIs */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js\");\nvar AnyAIDecoder_1 = __webpack_require__(/*! ./AnyAIDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js\");\nvar AI013103decoder_1 = __webpack_require__(/*! ./AI013103decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js\");\nvar AI01320xDecoder_1 = __webpack_require__(/*! ./AI01320xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js\");\nvar AI01392xDecoder_1 = __webpack_require__(/*! ./AI01392xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js\");\nvar AI01393xDecoder_1 = __webpack_require__(/*! ./AI01393xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js\");\nvar AI013x0x1xDecoder_1 = __webpack_require__(/*! ./AI013x0x1xDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js\");\nfunction createDecoder(information) {\n    try {\n        if (information.get(1)) {\n            return new AI01AndOtherAIs_1.default(information);\n        }\n        if (!information.get(2)) {\n            return new AnyAIDecoder_1.default(information);\n        }\n        var fourBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 4);\n        switch (fourBitEncodationMethod) {\n            case 4: return new AI013103decoder_1.default(information);\n            case 5: return new AI01320xDecoder_1.default(information);\n        }\n        var fiveBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 5);\n        switch (fiveBitEncodationMethod) {\n            case 12: return new AI01392xDecoder_1.default(information);\n            case 13: return new AI01393xDecoder_1.default(information);\n        }\n        var sevenBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 7);\n        switch (sevenBitEncodationMethod) {\n            case 56: return new AI013x0x1xDecoder_1.default(information, '310', '11');\n            case 57: return new AI013x0x1xDecoder_1.default(information, '320', '11');\n            case 58: return new AI013x0x1xDecoder_1.default(information, '310', '13');\n            case 59: return new AI013x0x1xDecoder_1.default(information, '320', '13');\n            case 60: return new AI013x0x1xDecoder_1.default(information, '310', '15');\n            case 61: return new AI013x0x1xDecoder_1.default(information, '320', '15');\n            case 62: return new AI013x0x1xDecoder_1.default(information, '310', '17');\n            case 63: return new AI013x0x1xDecoder_1.default(information, '320', '17');\n        }\n    }\n    catch (e) {\n        console.log(e);\n        throw new IllegalStateException_1.default('unknown decoder: ' + information);\n    }\n}\nexports.createDecoder = createDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BYnN0cmFjdEV4cGFuZGVkRGVjb2RlckNvbXBsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLDhCQUE4QixtQkFBTyxDQUFDLHFLQUFtQztBQUN6RSw0QkFBNEIsbUJBQU8sQ0FBQyxrTEFBdUI7QUFDM0Qsd0JBQXdCLG1CQUFPLENBQUMsMEtBQW1CO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLG9LQUFnQjtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQywwS0FBbUI7QUFDbkQsd0JBQXdCLG1CQUFPLENBQUMsMEtBQW1CO0FBQ25ELHdCQUF3QixtQkFBTyxDQUFDLDBLQUFtQjtBQUNuRCx3QkFBd0IsbUJBQU8sQ0FBQywwS0FBbUI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsOEtBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvQWJzdHJhY3RFeHBhbmRlZERlY29kZXJDb21wbGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEZWNvZGVyID0gdm9pZCAwO1xudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbnZhciBHZW5lcmFsQXBwSWREZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9HZW5lcmFsQXBwSWREZWNvZGVyXCIpO1xudmFyIEFJMDFBbmRPdGhlckFJc18xID0gcmVxdWlyZShcIi4vQUkwMUFuZE90aGVyQUlzXCIpO1xudmFyIEFueUFJRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQW55QUlEZWNvZGVyXCIpO1xudmFyIEFJMDEzMTAzZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTMxMDNkZWNvZGVyXCIpO1xudmFyIEFJMDEzMjB4RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTMyMHhEZWNvZGVyXCIpO1xudmFyIEFJMDEzOTJ4RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTM5MnhEZWNvZGVyXCIpO1xudmFyIEFJMDEzOTN4RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTM5M3hEZWNvZGVyXCIpO1xudmFyIEFJMDEzeDB4MXhEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxM3gweDF4RGVjb2RlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoaW5mb3JtYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoaW5mb3JtYXRpb24uZ2V0KDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFJMDFBbmRPdGhlckFJc18xLmRlZmF1bHQoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5mb3JtYXRpb24uZ2V0KDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFueUFJRGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXJfMS5kZWZhdWx0LmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDQpO1xuICAgICAgICBzd2l0Y2ggKGZvdXJCaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQUkwMTMxMDNkZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQUkwMTMyMHhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpdmVCaXRFbmNvZGF0aW9uTWV0aG9kID0gR2VuZXJhbEFwcElkRGVjb2Rlcl8xLmRlZmF1bHQuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgMSwgNSk7XG4gICAgICAgIHN3aXRjaCAoZml2ZUJpdEVuY29kYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBuZXcgQUkwMTM5MnhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gbmV3IEFJMDEzOTN4RGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXZlbkJpdEVuY29kYXRpb25NZXRob2QgPSBHZW5lcmFsQXBwSWREZWNvZGVyXzEuZGVmYXVsdC5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCAxLCA3KTtcbiAgICAgICAgc3dpdGNoIChzZXZlbkJpdEVuY29kYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgNTY6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzExJyk7XG4gICAgICAgICAgICBjYXNlIDU3OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbiwgJzMyMCcsICcxMScpO1xuICAgICAgICAgICAgY2FzZSA1ODogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24sICczMTAnLCAnMTMnKTtcbiAgICAgICAgICAgIGNhc2UgNTk6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzIwJywgJzEzJyk7XG4gICAgICAgICAgICBjYXNlIDYwOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbiwgJzMxMCcsICcxNScpO1xuICAgICAgICAgICAgY2FzZSA2MTogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24sICczMjAnLCAnMTUnKTtcbiAgICAgICAgICAgIGNhc2UgNjI6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzE3Jyk7XG4gICAgICAgICAgICBjYXNlIDYzOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbiwgJzMyMCcsICcxNycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEuZGVmYXVsdCgndW5rbm93biBkZWNvZGVyOiAnICsgaW5mb3JtYXRpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlRGVjb2RlciA9IGNyZWF0ZURlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js":
/*!***********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar AbstractExpandedDecoder_1 = __webpack_require__(/*! ./AbstractExpandedDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js\");\nvar AnyAIDecoder = /** @class */ (function (_super) {\n    __extends(AnyAIDecoder, _super);\n    function AnyAIDecoder(information) {\n        return _super.call(this, information) || this;\n    }\n    AnyAIDecoder.prototype.parseInformation = function () {\n        var buf = new StringBuilder_1.default();\n        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);\n    };\n    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;\n    return AnyAIDecoder;\n}(AbstractExpandedDecoder_1.default));\nexports[\"default\"] = AnyAIDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BbnlBSURlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQywrSkFBZ0M7QUFDOUQsZ0NBQWdDLG1CQUFPLENBQUMsMExBQTJCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvQW55QUlEZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RFeHBhbmRlZERlY29kZXJcIik7XG52YXIgQW55QUlEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbnlBSURlY29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW55QUlEZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgQW55QUlEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlQWxsQ29kZXMoYnVmLCBBbnlBSURlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgIH07XG4gICAgQW55QUlEZWNvZGVyLkhFQURFUl9TSVpFID0gMiArIDEgKyAyO1xuICAgIHJldHVybiBBbnlBSURlY29kZXI7XG59KEFic3RyYWN0RXhwYW5kZWREZWNvZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQW55QUlEZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js":
/*!****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BlockParsedResult = /** @class */ (function () {\n    function BlockParsedResult(finished, decodedInformation) {\n        if (decodedInformation) {\n            this.decodedInformation = null;\n        }\n        else {\n            this.finished = finished;\n            this.decodedInformation = decodedInformation;\n        }\n    }\n    BlockParsedResult.prototype.getDecodedInformation = function () {\n        return this.decodedInformation;\n    };\n    BlockParsedResult.prototype.isFinished = function () {\n        return this.finished;\n    };\n    return BlockParsedResult;\n}());\nexports[\"default\"] = BlockParsedResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9CbG9ja1BhcnNlZFJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0Jsb2NrUGFyc2VkUmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJsb2NrUGFyc2VkUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJsb2NrUGFyc2VkUmVzdWx0KGZpbmlzaGVkLCBkZWNvZGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgaWYgKGRlY29kZWRJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVkSW5mb3JtYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVkSW5mb3JtYXRpb24gPSBkZWNvZGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgQmxvY2tQYXJzZWRSZXN1bHQucHJvdG90eXBlLmdldERlY29kZWRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uO1xuICAgIH07XG4gICAgQmxvY2tQYXJzZWRSZXN1bHQucHJvdG90eXBlLmlzRmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaGVkO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrUGFyc2VkUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrUGFyc2VkUmVzdWx0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js\");\nvar DecodedChar = /** @class */ (function (_super) {\n    __extends(DecodedChar, _super);\n    function DecodedChar(newPosition, value) {\n        var _this = _super.call(this, newPosition) || this;\n        _this.value = value;\n        return _this;\n    }\n    DecodedChar.prototype.getValue = function () {\n        return this.value;\n    };\n    DecodedChar.prototype.isFNC1 = function () {\n        return this.value === DecodedChar.FNC1;\n    };\n    DecodedChar.FNC1 = '$';\n    return DecodedChar;\n}(DecodedObject_1.default));\nexports[\"default\"] = DecodedChar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9EZWNvZGVkQ2hhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLHNLQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZENoYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWNvZGVkT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9EZWNvZGVkT2JqZWN0XCIpO1xudmFyIERlY29kZWRDaGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNvZGVkQ2hhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWNvZGVkQ2hhcihuZXdQb3NpdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3UG9zaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGVjb2RlZENoYXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZWRDaGFyLnByb3RvdHlwZS5pc0ZOQzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBEZWNvZGVkQ2hhci5GTkMxO1xuICAgIH07XG4gICAgRGVjb2RlZENoYXIuRk5DMSA9ICckJztcbiAgICByZXR1cm4gRGVjb2RlZENoYXI7XG59KERlY29kZWRPYmplY3RfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVkQ2hhcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js\");\nvar DecodedInformation = /** @class */ (function (_super) {\n    __extends(DecodedInformation, _super);\n    function DecodedInformation(newPosition, newString, remainingValue) {\n        var _this = _super.call(this, newPosition) || this;\n        if (remainingValue) {\n            _this.remaining = true;\n            _this.remainingValue = _this.remainingValue;\n        }\n        else {\n            _this.remaining = false;\n            _this.remainingValue = 0;\n        }\n        _this.newString = newString;\n        return _this;\n    }\n    DecodedInformation.prototype.getNewString = function () {\n        return this.newString;\n    };\n    DecodedInformation.prototype.isRemaining = function () {\n        return this.remaining;\n    };\n    DecodedInformation.prototype.getRemainingValue = function () {\n        return this.remainingValue;\n    };\n    return DecodedInformation;\n}(DecodedObject_1.default));\nexports[\"default\"] = DecodedInformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9EZWNvZGVkSW5mb3JtYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyxzS0FBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZEluZm9ybWF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVjb2RlZE9iamVjdF8xID0gcmVxdWlyZShcIi4vRGVjb2RlZE9iamVjdFwiKTtcbnZhciBEZWNvZGVkSW5mb3JtYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY29kZWRJbmZvcm1hdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWNvZGVkSW5mb3JtYXRpb24obmV3UG9zaXRpb24sIG5ld1N0cmluZywgcmVtYWluaW5nVmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3UG9zaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIGlmIChyZW1haW5pbmdWYWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMucmVtYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1ZhbHVlID0gX3RoaXMucmVtYWluaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1haW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1ZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uZXdTdHJpbmcgPSBuZXdTdHJpbmc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGVjb2RlZEluZm9ybWF0aW9uLnByb3RvdHlwZS5nZXROZXdTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld1N0cmluZztcbiAgICB9O1xuICAgIERlY29kZWRJbmZvcm1hdGlvbi5wcm90b3R5cGUuaXNSZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICB9O1xuICAgIERlY29kZWRJbmZvcm1hdGlvbi5wcm90b3R5cGUuZ2V0UmVtYWluaW5nVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZ1ZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29kZWRJbmZvcm1hdGlvbjtcbn0oRGVjb2RlZE9iamVjdF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZWRJbmZvcm1hdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js":
/*!*************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar FormatException_1 = __webpack_require__(/*! ../../../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js\");\nvar DecodedNumeric = /** @class */ (function (_super) {\n    __extends(DecodedNumeric, _super);\n    function DecodedNumeric(newPosition, firstDigit, secondDigit) {\n        var _this = _super.call(this, newPosition) || this;\n        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {\n            throw new FormatException_1.default();\n        }\n        _this.firstDigit = firstDigit;\n        _this.secondDigit = secondDigit;\n        return _this;\n    }\n    DecodedNumeric.prototype.getFirstDigit = function () {\n        return this.firstDigit;\n    };\n    DecodedNumeric.prototype.getSecondDigit = function () {\n        return this.secondDigit;\n    };\n    DecodedNumeric.prototype.getValue = function () {\n        return this.firstDigit * 10 + this.secondDigit;\n    };\n    DecodedNumeric.prototype.isFirstDigitFNC1 = function () {\n        return this.firstDigit === DecodedNumeric.FNC1;\n    };\n    DecodedNumeric.prototype.isSecondDigitFNC1 = function () {\n        return this.secondDigit === DecodedNumeric.FNC1;\n    };\n    DecodedNumeric.prototype.isAnyFNC1 = function () {\n        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;\n    };\n    DecodedNumeric.FNC1 = 10;\n    return DecodedNumeric;\n}(DecodedObject_1.default));\nexports[\"default\"] = DecodedNumeric;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9EZWNvZGVkTnVtZXJpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHlKQUE2QjtBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyxzS0FBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZE51bWVyaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9Gb3JtYXRFeGNlcHRpb25cIik7XG52YXIgRGVjb2RlZE9iamVjdF8xID0gcmVxdWlyZShcIi4vRGVjb2RlZE9iamVjdFwiKTtcbnZhciBEZWNvZGVkTnVtZXJpYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVjb2RlZE51bWVyaWMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVjb2RlZE51bWVyaWMobmV3UG9zaXRpb24sIGZpcnN0RGlnaXQsIHNlY29uZERpZ2l0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ld1Bvc2l0aW9uKSB8fCB0aGlzO1xuICAgICAgICBpZiAoZmlyc3REaWdpdCA8IDAgfHwgZmlyc3REaWdpdCA+IDEwIHx8IHNlY29uZERpZ2l0IDwgMCB8fCBzZWNvbmREaWdpdCA+IDEwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmZpcnN0RGlnaXQgPSBmaXJzdERpZ2l0O1xuICAgICAgICBfdGhpcy5zZWNvbmREaWdpdCA9IHNlY29uZERpZ2l0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlY29kZWROdW1lcmljLnByb3RvdHlwZS5nZXRGaXJzdERpZ2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0O1xuICAgIH07XG4gICAgRGVjb2RlZE51bWVyaWMucHJvdG90eXBlLmdldFNlY29uZERpZ2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdDtcbiAgICB9O1xuICAgIERlY29kZWROdW1lcmljLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdCAqIDEwICsgdGhpcy5zZWNvbmREaWdpdDtcbiAgICB9O1xuICAgIERlY29kZWROdW1lcmljLnByb3RvdHlwZS5pc0ZpcnN0RGlnaXRGTkMxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxO1xuICAgIH07XG4gICAgRGVjb2RlZE51bWVyaWMucHJvdG90eXBlLmlzU2Vjb25kRGlnaXRGTkMxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICB9O1xuICAgIERlY29kZWROdW1lcmljLnByb3RvdHlwZS5pc0FueUZOQzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzEgfHwgdGhpcy5zZWNvbmREaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICB9O1xuICAgIERlY29kZWROdW1lcmljLkZOQzEgPSAxMDtcbiAgICByZXR1cm4gRGVjb2RlZE51bWVyaWM7XG59KERlY29kZWRPYmplY3RfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVkTnVtZXJpYztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js":
/*!************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DecodedObject = /** @class */ (function () {\n    function DecodedObject(newPosition) {\n        this.newPosition = newPosition;\n    }\n    DecodedObject.prototype.getNewPosition = function () {\n        return this.newPosition;\n    };\n    return DecodedObject;\n}());\nexports[\"default\"] = DecodedObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9EZWNvZGVkT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZE9iamVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWNvZGVkT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY29kZWRPYmplY3QobmV3UG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgICBEZWNvZGVkT2JqZWN0LnByb3RvdHlwZS5nZXROZXdQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3UG9zaXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb2RlZE9iamVjdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVkT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar FieldParser = /** @class */ (function () {\n    function FieldParser() {\n    }\n    FieldParser.parseFieldsInGeneralPurpose = function (rawInformation) {\n        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n        if (!rawInformation) {\n            return null;\n        }\n        // Processing 2-digit AIs\n        if (rawInformation.length < 2) {\n            throw new NotFoundException_1.default();\n        }\n        var firstTwoDigits = rawInformation.substring(0, 2);\n        try {\n            for (var _e = __values(FieldParser.TWO_DIGIT_DATA_LENGTH), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var dataLength = _f.value;\n                if (dataLength[0] === firstTwoDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (rawInformation.length < 3) {\n            throw new NotFoundException_1.default();\n        }\n        var firstThreeDigits = rawInformation.substring(0, 3);\n        try {\n            for (var _g = __values(FieldParser.THREE_DIGIT_DATA_LENGTH), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var dataLength = _h.value;\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        try {\n            for (var _j = __values(FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), _k = _j.next(); !_k.done; _k = _j.next()) {\n                var dataLength = _k.value;\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        if (rawInformation.length < 4) {\n            throw new NotFoundException_1.default();\n        }\n        var firstFourDigits = rawInformation.substring(0, 4);\n        try {\n            for (var _l = __values(FieldParser.FOUR_DIGIT_DATA_LENGTH), _m = _l.next(); !_m.done; _m = _l.next()) {\n                var dataLength = _m.value;\n                if (dataLength[0] === firstFourDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        throw new NotFoundException_1.default();\n    };\n    FieldParser.processFixedAI = function (aiSize, fieldSize, rawInformation) {\n        if (rawInformation.length < aiSize) {\n            throw new NotFoundException_1.default();\n        }\n        var ai = rawInformation.substring(0, aiSize);\n        if (rawInformation.length < aiSize + fieldSize) {\n            throw new NotFoundException_1.default();\n        }\n        var field = rawInformation.substring(aiSize, aiSize + fieldSize);\n        var remaining = rawInformation.substring(aiSize + fieldSize);\n        var result = '(' + ai + ')' + field;\n        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n        return parsedAI == null ? result : result + parsedAI;\n    };\n    FieldParser.processVariableAI = function (aiSize, variableFieldSize, rawInformation) {\n        var ai = rawInformation.substring(0, aiSize);\n        var maxSize;\n        if (rawInformation.length < aiSize + variableFieldSize) {\n            maxSize = rawInformation.length;\n        }\n        else {\n            maxSize = aiSize + variableFieldSize;\n        }\n        var field = rawInformation.substring(aiSize, maxSize);\n        var remaining = rawInformation.substring(maxSize);\n        var result = '(' + ai + ')' + field;\n        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n        return parsedAI == null ? result : result + parsedAI;\n    };\n    FieldParser.VARIABLE_LENGTH = [];\n    FieldParser.TWO_DIGIT_DATA_LENGTH = [\n        ['00', 18],\n        ['01', 14],\n        ['02', 14],\n        ['10', FieldParser.VARIABLE_LENGTH, 20],\n        ['11', 6],\n        ['12', 6],\n        ['13', 6],\n        ['15', 6],\n        ['17', 6],\n        ['20', 2],\n        ['21', FieldParser.VARIABLE_LENGTH, 20],\n        ['22', FieldParser.VARIABLE_LENGTH, 29],\n        ['30', FieldParser.VARIABLE_LENGTH, 8],\n        ['37', FieldParser.VARIABLE_LENGTH, 8],\n        // internal company codes\n        ['90', FieldParser.VARIABLE_LENGTH, 30],\n        ['91', FieldParser.VARIABLE_LENGTH, 30],\n        ['92', FieldParser.VARIABLE_LENGTH, 30],\n        ['93', FieldParser.VARIABLE_LENGTH, 30],\n        ['94', FieldParser.VARIABLE_LENGTH, 30],\n        ['95', FieldParser.VARIABLE_LENGTH, 30],\n        ['96', FieldParser.VARIABLE_LENGTH, 30],\n        ['97', FieldParser.VARIABLE_LENGTH, 3],\n        ['98', FieldParser.VARIABLE_LENGTH, 30],\n        ['99', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.THREE_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['240', FieldParser.VARIABLE_LENGTH, 30],\n        ['241', FieldParser.VARIABLE_LENGTH, 30],\n        ['242', FieldParser.VARIABLE_LENGTH, 6],\n        ['250', FieldParser.VARIABLE_LENGTH, 30],\n        ['251', FieldParser.VARIABLE_LENGTH, 30],\n        ['253', FieldParser.VARIABLE_LENGTH, 17],\n        ['254', FieldParser.VARIABLE_LENGTH, 20],\n        ['400', FieldParser.VARIABLE_LENGTH, 30],\n        ['401', FieldParser.VARIABLE_LENGTH, 30],\n        ['402', 17],\n        ['403', FieldParser.VARIABLE_LENGTH, 30],\n        ['410', 13],\n        ['411', 13],\n        ['412', 13],\n        ['413', 13],\n        ['414', 13],\n        ['420', FieldParser.VARIABLE_LENGTH, 20],\n        ['421', FieldParser.VARIABLE_LENGTH, 15],\n        ['422', 3],\n        ['423', FieldParser.VARIABLE_LENGTH, 15],\n        ['424', 3],\n        ['425', 3],\n        ['426', 3],\n    ];\n    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['310', 6],\n        ['311', 6],\n        ['312', 6],\n        ['313', 6],\n        ['314', 6],\n        ['315', 6],\n        ['316', 6],\n        ['320', 6],\n        ['321', 6],\n        ['322', 6],\n        ['323', 6],\n        ['324', 6],\n        ['325', 6],\n        ['326', 6],\n        ['327', 6],\n        ['328', 6],\n        ['329', 6],\n        ['330', 6],\n        ['331', 6],\n        ['332', 6],\n        ['333', 6],\n        ['334', 6],\n        ['335', 6],\n        ['336', 6],\n        ['340', 6],\n        ['341', 6],\n        ['342', 6],\n        ['343', 6],\n        ['344', 6],\n        ['345', 6],\n        ['346', 6],\n        ['347', 6],\n        ['348', 6],\n        ['349', 6],\n        ['350', 6],\n        ['351', 6],\n        ['352', 6],\n        ['353', 6],\n        ['354', 6],\n        ['355', 6],\n        ['356', 6],\n        ['357', 6],\n        ['360', 6],\n        ['361', 6],\n        ['362', 6],\n        ['363', 6],\n        ['364', 6],\n        ['365', 6],\n        ['366', 6],\n        ['367', 6],\n        ['368', 6],\n        ['369', 6],\n        ['390', FieldParser.VARIABLE_LENGTH, 15],\n        ['391', FieldParser.VARIABLE_LENGTH, 18],\n        ['392', FieldParser.VARIABLE_LENGTH, 15],\n        ['393', FieldParser.VARIABLE_LENGTH, 18],\n        ['703', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.FOUR_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['7001', 13],\n        ['7002', FieldParser.VARIABLE_LENGTH, 30],\n        ['7003', 10],\n        ['8001', 14],\n        ['8002', FieldParser.VARIABLE_LENGTH, 20],\n        ['8003', FieldParser.VARIABLE_LENGTH, 30],\n        ['8004', FieldParser.VARIABLE_LENGTH, 30],\n        ['8005', 6],\n        ['8006', 18],\n        ['8007', FieldParser.VARIABLE_LENGTH, 30],\n        ['8008', FieldParser.VARIABLE_LENGTH, 12],\n        ['8018', 18],\n        ['8020', FieldParser.VARIABLE_LENGTH, 25],\n        ['8100', 6],\n        ['8101', 10],\n        ['8102', 2],\n        ['8110', FieldParser.VARIABLE_LENGTH, 70],\n        ['8200', FieldParser.VARIABLE_LENGTH, 70],\n    ];\n    return FieldParser;\n}());\nexports[\"default\"] = FieldParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9GaWVsZFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyw2SkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixVQUFVO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvR0FBb0csVUFBVTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRmllbGRQYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbnZhciBGaWVsZFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWVsZFBhcnNlcigpIHtcbiAgICB9XG4gICAgRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlID0gZnVuY3Rpb24gKHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jLCBlXzQsIF9kO1xuICAgICAgICBpZiAoIXJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9jZXNzaW5nIDItZGlnaXQgQUlzXG4gICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0VHdvRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhGaWVsZFBhcnNlci5UV09fRElHSVRfREFUQV9MRU5HVEgpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUd29EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDIsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMiwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYSA9IF9lLnJldHVybikpIF9hLmNhbGwoX2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0VGhyZWVEaWdpdHMgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgMyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZyA9IF9fdmFsdWVzKEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX0RBVEFfTEVOR1RIKSwgX2ggPSBfZy5uZXh0KCk7ICFfaC5kb25lOyBfaCA9IF9nLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VGhyZWVEaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDMsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMywgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oICYmICFfaC5kb25lICYmIChfYiA9IF9nLnJldHVybikpIF9iLmNhbGwoX2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IF9fdmFsdWVzKEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX1BMVVNfRElHSVRfREFUQV9MRU5HVEgpLCBfayA9IF9qLm5leHQoKTsgIV9rLmRvbmU7IF9rID0gX2oubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBfay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUaHJlZURpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSg0LCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2sgJiYgIV9rLmRvbmUgJiYgKF9jID0gX2oucmV0dXJuKSkgX2MuY2FsbChfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RGb3VyRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2wgPSBfX3ZhbHVlcyhGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIKSwgX20gPSBfbC5uZXh0KCk7ICFfbS5kb25lOyBfbSA9IF9sLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gX20udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0Rm91ckRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSg0LCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX20gJiYgIV9tLmRvbmUgJiYgKF9kID0gX2wucmV0dXJuKSkgX2QuY2FsbChfbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkgPSBmdW5jdGlvbiAoYWlTaXplLCBmaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCBhaVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWkgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgYWlTaXplKTtcbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSArIGZpZWxkU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZCA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUsIGFpU2l6ZSArIGZpZWxkU2l6ZSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplICsgZmllbGRTaXplKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcoJyArIGFpICsgJyknICsgZmllbGQ7XG4gICAgICAgIHZhciBwYXJzZWRBSSA9IEZpZWxkUGFyc2VyLnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShyZW1haW5pbmcpO1xuICAgICAgICByZXR1cm4gcGFyc2VkQUkgPT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCArIHBhcnNlZEFJO1xuICAgIH07XG4gICAgRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkgPSBmdW5jdGlvbiAoYWlTaXplLCB2YXJpYWJsZUZpZWxkU2l6ZSwgcmF3SW5mb3JtYXRpb24pIHtcbiAgICAgICAgdmFyIGFpID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIGFpU2l6ZSk7XG4gICAgICAgIHZhciBtYXhTaXplO1xuICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgYWlTaXplICsgdmFyaWFibGVGaWVsZFNpemUpIHtcbiAgICAgICAgICAgIG1heFNpemUgPSByYXdJbmZvcm1hdGlvbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhTaXplID0gYWlTaXplICsgdmFyaWFibGVGaWVsZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKGFpU2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcobWF4U2l6ZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSAnKCcgKyBhaSArICcpJyArIGZpZWxkO1xuICAgICAgICB2YXIgcGFyc2VkQUkgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmVtYWluaW5nKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEFJID09IG51bGwgPyByZXN1bHQgOiByZXN1bHQgKyBwYXJzZWRBSTtcbiAgICB9O1xuICAgIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCA9IFtdO1xuICAgIEZpZWxkUGFyc2VyLlRXT19ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgWycwMCcsIDE4XSxcbiAgICAgICAgWycwMScsIDE0XSxcbiAgICAgICAgWycwMicsIDE0XSxcbiAgICAgICAgWycxMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzExJywgNl0sXG4gICAgICAgIFsnMTInLCA2XSxcbiAgICAgICAgWycxMycsIDZdLFxuICAgICAgICBbJzE1JywgNl0sXG4gICAgICAgIFsnMTcnLCA2XSxcbiAgICAgICAgWycyMCcsIDJdLFxuICAgICAgICBbJzIxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnMjInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI5XSxcbiAgICAgICAgWyczMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgOF0sXG4gICAgICAgIFsnMzcnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDhdLFxuICAgICAgICAvLyBpbnRlcm5hbCBjb21wYW55IGNvZGVzXG4gICAgICAgIFsnOTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk1JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTYnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgM10sXG4gICAgICAgIFsnOTgnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5OScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgIF07XG4gICAgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMjQwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjQyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA2XSxcbiAgICAgICAgWycyNTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE3XSxcbiAgICAgICAgWycyNTQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MDAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MDInLCAxN10sXG4gICAgICAgIFsnNDAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNDEwJywgMTNdLFxuICAgICAgICBbJzQxMScsIDEzXSxcbiAgICAgICAgWyc0MTInLCAxM10sXG4gICAgICAgIFsnNDEzJywgMTNdLFxuICAgICAgICBbJzQxNCcsIDEzXSxcbiAgICAgICAgWyc0MjAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc0MjEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjInLCAzXSxcbiAgICAgICAgWyc0MjMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyc0MjQnLCAzXSxcbiAgICAgICAgWyc0MjUnLCAzXSxcbiAgICAgICAgWyc0MjYnLCAzXSxcbiAgICBdO1xuICAgIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX1BMVVNfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnMzEwJywgNl0sXG4gICAgICAgIFsnMzExJywgNl0sXG4gICAgICAgIFsnMzEyJywgNl0sXG4gICAgICAgIFsnMzEzJywgNl0sXG4gICAgICAgIFsnMzE0JywgNl0sXG4gICAgICAgIFsnMzE1JywgNl0sXG4gICAgICAgIFsnMzE2JywgNl0sXG4gICAgICAgIFsnMzIwJywgNl0sXG4gICAgICAgIFsnMzIxJywgNl0sXG4gICAgICAgIFsnMzIyJywgNl0sXG4gICAgICAgIFsnMzIzJywgNl0sXG4gICAgICAgIFsnMzI0JywgNl0sXG4gICAgICAgIFsnMzI1JywgNl0sXG4gICAgICAgIFsnMzI2JywgNl0sXG4gICAgICAgIFsnMzI3JywgNl0sXG4gICAgICAgIFsnMzI4JywgNl0sXG4gICAgICAgIFsnMzI5JywgNl0sXG4gICAgICAgIFsnMzMwJywgNl0sXG4gICAgICAgIFsnMzMxJywgNl0sXG4gICAgICAgIFsnMzMyJywgNl0sXG4gICAgICAgIFsnMzMzJywgNl0sXG4gICAgICAgIFsnMzM0JywgNl0sXG4gICAgICAgIFsnMzM1JywgNl0sXG4gICAgICAgIFsnMzM2JywgNl0sXG4gICAgICAgIFsnMzQwJywgNl0sXG4gICAgICAgIFsnMzQxJywgNl0sXG4gICAgICAgIFsnMzQyJywgNl0sXG4gICAgICAgIFsnMzQzJywgNl0sXG4gICAgICAgIFsnMzQ0JywgNl0sXG4gICAgICAgIFsnMzQ1JywgNl0sXG4gICAgICAgIFsnMzQ2JywgNl0sXG4gICAgICAgIFsnMzQ3JywgNl0sXG4gICAgICAgIFsnMzQ4JywgNl0sXG4gICAgICAgIFsnMzQ5JywgNl0sXG4gICAgICAgIFsnMzUwJywgNl0sXG4gICAgICAgIFsnMzUxJywgNl0sXG4gICAgICAgIFsnMzUyJywgNl0sXG4gICAgICAgIFsnMzUzJywgNl0sXG4gICAgICAgIFsnMzU0JywgNl0sXG4gICAgICAgIFsnMzU1JywgNl0sXG4gICAgICAgIFsnMzU2JywgNl0sXG4gICAgICAgIFsnMzU3JywgNl0sXG4gICAgICAgIFsnMzYwJywgNl0sXG4gICAgICAgIFsnMzYxJywgNl0sXG4gICAgICAgIFsnMzYyJywgNl0sXG4gICAgICAgIFsnMzYzJywgNl0sXG4gICAgICAgIFsnMzY0JywgNl0sXG4gICAgICAgIFsnMzY1JywgNl0sXG4gICAgICAgIFsnMzY2JywgNl0sXG4gICAgICAgIFsnMzY3JywgNl0sXG4gICAgICAgIFsnMzY4JywgNl0sXG4gICAgICAgIFsnMzY5JywgNl0sXG4gICAgICAgIFsnMzkwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnMzkyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnMzkzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXG4gICAgICAgIFsnNzAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgXTtcbiAgICBGaWVsZFBhcnNlci5GT1VSX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxuICAgICAgICBbJzcwMDEnLCAxM10sXG4gICAgICAgIFsnNzAwMicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzcwMDMnLCAxMF0sXG4gICAgICAgIFsnODAwMScsIDE0XSxcbiAgICAgICAgWyc4MDAyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnODAwMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzgwMDQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc4MDA1JywgNl0sXG4gICAgICAgIFsnODAwNicsIDE4XSxcbiAgICAgICAgWyc4MDA3JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnODAwOCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTJdLFxuICAgICAgICBbJzgwMTgnLCAxOF0sXG4gICAgICAgIFsnODAyMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjVdLFxuICAgICAgICBbJzgxMDAnLCA2XSxcbiAgICAgICAgWyc4MTAxJywgMTBdLFxuICAgICAgICBbJzgxMDInLCAyXSxcbiAgICAgICAgWyc4MTEwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA3MF0sXG4gICAgICAgIFsnODIwMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNzBdLFxuICAgIF07XG4gICAgcmV0dXJuIEZpZWxkUGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZpZWxkUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js":
/*!******************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar FormatException_1 = __webpack_require__(/*! ../../../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../../../../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar BlockParsedResult_1 = __webpack_require__(/*! ./BlockParsedResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js\");\nvar DecodedChar_1 = __webpack_require__(/*! ./DecodedChar */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js\");\nvar DecodedInformation_1 = __webpack_require__(/*! ./DecodedInformation */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js\");\nvar DecodedNumeric_1 = __webpack_require__(/*! ./DecodedNumeric */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js\");\nvar FieldParser_1 = __webpack_require__(/*! ./FieldParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js\");\nvar GeneralAppIdDecoder = /** @class */ (function () {\n    function GeneralAppIdDecoder(information) {\n        this.buffer = new StringBuilder_1.default();\n        this.information = information;\n    }\n    GeneralAppIdDecoder.prototype.decodeAllCodes = function (buff, initialPosition) {\n        var currentPosition = initialPosition;\n        var remaining = null;\n        do {\n            var info = this.decodeGeneralPurposeField(currentPosition, remaining);\n            var parsedFields = FieldParser_1.default.parseFieldsInGeneralPurpose(info.getNewString());\n            if (parsedFields != null) {\n                buff.append(parsedFields);\n            }\n            if (info.isRemaining()) {\n                remaining = '' + info.getRemainingValue();\n            }\n            else {\n                remaining = null;\n            }\n            if (currentPosition === info.getNewPosition()) { // No step forward!\n                break;\n            }\n            currentPosition = info.getNewPosition();\n        } while (true);\n        return buff.toString();\n    };\n    GeneralAppIdDecoder.prototype.isStillNumeric = function (pos) {\n        // It's numeric if it still has 7 positions\n        // and one of the first 4 bits is \"1\".\n        if (pos + 7 > this.information.getSize()) {\n            return pos + 4 <= this.information.getSize();\n        }\n        for (var i = pos; i < pos + 3; ++i) {\n            if (this.information.get(i)) {\n                return true;\n            }\n        }\n        return this.information.get(pos + 3);\n    };\n    GeneralAppIdDecoder.prototype.decodeNumeric = function (pos) {\n        if (pos + 7 > this.information.getSize()) {\n            var numeric_1 = this.extractNumericValueFromBitArray(pos, 4);\n            if (numeric_1 === 0) {\n                return new DecodedNumeric_1.default(this.information.getSize(), DecodedNumeric_1.default.FNC1, DecodedNumeric_1.default.FNC1);\n            }\n            return new DecodedNumeric_1.default(this.information.getSize(), numeric_1 - 1, DecodedNumeric_1.default.FNC1);\n        }\n        var numeric = this.extractNumericValueFromBitArray(pos, 7);\n        var digit1 = (numeric - 8) / 11;\n        var digit2 = (numeric - 8) % 11;\n        return new DecodedNumeric_1.default(pos + 7, digit1, digit2);\n    };\n    GeneralAppIdDecoder.prototype.extractNumericValueFromBitArray = function (pos, bits) {\n        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);\n    };\n    GeneralAppIdDecoder.extractNumericValueFromBitArray = function (information, pos, bits) {\n        var value = 0;\n        for (var i = 0; i < bits; ++i) {\n            if (information.get(pos + i)) {\n                value |= 1 << (bits - i - 1);\n            }\n        }\n        return value;\n    };\n    GeneralAppIdDecoder.prototype.decodeGeneralPurposeField = function (pos, remaining) {\n        // this.buffer.setLength(0);\n        this.buffer.setLengthToZero();\n        if (remaining != null) {\n            this.buffer.append(remaining);\n        }\n        this.current.setPosition(pos);\n        var lastDecoded = this.parseBlocks();\n        if (lastDecoded != null && lastDecoded.isRemaining()) {\n            return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());\n        }\n        return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());\n    };\n    GeneralAppIdDecoder.prototype.parseBlocks = function () {\n        var isFinished;\n        var result;\n        do {\n            var initialPosition = this.current.getPosition();\n            if (this.current.isAlpha()) {\n                result = this.parseAlphaBlock();\n                isFinished = result.isFinished();\n            }\n            else if (this.current.isIsoIec646()) {\n                result = this.parseIsoIec646Block();\n                isFinished = result.isFinished();\n            }\n            else { // it must be numeric\n                result = this.parseNumericBlock();\n                isFinished = result.isFinished();\n            }\n            var positionChanged = initialPosition !== this.current.getPosition();\n            if (!positionChanged && !isFinished) {\n                break;\n            }\n        } while (!isFinished);\n        return result.getDecodedInformation();\n    };\n    GeneralAppIdDecoder.prototype.parseNumericBlock = function () {\n        while (this.isStillNumeric(this.current.getPosition())) {\n            var numeric = this.decodeNumeric(this.current.getPosition());\n            this.current.setPosition(numeric.getNewPosition());\n            if (numeric.isFirstDigitFNC1()) {\n                var information = void 0;\n                if (numeric.isSecondDigitFNC1()) {\n                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());\n                }\n                else {\n                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());\n                }\n                return new BlockParsedResult_1.default(true, information);\n            }\n            this.buffer.append(numeric.getFirstDigit());\n            if (numeric.isSecondDigitFNC1()) {\n                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());\n                return new BlockParsedResult_1.default(true, information);\n            }\n            this.buffer.append(numeric.getSecondDigit());\n        }\n        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {\n            this.current.setAlpha();\n            this.current.incrementPosition(4);\n        }\n        return new BlockParsedResult_1.default(false);\n    };\n    GeneralAppIdDecoder.prototype.parseIsoIec646Block = function () {\n        while (this.isStillIsoIec646(this.current.getPosition())) {\n            var iso = this.decodeIsoIec646(this.current.getPosition());\n            this.current.setPosition(iso.getNewPosition());\n            if (iso.isFNC1()) {\n                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());\n                return new BlockParsedResult_1.default(true, information);\n            }\n            this.buffer.append(iso.getValue());\n        }\n        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n            this.current.incrementPosition(3);\n            this.current.setNumeric();\n        }\n        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n            if (this.current.getPosition() + 5 < this.information.getSize()) {\n                this.current.incrementPosition(5);\n            }\n            else {\n                this.current.setPosition(this.information.getSize());\n            }\n            this.current.setAlpha();\n        }\n        return new BlockParsedResult_1.default(false);\n    };\n    GeneralAppIdDecoder.prototype.parseAlphaBlock = function () {\n        while (this.isStillAlpha(this.current.getPosition())) {\n            var alpha = this.decodeAlphanumeric(this.current.getPosition());\n            this.current.setPosition(alpha.getNewPosition());\n            if (alpha.isFNC1()) {\n                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());\n                return new BlockParsedResult_1.default(true, information); // end of the char block\n            }\n            this.buffer.append(alpha.getValue());\n        }\n        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n            this.current.incrementPosition(3);\n            this.current.setNumeric();\n        }\n        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n            if (this.current.getPosition() + 5 < this.information.getSize()) {\n                this.current.incrementPosition(5);\n            }\n            else {\n                this.current.setPosition(this.information.getSize());\n            }\n            this.current.setIsoIec646();\n        }\n        return new BlockParsedResult_1.default(false);\n    };\n    GeneralAppIdDecoder.prototype.isStillIsoIec646 = function (pos) {\n        if (pos + 5 > this.information.getSize()) {\n            return false;\n        }\n        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n        if (fiveBitValue >= 5 && fiveBitValue < 16) {\n            return true;\n        }\n        if (pos + 7 > this.information.getSize()) {\n            return false;\n        }\n        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n        if (sevenBitValue >= 64 && sevenBitValue < 116) {\n            return true;\n        }\n        if (pos + 8 > this.information.getSize()) {\n            return false;\n        }\n        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n        return eightBitValue >= 232 && eightBitValue < 253;\n    };\n    GeneralAppIdDecoder.prototype.decodeIsoIec646 = function (pos) {\n        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n        if (fiveBitValue === 15) {\n            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);\n        }\n        if (fiveBitValue >= 5 && fiveBitValue < 15) {\n            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));\n        }\n        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n        if (sevenBitValue >= 64 && sevenBitValue < 90) {\n            return new DecodedChar_1.default(pos + 7, ('' + (sevenBitValue + 1)));\n        }\n        if (sevenBitValue >= 90 && sevenBitValue < 116) {\n            return new DecodedChar_1.default(pos + 7, ('' + (sevenBitValue + 7)));\n        }\n        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n        var c;\n        switch (eightBitValue) {\n            case 232:\n                c = '!';\n                break;\n            case 233:\n                c = '\"';\n                break;\n            case 234:\n                c = '%';\n                break;\n            case 235:\n                c = '&';\n                break;\n            case 236:\n                c = '\\'';\n                break;\n            case 237:\n                c = '(';\n                break;\n            case 238:\n                c = ')';\n                break;\n            case 239:\n                c = '*';\n                break;\n            case 240:\n                c = '+';\n                break;\n            case 241:\n                c = ',';\n                break;\n            case 242:\n                c = '-';\n                break;\n            case 243:\n                c = '.';\n                break;\n            case 244:\n                c = '/';\n                break;\n            case 245:\n                c = ':';\n                break;\n            case 246:\n                c = ';';\n                break;\n            case 247:\n                c = '<';\n                break;\n            case 248:\n                c = '=';\n                break;\n            case 249:\n                c = '>';\n                break;\n            case 250:\n                c = '?';\n                break;\n            case 251:\n                c = '_';\n                break;\n            case 252:\n                c = ' ';\n                break;\n            default:\n                throw new FormatException_1.default();\n        }\n        return new DecodedChar_1.default(pos + 8, c);\n    };\n    GeneralAppIdDecoder.prototype.isStillAlpha = function (pos) {\n        if (pos + 5 > this.information.getSize()) {\n            return false;\n        }\n        // We now check if it's a valid 5-bit value (0..9 and FNC1)\n        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n        if (fiveBitValue >= 5 && fiveBitValue < 16) {\n            return true;\n        }\n        if (pos + 6 > this.information.getSize()) {\n            return false;\n        }\n        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n        return sixBitValue >= 16 && sixBitValue < 63; // 63 not included\n    };\n    GeneralAppIdDecoder.prototype.decodeAlphanumeric = function (pos) {\n        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n        if (fiveBitValue === 15) {\n            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);\n        }\n        if (fiveBitValue >= 5 && fiveBitValue < 15) {\n            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));\n        }\n        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n        if (sixBitValue >= 32 && sixBitValue < 58) {\n            return new DecodedChar_1.default(pos + 6, ('' + (sixBitValue + 33)));\n        }\n        var c;\n        switch (sixBitValue) {\n            case 58:\n                c = '*';\n                break;\n            case 59:\n                c = ',';\n                break;\n            case 60:\n                c = '-';\n                break;\n            case 61:\n                c = '.';\n                break;\n            case 62:\n                c = '/';\n                break;\n            default:\n                throw new IllegalStateException_1.default('Decoding invalid alphanumeric value: ' + sixBitValue);\n        }\n        return new DecodedChar_1.default(pos + 6, c);\n    };\n    GeneralAppIdDecoder.prototype.isAlphaTo646ToAlphaLatch = function (pos) {\n        if (pos + 1 > this.information.getSize()) {\n            return false;\n        }\n        for (var i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {\n            if (i === 2) {\n                if (!this.information.get(pos + 2)) {\n                    return false;\n                }\n            }\n            else if (this.information.get(pos + i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    GeneralAppIdDecoder.prototype.isAlphaOr646ToNumericLatch = function (pos) {\n        // Next is alphanumeric if there are 3 positions and they are all zeros\n        if (pos + 3 > this.information.getSize()) {\n            return false;\n        }\n        for (var i = pos; i < pos + 3; ++i) {\n            if (this.information.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    GeneralAppIdDecoder.prototype.isNumericToAlphaNumericLatch = function (pos) {\n        // Next is alphanumeric if there are 4 positions and they are all zeros, or\n        // if there is a subset of this just before the end of the symbol\n        if (pos + 1 > this.information.getSize()) {\n            return false;\n        }\n        for (var i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {\n            if (this.information.get(pos + i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return GeneralAppIdDecoder;\n}());\nexports[\"default\"] = GeneralAppIdDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9HZW5lcmFsQXBwSWREZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHlKQUE2QjtBQUM3RCw4QkFBOEIsbUJBQU8sQ0FBQyxxS0FBbUM7QUFDekUsc0JBQXNCLG1CQUFPLENBQUMsK0pBQWdDO0FBQzlELDBCQUEwQixtQkFBTyxDQUFDLDhLQUFxQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxrS0FBZTtBQUMzQywyQkFBMkIsbUJBQU8sQ0FBQyxnTEFBc0I7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsd0tBQWtCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLGtLQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQStDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUErQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9HZW5lcmFsQXBwSWREZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9JbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbnZhciBCbG9ja1BhcnNlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4vQmxvY2tQYXJzZWRSZXN1bHRcIik7XG52YXIgRGVjb2RlZENoYXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRDaGFyXCIpO1xudmFyIERlY29kZWRJbmZvcm1hdGlvbl8xID0gcmVxdWlyZShcIi4vRGVjb2RlZEluZm9ybWF0aW9uXCIpO1xudmFyIERlY29kZWROdW1lcmljXzEgPSByZXF1aXJlKFwiLi9EZWNvZGVkTnVtZXJpY1wiKTtcbnZhciBGaWVsZFBhcnNlcl8xID0gcmVxdWlyZShcIi4vRmllbGRQYXJzZXJcIik7XG52YXIgR2VuZXJhbEFwcElkRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHZW5lcmFsQXBwSWREZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbjtcbiAgICB9XG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQWxsQ29kZXMgPSBmdW5jdGlvbiAoYnVmZiwgaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChjdXJyZW50UG9zaXRpb24sIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkRmllbGRzID0gRmllbGRQYXJzZXJfMS5kZWZhdWx0LnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShpbmZvLmdldE5ld1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJ1ZmYuYXBwZW5kKHBhcnNlZEZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5mby5pc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gJycgKyBpbmZvLmdldFJlbWFpbmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gaW5mby5nZXROZXdQb3NpdGlvbigpKSB7IC8vIE5vIHN0ZXAgZm9yd2FyZCFcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGluZm8uZ2V0TmV3UG9zaXRpb24oKTtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5pc1N0aWxsTnVtZXJpYyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgLy8gSXQncyBudW1lcmljIGlmIGl0IHN0aWxsIGhhcyA3IHBvc2l0aW9uc1xuICAgICAgICAvLyBhbmQgb25lIG9mIHRoZSBmaXJzdCA0IGJpdHMgaXMgXCIxXCIuXG4gICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3MgKyA0IDw9IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBwb3MgKyAzOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyAzKTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmRlY29kZU51bWVyaWMgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHZhciBudW1lcmljXzEgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA0KTtcbiAgICAgICAgICAgIGlmIChudW1lcmljXzEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljXzEuZGVmYXVsdCh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgRGVjb2RlZE51bWVyaWNfMS5kZWZhdWx0LkZOQzEsIERlY29kZWROdW1lcmljXzEuZGVmYXVsdC5GTkMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWNfMS5kZWZhdWx0KHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpLCBudW1lcmljXzEgLSAxLCBEZWNvZGVkTnVtZXJpY18xLmRlZmF1bHQuRk5DMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWVyaWMgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA3KTtcbiAgICAgICAgdmFyIGRpZ2l0MSA9IChudW1lcmljIC0gOCkgLyAxMTtcbiAgICAgICAgdmFyIGRpZ2l0MiA9IChudW1lcmljIC0gOCkgJSAxMTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkTnVtZXJpY18xLmRlZmF1bHQocG9zICsgNywgZGlnaXQxLCBkaWdpdDIpO1xuICAgIH07XG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheSA9IGZ1bmN0aW9uIChwb3MsIGJpdHMpIHtcbiAgICAgICAgcmV0dXJuIEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheSh0aGlzLmluZm9ybWF0aW9uLCBwb3MsIGJpdHMpO1xuICAgIH07XG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5ID0gZnVuY3Rpb24gKGluZm9ybWF0aW9uLCBwb3MsIGJpdHMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSB8PSAxIDw8IChiaXRzIC0gaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQgPSBmdW5jdGlvbiAocG9zLCByZW1haW5pbmcpIHtcbiAgICAgICAgLy8gdGhpcy5idWZmZXIuc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zZXRMZW5ndGhUb1plcm8oKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQocmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24ocG9zKTtcbiAgICAgICAgdmFyIGxhc3REZWNvZGVkID0gdGhpcy5wYXJzZUJsb2NrcygpO1xuICAgICAgICBpZiAobGFzdERlY29kZWQgIT0gbnVsbCAmJiBsYXN0RGVjb2RlZC5pc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRJbmZvcm1hdGlvbl8xLmRlZmF1bHQodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCksIGxhc3REZWNvZGVkLmdldFJlbWFpbmluZ1ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5wYXJzZUJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzRmluaXNoZWQ7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaXNBbHBoYSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFscGhhQmxvY2soKTtcbiAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudC5pc0lzb0llYzY0NigpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUlzb0llYzY0NkJsb2NrKCk7XG4gICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHJlc3VsdC5pc0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gaXQgbXVzdCBiZSBudW1lcmljXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZU51bWVyaWNCbG9jaygpO1xuICAgICAgICAgICAgICAgIGlzRmluaXNoZWQgPSByZXN1bHQuaXNGaW5pc2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQ2hhbmdlZCA9IGluaXRpYWxQb3NpdGlvbiAhPT0gdGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uQ2hhbmdlZCAmJiAhaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghaXNGaW5pc2hlZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZ2V0RGVjb2RlZEluZm9ybWF0aW9uKCk7XG4gICAgfTtcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5wYXJzZU51bWVyaWNCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbE51bWVyaWModGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICB2YXIgbnVtZXJpYyA9IHRoaXMuZGVjb2RlTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24obnVtZXJpYy5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljLmlzRmlyc3REaWdpdEZOQzEoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvcm1hdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc1NlY29uZERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbl8xLmRlZmF1bHQodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSwgbnVtZXJpYy5nZXRTZWNvbmREaWdpdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0Rmlyc3REaWdpdCgpKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljLmlzU2Vjb25kRGlnaXRGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKG51bWVyaWMuZ2V0U2Vjb25kRGlnaXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRBbHBoYSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHRfMS5kZWZhdWx0KGZhbHNlKTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLnBhcnNlSXNvSWVjNjQ2QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzU3RpbGxJc29JZWM2NDYodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICB2YXIgaXNvID0gdGhpcy5kZWNvZGVJc29JZWM2NDYodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKGlzby5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIGlmIChpc28uaXNGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGlzby5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXROdW1lcmljKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkgKyA1IDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24odGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldEFscGhhKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQoZmFsc2UpO1xuICAgIH07XG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUucGFyc2VBbHBoYUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsQWxwaGEodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmRlY29kZUFscGhhbnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24oYWxwaGEuZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICBpZiAoYWxwaGEuaXNGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pOyAvLyBlbmQgb2YgdGhlIGNoYXIgYmxvY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChhbHBoYS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbigzKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXROdW1lcmljKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkgKyA1IDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24odGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldElzb0llYzY0NigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHRfMS5kZWZhdWx0KGZhbHNlKTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmlzU3RpbGxJc29JZWM2NDYgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyArIDcgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXZlbkJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgKyA4ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICByZXR1cm4gZWlnaHRCaXRWYWx1ZSA+PSAyMzIgJiYgZWlnaHRCaXRWYWx1ZSA8IDI1MztcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmRlY29kZUlzb0llYzY0NiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIGZpdmVCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDUpO1xuICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID09PSAxNSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgNSwgRGVjb2RlZENoYXJfMS5kZWZhdWx0LkZOQzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgNSwgKCcwJyArIChmaXZlQml0VmFsdWUgLSA1KSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXZlbkJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCA5MCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgNywgKCcnICsgKHNldmVuQml0VmFsdWUgKyAxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDkwICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDcsICgnJyArIChzZXZlbkJpdFZhbHVlICsgNykpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgc3dpdGNoIChlaWdodEJpdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIDIzMjpcbiAgICAgICAgICAgICAgICBjID0gJyEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMzM6XG4gICAgICAgICAgICAgICAgYyA9ICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzNDpcbiAgICAgICAgICAgICAgICBjID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMzU6XG4gICAgICAgICAgICAgICAgYyA9ICcmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjM2OlxuICAgICAgICAgICAgICAgIGMgPSAnXFwnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjM3OlxuICAgICAgICAgICAgICAgIGMgPSAnKCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzODpcbiAgICAgICAgICAgICAgICBjID0gJyknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMzk6XG4gICAgICAgICAgICAgICAgYyA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQwOlxuICAgICAgICAgICAgICAgIGMgPSAnKyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0MTpcbiAgICAgICAgICAgICAgICBjID0gJywnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDI6XG4gICAgICAgICAgICAgICAgYyA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQzOlxuICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0NDpcbiAgICAgICAgICAgICAgICBjID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDU6XG4gICAgICAgICAgICAgICAgYyA9ICc6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ2OlxuICAgICAgICAgICAgICAgIGMgPSAnOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0NzpcbiAgICAgICAgICAgICAgICBjID0gJzwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgICAgICAgYyA9ICc9JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ5OlxuICAgICAgICAgICAgICAgIGMgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1MDpcbiAgICAgICAgICAgICAgICBjID0gJz8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTE6XG4gICAgICAgICAgICAgICAgYyA9ICdfJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjUyOlxuICAgICAgICAgICAgICAgIGMgPSAnICc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgOCwgYyk7XG4gICAgfTtcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5pc1N0aWxsQWxwaGEgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBub3cgY2hlY2sgaWYgaXQncyBhIHZhbGlkIDUtYml0IHZhbHVlICgwLi45IGFuZCBGTkMxKVxuICAgICAgICB2YXIgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyArIDYgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXhCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDYpO1xuICAgICAgICByZXR1cm4gc2l4Qml0VmFsdWUgPj0gMTYgJiYgc2l4Qml0VmFsdWUgPCA2MzsgLy8gNjMgbm90IGluY2x1ZGVkXG4gICAgfTtcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVBbHBoYW51bWVyaWMgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcbiAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PT0gMTUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDUsIERlY29kZWRDaGFyXzEuZGVmYXVsdC5GTkMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDUsICgnMCcgKyAoZml2ZUJpdFZhbHVlIC0gNSkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l4Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA2KTtcbiAgICAgICAgaWYgKHNpeEJpdFZhbHVlID49IDMyICYmIHNpeEJpdFZhbHVlIDwgNTgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDYsICgnJyArIChzaXhCaXRWYWx1ZSArIDMzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjO1xuICAgICAgICBzd2l0Y2ggKHNpeEJpdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgIGMgPSAnKic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICAgIGMgPSAnLCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICAgIGMgPSAnLSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICAgIGMgPSAnLyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCdEZWNvZGluZyBpbnZhbGlkIGFscGhhbnVtZXJpYyB2YWx1ZTogJyArIHNpeEJpdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyXzEuZGVmYXVsdChwb3MgKyA2LCBjKTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyArIDEgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNSAmJiBpICsgcG9zIDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAvLyBOZXh0IGlzIGFscGhhbnVtZXJpYyBpZiB0aGVyZSBhcmUgMyBwb3NpdGlvbnMgYW5kIHRoZXkgYXJlIGFsbCB6ZXJvc1xuICAgICAgICBpZiAocG9zICsgMyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IHBvcyArIDM7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgLy8gTmV4dCBpcyBhbHBoYW51bWVyaWMgaWYgdGhlcmUgYXJlIDQgcG9zaXRpb25zIGFuZCB0aGV5IGFyZSBhbGwgemVyb3MsIG9yXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2V0IG9mIHRoaXMganVzdCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc3ltYm9sXG4gICAgICAgIGlmIChwb3MgKyAxID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgaSArIHBvcyA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBHZW5lcmFsQXBwSWREZWNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEdlbmVyYWxBcHBJZERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2009 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n// package com.google.zxing.pdf417;\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import java.util.Arrays;\nvar Arrays_1 = __webpack_require__(/*! ../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\n// import java.util.Collection;\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = __webpack_require__(/*! ../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\n/**\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author Guenther Grau\n */\nvar PDF417Common = /** @class */ (function () {\n    function PDF417Common() {\n    }\n    PDF417Common.prototype.PDF417Common = function () {\n    };\n    /**\n     * @param moduleBitCount values to sum\n     * @return sum of values\n     * @deprecated call {@link MathUtils#sum(int[])}\n     */\n    // @Deprecated\n    PDF417Common.getBitCountSum = function (moduleBitCount) {\n        return MathUtils_1.default.sum(moduleBitCount);\n    };\n    PDF417Common.toIntArray = function (list) {\n        var e_1, _a;\n        if (list == null || !list.length) {\n            return PDF417Common.EMPTY_INT_ARRAY;\n        }\n        var result = new Int32Array(list.length);\n        var i = 0;\n        try {\n            for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {\n                var integer = list_1_1.value;\n                result[i++] = integer;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    /**\n     * @param symbol encoded symbol to translate to a codeword\n     * @return the codeword corresponding to the symbol.\n     */\n    PDF417Common.getCodeword = function (symbol /*int*/) {\n        var i = Arrays_1.default.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);\n        if (i < 0) {\n            return -1;\n        }\n        return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;\n    };\n    PDF417Common.NUMBER_OF_CODEWORDS = 929;\n    // Maximum Codewords (Data + Error).\n    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;\n    PDF417Common.MIN_ROWS_IN_BARCODE = 3;\n    PDF417Common.MAX_ROWS_IN_BARCODE = 90;\n    // One left row indication column + max 30 data columns + one right row indicator column\n    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;\n    PDF417Common.MODULES_IN_CODEWORD = 17;\n    PDF417Common.MODULES_IN_STOP_PATTERN = 18;\n    PDF417Common.BARS_IN_MODULE = 8;\n    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);\n    /**\n     * The sorted table of all possible symbols. Extracted from the PDF417\n     * specification. The index of a symbol in this table corresponds to the\n     * index into the codeword table.\n     */\n    PDF417Common.SYMBOL_TABLE = Int32Array.from([\n        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,\n        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,\n        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,\n        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,\n        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,\n        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,\n        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,\n        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,\n        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,\n        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,\n        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,\n        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,\n        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,\n        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,\n        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,\n        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,\n        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,\n        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,\n        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,\n        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,\n        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,\n        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,\n        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,\n        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,\n        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,\n        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,\n        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,\n        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,\n        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,\n        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,\n        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,\n        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,\n        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,\n        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,\n        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,\n        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,\n        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,\n        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,\n        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,\n        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,\n        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,\n        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,\n        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,\n        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,\n        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,\n        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,\n        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,\n        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,\n        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,\n        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,\n        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,\n        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,\n        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,\n        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,\n        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,\n        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,\n        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,\n        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,\n        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,\n        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,\n        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,\n        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,\n        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,\n        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,\n        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,\n        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,\n        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,\n        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,\n        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,\n        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,\n        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,\n        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,\n        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,\n        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,\n        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,\n        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,\n        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,\n        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,\n        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,\n        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,\n        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,\n        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,\n        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,\n        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,\n        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,\n        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,\n        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,\n        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,\n        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,\n        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,\n        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,\n        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,\n        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,\n        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,\n        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,\n        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,\n        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,\n        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,\n        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,\n        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,\n        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,\n        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,\n        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,\n        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,\n        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,\n        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,\n        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,\n        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,\n        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,\n        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,\n        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,\n        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,\n        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,\n        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,\n        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,\n        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,\n        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,\n        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,\n        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,\n        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,\n        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,\n        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,\n        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,\n        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,\n        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,\n        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,\n        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,\n        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,\n        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,\n        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,\n        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,\n        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,\n        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,\n        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,\n        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,\n        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,\n        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,\n        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,\n        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,\n        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,\n        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,\n        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,\n        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,\n        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,\n        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,\n        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,\n        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,\n        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,\n        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,\n        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,\n        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,\n        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,\n        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,\n        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,\n        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,\n        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,\n        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,\n        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,\n        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,\n        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,\n        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,\n        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,\n        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,\n        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,\n        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,\n        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,\n        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,\n        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,\n        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,\n        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,\n        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,\n        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,\n        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,\n        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,\n        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,\n        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,\n        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,\n        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,\n        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,\n        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,\n        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,\n        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,\n        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,\n        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,\n        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,\n        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,\n        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,\n        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,\n        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,\n        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,\n        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,\n        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,\n        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,\n        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,\n        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,\n        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,\n        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,\n        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,\n        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,\n        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,\n        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,\n        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,\n        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,\n        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,\n        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,\n        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,\n        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,\n        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,\n        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,\n        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,\n        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,\n        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,\n        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,\n        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,\n        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,\n        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,\n        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,\n        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,\n        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,\n        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,\n        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,\n        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,\n        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,\n        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,\n        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,\n        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,\n        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,\n        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,\n        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,\n        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,\n        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,\n        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,\n        0x1fba8, 0x1fbb6, 0x1fbda\n    ]);\n    /**\n     * This table contains to codewords for all symbols.\n     */\n    PDF417Common.CODEWORD_TABLE = Int32Array.from([\n        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,\n        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,\n        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,\n        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,\n        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,\n        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,\n        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,\n        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,\n        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,\n        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,\n        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,\n        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,\n        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,\n        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,\n        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,\n        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,\n        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,\n        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,\n        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,\n        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,\n        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,\n        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,\n        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,\n        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,\n        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,\n        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,\n        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,\n        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,\n        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,\n        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,\n        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,\n        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,\n        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,\n        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,\n        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,\n        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,\n        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,\n        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,\n        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,\n        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,\n        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,\n        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,\n        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,\n        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,\n        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,\n        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,\n        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,\n        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,\n        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,\n        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,\n        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,\n        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,\n        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,\n        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,\n        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,\n        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,\n        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,\n        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,\n        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,\n        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,\n        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,\n        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,\n        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,\n        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,\n        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,\n        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,\n        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,\n        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,\n        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,\n        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,\n        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,\n        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,\n        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,\n        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,\n        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,\n        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,\n        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,\n        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,\n        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,\n        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,\n        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,\n        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,\n        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,\n        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,\n        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,\n        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,\n        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,\n        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,\n        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,\n        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,\n        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,\n        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,\n        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,\n        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,\n        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,\n        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,\n        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,\n        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,\n        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,\n        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,\n        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,\n        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,\n        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,\n        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,\n        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,\n        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,\n        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,\n        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,\n        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,\n        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,\n        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,\n        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,\n        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,\n        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,\n        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,\n        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,\n        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,\n        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,\n        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,\n        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,\n        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,\n        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,\n        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,\n        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,\n        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,\n        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,\n        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,\n        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,\n        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,\n        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,\n        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,\n        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,\n        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,\n        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,\n        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,\n        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,\n        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,\n        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,\n        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,\n        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700\n    ]);\n    return PDF417Common;\n}());\nexports[\"default\"] = PDF417Common;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvUERGNDE3Q29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0lBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxvS0FBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGdCQUFnQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvUERGNDE3Q29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNztcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJyYXlzXCIpO1xuLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLmRldGVjdG9yLk1hdGhVdGlscztcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzXCIpO1xuLyoqXG4gKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gKi9cbnZhciBQREY0MTdDb21tb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUERGNDE3Q29tbW9uKCkge1xuICAgIH1cbiAgICBQREY0MTdDb21tb24ucHJvdG90eXBlLlBERjQxN0NvbW1vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtb2R1bGVCaXRDb3VudCB2YWx1ZXMgdG8gc3VtXG4gICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzXG4gICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XG4gICAgICovXG4gICAgLy8gQERlcHJlY2F0ZWRcbiAgICBQREY0MTdDb21tb24uZ2V0Qml0Q291bnRTdW0gPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICB9O1xuICAgIFBERjQxN0NvbW1vbi50b0ludEFycmF5ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChsaXN0ID09IG51bGwgfHwgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uLkVNUFRZX0lOVF9BUlJBWTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobGlzdC5sZW5ndGgpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0XzEgPSBfX3ZhbHVlcyhsaXN0KSwgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpOyAhbGlzdF8xXzEuZG9uZTsgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVnZXIgPSBsaXN0XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGludGVnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0XzFfMSAmJiAhbGlzdF8xXzEuZG9uZSAmJiAoX2EgPSBsaXN0XzEucmV0dXJuKSkgX2EuY2FsbChsaXN0XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc3ltYm9sIGVuY29kZWQgc3ltYm9sIHRvIHRyYW5zbGF0ZSB0byBhIGNvZGV3b3JkXG4gICAgICogQHJldHVybiB0aGUgY29kZXdvcmQgY29ycmVzcG9uZGluZyB0byB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZCA9IGZ1bmN0aW9uIChzeW1ib2wgLyppbnQqLykge1xuICAgICAgICB2YXIgaSA9IEFycmF5c18xLmRlZmF1bHQuYmluYXJ5U2VhcmNoKFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUsIHN5bWJvbCAmIDB4M0ZGRkYpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFBERjQxN0NvbW1vbi5DT0RFV09SRF9UQUJMRVtpXSAtIDEpICUgUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFM7XG4gICAgfTtcbiAgICBQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUyA9IDkyOTtcbiAgICAvLyBNYXhpbXVtIENvZGV3b3JkcyAoRGF0YSArIEVycm9yKS5cbiAgICBQREY0MTdDb21tb24uTUFYX0NPREVXT1JEU19JTl9CQVJDT0RFID0gUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMgLSAxO1xuICAgIFBERjQxN0NvbW1vbi5NSU5fUk9XU19JTl9CQVJDT0RFID0gMztcbiAgICBQREY0MTdDb21tb24uTUFYX1JPV1NfSU5fQkFSQ09ERSA9IDkwO1xuICAgIC8vIE9uZSBsZWZ0IHJvdyBpbmRpY2F0aW9uIGNvbHVtbiArIG1heCAzMCBkYXRhIGNvbHVtbnMgKyBvbmUgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW5cbiAgICAvLyBwdWJsaWMgc3RhdGljIC8qZmluYWwqLyBNQVhfQ09ERVdPUkRTX0lOX1JPVzogLyppbnQqLyBudW1iZXIgPSAzMjtcbiAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCA9IDE3O1xuICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiA9IDE4O1xuICAgIFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSA9IDg7XG4gICAgUERGNDE3Q29tbW9uLkVNUFRZX0lOVF9BUlJBWSA9IG5ldyBJbnQzMkFycmF5KFtdKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc29ydGVkIHRhYmxlIG9mIGFsbCBwb3NzaWJsZSBzeW1ib2xzLiBFeHRyYWN0ZWQgZnJvbSB0aGUgUERGNDE3XG4gICAgICogc3BlY2lmaWNhdGlvbi4gVGhlIGluZGV4IG9mIGEgc3ltYm9sIGluIHRoaXMgdGFibGUgY29ycmVzcG9uZHMgdG8gdGhlXG4gICAgICogaW5kZXggaW50byB0aGUgY29kZXdvcmQgdGFibGUuXG4gICAgICovXG4gICAgUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDB4MTAyNWUsIDB4MTAyN2EsIDB4MTAyOWUsIDB4MTAyYmMsIDB4MTAyZjIsIDB4MTAyZjQsIDB4MTAzMmUsIDB4MTAzNGUsIDB4MTAzNWMsIDB4MTAzOTYsIDB4MTAzYTYsIDB4MTAzYWMsXG4gICAgICAgIDB4MTA0MjIsIDB4MTA0MjgsIDB4MTA0MzYsIDB4MTA0NDIsIDB4MTA0NDQsIDB4MTA0NDgsIDB4MTA0NTAsIDB4MTA0NWUsIDB4MTA0NjYsIDB4MTA0NmMsIDB4MTA0N2EsIDB4MTA0ODIsXG4gICAgICAgIDB4MTA0OWUsIDB4MTA0YTAsIDB4MTA0YmMsIDB4MTA0YzYsIDB4MTA0ZDgsIDB4MTA0ZWUsIDB4MTA0ZjIsIDB4MTA0ZjQsIDB4MTA1MDQsIDB4MTA1MDgsIDB4MTA1MTAsIDB4MTA1MWUsXG4gICAgICAgIDB4MTA1MjAsIDB4MTA1M2MsIDB4MTA1NDAsIDB4MTA1NzgsIDB4MTA1ODYsIDB4MTA1OGMsIDB4MTA1OTgsIDB4MTA1YjAsIDB4MTA1YmUsIDB4MTA1Y2UsIDB4MTA1ZGMsIDB4MTA1ZTIsXG4gICAgICAgIDB4MTA1ZTQsIDB4MTA1ZTgsIDB4MTA1ZjYsIDB4MTA2MmUsIDB4MTA2NGUsIDB4MTA2NWMsIDB4MTA2OGUsIDB4MTA2OWMsIDB4MTA2YjgsIDB4MTA2ZGUsIDB4MTA2ZmEsIDB4MTA3MTYsXG4gICAgICAgIDB4MTA3MjYsIDB4MTA3MmMsIDB4MTA3NDYsIDB4MTA3NGMsIDB4MTA3NTgsIDB4MTA3NmUsIDB4MTA3OTIsIDB4MTA3OTQsIDB4MTA3YTIsIDB4MTA3YTQsIDB4MTA3YTgsIDB4MTA3YjYsXG4gICAgICAgIDB4MTA4MjIsIDB4MTA4MjgsIDB4MTA4NDIsIDB4MTA4NDgsIDB4MTA4NTAsIDB4MTA4NWUsIDB4MTA4NjYsIDB4MTA4NmMsIDB4MTA4N2EsIDB4MTA4ODIsIDB4MTA4ODQsIDB4MTA4OTAsXG4gICAgICAgIDB4MTA4OWUsIDB4MTA4YTAsIDB4MTA4YmMsIDB4MTA4YzYsIDB4MTA4Y2MsIDB4MTA4ZDgsIDB4MTA4ZWUsIDB4MTA4ZjIsIDB4MTA4ZjQsIDB4MTA5MDIsIDB4MTA5MDgsIDB4MTA5MWUsXG4gICAgICAgIDB4MTA5MjAsIDB4MTA5M2MsIDB4MTA5NDAsIDB4MTA5NzgsIDB4MTA5ODYsIDB4MTA5OTgsIDB4MTA5YjAsIDB4MTA5YmUsIDB4MTA5Y2UsIDB4MTA5ZGMsIDB4MTA5ZTIsIDB4MTA5ZTQsXG4gICAgICAgIDB4MTA5ZTgsIDB4MTA5ZjYsIDB4MTBhMDgsIDB4MTBhMTAsIDB4MTBhMWUsIDB4MTBhMjAsIDB4MTBhM2MsIDB4MTBhNDAsIDB4MTBhNzgsIDB4MTBhZjAsIDB4MTBiMDYsIDB4MTBiMGMsXG4gICAgICAgIDB4MTBiMTgsIDB4MTBiMzAsIDB4MTBiM2UsIDB4MTBiNjAsIDB4MTBiN2MsIDB4MTBiOGUsIDB4MTBiOWMsIDB4MTBiYjgsIDB4MTBiYzIsIDB4MTBiYzQsIDB4MTBiYzgsIDB4MTBiZDAsXG4gICAgICAgIDB4MTBiZGUsIDB4MTBiZTYsIDB4MTBiZWMsIDB4MTBjMmUsIDB4MTBjNGUsIDB4MTBjNWMsIDB4MTBjNjIsIDB4MTBjNjQsIDB4MTBjNjgsIDB4MTBjNzYsIDB4MTBjOGUsIDB4MTBjOWMsXG4gICAgICAgIDB4MTBjYjgsIDB4MTBjYzIsIDB4MTBjYzQsIDB4MTBjYzgsIDB4MTBjZDAsIDB4MTBjZGUsIDB4MTBjZTYsIDB4MTBjZWMsIDB4MTBjZmEsIDB4MTBkMGUsIDB4MTBkMWMsIDB4MTBkMzgsXG4gICAgICAgIDB4MTBkNzAsIDB4MTBkN2UsIDB4MTBkODIsIDB4MTBkODQsIDB4MTBkODgsIDB4MTBkOTAsIDB4MTBkOWUsIDB4MTBkYTAsIDB4MTBkYmMsIDB4MTBkYzYsIDB4MTBkY2MsIDB4MTBkZDgsXG4gICAgICAgIDB4MTBkZWUsIDB4MTBkZjIsIDB4MTBkZjQsIDB4MTBlMTYsIDB4MTBlMjYsIDB4MTBlMmMsIDB4MTBlNDYsIDB4MTBlNTgsIDB4MTBlNmUsIDB4MTBlODYsIDB4MTBlOGMsIDB4MTBlOTgsXG4gICAgICAgIDB4MTBlYjAsIDB4MTBlYmUsIDB4MTBlY2UsIDB4MTBlZGMsIDB4MTBmMGEsIDB4MTBmMTIsIDB4MTBmMTQsIDB4MTBmMjIsIDB4MTBmMjgsIDB4MTBmMzYsIDB4MTBmNDIsIDB4MTBmNDQsXG4gICAgICAgIDB4MTBmNDgsIDB4MTBmNTAsIDB4MTBmNWUsIDB4MTBmNjYsIDB4MTBmNmMsIDB4MTBmYjIsIDB4MTBmYjQsIDB4MTEwMjIsIDB4MTEwMjgsIDB4MTEwNDIsIDB4MTEwNDgsIDB4MTEwNTAsXG4gICAgICAgIDB4MTEwNWUsIDB4MTEwN2EsIDB4MTEwODIsIDB4MTEwODQsIDB4MTEwOTAsIDB4MTEwOWUsIDB4MTEwYTAsIDB4MTEwYmMsIDB4MTEwYzYsIDB4MTEwY2MsIDB4MTEwZDgsIDB4MTEwZWUsXG4gICAgICAgIDB4MTEwZjIsIDB4MTEwZjQsIDB4MTExMDIsIDB4MTExMWUsIDB4MTExMjAsIDB4MTExM2MsIDB4MTExNDAsIDB4MTExNzgsIDB4MTExODYsIDB4MTExOTgsIDB4MTExYjAsIDB4MTExYmUsXG4gICAgICAgIDB4MTExY2UsIDB4MTExZGMsIDB4MTExZTIsIDB4MTExZTQsIDB4MTExZTgsIDB4MTExZjYsIDB4MTEyMDgsIDB4MTEyMWUsIDB4MTEyMjAsIDB4MTEyNzgsIDB4MTEyZjAsIDB4MTEzMGMsXG4gICAgICAgIDB4MTEzMzAsIDB4MTEzM2UsIDB4MTEzNjAsIDB4MTEzN2MsIDB4MTEzOGUsIDB4MTEzOWMsIDB4MTEzYjgsIDB4MTEzYzIsIDB4MTEzYzgsIDB4MTEzZDAsIDB4MTEzZGUsIDB4MTEzZTYsXG4gICAgICAgIDB4MTEzZWMsIDB4MTE0MDgsIDB4MTE0MTAsIDB4MTE0MWUsIDB4MTE0MjAsIDB4MTE0M2MsIDB4MTE0NDAsIDB4MTE0NzgsIDB4MTE0ZjAsIDB4MTE1ZTAsIDB4MTE2MGMsIDB4MTE2MTgsXG4gICAgICAgIDB4MTE2MzAsIDB4MTE2M2UsIDB4MTE2NjAsIDB4MTE2N2MsIDB4MTE2YzAsIDB4MTE2ZjgsIDB4MTE3MWMsIDB4MTE3MzgsIDB4MTE3NzAsIDB4MTE3N2UsIDB4MTE3ODIsIDB4MTE3ODQsXG4gICAgICAgIDB4MTE3ODgsIDB4MTE3OTAsIDB4MTE3OWUsIDB4MTE3YTAsIDB4MTE3YmMsIDB4MTE3YzYsIDB4MTE3Y2MsIDB4MTE3ZDgsIDB4MTE3ZWUsIDB4MTE4MmUsIDB4MTE4MzQsIDB4MTE4NGUsXG4gICAgICAgIDB4MTE4NWMsIDB4MTE4NjIsIDB4MTE4NjQsIDB4MTE4NjgsIDB4MTE4NzYsIDB4MTE4OGUsIDB4MTE4OWMsIDB4MTE4YjgsIDB4MTE4YzIsIDB4MTE4YzgsIDB4MTE4ZDAsIDB4MTE4ZGUsXG4gICAgICAgIDB4MTE4ZTYsIDB4MTE4ZWMsIDB4MTE4ZmEsIDB4MTE5MGUsIDB4MTE5MWMsIDB4MTE5MzgsIDB4MTE5NzAsIDB4MTE5N2UsIDB4MTE5ODIsIDB4MTE5ODQsIDB4MTE5OTAsIDB4MTE5OWUsXG4gICAgICAgIDB4MTE5YTAsIDB4MTE5YmMsIDB4MTE5YzYsIDB4MTE5Y2MsIDB4MTE5ZDgsIDB4MTE5ZWUsIDB4MTE5ZjIsIDB4MTE5ZjQsIDB4MTFhMGUsIDB4MTFhMWMsIDB4MTFhMzgsIDB4MTFhNzAsXG4gICAgICAgIDB4MTFhN2UsIDB4MTFhZTAsIDB4MTFhZmMsIDB4MTFiMDgsIDB4MTFiMTAsIDB4MTFiMWUsIDB4MTFiMjAsIDB4MTFiM2MsIDB4MTFiNDAsIDB4MTFiNzgsIDB4MTFiOGMsIDB4MTFiOTgsXG4gICAgICAgIDB4MTFiYjAsIDB4MTFiYmUsIDB4MTFiY2UsIDB4MTFiZGMsIDB4MTFiZTIsIDB4MTFiZTQsIDB4MTFiZTgsIDB4MTFiZjYsIDB4MTFjMTYsIDB4MTFjMjYsIDB4MTFjMmMsIDB4MTFjNDYsXG4gICAgICAgIDB4MTFjNGMsIDB4MTFjNTgsIDB4MTFjNmUsIDB4MTFjODYsIDB4MTFjOTgsIDB4MTFjYjAsIDB4MTFjYmUsIDB4MTFjY2UsIDB4MTFjZGMsIDB4MTFjZTIsIDB4MTFjZTQsIDB4MTFjZTgsXG4gICAgICAgIDB4MTFjZjYsIDB4MTFkMDYsIDB4MTFkMGMsIDB4MTFkMTgsIDB4MTFkMzAsIDB4MTFkM2UsIDB4MTFkNjAsIDB4MTFkN2MsIDB4MTFkOGUsIDB4MTFkOWMsIDB4MTFkYjgsIDB4MTFkYzQsXG4gICAgICAgIDB4MTFkYzgsIDB4MTFkZDAsIDB4MTFkZGUsIDB4MTFkZTYsIDB4MTFkZWMsIDB4MTFkZmEsIDB4MTFlMGEsIDB4MTFlMTIsIDB4MTFlMTQsIDB4MTFlMjIsIDB4MTFlMjQsIDB4MTFlMjgsXG4gICAgICAgIDB4MTFlMzYsIDB4MTFlNDIsIDB4MTFlNDQsIDB4MTFlNTAsIDB4MTFlNWUsIDB4MTFlNjYsIDB4MTFlNmMsIDB4MTFlODIsIDB4MTFlODQsIDB4MTFlODgsIDB4MTFlOTAsIDB4MTFlOWUsXG4gICAgICAgIDB4MTFlYTAsIDB4MTFlYmMsIDB4MTFlYzYsIDB4MTFlY2MsIDB4MTFlZDgsIDB4MTFlZWUsIDB4MTFmMWEsIDB4MTFmMmUsIDB4MTFmMzIsIDB4MTFmMzQsIDB4MTFmNGUsIDB4MTFmNWMsXG4gICAgICAgIDB4MTFmNjIsIDB4MTFmNjQsIDB4MTFmNjgsIDB4MTFmNzYsIDB4MTIwNDgsIDB4MTIwNWUsIDB4MTIwODIsIDB4MTIwODQsIDB4MTIwOTAsIDB4MTIwOWUsIDB4MTIwYTAsIDB4MTIwYmMsXG4gICAgICAgIDB4MTIwZDgsIDB4MTIwZjIsIDB4MTIwZjQsIDB4MTIxMDgsIDB4MTIxMWUsIDB4MTIxMjAsIDB4MTIxM2MsIDB4MTIxNDAsIDB4MTIxNzgsIDB4MTIxODYsIDB4MTIxOTgsIDB4MTIxYjAsXG4gICAgICAgIDB4MTIxYmUsIDB4MTIxZTIsIDB4MTIxZTQsIDB4MTIxZTgsIDB4MTIxZjYsIDB4MTIyMDQsIDB4MTIyMTAsIDB4MTIyMWUsIDB4MTIyMjAsIDB4MTIyNzgsIDB4MTIyZjAsIDB4MTIzMDYsXG4gICAgICAgIDB4MTIzMGMsIDB4MTIzMzAsIDB4MTIzM2UsIDB4MTIzNjAsIDB4MTIzN2MsIDB4MTIzOGUsIDB4MTIzOWMsIDB4MTIzYjgsIDB4MTIzYzIsIDB4MTIzYzgsIDB4MTIzZDAsIDB4MTIzZTYsXG4gICAgICAgIDB4MTIzZWMsIDB4MTI0MWUsIDB4MTI0MjAsIDB4MTI0M2MsIDB4MTI0ZjAsIDB4MTI1ZTAsIDB4MTI2MTgsIDB4MTI2M2UsIDB4MTI2NjAsIDB4MTI2N2MsIDB4MTI2YzAsIDB4MTI2ZjgsXG4gICAgICAgIDB4MTI3MzgsIDB4MTI3NzAsIDB4MTI3N2UsIDB4MTI3ODIsIDB4MTI3ODQsIDB4MTI3OTAsIDB4MTI3OWUsIDB4MTI3YTAsIDB4MTI3YmMsIDB4MTI3YzYsIDB4MTI3Y2MsIDB4MTI3ZDgsXG4gICAgICAgIDB4MTI3ZWUsIDB4MTI4MjAsIDB4MTI4M2MsIDB4MTI4NDAsIDB4MTI4NzgsIDB4MTI4ZjAsIDB4MTI5ZTAsIDB4MTJiYzAsIDB4MTJjMTgsIDB4MTJjMzAsIDB4MTJjM2UsIDB4MTJjNjAsXG4gICAgICAgIDB4MTJjN2MsIDB4MTJjYzAsIDB4MTJjZjgsIDB4MTJkZjAsIDB4MTJlMWMsIDB4MTJlMzgsIDB4MTJlNzAsIDB4MTJlN2UsIDB4MTJlZTAsIDB4MTJlZmMsIDB4MTJmMDQsIDB4MTJmMDgsXG4gICAgICAgIDB4MTJmMTAsIDB4MTJmMjAsIDB4MTJmM2MsIDB4MTJmNDAsIDB4MTJmNzgsIDB4MTJmODYsIDB4MTJmOGMsIDB4MTJmOTgsIDB4MTJmYjAsIDB4MTJmYmUsIDB4MTJmY2UsIDB4MTJmZGMsXG4gICAgICAgIDB4MTMwMmUsIDB4MTMwNGUsIDB4MTMwNWMsIDB4MTMwNjIsIDB4MTMwNjgsIDB4MTMwOGUsIDB4MTMwOWMsIDB4MTMwYjgsIDB4MTMwYzIsIDB4MTMwYzgsIDB4MTMwZDAsIDB4MTMwZGUsXG4gICAgICAgIDB4MTMwZWMsIDB4MTMwZmEsIDB4MTMxMGUsIDB4MTMxMzgsIDB4MTMxNzAsIDB4MTMxN2UsIDB4MTMxODIsIDB4MTMxODQsIDB4MTMxOTAsIDB4MTMxOWUsIDB4MTMxYTAsIDB4MTMxYmMsXG4gICAgICAgIDB4MTMxYzYsIDB4MTMxY2MsIDB4MTMxZDgsIDB4MTMxZjIsIDB4MTMxZjQsIDB4MTMyMGUsIDB4MTMyMWMsIDB4MTMyNzAsIDB4MTMyN2UsIDB4MTMyZTAsIDB4MTMyZmMsIDB4MTMzMDgsXG4gICAgICAgIDB4MTMzMWUsIDB4MTMzMjAsIDB4MTMzM2MsIDB4MTMzNDAsIDB4MTMzNzgsIDB4MTMzODYsIDB4MTMzOTgsIDB4MTMzYjAsIDB4MTMzYmUsIDB4MTMzY2UsIDB4MTMzZGMsIDB4MTMzZTIsXG4gICAgICAgIDB4MTMzZTQsIDB4MTMzZTgsIDB4MTMzZjYsIDB4MTM0MGUsIDB4MTM0MWMsIDB4MTM0MzgsIDB4MTM0NzAsIDB4MTM0N2UsIDB4MTM0ZTAsIDB4MTM0ZmMsIDB4MTM1YzAsIDB4MTM1ZjgsXG4gICAgICAgIDB4MTM2MDgsIDB4MTM2MTAsIDB4MTM2MWUsIDB4MTM2MjAsIDB4MTM2M2MsIDB4MTM2NDAsIDB4MTM2NzgsIDB4MTM2ZjAsIDB4MTM3MGMsIDB4MTM3MTgsIDB4MTM3MzAsIDB4MTM3M2UsXG4gICAgICAgIDB4MTM3NjAsIDB4MTM3N2MsIDB4MTM3OWMsIDB4MTM3YjgsIDB4MTM3YzIsIDB4MTM3YzQsIDB4MTM3YzgsIDB4MTM3ZDAsIDB4MTM3ZGUsIDB4MTM3ZTYsIDB4MTM3ZWMsIDB4MTM4MTYsXG4gICAgICAgIDB4MTM4MjYsIDB4MTM4MmMsIDB4MTM4NDYsIDB4MTM4NGMsIDB4MTM4NTgsIDB4MTM4NmUsIDB4MTM4NzQsIDB4MTM4ODYsIDB4MTM4OTgsIDB4MTM4YjAsIDB4MTM4YmUsIDB4MTM4Y2UsXG4gICAgICAgIDB4MTM4ZGMsIDB4MTM4ZTIsIDB4MTM4ZTQsIDB4MTM4ZTgsIDB4MTM5MDYsIDB4MTM5MGMsIDB4MTM5MzAsIDB4MTM5M2UsIDB4MTM5NjAsIDB4MTM5N2MsIDB4MTM5OGUsIDB4MTM5OWMsXG4gICAgICAgIDB4MTM5YjgsIDB4MTM5YzgsIDB4MTM5ZDAsIDB4MTM5ZGUsIDB4MTM5ZTYsIDB4MTM5ZWMsIDB4MTM5ZmEsIDB4MTNhMDYsIDB4MTNhMGMsIDB4MTNhMTgsIDB4MTNhMzAsIDB4MTNhM2UsXG4gICAgICAgIDB4MTNhNjAsIDB4MTNhN2MsIDB4MTNhYzAsIDB4MTNhZjgsIDB4MTNiMGUsIDB4MTNiMWMsIDB4MTNiMzgsIDB4MTNiNzAsIDB4MTNiN2UsIDB4MTNiODgsIDB4MTNiOTAsIDB4MTNiOWUsXG4gICAgICAgIDB4MTNiYTAsIDB4MTNiYmMsIDB4MTNiY2MsIDB4MTNiZDgsIDB4MTNiZWUsIDB4MTNiZjIsIDB4MTNiZjQsIDB4MTNjMTIsIDB4MTNjMTQsIDB4MTNjMjIsIDB4MTNjMjQsIDB4MTNjMjgsXG4gICAgICAgIDB4MTNjMzYsIDB4MTNjNDIsIDB4MTNjNDgsIDB4MTNjNTAsIDB4MTNjNWUsIDB4MTNjNjYsIDB4MTNjNmMsIDB4MTNjODIsIDB4MTNjODQsIDB4MTNjOTAsIDB4MTNjOWUsIDB4MTNjYTAsXG4gICAgICAgIDB4MTNjYmMsIDB4MTNjYzYsIDB4MTNjY2MsIDB4MTNjZDgsIDB4MTNjZWUsIDB4MTNkMDIsIDB4MTNkMDQsIDB4MTNkMDgsIDB4MTNkMTAsIDB4MTNkMWUsIDB4MTNkMjAsIDB4MTNkM2MsXG4gICAgICAgIDB4MTNkNDAsIDB4MTNkNzgsIDB4MTNkODYsIDB4MTNkOGMsIDB4MTNkOTgsIDB4MTNkYjAsIDB4MTNkYmUsIDB4MTNkY2UsIDB4MTNkZGMsIDB4MTNkZTQsIDB4MTNkZTgsIDB4MTNkZjYsXG4gICAgICAgIDB4MTNlMWEsIDB4MTNlMmUsIDB4MTNlMzIsIDB4MTNlMzQsIDB4MTNlNGUsIDB4MTNlNWMsIDB4MTNlNjIsIDB4MTNlNjQsIDB4MTNlNjgsIDB4MTNlNzYsIDB4MTNlOGUsIDB4MTNlOWMsXG4gICAgICAgIDB4MTNlYjgsIDB4MTNlYzIsIDB4MTNlYzQsIDB4MTNlYzgsIDB4MTNlZDAsIDB4MTNlZGUsIDB4MTNlZTYsIDB4MTNlZWMsIDB4MTNmMjYsIDB4MTNmMmMsIDB4MTNmM2EsIDB4MTNmNDYsXG4gICAgICAgIDB4MTNmNGMsIDB4MTNmNTgsIDB4MTNmNmUsIDB4MTNmNzIsIDB4MTNmNzQsIDB4MTQwODIsIDB4MTQwOWUsIDB4MTQwYTAsIDB4MTQwYmMsIDB4MTQxMDQsIDB4MTQxMDgsIDB4MTQxMTAsXG4gICAgICAgIDB4MTQxMWUsIDB4MTQxMjAsIDB4MTQxM2MsIDB4MTQxNDAsIDB4MTQxNzgsIDB4MTQxOGMsIDB4MTQxOTgsIDB4MTQxYjAsIDB4MTQxYmUsIDB4MTQxZTIsIDB4MTQxZTQsIDB4MTQxZTgsXG4gICAgICAgIDB4MTQyMDgsIDB4MTQyMTAsIDB4MTQyMWUsIDB4MTQyMjAsIDB4MTQyM2MsIDB4MTQyNDAsIDB4MTQyNzgsIDB4MTQyZjAsIDB4MTQzMDYsIDB4MTQzMGMsIDB4MTQzMTgsIDB4MTQzMzAsXG4gICAgICAgIDB4MTQzM2UsIDB4MTQzNjAsIDB4MTQzN2MsIDB4MTQzOGUsIDB4MTQzYzIsIDB4MTQzYzQsIDB4MTQzYzgsIDB4MTQzZDAsIDB4MTQzZTYsIDB4MTQzZWMsIDB4MTQ0MDgsIDB4MTQ0MTAsXG4gICAgICAgIDB4MTQ0MWUsIDB4MTQ0MjAsIDB4MTQ0M2MsIDB4MTQ0NDAsIDB4MTQ0NzgsIDB4MTQ0ZjAsIDB4MTQ1ZTAsIDB4MTQ2MGMsIDB4MTQ2MTgsIDB4MTQ2MzAsIDB4MTQ2M2UsIDB4MTQ2NjAsXG4gICAgICAgIDB4MTQ2N2MsIDB4MTQ2YzAsIDB4MTQ2ZjgsIDB4MTQ3MWMsIDB4MTQ3MzgsIDB4MTQ3NzAsIDB4MTQ3N2UsIDB4MTQ3ODIsIDB4MTQ3ODQsIDB4MTQ3ODgsIDB4MTQ3OTAsIDB4MTQ3YTAsXG4gICAgICAgIDB4MTQ3YmMsIDB4MTQ3YzYsIDB4MTQ3Y2MsIDB4MTQ3ZDgsIDB4MTQ3ZWUsIDB4MTQ4MTAsIDB4MTQ4MjAsIDB4MTQ4M2MsIDB4MTQ4NDAsIDB4MTQ4NzgsIDB4MTQ4ZjAsIDB4MTQ5ZTAsXG4gICAgICAgIDB4MTRiYzAsIDB4MTRjMzAsIDB4MTRjM2UsIDB4MTRjNjAsIDB4MTRjN2MsIDB4MTRjYzAsIDB4MTRjZjgsIDB4MTRkZjAsIDB4MTRlMzgsIDB4MTRlNzAsIDB4MTRlN2UsIDB4MTRlZTAsXG4gICAgICAgIDB4MTRlZmMsIDB4MTRmMDQsIDB4MTRmMDgsIDB4MTRmMTAsIDB4MTRmMWUsIDB4MTRmMjAsIDB4MTRmM2MsIDB4MTRmNDAsIDB4MTRmNzgsIDB4MTRmODYsIDB4MTRmOGMsIDB4MTRmOTgsXG4gICAgICAgIDB4MTRmYjAsIDB4MTRmY2UsIDB4MTRmZGMsIDB4MTUwMjAsIDB4MTUwNDAsIDB4MTUwNzgsIDB4MTUwZjAsIDB4MTUxZTAsIDB4MTUzYzAsIDB4MTU4NjAsIDB4MTU4N2MsIDB4MTU4YzAsXG4gICAgICAgIDB4MTU4ZjgsIDB4MTU5ZjAsIDB4MTViZTAsIDB4MTVjNzAsIDB4MTVjN2UsIDB4MTVjZTAsIDB4MTVjZmMsIDB4MTVkYzAsIDB4MTVkZjgsIDB4MTVlMDgsIDB4MTVlMTAsIDB4MTVlMjAsXG4gICAgICAgIDB4MTVlNDAsIDB4MTVlNzgsIDB4MTVlZjAsIDB4MTVmMGMsIDB4MTVmMTgsIDB4MTVmMzAsIDB4MTVmNjAsIDB4MTVmN2MsIDB4MTVmOGUsIDB4MTVmOWMsIDB4MTVmYjgsIDB4MTYwNGUsXG4gICAgICAgIDB4MTYwNWMsIDB4MTYwOGUsIDB4MTYwOWMsIDB4MTYwYjgsIDB4MTYwYzIsIDB4MTYwYzQsIDB4MTYwYzgsIDB4MTYwZGUsIDB4MTYxMGUsIDB4MTYxMWMsIDB4MTYxMzgsIDB4MTYxNzAsXG4gICAgICAgIDB4MTYxN2UsIDB4MTYxODQsIDB4MTYxODgsIDB4MTYxOTAsIDB4MTYxOWUsIDB4MTYxYTAsIDB4MTYxYmMsIDB4MTYxYzYsIDB4MTYxY2MsIDB4MTYxZDgsIDB4MTYxZjIsIDB4MTYxZjQsXG4gICAgICAgIDB4MTYyMGUsIDB4MTYyMWMsIDB4MTYyMzgsIDB4MTYyNzAsIDB4MTYyN2UsIDB4MTYyZTAsIDB4MTYyZmMsIDB4MTYzMDQsIDB4MTYzMDgsIDB4MTYzMTAsIDB4MTYzMWUsIDB4MTYzMjAsXG4gICAgICAgIDB4MTYzM2MsIDB4MTYzNDAsIDB4MTYzNzgsIDB4MTYzODYsIDB4MTYzOGMsIDB4MTYzOTgsIDB4MTYzYjAsIDB4MTYzYmUsIDB4MTYzY2UsIDB4MTYzZGMsIDB4MTYzZTIsIDB4MTYzZTQsXG4gICAgICAgIDB4MTYzZTgsIDB4MTYzZjYsIDB4MTY0MGUsIDB4MTY0MWMsIDB4MTY0MzgsIDB4MTY0NzAsIDB4MTY0N2UsIDB4MTY0ZTAsIDB4MTY0ZmMsIDB4MTY1YzAsIDB4MTY1ZjgsIDB4MTY2MTAsXG4gICAgICAgIDB4MTY2MWUsIDB4MTY2MjAsIDB4MTY2M2MsIDB4MTY2NDAsIDB4MTY2NzgsIDB4MTY2ZjAsIDB4MTY3MTgsIDB4MTY3MzAsIDB4MTY3M2UsIDB4MTY3NjAsIDB4MTY3N2MsIDB4MTY3OGUsXG4gICAgICAgIDB4MTY3OWMsIDB4MTY3YjgsIDB4MTY3YzIsIDB4MTY3YzQsIDB4MTY3YzgsIDB4MTY3ZDAsIDB4MTY3ZGUsIDB4MTY3ZTYsIDB4MTY3ZWMsIDB4MTY4MWMsIDB4MTY4MzgsIDB4MTY4NzAsXG4gICAgICAgIDB4MTY4ZTAsIDB4MTY4ZmMsIDB4MTY5YzAsIDB4MTY5ZjgsIDB4MTZiZjAsIDB4MTZjMTAsIDB4MTZjMWUsIDB4MTZjMjAsIDB4MTZjM2MsIDB4MTZjNDAsIDB4MTZjNzgsIDB4MTZjZjAsXG4gICAgICAgIDB4MTZkZTAsIDB4MTZlMTgsIDB4MTZlMzAsIDB4MTZlM2UsIDB4MTZlNjAsIDB4MTZlN2MsIDB4MTZlYzAsIDB4MTZlZjgsIDB4MTZmMWMsIDB4MTZmMzgsIDB4MTZmNzAsIDB4MTZmN2UsXG4gICAgICAgIDB4MTZmODQsIDB4MTZmODgsIDB4MTZmOTAsIDB4MTZmOWUsIDB4MTZmYTAsIDB4MTZmYmMsIDB4MTZmYzYsIDB4MTZmY2MsIDB4MTZmZDgsIDB4MTcwMjYsIDB4MTcwMmMsIDB4MTcwNDYsXG4gICAgICAgIDB4MTcwNGMsIDB4MTcwNTgsIDB4MTcwNmUsIDB4MTcwODYsIDB4MTcwOGMsIDB4MTcwOTgsIDB4MTcwYjAsIDB4MTcwYmUsIDB4MTcwY2UsIDB4MTcwZGMsIDB4MTcwZTgsIDB4MTcxMDYsXG4gICAgICAgIDB4MTcxMGMsIDB4MTcxMTgsIDB4MTcxMzAsIDB4MTcxM2UsIDB4MTcxNjAsIDB4MTcxN2MsIDB4MTcxOGUsIDB4MTcxOWMsIDB4MTcxYjgsIDB4MTcxYzIsIDB4MTcxYzQsIDB4MTcxYzgsXG4gICAgICAgIDB4MTcxZDAsIDB4MTcxZGUsIDB4MTcxZTYsIDB4MTcxZWMsIDB4MTcxZmEsIDB4MTcyMDYsIDB4MTcyMGMsIDB4MTcyMTgsIDB4MTcyMzAsIDB4MTcyM2UsIDB4MTcyNjAsIDB4MTcyN2MsXG4gICAgICAgIDB4MTcyYzAsIDB4MTcyZjgsIDB4MTczMGUsIDB4MTczMWMsIDB4MTczMzgsIDB4MTczNzAsIDB4MTczN2UsIDB4MTczODgsIDB4MTczOTAsIDB4MTczOWUsIDB4MTczYTAsIDB4MTczYmMsXG4gICAgICAgIDB4MTczY2MsIDB4MTczZDgsIDB4MTczZWUsIDB4MTczZjIsIDB4MTczZjQsIDB4MTc0MGMsIDB4MTc0MTgsIDB4MTc0MzAsIDB4MTc0M2UsIDB4MTc0NjAsIDB4MTc0N2MsIDB4MTc0YzAsXG4gICAgICAgIDB4MTc0ZjgsIDB4MTc1ZjAsIDB4MTc2MGUsIDB4MTc2MWMsIDB4MTc2MzgsIDB4MTc2NzAsIDB4MTc2N2UsIDB4MTc2ZTAsIDB4MTc2ZmMsIDB4MTc3MDgsIDB4MTc3MTAsIDB4MTc3MWUsXG4gICAgICAgIDB4MTc3MjAsIDB4MTc3M2MsIDB4MTc3NDAsIDB4MTc3NzgsIDB4MTc3OTgsIDB4MTc3YjAsIDB4MTc3YmUsIDB4MTc3ZGMsIDB4MTc3ZTIsIDB4MTc3ZTQsIDB4MTc3ZTgsIDB4MTc4MjIsXG4gICAgICAgIDB4MTc4MjQsIDB4MTc4MjgsIDB4MTc4MzYsIDB4MTc4NDIsIDB4MTc4NDQsIDB4MTc4NDgsIDB4MTc4NTAsIDB4MTc4NWUsIDB4MTc4NjYsIDB4MTc4NmMsIDB4MTc4ODIsIDB4MTc4ODQsXG4gICAgICAgIDB4MTc4ODgsIDB4MTc4OTAsIDB4MTc4OWUsIDB4MTc4YTAsIDB4MTc4YmMsIDB4MTc4YzYsIDB4MTc4Y2MsIDB4MTc4ZDgsIDB4MTc4ZWUsIDB4MTc4ZjIsIDB4MTc4ZjQsIDB4MTc5MDIsXG4gICAgICAgIDB4MTc5MDQsIDB4MTc5MDgsIDB4MTc5MTAsIDB4MTc5MWUsIDB4MTc5MjAsIDB4MTc5M2MsIDB4MTc5NDAsIDB4MTc5NzgsIDB4MTc5ODYsIDB4MTc5OGMsIDB4MTc5OTgsIDB4MTc5YjAsXG4gICAgICAgIDB4MTc5YmUsIDB4MTc5Y2UsIDB4MTc5ZGMsIDB4MTc5ZTIsIDB4MTc5ZTQsIDB4MTc5ZTgsIDB4MTc5ZjYsIDB4MTdhMDQsIDB4MTdhMDgsIDB4MTdhMTAsIDB4MTdhMWUsIDB4MTdhMjAsXG4gICAgICAgIDB4MTdhM2MsIDB4MTdhNDAsIDB4MTdhNzgsIDB4MTdhZjAsIDB4MTdiMDYsIDB4MTdiMGMsIDB4MTdiMTgsIDB4MTdiMzAsIDB4MTdiM2UsIDB4MTdiNjAsIDB4MTdiN2MsIDB4MTdiOGUsXG4gICAgICAgIDB4MTdiOWMsIDB4MTdiYjgsIDB4MTdiYzQsIDB4MTdiYzgsIDB4MTdiZDAsIDB4MTdiZGUsIDB4MTdiZTYsIDB4MTdiZWMsIDB4MTdjMmUsIDB4MTdjMzIsIDB4MTdjMzQsIDB4MTdjNGUsXG4gICAgICAgIDB4MTdjNWMsIDB4MTdjNjIsIDB4MTdjNjQsIDB4MTdjNjgsIDB4MTdjNzYsIDB4MTdjOGUsIDB4MTdjOWMsIDB4MTdjYjgsIDB4MTdjYzIsIDB4MTdjYzQsIDB4MTdjYzgsIDB4MTdjZDAsXG4gICAgICAgIDB4MTdjZGUsIDB4MTdjZTYsIDB4MTdjZWMsIDB4MTdkMGUsIDB4MTdkMWMsIDB4MTdkMzgsIDB4MTdkNzAsIDB4MTdkODIsIDB4MTdkODQsIDB4MTdkODgsIDB4MTdkOTAsIDB4MTdkOWUsXG4gICAgICAgIDB4MTdkYTAsIDB4MTdkYmMsIDB4MTdkYzYsIDB4MTdkY2MsIDB4MTdkZDgsIDB4MTdkZWUsIDB4MTdlMjYsIDB4MTdlMmMsIDB4MTdlM2EsIDB4MTdlNDYsIDB4MTdlNGMsIDB4MTdlNTgsXG4gICAgICAgIDB4MTdlNmUsIDB4MTdlNzIsIDB4MTdlNzQsIDB4MTdlODYsIDB4MTdlOGMsIDB4MTdlOTgsIDB4MTdlYjAsIDB4MTdlY2UsIDB4MTdlZGMsIDB4MTdlZTIsIDB4MTdlZTQsIDB4MTdlZTgsXG4gICAgICAgIDB4MTdlZjYsIDB4MTgxM2EsIDB4MTgxNzIsIDB4MTgxNzQsIDB4MTgyMTYsIDB4MTgyMjYsIDB4MTgyM2EsIDB4MTgyNGMsIDB4MTgyNTgsIDB4MTgyNmUsIDB4MTgyNzIsIDB4MTgyNzQsXG4gICAgICAgIDB4MTgyOTgsIDB4MTgyYmUsIDB4MTgyZTIsIDB4MTgyZTQsIDB4MTgyZTgsIDB4MTgyZjYsIDB4MTgzNWUsIDB4MTgzN2EsIDB4MTgzYWUsIDB4MTgzZDYsIDB4MTg0MTYsIDB4MTg0MjYsXG4gICAgICAgIDB4MTg0MmMsIDB4MTg0M2EsIDB4MTg0NDYsIDB4MTg0NTgsIDB4MTg0NmUsIDB4MTg0NzIsIDB4MTg0NzQsIDB4MTg0ODYsIDB4MTg0YjAsIDB4MTg0YmUsIDB4MTg0Y2UsIDB4MTg0ZGMsXG4gICAgICAgIDB4MTg0ZTIsIDB4MTg0ZTQsIDB4MTg0ZTgsIDB4MTg0ZjYsIDB4MTg1MDYsIDB4MTg1MGMsIDB4MTg1MTgsIDB4MTg1MzAsIDB4MTg1M2UsIDB4MTg1NjAsIDB4MTg1N2MsIDB4MTg1OGUsXG4gICAgICAgIDB4MTg1OWMsIDB4MTg1YjgsIDB4MTg1YzIsIDB4MTg1YzQsIDB4MTg1YzgsIDB4MTg1ZDAsIDB4MTg1ZGUsIDB4MTg1ZTYsIDB4MTg1ZWMsIDB4MTg1ZmEsIDB4MTg2MTIsIDB4MTg2MTQsXG4gICAgICAgIDB4MTg2MjIsIDB4MTg2MjgsIDB4MTg2MzYsIDB4MTg2NDIsIDB4MTg2NTAsIDB4MTg2NWUsIDB4MTg2N2EsIDB4MTg2ODIsIDB4MTg2ODQsIDB4MTg2ODgsIDB4MTg2OTAsIDB4MTg2OWUsXG4gICAgICAgIDB4MTg2YTAsIDB4MTg2YmMsIDB4MTg2YzYsIDB4MTg2Y2MsIDB4MTg2ZDgsIDB4MTg2ZWUsIDB4MTg2ZjIsIDB4MTg2ZjQsIDB4MTg3MmUsIDB4MTg3NGUsIDB4MTg3NWMsIDB4MTg3OTYsXG4gICAgICAgIDB4MTg3YTYsIDB4MTg3YWMsIDB4MTg3ZDIsIDB4MTg3ZDQsIDB4MTg4MjYsIDB4MTg4MmMsIDB4MTg4M2EsIDB4MTg4NDYsIDB4MTg4NGMsIDB4MTg4NTgsIDB4MTg4NmUsIDB4MTg4NzIsXG4gICAgICAgIDB4MTg4NzQsIDB4MTg4ODYsIDB4MTg4OTgsIDB4MTg4YjAsIDB4MTg4YmUsIDB4MTg4Y2UsIDB4MTg4ZGMsIDB4MTg4ZTIsIDB4MTg4ZTQsIDB4MTg4ZTgsIDB4MTg4ZjYsIDB4MTg5MGMsXG4gICAgICAgIDB4MTg5MzAsIDB4MTg5M2UsIDB4MTg5NjAsIDB4MTg5N2MsIDB4MTg5OGUsIDB4MTg5YjgsIDB4MTg5YzIsIDB4MTg5YzgsIDB4MTg5ZDAsIDB4MTg5ZGUsIDB4MTg5ZTYsIDB4MTg5ZWMsXG4gICAgICAgIDB4MTg5ZmEsIDB4MThhMTgsIDB4MThhMzAsIDB4MThhM2UsIDB4MThhNjAsIDB4MThhN2MsIDB4MThhYzAsIDB4MThhZjgsIDB4MThiMWMsIDB4MThiMzgsIDB4MThiNzAsIDB4MThiN2UsXG4gICAgICAgIDB4MThiODIsIDB4MThiODQsIDB4MThiODgsIDB4MThiOTAsIDB4MThiOWUsIDB4MThiYTAsIDB4MThiYmMsIDB4MThiYzYsIDB4MThiY2MsIDB4MThiZDgsIDB4MThiZWUsIDB4MThiZjIsXG4gICAgICAgIDB4MThiZjQsIDB4MThjMjIsIDB4MThjMjQsIDB4MThjMjgsIDB4MThjMzYsIDB4MThjNDIsIDB4MThjNDgsIDB4MThjNTAsIDB4MThjNWUsIDB4MThjNjYsIDB4MThjN2EsIDB4MThjODIsXG4gICAgICAgIDB4MThjODQsIDB4MThjOTAsIDB4MThjOWUsIDB4MThjYTAsIDB4MThjYmMsIDB4MThjY2MsIDB4MThjZjIsIDB4MThjZjQsIDB4MThkMDQsIDB4MThkMDgsIDB4MThkMTAsIDB4MThkMWUsXG4gICAgICAgIDB4MThkMjAsIDB4MThkM2MsIDB4MThkNDAsIDB4MThkNzgsIDB4MThkODYsIDB4MThkOTgsIDB4MThkY2UsIDB4MThkZTIsIDB4MThkZTQsIDB4MThkZTgsIDB4MThlMmUsIDB4MThlMzIsXG4gICAgICAgIDB4MThlMzQsIDB4MThlNGUsIDB4MThlNWMsIDB4MThlNjIsIDB4MThlNjQsIDB4MThlNjgsIDB4MThlOGUsIDB4MThlOWMsIDB4MThlYjgsIDB4MThlYzIsIDB4MThlYzQsIDB4MThlYzgsXG4gICAgICAgIDB4MThlZDAsIDB4MThlZmEsIDB4MThmMTYsIDB4MThmMjYsIDB4MThmMmMsIDB4MThmNDYsIDB4MThmNGMsIDB4MThmNTgsIDB4MThmNmUsIDB4MThmOGEsIDB4MThmOTIsIDB4MThmOTQsXG4gICAgICAgIDB4MThmYTIsIDB4MThmYTQsIDB4MThmYTgsIDB4MThmYjYsIDB4MTkwMmMsIDB4MTkwM2EsIDB4MTkwNDYsIDB4MTkwNGMsIDB4MTkwNTgsIDB4MTkwNzIsIDB4MTkwNzQsIDB4MTkwODYsXG4gICAgICAgIDB4MTkwOTgsIDB4MTkwYjAsIDB4MTkwYmUsIDB4MTkwY2UsIDB4MTkwZGMsIDB4MTkwZTIsIDB4MTkwZTgsIDB4MTkwZjYsIDB4MTkxMDYsIDB4MTkxMGMsIDB4MTkxMzAsIDB4MTkxM2UsXG4gICAgICAgIDB4MTkxNjAsIDB4MTkxN2MsIDB4MTkxOGUsIDB4MTkxOWMsIDB4MTkxYjgsIDB4MTkxYzIsIDB4MTkxYzgsIDB4MTkxZDAsIDB4MTkxZGUsIDB4MTkxZTYsIDB4MTkxZWMsIDB4MTkxZmEsXG4gICAgICAgIDB4MTkyMTgsIDB4MTkyM2UsIDB4MTkyNjAsIDB4MTkyN2MsIDB4MTkyYzAsIDB4MTkyZjgsIDB4MTkzMzgsIDB4MTkzNzAsIDB4MTkzN2UsIDB4MTkzODIsIDB4MTkzODQsIDB4MTkzOTAsXG4gICAgICAgIDB4MTkzOWUsIDB4MTkzYTAsIDB4MTkzYmMsIDB4MTkzYzYsIDB4MTkzY2MsIDB4MTkzZDgsIDB4MTkzZWUsIDB4MTkzZjIsIDB4MTkzZjQsIDB4MTk0MzAsIDB4MTk0M2UsIDB4MTk0NjAsXG4gICAgICAgIDB4MTk0N2MsIDB4MTk0YzAsIDB4MTk0ZjgsIDB4MTk1ZjAsIDB4MTk2MzgsIDB4MTk2NzAsIDB4MTk2N2UsIDB4MTk2ZTAsIDB4MTk2ZmMsIDB4MTk3MDIsIDB4MTk3MDQsIDB4MTk3MDgsXG4gICAgICAgIDB4MTk3MTAsIDB4MTk3MjAsIDB4MTk3M2MsIDB4MTk3NDAsIDB4MTk3NzgsIDB4MTk3ODYsIDB4MTk3OGMsIDB4MTk3OTgsIDB4MTk3YjAsIDB4MTk3YmUsIDB4MTk3Y2UsIDB4MTk3ZGMsXG4gICAgICAgIDB4MTk3ZTIsIDB4MTk3ZTQsIDB4MTk3ZTgsIDB4MTk4MjIsIDB4MTk4MjQsIDB4MTk4NDIsIDB4MTk4NDgsIDB4MTk4NTAsIDB4MTk4NWUsIDB4MTk4NjYsIDB4MTk4N2EsIDB4MTk4ODIsXG4gICAgICAgIDB4MTk4ODQsIDB4MTk4OTAsIDB4MTk4OWUsIDB4MTk4YTAsIDB4MTk4YmMsIDB4MTk4Y2MsIDB4MTk4ZjIsIDB4MTk4ZjQsIDB4MTk5MDIsIDB4MTk5MDgsIDB4MTk5MWUsIDB4MTk5MjAsXG4gICAgICAgIDB4MTk5M2MsIDB4MTk5NDAsIDB4MTk5NzgsIDB4MTk5ODYsIDB4MTk5OTgsIDB4MTk5Y2UsIDB4MTk5ZTIsIDB4MTk5ZTQsIDB4MTk5ZTgsIDB4MTlhMDgsIDB4MTlhMTAsIDB4MTlhMWUsXG4gICAgICAgIDB4MTlhMjAsIDB4MTlhM2MsIDB4MTlhNDAsIDB4MTlhNzgsIDB4MTlhZjAsIDB4MTliMTgsIDB4MTliM2UsIDB4MTliNjAsIDB4MTliOWMsIDB4MTliYzIsIDB4MTliYzQsIDB4MTliYzgsXG4gICAgICAgIDB4MTliZDAsIDB4MTliZTYsIDB4MTljMmUsIDB4MTljMzQsIDB4MTljNGUsIDB4MTljNWMsIDB4MTljNjIsIDB4MTljNjQsIDB4MTljNjgsIDB4MTljOGUsIDB4MTljOWMsIDB4MTljYjgsXG4gICAgICAgIDB4MTljYzIsIDB4MTljYzgsIDB4MTljZDAsIDB4MTljZTYsIDB4MTljZmEsIDB4MTlkMGUsIDB4MTlkMWMsIDB4MTlkMzgsIDB4MTlkNzAsIDB4MTlkN2UsIDB4MTlkODIsIDB4MTlkODQsXG4gICAgICAgIDB4MTlkODgsIDB4MTlkOTAsIDB4MTlkYTAsIDB4MTlkY2MsIDB4MTlkZjIsIDB4MTlkZjQsIDB4MTllMTYsIDB4MTllMjYsIDB4MTllMmMsIDB4MTllNDYsIDB4MTllNGMsIDB4MTllNTgsXG4gICAgICAgIDB4MTllNzQsIDB4MTllODYsIDB4MTllOGMsIDB4MTllOTgsIDB4MTllYjAsIDB4MTllYmUsIDB4MTllY2UsIDB4MTllZTIsIDB4MTllZTQsIDB4MTllZTgsIDB4MTlmMGEsIDB4MTlmMTIsXG4gICAgICAgIDB4MTlmMTQsIDB4MTlmMjIsIDB4MTlmMjQsIDB4MTlmMjgsIDB4MTlmNDIsIDB4MTlmNDQsIDB4MTlmNDgsIDB4MTlmNTAsIDB4MTlmNWUsIDB4MTlmNmMsIDB4MTlmOWEsIDB4MTlmYWUsXG4gICAgICAgIDB4MTlmYjIsIDB4MTlmYjQsIDB4MWEwNDYsIDB4MWEwNGMsIDB4MWEwNzIsIDB4MWEwNzQsIDB4MWEwODYsIDB4MWEwOGMsIDB4MWEwOTgsIDB4MWEwYjAsIDB4MWEwYmUsIDB4MWEwZTIsXG4gICAgICAgIDB4MWEwZTQsIDB4MWEwZTgsIDB4MWEwZjYsIDB4MWExMDYsIDB4MWExMGMsIDB4MWExMTgsIDB4MWExMzAsIDB4MWExM2UsIDB4MWExNjAsIDB4MWExN2MsIDB4MWExOGUsIDB4MWExOWMsXG4gICAgICAgIDB4MWExYjgsIDB4MWExYzIsIDB4MWExYzQsIDB4MWExYzgsIDB4MWExZDAsIDB4MWExZGUsIDB4MWExZTYsIDB4MWExZWMsIDB4MWEyMTgsIDB4MWEyMzAsIDB4MWEyM2UsIDB4MWEyNjAsXG4gICAgICAgIDB4MWEyN2MsIDB4MWEyYzAsIDB4MWEyZjgsIDB4MWEzMWMsIDB4MWEzMzgsIDB4MWEzNzAsIDB4MWEzN2UsIDB4MWEzODIsIDB4MWEzODQsIDB4MWEzODgsIDB4MWEzOTAsIDB4MWEzOWUsXG4gICAgICAgIDB4MWEzYTAsIDB4MWEzYmMsIDB4MWEzYzYsIDB4MWEzY2MsIDB4MWEzZDgsIDB4MWEzZWUsIDB4MWEzZjIsIDB4MWEzZjQsIDB4MWE0MTgsIDB4MWE0MzAsIDB4MWE0M2UsIDB4MWE0NjAsXG4gICAgICAgIDB4MWE0N2MsIDB4MWE0YzAsIDB4MWE0ZjgsIDB4MWE1ZjAsIDB4MWE2MWMsIDB4MWE2MzgsIDB4MWE2NzAsIDB4MWE2N2UsIDB4MWE2ZTAsIDB4MWE2ZmMsIDB4MWE3MDIsIDB4MWE3MDQsXG4gICAgICAgIDB4MWE3MDgsIDB4MWE3MTAsIDB4MWE3MWUsIDB4MWE3MjAsIDB4MWE3M2MsIDB4MWE3NDAsIDB4MWE3NzgsIDB4MWE3ODYsIDB4MWE3OGMsIDB4MWE3OTgsIDB4MWE3YjAsIDB4MWE3YmUsXG4gICAgICAgIDB4MWE3Y2UsIDB4MWE3ZGMsIDB4MWE3ZTIsIDB4MWE3ZTQsIDB4MWE3ZTgsIDB4MWE4MzAsIDB4MWE4NjAsIDB4MWE4N2MsIDB4MWE4YzAsIDB4MWE4ZjgsIDB4MWE5ZjAsIDB4MWFiZTAsXG4gICAgICAgIDB4MWFjNzAsIDB4MWFjN2UsIDB4MWFjZTAsIDB4MWFjZmMsIDB4MWFkYzAsIDB4MWFkZjgsIDB4MWFlMDQsIDB4MWFlMDgsIDB4MWFlMTAsIDB4MWFlMjAsIDB4MWFlM2MsIDB4MWFlNDAsXG4gICAgICAgIDB4MWFlNzgsIDB4MWFlZjAsIDB4MWFmMDYsIDB4MWFmMGMsIDB4MWFmMTgsIDB4MWFmMzAsIDB4MWFmM2UsIDB4MWFmNjAsIDB4MWFmN2MsIDB4MWFmOGUsIDB4MWFmOWMsIDB4MWFmYjgsXG4gICAgICAgIDB4MWFmYzQsIDB4MWFmYzgsIDB4MWFmZDAsIDB4MWFmZGUsIDB4MWIwNDIsIDB4MWIwNWUsIDB4MWIwN2EsIDB4MWIwODIsIDB4MWIwODQsIDB4MWIwODgsIDB4MWIwOTAsIDB4MWIwOWUsXG4gICAgICAgIDB4MWIwYTAsIDB4MWIwYmMsIDB4MWIwY2MsIDB4MWIwZjIsIDB4MWIwZjQsIDB4MWIxMDIsIDB4MWIxMDQsIDB4MWIxMDgsIDB4MWIxMTAsIDB4MWIxMWUsIDB4MWIxMjAsIDB4MWIxM2MsXG4gICAgICAgIDB4MWIxNDAsIDB4MWIxNzgsIDB4MWIxODYsIDB4MWIxOTgsIDB4MWIxY2UsIDB4MWIxZTIsIDB4MWIxZTQsIDB4MWIxZTgsIDB4MWIyMDQsIDB4MWIyMDgsIDB4MWIyMTAsIDB4MWIyMWUsXG4gICAgICAgIDB4MWIyMjAsIDB4MWIyM2MsIDB4MWIyNDAsIDB4MWIyNzgsIDB4MWIyZjAsIDB4MWIzMGMsIDB4MWIzM2UsIDB4MWIzNjAsIDB4MWIzOWMsIDB4MWIzYzIsIDB4MWIzYzQsIDB4MWIzYzgsXG4gICAgICAgIDB4MWIzZDAsIDB4MWIzZTYsIDB4MWI0MTAsIDB4MWI0MWUsIDB4MWI0MjAsIDB4MWI0M2MsIDB4MWI0NDAsIDB4MWI0NzgsIDB4MWI0ZjAsIDB4MWI1ZTAsIDB4MWI2MTgsIDB4MWI2NjAsXG4gICAgICAgIDB4MWI2N2MsIDB4MWI2YzAsIDB4MWI3MzgsIDB4MWI3ODIsIDB4MWI3ODQsIDB4MWI3ODgsIDB4MWI3OTAsIDB4MWI3OWUsIDB4MWI3YTAsIDB4MWI3Y2MsIDB4MWI4MmUsIDB4MWI4NGUsXG4gICAgICAgIDB4MWI4NWMsIDB4MWI4OGUsIDB4MWI4OWMsIDB4MWI4YjgsIDB4MWI4YzIsIDB4MWI4YzQsIDB4MWI4YzgsIDB4MWI4ZDAsIDB4MWI4ZTYsIDB4MWI4ZmEsIDB4MWI5MGUsIDB4MWI5MWMsXG4gICAgICAgIDB4MWI5MzgsIDB4MWI5NzAsIDB4MWI5N2UsIDB4MWI5ODIsIDB4MWI5ODQsIDB4MWI5ODgsIDB4MWI5OTAsIDB4MWI5OWUsIDB4MWI5YTAsIDB4MWI5Y2MsIDB4MWI5ZjIsIDB4MWI5ZjQsXG4gICAgICAgIDB4MWJhMGUsIDB4MWJhMWMsIDB4MWJhMzgsIDB4MWJhNzAsIDB4MWJhN2UsIDB4MWJhZTAsIDB4MWJhZmMsIDB4MWJiMDgsIDB4MWJiMTAsIDB4MWJiMjAsIDB4MWJiM2MsIDB4MWJiNDAsXG4gICAgICAgIDB4MWJiOTgsIDB4MWJiY2UsIDB4MWJiZTIsIDB4MWJiZTQsIDB4MWJiZTgsIDB4MWJjMTYsIDB4MWJjMjYsIDB4MWJjMmMsIDB4MWJjNDYsIDB4MWJjNGMsIDB4MWJjNTgsIDB4MWJjNzIsXG4gICAgICAgIDB4MWJjNzQsIDB4MWJjODYsIDB4MWJjOGMsIDB4MWJjOTgsIDB4MWJjYjAsIDB4MWJjYmUsIDB4MWJjY2UsIDB4MWJjZTIsIDB4MWJjZTQsIDB4MWJjZTgsIDB4MWJkMDYsIDB4MWJkMGMsXG4gICAgICAgIDB4MWJkMTgsIDB4MWJkMzAsIDB4MWJkM2UsIDB4MWJkNjAsIDB4MWJkN2MsIDB4MWJkOWMsIDB4MWJkYzIsIDB4MWJkYzQsIDB4MWJkYzgsIDB4MWJkZDAsIDB4MWJkZTYsIDB4MWJkZmEsXG4gICAgICAgIDB4MWJlMTIsIDB4MWJlMTQsIDB4MWJlMjIsIDB4MWJlMjQsIDB4MWJlMjgsIDB4MWJlNDIsIDB4MWJlNDQsIDB4MWJlNDgsIDB4MWJlNTAsIDB4MWJlNWUsIDB4MWJlNjYsIDB4MWJlODIsXG4gICAgICAgIDB4MWJlODQsIDB4MWJlODgsIDB4MWJlOTAsIDB4MWJlOWUsIDB4MWJlYTAsIDB4MWJlYmMsIDB4MWJlY2MsIDB4MWJlZjQsIDB4MWJmMWEsIDB4MWJmMmUsIDB4MWJmMzIsIDB4MWJmMzQsXG4gICAgICAgIDB4MWJmNGUsIDB4MWJmNWMsIDB4MWJmNjIsIDB4MWJmNjQsIDB4MWJmNjgsIDB4MWMwOWEsIDB4MWMwYjIsIDB4MWMwYjQsIDB4MWMxMWEsIDB4MWMxMzIsIDB4MWMxMzQsIDB4MWMxNjIsXG4gICAgICAgIDB4MWMxNjQsIDB4MWMxNjgsIDB4MWMxNzYsIDB4MWMxYmEsIDB4MWMyMWEsIDB4MWMyMzIsIDB4MWMyMzQsIDB4MWMyNGUsIDB4MWMyNWMsIDB4MWMyNjIsIDB4MWMyNjQsIDB4MWMyNjgsXG4gICAgICAgIDB4MWMyNzYsIDB4MWMyOGUsIDB4MWMyYzIsIDB4MWMyYzQsIDB4MWMyYzgsIDB4MWMyZDAsIDB4MWMyZGUsIDB4MWMyZTYsIDB4MWMyZWMsIDB4MWMyZmEsIDB4MWMzMTYsIDB4MWMzMjYsXG4gICAgICAgIDB4MWMzM2EsIDB4MWMzNDYsIDB4MWMzNGMsIDB4MWMzNzIsIDB4MWMzNzQsIDB4MWM0MWEsIDB4MWM0MmUsIDB4MWM0MzIsIDB4MWM0MzQsIDB4MWM0NGUsIDB4MWM0NWMsIDB4MWM0NjIsXG4gICAgICAgIDB4MWM0NjQsIDB4MWM0NjgsIDB4MWM0NzYsIDB4MWM0OGUsIDB4MWM0OWMsIDB4MWM0YjgsIDB4MWM0YzIsIDB4MWM0YzgsIDB4MWM0ZDAsIDB4MWM0ZGUsIDB4MWM0ZTYsIDB4MWM0ZWMsXG4gICAgICAgIDB4MWM0ZmEsIDB4MWM1MWMsIDB4MWM1MzgsIDB4MWM1NzAsIDB4MWM1N2UsIDB4MWM1ODIsIDB4MWM1ODQsIDB4MWM1ODgsIDB4MWM1OTAsIDB4MWM1OWUsIDB4MWM1YTAsIDB4MWM1YmMsXG4gICAgICAgIDB4MWM1YzYsIDB4MWM1Y2MsIDB4MWM1ZDgsIDB4MWM1ZWUsIDB4MWM1ZjIsIDB4MWM1ZjQsIDB4MWM2MTYsIDB4MWM2MjYsIDB4MWM2MmMsIDB4MWM2M2EsIDB4MWM2NDYsIDB4MWM2NGMsXG4gICAgICAgIDB4MWM2NTgsIDB4MWM2NmUsIDB4MWM2NzIsIDB4MWM2NzQsIDB4MWM2ODYsIDB4MWM2OGMsIDB4MWM2OTgsIDB4MWM2YjAsIDB4MWM2YmUsIDB4MWM2Y2UsIDB4MWM2ZGMsIDB4MWM2ZTIsXG4gICAgICAgIDB4MWM2ZTQsIDB4MWM2ZTgsIDB4MWM3MTIsIDB4MWM3MTQsIDB4MWM3MjIsIDB4MWM3MjgsIDB4MWM3MzYsIDB4MWM3NDIsIDB4MWM3NDQsIDB4MWM3NDgsIDB4MWM3NTAsIDB4MWM3NWUsXG4gICAgICAgIDB4MWM3NjYsIDB4MWM3NmMsIDB4MWM3N2EsIDB4MWM3YWUsIDB4MWM3ZDYsIDB4MWM3ZWEsIDB4MWM4MWEsIDB4MWM4MmUsIDB4MWM4MzIsIDB4MWM4MzQsIDB4MWM4NGUsIDB4MWM4NWMsXG4gICAgICAgIDB4MWM4NjIsIDB4MWM4NjQsIDB4MWM4NjgsIDB4MWM4NzYsIDB4MWM4OGUsIDB4MWM4OWMsIDB4MWM4YjgsIDB4MWM4YzIsIDB4MWM4YzgsIDB4MWM4ZDAsIDB4MWM4ZGUsIDB4MWM4ZTYsXG4gICAgICAgIDB4MWM4ZWMsIDB4MWM4ZmEsIDB4MWM5MGUsIDB4MWM5MzgsIDB4MWM5NzAsIDB4MWM5N2UsIDB4MWM5ODIsIDB4MWM5ODQsIDB4MWM5OTAsIDB4MWM5OWUsIDB4MWM5YTAsIDB4MWM5YmMsXG4gICAgICAgIDB4MWM5YzYsIDB4MWM5Y2MsIDB4MWM5ZDgsIDB4MWM5ZWUsIDB4MWM5ZjIsIDB4MWM5ZjQsIDB4MWNhMzgsIDB4MWNhNzAsIDB4MWNhN2UsIDB4MWNhZTAsIDB4MWNhZmMsIDB4MWNiMDIsXG4gICAgICAgIDB4MWNiMDQsIDB4MWNiMDgsIDB4MWNiMTAsIDB4MWNiMjAsIDB4MWNiM2MsIDB4MWNiNDAsIDB4MWNiNzgsIDB4MWNiODYsIDB4MWNiOGMsIDB4MWNiOTgsIDB4MWNiYjAsIDB4MWNiYmUsXG4gICAgICAgIDB4MWNiY2UsIDB4MWNiZGMsIDB4MWNiZTIsIDB4MWNiZTQsIDB4MWNiZTgsIDB4MWNiZjYsIDB4MWNjMTYsIDB4MWNjMjYsIDB4MWNjMmMsIDB4MWNjM2EsIDB4MWNjNDYsIDB4MWNjNTgsXG4gICAgICAgIDB4MWNjNzIsIDB4MWNjNzQsIDB4MWNjODYsIDB4MWNjYjAsIDB4MWNjYmUsIDB4MWNjY2UsIDB4MWNjZTIsIDB4MWNjZTQsIDB4MWNjZTgsIDB4MWNkMDYsIDB4MWNkMGMsIDB4MWNkMTgsXG4gICAgICAgIDB4MWNkMzAsIDB4MWNkM2UsIDB4MWNkNjAsIDB4MWNkN2MsIDB4MWNkOWMsIDB4MWNkYzIsIDB4MWNkYzQsIDB4MWNkYzgsIDB4MWNkZDAsIDB4MWNkZGUsIDB4MWNkZTYsIDB4MWNkZmEsXG4gICAgICAgIDB4MWNlMjIsIDB4MWNlMjgsIDB4MWNlNDIsIDB4MWNlNTAsIDB4MWNlNWUsIDB4MWNlNjYsIDB4MWNlN2EsIDB4MWNlODIsIDB4MWNlODQsIDB4MWNlODgsIDB4MWNlOTAsIDB4MWNlOWUsXG4gICAgICAgIDB4MWNlYTAsIDB4MWNlYmMsIDB4MWNlY2MsIDB4MWNlZjIsIDB4MWNlZjQsIDB4MWNmMmUsIDB4MWNmMzIsIDB4MWNmMzQsIDB4MWNmNGUsIDB4MWNmNWMsIDB4MWNmNjIsIDB4MWNmNjQsXG4gICAgICAgIDB4MWNmNjgsIDB4MWNmOTYsIDB4MWNmYTYsIDB4MWNmYWMsIDB4MWNmY2EsIDB4MWNmZDIsIDB4MWNmZDQsIDB4MWQwMmUsIDB4MWQwMzIsIDB4MWQwMzQsIDB4MWQwNGUsIDB4MWQwNWMsXG4gICAgICAgIDB4MWQwNjIsIDB4MWQwNjQsIDB4MWQwNjgsIDB4MWQwNzYsIDB4MWQwOGUsIDB4MWQwOWMsIDB4MWQwYjgsIDB4MWQwYzIsIDB4MWQwYzQsIDB4MWQwYzgsIDB4MWQwZDAsIDB4MWQwZGUsXG4gICAgICAgIDB4MWQwZTYsIDB4MWQwZWMsIDB4MWQwZmEsIDB4MWQxMWMsIDB4MWQxMzgsIDB4MWQxNzAsIDB4MWQxN2UsIDB4MWQxODIsIDB4MWQxODQsIDB4MWQxODgsIDB4MWQxOTAsIDB4MWQxOWUsXG4gICAgICAgIDB4MWQxYTAsIDB4MWQxYmMsIDB4MWQxYzYsIDB4MWQxY2MsIDB4MWQxZDgsIDB4MWQxZWUsIDB4MWQxZjIsIDB4MWQxZjQsIDB4MWQyMWMsIDB4MWQyMzgsIDB4MWQyNzAsIDB4MWQyN2UsXG4gICAgICAgIDB4MWQyZTAsIDB4MWQyZmMsIDB4MWQzMDIsIDB4MWQzMDQsIDB4MWQzMDgsIDB4MWQzMTAsIDB4MWQzMWUsIDB4MWQzMjAsIDB4MWQzM2MsIDB4MWQzNDAsIDB4MWQzNzgsIDB4MWQzODYsXG4gICAgICAgIDB4MWQzOGMsIDB4MWQzOTgsIDB4MWQzYjAsIDB4MWQzYmUsIDB4MWQzY2UsIDB4MWQzZGMsIDB4MWQzZTIsIDB4MWQzZTQsIDB4MWQzZTgsIDB4MWQzZjYsIDB4MWQ0NzAsIDB4MWQ0N2UsXG4gICAgICAgIDB4MWQ0ZTAsIDB4MWQ0ZmMsIDB4MWQ1YzAsIDB4MWQ1ZjgsIDB4MWQ2MDQsIDB4MWQ2MDgsIDB4MWQ2MTAsIDB4MWQ2MjAsIDB4MWQ2NDAsIDB4MWQ2NzgsIDB4MWQ2ZjAsIDB4MWQ3MDYsXG4gICAgICAgIDB4MWQ3MGMsIDB4MWQ3MTgsIDB4MWQ3MzAsIDB4MWQ3M2UsIDB4MWQ3NjAsIDB4MWQ3N2MsIDB4MWQ3OGUsIDB4MWQ3OWMsIDB4MWQ3YjgsIDB4MWQ3YzIsIDB4MWQ3YzQsIDB4MWQ3YzgsXG4gICAgICAgIDB4MWQ3ZDAsIDB4MWQ3ZGUsIDB4MWQ3ZTYsIDB4MWQ3ZWMsIDB4MWQ4MjYsIDB4MWQ4MmMsIDB4MWQ4M2EsIDB4MWQ4NDYsIDB4MWQ4NGMsIDB4MWQ4NTgsIDB4MWQ4NzIsIDB4MWQ4NzQsXG4gICAgICAgIDB4MWQ4ODYsIDB4MWQ4OGMsIDB4MWQ4OTgsIDB4MWQ4YjAsIDB4MWQ4YmUsIDB4MWQ4Y2UsIDB4MWQ4ZTIsIDB4MWQ4ZTQsIDB4MWQ4ZTgsIDB4MWQ4ZjYsIDB4MWQ5MGMsIDB4MWQ5MTgsXG4gICAgICAgIDB4MWQ5MzAsIDB4MWQ5M2UsIDB4MWQ5NjAsIDB4MWQ5N2MsIDB4MWQ5OWMsIDB4MWQ5YzIsIDB4MWQ5YzQsIDB4MWQ5YzgsIDB4MWQ5ZDAsIDB4MWQ5ZTYsIDB4MWQ5ZmEsIDB4MWRhMGMsXG4gICAgICAgIDB4MWRhMTgsIDB4MWRhMzAsIDB4MWRhM2UsIDB4MWRhNjAsIDB4MWRhN2MsIDB4MWRhYzAsIDB4MWRhZjgsIDB4MWRiMzgsIDB4MWRiODIsIDB4MWRiODQsIDB4MWRiODgsIDB4MWRiOTAsXG4gICAgICAgIDB4MWRiOWUsIDB4MWRiYTAsIDB4MWRiY2MsIDB4MWRiZjIsIDB4MWRiZjQsIDB4MWRjMjIsIDB4MWRjNDIsIDB4MWRjNDQsIDB4MWRjNDgsIDB4MWRjNTAsIDB4MWRjNWUsIDB4MWRjNjYsXG4gICAgICAgIDB4MWRjN2EsIDB4MWRjODIsIDB4MWRjODQsIDB4MWRjODgsIDB4MWRjOTAsIDB4MWRjOWUsIDB4MWRjYTAsIDB4MWRjYmMsIDB4MWRjY2MsIDB4MWRjZjIsIDB4MWRjZjQsIDB4MWRkMDQsXG4gICAgICAgIDB4MWRkMDgsIDB4MWRkMTAsIDB4MWRkMWUsIDB4MWRkMjAsIDB4MWRkM2MsIDB4MWRkNDAsIDB4MWRkNzgsIDB4MWRkODYsIDB4MWRkOTgsIDB4MWRkY2UsIDB4MWRkZTIsIDB4MWRkZTQsXG4gICAgICAgIDB4MWRkZTgsIDB4MWRlMmUsIDB4MWRlMzIsIDB4MWRlMzQsIDB4MWRlNGUsIDB4MWRlNWMsIDB4MWRlNjIsIDB4MWRlNjQsIDB4MWRlNjgsIDB4MWRlOGUsIDB4MWRlOWMsIDB4MWRlYjgsXG4gICAgICAgIDB4MWRlYzIsIDB4MWRlYzQsIDB4MWRlYzgsIDB4MWRlZDAsIDB4MWRlZTYsIDB4MWRlZmEsIDB4MWRmMTYsIDB4MWRmMjYsIDB4MWRmMmMsIDB4MWRmNDYsIDB4MWRmNGMsIDB4MWRmNTgsXG4gICAgICAgIDB4MWRmNzIsIDB4MWRmNzQsIDB4MWRmOGEsIDB4MWRmOTIsIDB4MWRmOTQsIDB4MWRmYTIsIDB4MWRmYTQsIDB4MWRmYTgsIDB4MWUwOGEsIDB4MWUwOTIsIDB4MWUwOTQsIDB4MWUwYTIsXG4gICAgICAgIDB4MWUwYTQsIDB4MWUwYTgsIDB4MWUwYjYsIDB4MWUwZGEsIDB4MWUxMGEsIDB4MWUxMTIsIDB4MWUxMTQsIDB4MWUxMjIsIDB4MWUxMjQsIDB4MWUxMjgsIDB4MWUxMzYsIDB4MWUxNDIsXG4gICAgICAgIDB4MWUxNDQsIDB4MWUxNDgsIDB4MWUxNTAsIDB4MWUxNjYsIDB4MWUxNmMsIDB4MWUxN2EsIDB4MWUxOWEsIDB4MWUxYjIsIDB4MWUxYjQsIDB4MWUyMGEsIDB4MWUyMTIsIDB4MWUyMTQsXG4gICAgICAgIDB4MWUyMjIsIDB4MWUyMjQsIDB4MWUyMjgsIDB4MWUyMzYsIDB4MWUyNDIsIDB4MWUyNDgsIDB4MWUyNTAsIDB4MWUyNWUsIDB4MWUyNjYsIDB4MWUyNmMsIDB4MWUyN2EsIDB4MWUyODIsXG4gICAgICAgIDB4MWUyODQsIDB4MWUyODgsIDB4MWUyOTAsIDB4MWUyYTAsIDB4MWUyYmMsIDB4MWUyYzYsIDB4MWUyY2MsIDB4MWUyZDgsIDB4MWUyZWUsIDB4MWUyZjIsIDB4MWUyZjQsIDB4MWUzMWEsXG4gICAgICAgIDB4MWUzMzIsIDB4MWUzMzQsIDB4MWUzNWMsIDB4MWUzNjIsIDB4MWUzNjQsIDB4MWUzNjgsIDB4MWUzYmEsIDB4MWU0MGEsIDB4MWU0MTIsIDB4MWU0MTQsIDB4MWU0MjIsIDB4MWU0MjgsXG4gICAgICAgIDB4MWU0MzYsIDB4MWU0NDIsIDB4MWU0NDgsIDB4MWU0NTAsIDB4MWU0NWUsIDB4MWU0NjYsIDB4MWU0NmMsIDB4MWU0N2EsIDB4MWU0ODIsIDB4MWU0ODQsIDB4MWU0OTAsIDB4MWU0OWUsXG4gICAgICAgIDB4MWU0YTAsIDB4MWU0YmMsIDB4MWU0YzYsIDB4MWU0Y2MsIDB4MWU0ZDgsIDB4MWU0ZWUsIDB4MWU0ZjIsIDB4MWU0ZjQsIDB4MWU1MDIsIDB4MWU1MDQsIDB4MWU1MDgsIDB4MWU1MTAsXG4gICAgICAgIDB4MWU1MWUsIDB4MWU1MjAsIDB4MWU1M2MsIDB4MWU1NDAsIDB4MWU1NzgsIDB4MWU1ODYsIDB4MWU1OGMsIDB4MWU1OTgsIDB4MWU1YjAsIDB4MWU1YmUsIDB4MWU1Y2UsIDB4MWU1ZGMsXG4gICAgICAgIDB4MWU1ZTIsIDB4MWU1ZTQsIDB4MWU1ZTgsIDB4MWU1ZjYsIDB4MWU2MWEsIDB4MWU2MmUsIDB4MWU2MzIsIDB4MWU2MzQsIDB4MWU2NGUsIDB4MWU2NWMsIDB4MWU2NjIsIDB4MWU2NjgsXG4gICAgICAgIDB4MWU2OGUsIDB4MWU2OWMsIDB4MWU2YjgsIDB4MWU2YzIsIDB4MWU2YzQsIDB4MWU2YzgsIDB4MWU2ZDAsIDB4MWU2ZTYsIDB4MWU2ZmEsIDB4MWU3MTYsIDB4MWU3MjYsIDB4MWU3MmMsXG4gICAgICAgIDB4MWU3M2EsIDB4MWU3NDYsIDB4MWU3NGMsIDB4MWU3NTgsIDB4MWU3NzIsIDB4MWU3NzQsIDB4MWU3OTIsIDB4MWU3OTQsIDB4MWU3YTIsIDB4MWU3YTQsIDB4MWU3YTgsIDB4MWU3YjYsXG4gICAgICAgIDB4MWU4MTIsIDB4MWU4MTQsIDB4MWU4MjIsIDB4MWU4MjQsIDB4MWU4MjgsIDB4MWU4MzYsIDB4MWU4NDIsIDB4MWU4NDQsIDB4MWU4NDgsIDB4MWU4NTAsIDB4MWU4NWUsIDB4MWU4NjYsXG4gICAgICAgIDB4MWU4NmMsIDB4MWU4N2EsIDB4MWU4ODIsIDB4MWU4ODQsIDB4MWU4ODgsIDB4MWU4OTAsIDB4MWU4OWUsIDB4MWU4YTAsIDB4MWU4YmMsIDB4MWU4YzYsIDB4MWU4Y2MsIDB4MWU4ZDgsXG4gICAgICAgIDB4MWU4ZWUsIDB4MWU4ZjIsIDB4MWU4ZjQsIDB4MWU5MDIsIDB4MWU5MDQsIDB4MWU5MDgsIDB4MWU5MTAsIDB4MWU5MjAsIDB4MWU5M2MsIDB4MWU5NDAsIDB4MWU5NzgsIDB4MWU5ODYsXG4gICAgICAgIDB4MWU5OGMsIDB4MWU5OTgsIDB4MWU5YjAsIDB4MWU5YmUsIDB4MWU5Y2UsIDB4MWU5ZGMsIDB4MWU5ZTIsIDB4MWU5ZTQsIDB4MWU5ZTgsIDB4MWU5ZjYsIDB4MWVhMDQsIDB4MWVhMDgsXG4gICAgICAgIDB4MWVhMTAsIDB4MWVhMjAsIDB4MWVhNDAsIDB4MWVhNzgsIDB4MWVhZjAsIDB4MWViMDYsIDB4MWViMGMsIDB4MWViMTgsIDB4MWViMzAsIDB4MWViM2UsIDB4MWViNjAsIDB4MWViN2MsXG4gICAgICAgIDB4MWViOGUsIDB4MWViOWMsIDB4MWViYjgsIDB4MWViYzIsIDB4MWViYzQsIDB4MWViYzgsIDB4MWViZDAsIDB4MWViZGUsIDB4MWViZTYsIDB4MWViZWMsIDB4MWVjMWEsIDB4MWVjMmUsXG4gICAgICAgIDB4MWVjMzIsIDB4MWVjMzQsIDB4MWVjNGUsIDB4MWVjNWMsIDB4MWVjNjIsIDB4MWVjNjQsIDB4MWVjNjgsIDB4MWVjOGUsIDB4MWVjOWMsIDB4MWVjYjgsIDB4MWVjYzIsIDB4MWVjYzQsXG4gICAgICAgIDB4MWVjYzgsIDB4MWVjZDAsIDB4MWVjZTYsIDB4MWVjZmEsIDB4MWVkMGUsIDB4MWVkMWMsIDB4MWVkMzgsIDB4MWVkNzAsIDB4MWVkN2UsIDB4MWVkODIsIDB4MWVkODQsIDB4MWVkODgsXG4gICAgICAgIDB4MWVkOTAsIDB4MWVkOWUsIDB4MWVkYTAsIDB4MWVkY2MsIDB4MWVkZjIsIDB4MWVkZjQsIDB4MWVlMTYsIDB4MWVlMjYsIDB4MWVlMmMsIDB4MWVlM2EsIDB4MWVlNDYsIDB4MWVlNGMsXG4gICAgICAgIDB4MWVlNTgsIDB4MWVlNmUsIDB4MWVlNzIsIDB4MWVlNzQsIDB4MWVlODYsIDB4MWVlOGMsIDB4MWVlOTgsIDB4MWVlYjAsIDB4MWVlYmUsIDB4MWVlY2UsIDB4MWVlZGMsIDB4MWVlZTIsXG4gICAgICAgIDB4MWVlZTQsIDB4MWVlZTgsIDB4MWVmMTIsIDB4MWVmMjIsIDB4MWVmMjQsIDB4MWVmMjgsIDB4MWVmMzYsIDB4MWVmNDIsIDB4MWVmNDQsIDB4MWVmNDgsIDB4MWVmNTAsIDB4MWVmNWUsXG4gICAgICAgIDB4MWVmNjYsIDB4MWVmNmMsIDB4MWVmN2EsIDB4MWVmYWUsIDB4MWVmYjIsIDB4MWVmYjQsIDB4MWVmZDYsIDB4MWYwOTYsIDB4MWYwYTYsIDB4MWYwYWMsIDB4MWYwYmEsIDB4MWYwY2EsXG4gICAgICAgIDB4MWYwZDIsIDB4MWYwZDQsIDB4MWYxMTYsIDB4MWYxMjYsIDB4MWYxMmMsIDB4MWYxM2EsIDB4MWYxNDYsIDB4MWYxNGMsIDB4MWYxNTgsIDB4MWYxNmUsIDB4MWYxNzIsIDB4MWYxNzQsXG4gICAgICAgIDB4MWYxOGEsIDB4MWYxOTIsIDB4MWYxOTQsIDB4MWYxYTIsIDB4MWYxYTQsIDB4MWYxYTgsIDB4MWYxZGEsIDB4MWYyMTYsIDB4MWYyMjYsIDB4MWYyMmMsIDB4MWYyM2EsIDB4MWYyNDYsXG4gICAgICAgIDB4MWYyNTgsIDB4MWYyNmUsIDB4MWYyNzIsIDB4MWYyNzQsIDB4MWYyODYsIDB4MWYyOGMsIDB4MWYyOTgsIDB4MWYyYjAsIDB4MWYyYmUsIDB4MWYyY2UsIDB4MWYyZGMsIDB4MWYyZTIsXG4gICAgICAgIDB4MWYyZTQsIDB4MWYyZTgsIDB4MWYyZjYsIDB4MWYzMGEsIDB4MWYzMTIsIDB4MWYzMTQsIDB4MWYzMjIsIDB4MWYzMjgsIDB4MWYzNDIsIDB4MWYzNDQsIDB4MWYzNDgsIDB4MWYzNTAsXG4gICAgICAgIDB4MWYzNWUsIDB4MWYzNjYsIDB4MWYzN2EsIDB4MWYzOWEsIDB4MWYzYWUsIDB4MWYzYjIsIDB4MWYzYjQsIDB4MWY0MTYsIDB4MWY0MjYsIDB4MWY0MmMsIDB4MWY0M2EsIDB4MWY0NDYsXG4gICAgICAgIDB4MWY0NGMsIDB4MWY0NTgsIDB4MWY0NmUsIDB4MWY0NzIsIDB4MWY0NzQsIDB4MWY0ODYsIDB4MWY0OGMsIDB4MWY0OTgsIDB4MWY0YjAsIDB4MWY0YmUsIDB4MWY0Y2UsIDB4MWY0ZGMsXG4gICAgICAgIDB4MWY0ZTIsIDB4MWY0ZTQsIDB4MWY0ZTgsIDB4MWY0ZjYsIDB4MWY1MDYsIDB4MWY1MGMsIDB4MWY1MTgsIDB4MWY1MzAsIDB4MWY1M2UsIDB4MWY1NjAsIDB4MWY1N2MsIDB4MWY1OGUsXG4gICAgICAgIDB4MWY1OWMsIDB4MWY1YjgsIDB4MWY1YzIsIDB4MWY1YzQsIDB4MWY1YzgsIDB4MWY1ZDAsIDB4MWY1ZGUsIDB4MWY1ZTYsIDB4MWY1ZWMsIDB4MWY1ZmEsIDB4MWY2MGEsIDB4MWY2MTIsXG4gICAgICAgIDB4MWY2MTQsIDB4MWY2MjIsIDB4MWY2MjQsIDB4MWY2MjgsIDB4MWY2MzYsIDB4MWY2NDIsIDB4MWY2NDQsIDB4MWY2NDgsIDB4MWY2NTAsIDB4MWY2NWUsIDB4MWY2NjYsIDB4MWY2N2EsXG4gICAgICAgIDB4MWY2ODIsIDB4MWY2ODQsIDB4MWY2ODgsIDB4MWY2OTAsIDB4MWY2OWUsIDB4MWY2YTAsIDB4MWY2YmMsIDB4MWY2Y2MsIDB4MWY2ZjIsIDB4MWY2ZjQsIDB4MWY3MWEsIDB4MWY3MmUsXG4gICAgICAgIDB4MWY3MzIsIDB4MWY3MzQsIDB4MWY3NGUsIDB4MWY3NWMsIDB4MWY3NjIsIDB4MWY3NjQsIDB4MWY3NjgsIDB4MWY3NzYsIDB4MWY3OTYsIDB4MWY3YTYsIDB4MWY3YWMsIDB4MWY3YmEsXG4gICAgICAgIDB4MWY3ZDIsIDB4MWY3ZDQsIDB4MWY4OWEsIDB4MWY4YWUsIDB4MWY4YjIsIDB4MWY4YjQsIDB4MWY4ZDYsIDB4MWY4ZWEsIDB4MWY5MWEsIDB4MWY5MmUsIDB4MWY5MzIsIDB4MWY5MzQsXG4gICAgICAgIDB4MWY5NGUsIDB4MWY5NWMsIDB4MWY5NjIsIDB4MWY5NjQsIDB4MWY5NjgsIDB4MWY5NzYsIDB4MWY5OTYsIDB4MWY5YTYsIDB4MWY5YWMsIDB4MWY5YmEsIDB4MWY5Y2EsIDB4MWY5ZDIsXG4gICAgICAgIDB4MWY5ZDQsIDB4MWZhMWEsIDB4MWZhMmUsIDB4MWZhMzIsIDB4MWZhMzQsIDB4MWZhNGUsIDB4MWZhNWMsIDB4MWZhNjIsIDB4MWZhNjQsIDB4MWZhNjgsIDB4MWZhNzYsIDB4MWZhOGUsXG4gICAgICAgIDB4MWZhOWMsIDB4MWZhYjgsIDB4MWZhYzIsIDB4MWZhYzQsIDB4MWZhYzgsIDB4MWZhZDAsIDB4MWZhZGUsIDB4MWZhZTYsIDB4MWZhZWMsIDB4MWZiMTYsIDB4MWZiMjYsIDB4MWZiMmMsXG4gICAgICAgIDB4MWZiM2EsIDB4MWZiNDYsIDB4MWZiNGMsIDB4MWZiNTgsIDB4MWZiNmUsIDB4MWZiNzIsIDB4MWZiNzQsIDB4MWZiOGEsIDB4MWZiOTIsIDB4MWZiOTQsIDB4MWZiYTIsIDB4MWZiYTQsXG4gICAgICAgIDB4MWZiYTgsIDB4MWZiYjYsIDB4MWZiZGFcbiAgICBdKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRhYmxlIGNvbnRhaW5zIHRvIGNvZGV3b3JkcyBmb3IgYWxsIHN5bWJvbHMuXG4gICAgICovXG4gICAgUERGNDE3Q29tbW9uLkNPREVXT1JEX1RBQkxFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgMjYyNywgMTgxOSwgMjYyMiwgMjYyMSwgMTgxMywgMTgxMiwgMjcyOSwgMjcyNCwgMjcyMywgMjc3OSwgMjc3NCwgMjc3MywgOTAyLCA4OTYsIDkwOCwgODY4LCA4NjUsIDg2MSwgODU5LCAyNTExLFxuICAgICAgICA4NzMsIDg3MSwgMTc4MCwgODM1LCAyNDkzLCA4MjUsIDI0OTEsIDg0MiwgODM3LCA4NDQsIDE3NjQsIDE3NjIsIDgxMSwgODEwLCA4MDksIDI0ODMsIDgwNywgMjQ4MiwgODA2LCAyNDgwLCA4MTUsXG4gICAgICAgIDgxNCwgODEzLCA4MTIsIDI0ODQsIDgxNywgODE2LCAxNzQ1LCAxNzQ0LCAxNzQyLCAxNzQ2LCAyNjU1LCAyNjM3LCAyNjM1LCAyNjI2LCAyNjI1LCAyNjIzLCAyNjI4LCAxODIwLCAyNzUyLFxuICAgICAgICAyNzM5LCAyNzM3LCAyNzI4LCAyNzI3LCAyNzI1LCAyNzMwLCAyNzg1LCAyNzgzLCAyNzc4LCAyNzc3LCAyNzc1LCAyNzgwLCA3ODcsIDc4MSwgNzQ3LCA3MzksIDczNiwgMjQxMywgNzU0LCA3NTIsXG4gICAgICAgIDE3MTksIDY5MiwgNjg5LCA2ODEsIDIzNzEsIDY3OCwgMjM2OSwgNzAwLCA2OTcsIDY5NCwgNzAzLCAxNjg4LCAxNjg2LCA2NDIsIDYzOCwgMjM0MywgNjMxLCAyMzQxLCA2MjcsIDIzMzgsIDY1MSxcbiAgICAgICAgNjQ2LCA2NDMsIDIzNDUsIDY1NCwgNjUyLCAxNjUyLCAxNjUwLCAxNjQ3LCAxNjU0LCA2MDEsIDU5OSwgMjMyMiwgNTk2LCAyMzIxLCA1OTQsIDIzMTksIDIzMTcsIDYxMSwgNjEwLCA2MDgsIDYwNixcbiAgICAgICAgMjMyNCwgNjAzLCAyMzIzLCA2MTUsIDYxNCwgNjEyLCAxNjE3LCAxNjE2LCAxNjE0LCAxNjEyLCA2MTYsIDE2MTksIDE2MTgsIDI1NzUsIDI1MzgsIDI1MzYsIDkwNSwgOTAxLCA4OTgsIDkwOSxcbiAgICAgICAgMjUwOSwgMjUwNywgMjUwNCwgODcwLCA4NjcsIDg2NCwgODYwLCAyNTEyLCA4NzUsIDg3MiwgMTc4MSwgMjQ5MCwgMjQ4OSwgMjQ4NywgMjQ4NSwgMTc0OCwgODM2LCA4MzQsIDgzMiwgODMwLFxuICAgICAgICAyNDk0LCA4MjcsIDI0OTIsIDg0MywgODQxLCA4MzksIDg0NSwgMTc2NSwgMTc2MywgMjcwMSwgMjY3NiwgMjY3NCwgMjY1MywgMjY0OCwgMjY1NiwgMjYzNCwgMjYzMywgMjYzMSwgMjYyOSxcbiAgICAgICAgMTgyMSwgMjYzOCwgMjYzNiwgMjc3MCwgMjc2MywgMjc2MSwgMjc1MCwgMjc0NSwgMjc1MywgMjczNiwgMjczNSwgMjczMywgMjczMSwgMTg0OCwgMjc0MCwgMjczOCwgMjc4NiwgMjc4NCwgNTkxLFxuICAgICAgICA1ODgsIDU3NiwgNTY5LCA1NjYsIDIyOTYsIDE1OTAsIDUzNywgNTM0LCA1MjYsIDIyNzYsIDUyMiwgMjI3NCwgNTQ1LCA1NDIsIDUzOSwgNTQ4LCAxNTcyLCAxNTcwLCA0ODEsIDIyNDUsIDQ2NixcbiAgICAgICAgMjI0MiwgNDYyLCAyMjM5LCA0OTIsIDQ4NSwgNDgyLCAyMjQ5LCA0OTYsIDQ5NCwgMTUzNCwgMTUzMSwgMTUyOCwgMTUzOCwgNDEzLCAyMTk2LCA0MDYsIDIxOTEsIDIxODgsIDQyNSwgNDE5LFxuICAgICAgICAyMjAyLCA0MTUsIDIxOTksIDQzMiwgNDMwLCA0MjcsIDE0NzIsIDE0NjcsIDE0NjQsIDQzMywgMTQ3NiwgMTQ3NCwgMzY4LCAzNjcsIDIxNjAsIDM2NSwgMjE1OSwgMzYyLCAyMTU3LCAyMTU1LFxuICAgICAgICAyMTUyLCAzNzgsIDM3NywgMzc1LCAyMTY2LCAzNzIsIDIxNjUsIDM2OSwgMjE2MiwgMzgzLCAzODEsIDM3OSwgMjE2OCwgMTQxOSwgMTQxOCwgMTQxNiwgMTQxNCwgMzg1LCAxNDExLCAzODQsXG4gICAgICAgIDE0MjMsIDE0MjIsIDE0MjAsIDE0MjQsIDI0NjEsIDgwMiwgMjQ0MSwgMjQzOSwgNzkwLCA3ODYsIDc4MywgNzk0LCAyNDA5LCAyNDA2LCAyNDAzLCA3NTAsIDc0MiwgNzM4LCAyNDE0LCA3NTYsXG4gICAgICAgIDc1MywgMTcyMCwgMjM2NywgMjM2NSwgMjM2MiwgMjM1OSwgMTY2MywgNjkzLCA2OTEsIDY4NCwgMjM3MywgNjgwLCAyMzcwLCA3MDIsIDY5OSwgNjk2LCA3MDQsIDE2OTAsIDE2ODcsIDIzMzcsXG4gICAgICAgIDIzMzYsIDIzMzQsIDIzMzIsIDE2MjQsIDIzMjksIDE2MjIsIDY0MCwgNjM3LCAyMzQ0LCA2MzQsIDIzNDIsIDYzMCwgMjM0MCwgNjUwLCA2NDgsIDY0NSwgMjM0NiwgNjU1LCA2NTMsIDE2NTMsXG4gICAgICAgIDE2NTEsIDE2NDksIDE2NTUsIDI2MTIsIDI1OTcsIDI1OTUsIDI1NzEsIDI1NjgsIDI1NjUsIDI1NzYsIDI1MzQsIDI1MjksIDI1MjYsIDE3ODcsIDI1NDAsIDI1MzcsIDkwNywgOTA0LCA5MDAsXG4gICAgICAgIDkxMCwgMjUwMywgMjUwMiwgMjUwMCwgMjQ5OCwgMTc2OCwgMjQ5NSwgMTc2NywgMjUxMCwgMjUwOCwgMjUwNiwgODY5LCA4NjYsIDg2MywgMjUxMywgODc2LCA4NzQsIDE3ODIsIDI3MjAsIDI3MTMsXG4gICAgICAgIDI3MTEsIDI2OTcsIDI2OTQsIDI2OTEsIDI3MDIsIDI2NzIsIDI2NzAsIDI2NjQsIDE4MjgsIDI2NzgsIDI2NzUsIDI2NDcsIDI2NDYsIDI2NDQsIDI2NDIsIDE4MjMsIDI2MzksIDE4MjIsIDI2NTQsXG4gICAgICAgIDI2NTIsIDI2NTAsIDI2NTcsIDI3NzEsIDE4NTUsIDI3NjUsIDI3NjIsIDE4NTAsIDE4NDksIDI3NTEsIDI3NDksIDI3NDcsIDI3NTQsIDM1MywgMjE0OCwgMzQ0LCAzNDIsIDMzNiwgMjE0MixcbiAgICAgICAgMzMyLCAyMTQwLCAzNDUsIDEzNzUsIDEzNzMsIDMwNiwgMjEzMCwgMjk5LCAyMTI4LCAyOTUsIDIxMjUsIDMxOSwgMzE0LCAzMTEsIDIxMzIsIDEzNTQsIDEzNTIsIDEzNDksIDEzNTYsIDI2MixcbiAgICAgICAgMjU3LCAyMTAxLCAyNTMsIDIwOTYsIDIwOTMsIDI3NCwgMjczLCAyNjcsIDIxMDcsIDI2MywgMjEwNCwgMjgwLCAyNzgsIDI3NSwgMTMxNiwgMTMxMSwgMTMwOCwgMTMyMCwgMTMxOCwgMjA1MixcbiAgICAgICAgMjAyLCAyMDUwLCAyMDQ0LCAyMDQwLCAyMTksIDIwNjMsIDIxMiwgMjA2MCwgMjA4LCAyMDU1LCAyMjQsIDIyMSwgMjA2NiwgMTI2MCwgMTI1OCwgMTI1MiwgMjMxLCAxMjQ4LCAyMjksIDEyNjYsXG4gICAgICAgIDEyNjQsIDEyNjEsIDEyNjgsIDE1NSwgMTk5OCwgMTUzLCAxOTk2LCAxOTk0LCAxOTkxLCAxOTg4LCAxNjUsIDE2NCwgMjAwNywgMTYyLCAyMDA2LCAxNTksIDIwMDMsIDIwMDAsIDE3MiwgMTcxLFxuICAgICAgICAxNjksIDIwMTIsIDE2NiwgMjAxMCwgMTE4NiwgMTE4NCwgMTE4MiwgMTE3OSwgMTc1LCAxMTc2LCAxNzMsIDExOTIsIDExOTEsIDExODksIDExODcsIDE3NiwgMTE5NCwgMTE5MywgMjMxMyxcbiAgICAgICAgMjMwNywgMjMwNSwgNTkyLCA1ODksIDIyOTQsIDIyOTIsIDIyODksIDU3OCwgNTcyLCA1NjgsIDIyOTcsIDU4MCwgMTU5MSwgMjI3MiwgMjI2NywgMjI2NCwgMTU0NywgNTM4LCA1MzYsIDUyOSxcbiAgICAgICAgMjI3OCwgNTI1LCAyMjc1LCA1NDcsIDU0NCwgNTQxLCAxNTc0LCAxNTcxLCAyMjM3LCAyMjM1LCAyMjI5LCAxNDkzLCAyMjI1LCAxNDg5LCA0NzgsIDIyNDcsIDQ3MCwgMjI0NCwgNDY1LCAyMjQxLFxuICAgICAgICA0OTMsIDQ4OCwgNDg0LCAyMjUwLCA0OTgsIDQ5NSwgMTUzNiwgMTUzMywgMTUzMCwgMTUzOSwgMjE4NywgMjE4NiwgMjE4NCwgMjE4MiwgMTQzMiwgMjE3OSwgMTQzMCwgMjE3NiwgMTQyNywgNDE0LFxuICAgICAgICA0MTIsIDIxOTcsIDQwOSwgMjE5NSwgNDA1LCAyMTkzLCAyMTkwLCA0MjYsIDQyNCwgNDIxLCAyMjAzLCA0MTgsIDIyMDEsIDQzMSwgNDI5LCAxNDczLCAxNDcxLCAxNDY5LCAxNDY2LCA0MzQsXG4gICAgICAgIDE0NzcsIDE0NzUsIDI0NzgsIDI0NzIsIDI0NzAsIDI0NTksIDI0NTcsIDI0NTQsIDI0NjIsIDgwMywgMjQzNywgMjQzMiwgMjQyOSwgMTcyNiwgMjQ0MywgMjQ0MCwgNzkyLCA3ODksIDc4NSxcbiAgICAgICAgMjQwMSwgMjM5OSwgMjM5MywgMTcwMiwgMjM4OSwgMTY5OSwgMjQxMSwgMjQwOCwgMjQwNSwgNzQ1LCA3NDEsIDI0MTUsIDc1OCwgNzU1LCAxNzIxLCAyMzU4LCAyMzU3LCAyMzU1LCAyMzUzLFxuICAgICAgICAxNjYxLCAyMzUwLCAxNjYwLCAyMzQ3LCAxNjU3LCAyMzY4LCAyMzY2LCAyMzY0LCAyMzYxLCAxNjY2LCA2OTAsIDY4NywgMjM3NCwgNjgzLCAyMzcyLCA3MDEsIDY5OCwgNzA1LCAxNjkxLCAxNjg5LFxuICAgICAgICAyNjE5LCAyNjE3LCAyNjEwLCAyNjA4LCAyNjA1LCAyNjEzLCAyNTkzLCAyNTg4LCAyNTg1LCAxODAzLCAyNTk5LCAyNTk2LCAyNTYzLCAyNTYxLCAyNTU1LCAxNzk3LCAyNTUxLCAxNzk1LCAyNTczLFxuICAgICAgICAyNTcwLCAyNTY3LCAyNTc3LCAyNTI1LCAyNTI0LCAyNTIyLCAyNTIwLCAxNzg2LCAyNTE3LCAxNzg1LCAyNTE0LCAxNzgzLCAyNTM1LCAyNTMzLCAyNTMxLCAyNTI4LCAxNzg4LCAyNTQxLCAyNTM5LFxuICAgICAgICA5MDYsIDkwMywgOTExLCAyNzIxLCAxODQ0LCAyNzE1LCAyNzEyLCAxODM4LCAxODM2LCAyNjk5LCAyNjk2LCAyNjkzLCAyNzAzLCAxODI3LCAxODI2LCAxODI0LCAyNjczLCAyNjcxLCAyNjY5LFxuICAgICAgICAyNjY2LCAxODI5LCAyNjc5LCAyNjc3LCAxODU4LCAxODU3LCAyNzcyLCAxODU0LCAxODUzLCAxODUxLCAxODU2LCAyNzY2LCAyNzY0LCAxNDMsIDE5ODcsIDEzOSwgMTk4NiwgMTM1LCAxMzMsXG4gICAgICAgIDEzMSwgMTk4NCwgMTI4LCAxOTgzLCAxMjUsIDE5ODEsIDEzOCwgMTM3LCAxMzYsIDE5ODUsIDExMzMsIDExMzIsIDExMzAsIDExMiwgMTEwLCAxOTc0LCAxMDcsIDE5NzMsIDEwNCwgMTk3MSxcbiAgICAgICAgMTk2OSwgMTIyLCAxMjEsIDExOSwgMTE3LCAxOTc3LCAxMTQsIDE5NzYsIDEyNCwgMTExNSwgMTExNCwgMTExMiwgMTExMCwgMTExNywgMTExNiwgODQsIDgzLCAxOTUzLCA4MSwgMTk1MiwgNzgsXG4gICAgICAgIDE5NTAsIDE5NDgsIDE5NDUsIDk0LCA5MywgOTEsIDE5NTksIDg4LCAxOTU4LCA4NSwgMTk1NSwgOTksIDk3LCA5NSwgMTk2MSwgMTA4NiwgMTA4NSwgMTA4MywgMTA4MSwgMTA3OCwgMTAwLFxuICAgICAgICAxMDkwLCAxMDg5LCAxMDg3LCAxMDkxLCA0OSwgNDcsIDE5MTcsIDQ0LCAxOTE1LCAxOTEzLCAxOTEwLCAxOTA3LCA1OSwgMTkyNiwgNTYsIDE5MjUsIDUzLCAxOTIyLCAxOTE5LCA2NiwgNjQsXG4gICAgICAgIDE5MzEsIDYxLCAxOTI5LCAxMDQyLCAxMDQwLCAxMDM4LCA3MSwgMTAzNSwgNzAsIDEwMzIsIDY4LCAxMDQ4LCAxMDQ3LCAxMDQ1LCAxMDQzLCAxMDUwLCAxMDQ5LCAxMiwgMTAsIDE4NjksIDE4NjcsXG4gICAgICAgIDE4NjQsIDE4NjEsIDIxLCAxODgwLCAxOSwgMTg3NywgMTg3NCwgMTg3MSwgMjgsIDE4ODgsIDI1LCAxODg2LCAyMiwgMTg4MywgOTgyLCA5ODAsIDk3NywgOTc0LCAzMiwgMzAsIDk5MSwgOTg5LFxuICAgICAgICA5ODcsIDk4NCwgMzQsIDk5NSwgOTk0LCA5OTIsIDIxNTEsIDIxNTAsIDIxNDcsIDIxNDYsIDIxNDQsIDM1NiwgMzU1LCAzNTQsIDIxNDksIDIxMzksIDIxMzgsIDIxMzYsIDIxMzQsIDEzNTksXG4gICAgICAgIDM0MywgMzQxLCAzMzgsIDIxNDMsIDMzNSwgMjE0MSwgMzQ4LCAzNDcsIDM0NiwgMTM3NiwgMTM3NCwgMjEyNCwgMjEyMywgMjEyMSwgMjExOSwgMTMyNiwgMjExNiwgMTMyNCwgMzEwLCAzMDgsXG4gICAgICAgIDMwNSwgMjEzMSwgMzAyLCAyMTI5LCAyOTgsIDIxMjcsIDMyMCwgMzE4LCAzMTYsIDMxMywgMjEzMywgMzIyLCAzMjEsIDEzNTUsIDEzNTMsIDEzNTEsIDEzNTcsIDIwOTIsIDIwOTEsIDIwODksXG4gICAgICAgIDIwODcsIDEyNzYsIDIwODQsIDEyNzQsIDIwODEsIDEyNzEsIDI1OSwgMjEwMiwgMjU2LCAyMTAwLCAyNTIsIDIwOTgsIDIwOTUsIDI3MiwgMjY5LCAyMTA4LCAyNjYsIDIxMDYsIDI4MSwgMjc5LFxuICAgICAgICAyNzcsIDEzMTcsIDEzMTUsIDEzMTMsIDEzMTAsIDI4MiwgMTMyMSwgMTMxOSwgMjAzOSwgMjAzNywgMjAzNSwgMjAzMiwgMTIwMywgMjAyOSwgMTIwMCwgMTE5NywgMjA3LCAyMDUzLCAyMDUsXG4gICAgICAgIDIwNTEsIDIwMSwgMjA0OSwgMjA0NiwgMjA0MywgMjIwLCAyMTgsIDIwNjQsIDIxNSwgMjA2MiwgMjExLCAyMDU5LCAyMjgsIDIyNiwgMjIzLCAyMDY5LCAxMjU5LCAxMjU3LCAxMjU0LCAyMzIsXG4gICAgICAgIDEyNTEsIDIzMCwgMTI2NywgMTI2NSwgMTI2MywgMjMxNiwgMjMxNSwgMjMxMiwgMjMxMSwgMjMwOSwgMjMxNCwgMjMwNCwgMjMwMywgMjMwMSwgMjI5OSwgMTU5MywgMjMwOCwgMjMwNiwgNTkwLFxuICAgICAgICAyMjg4LCAyMjg3LCAyMjg1LCAyMjgzLCAxNTc4LCAyMjgwLCAxNTc3LCAyMjk1LCAyMjkzLCAyMjkxLCA1NzksIDU3NywgNTc0LCA1NzEsIDIyOTgsIDU4MiwgNTgxLCAxNTkyLCAyMjYzLCAyMjYyLFxuICAgICAgICAyMjYwLCAyMjU4LCAxNTQ1LCAyMjU1LCAxNTQ0LCAyMjUyLCAxNTQxLCAyMjczLCAyMjcxLCAyMjY5LCAyMjY2LCAxNTUwLCA1MzUsIDUzMiwgMjI3OSwgNTI4LCAyMjc3LCA1NDYsIDU0MywgNTQ5LFxuICAgICAgICAxNTc1LCAxNTczLCAyMjI0LCAyMjIyLCAyMjIwLCAxNDg2LCAyMjE3LCAxNDg1LCAyMjE0LCAxNDgyLCAxNDc5LCAyMjM4LCAyMjM2LCAyMjM0LCAyMjMxLCAxNDk2LCAyMjI4LCAxNDkyLCA0ODAsXG4gICAgICAgIDQ3NywgMjI0OCwgNDczLCAyMjQ2LCA0NjksIDIyNDMsIDQ5MCwgNDg3LCAyMjUxLCA0OTcsIDE1MzcsIDE1MzUsIDE1MzIsIDI0NzcsIDI0NzYsIDI0NzQsIDI0NzksIDI0NjksIDI0NjgsIDI0NjYsXG4gICAgICAgIDI0NjQsIDE3MzAsIDI0NzMsIDI0NzEsIDI0NTMsIDI0NTIsIDI0NTAsIDI0NDgsIDE3MjksIDI0NDUsIDE3MjgsIDI0NjAsIDI0NTgsIDI0NTYsIDI0NjMsIDgwNSwgODA0LCAyNDI4LCAyNDI3LFxuICAgICAgICAyNDI1LCAyNDIzLCAxNzI1LCAyNDIwLCAxNzI0LCAyNDE3LCAxNzIyLCAyNDM4LCAyNDM2LCAyNDM0LCAyNDMxLCAxNzI3LCAyNDQ0LCAyNDQyLCA3OTMsIDc5MSwgNzg4LCA3OTUsIDIzODgsXG4gICAgICAgIDIzODYsIDIzODQsIDE2OTcsIDIzODEsIDE2OTYsIDIzNzgsIDE2OTQsIDE2OTIsIDI0MDIsIDI0MDAsIDIzOTgsIDIzOTUsIDE3MDMsIDIzOTIsIDE3MDEsIDI0MTIsIDI0MTAsIDI0MDcsIDc1MSxcbiAgICAgICAgNzQ4LCA3NDQsIDI0MTYsIDc1OSwgNzU3LCAxODA3LCAyNjIwLCAyNjE4LCAxODA2LCAxODA1LCAyNjExLCAyNjA5LCAyNjA3LCAyNjE0LCAxODAyLCAxODAxLCAxNzk5LCAyNTk0LCAyNTkyLFxuICAgICAgICAyNTkwLCAyNTg3LCAxODA0LCAyNjAwLCAyNTk4LCAxNzk0LCAxNzkzLCAxNzkxLCAxNzg5LCAyNTY0LCAyNTYyLCAyNTYwLCAyNTU3LCAxNzk4LCAyNTU0LCAxNzk2LCAyNTc0LCAyNTcyLCAyNTY5LFxuICAgICAgICAyNTc4LCAxODQ3LCAxODQ2LCAyNzIyLCAxODQzLCAxODQyLCAxODQwLCAxODQ1LCAyNzE2LCAyNzE0LCAxODM1LCAxODM0LCAxODMyLCAxODMwLCAxODM5LCAxODM3LCAyNzAwLCAyNjk4LCAyNjk1LFxuICAgICAgICAyNzA0LCAxODE3LCAxODExLCAxODEwLCA4OTcsIDg2MiwgMTc3NywgODI5LCA4MjYsIDgzOCwgMTc2MCwgMTc1OCwgODA4LCAyNDgxLCAxNzQxLCAxNzQwLCAxNzM4LCAxNzQzLCAyNjI0LCAxODE4LFxuICAgICAgICAyNzI2LCAyNzc2LCA3ODIsIDc0MCwgNzM3LCAxNzE1LCA2ODYsIDY3OSwgNjk1LCAxNjgyLCAxNjgwLCA2MzksIDYyOCwgMjMzOSwgNjQ3LCA2NDQsIDE2NDUsIDE2NDMsIDE2NDAsIDE2NDgsXG4gICAgICAgIDYwMiwgNjAwLCA1OTcsIDU5NSwgMjMyMCwgNTkzLCAyMzE4LCA2MDksIDYwNywgNjA0LCAxNjExLCAxNjEwLCAxNjA4LCAxNjA2LCA2MTMsIDE2MTUsIDE2MTMsIDIzMjgsIDkyNiwgOTI0LCA4OTIsXG4gICAgICAgIDg4NiwgODk5LCA4NTcsIDg1MCwgMjUwNSwgMTc3OCwgODI0LCA4MjMsIDgyMSwgODE5LCAyNDg4LCA4MTgsIDI0ODYsIDgzMywgODMxLCA4MjgsIDg0MCwgMTc2MSwgMTc1OSwgMjY0OSwgMjYzMixcbiAgICAgICAgMjYzMCwgMjc0NiwgMjczNCwgMjczMiwgMjc4MiwgMjc4MSwgNTcwLCA1NjcsIDE1ODcsIDUzMSwgNTI3LCA1MjMsIDU0MCwgMTU2NiwgMTU2NCwgNDc2LCA0NjcsIDQ2MywgMjI0MCwgNDg2LFxuICAgICAgICA0ODMsIDE1MjQsIDE1MjEsIDE1MTgsIDE1MjksIDQxMSwgNDAzLCAyMTkyLCAzOTksIDIxODksIDQyMywgNDE2LCAxNDYyLCAxNDU3LCAxNDU0LCA0MjgsIDE0NjgsIDE0NjUsIDIyMTAsIDM2NixcbiAgICAgICAgMzYzLCAyMTU4LCAzNjAsIDIxNTYsIDM1NywgMjE1MywgMzc2LCAzNzMsIDM3MCwgMjE2MywgMTQxMCwgMTQwOSwgMTQwNywgMTQwNSwgMzgyLCAxNDAyLCAzODAsIDE0MTcsIDE0MTUsIDE0MTIsXG4gICAgICAgIDE0MjEsIDIxNzUsIDIxNzQsIDc3NywgNzc0LCA3NzEsIDc4NCwgNzMyLCA3MjUsIDcyMiwgMjQwNCwgNzQzLCAxNzE2LCA2NzYsIDY3NCwgNjY4LCAyMzYzLCA2NjUsIDIzNjAsIDY4NSwgMTY4NCxcbiAgICAgICAgMTY4MSwgNjI2LCA2MjQsIDYyMiwgMjMzNSwgNjIwLCAyMzMzLCA2MTcsIDIzMzAsIDY0MSwgNjM1LCA2NDksIDE2NDYsIDE2NDQsIDE2NDIsIDI1NjYsIDkyOCwgOTI1LCAyNTMwLCAyNTI3LFxuICAgICAgICA4OTQsIDg5MSwgODg4LCAyNTAxLCAyNDk5LCAyNDk2LCA4NTgsIDg1NiwgODU0LCA4NTEsIDE3NzksIDI2OTIsIDI2NjgsIDI2NjUsIDI2NDUsIDI2NDMsIDI2NDAsIDI2NTEsIDI3NjgsIDI3NTksXG4gICAgICAgIDI3NTcsIDI3NDQsIDI3NDMsIDI3NDEsIDI3NDgsIDM1MiwgMTM4MiwgMzQwLCAzMzcsIDMzMywgMTM3MSwgMTM2OSwgMzA3LCAzMDAsIDI5NiwgMjEyNiwgMzE1LCAzMTIsIDEzNDcsIDEzNDIsXG4gICAgICAgIDEzNTAsIDI2MSwgMjU4LCAyNTAsIDIwOTcsIDI0NiwgMjA5NCwgMjcxLCAyNjgsIDI2NCwgMTMwNiwgMTMwMSwgMTI5OCwgMjc2LCAxMzEyLCAxMzA5LCAyMTE1LCAyMDMsIDIwNDgsIDE5NSxcbiAgICAgICAgMjA0NSwgMTkxLCAyMDQxLCAyMTMsIDIwOSwgMjA1NiwgMTI0NiwgMTI0NCwgMTIzOCwgMjI1LCAxMjM0LCAyMjIsIDEyNTYsIDEyNTMsIDEyNDksIDEyNjIsIDIwODAsIDIwNzksIDE1NCwgMTk5NyxcbiAgICAgICAgMTUwLCAxOTk1LCAxNDcsIDE5OTIsIDE5ODksIDE2MywgMTYwLCAyMDA0LCAxNTYsIDIwMDEsIDExNzUsIDExNzQsIDExNzIsIDExNzAsIDExNjcsIDE3MCwgMTE2NCwgMTY3LCAxMTg1LCAxMTgzLFxuICAgICAgICAxMTgwLCAxMTc3LCAxNzQsIDExOTAsIDExODgsIDIwMjUsIDIwMjQsIDIwMjIsIDU4NywgNTg2LCA1NjQsIDU1OSwgNTU2LCAyMjkwLCA1NzMsIDE1ODgsIDUyMCwgNTE4LCA1MTIsIDIyNjgsXG4gICAgICAgIDUwOCwgMjI2NSwgNTMwLCAxNTY4LCAxNTY1LCA0NjEsIDQ1NywgMjIzMywgNDUwLCAyMjMwLCA0NDYsIDIyMjYsIDQ3OSwgNDcxLCA0ODksIDE1MjYsIDE1MjMsIDE1MjAsIDM5NywgMzk1LFxuICAgICAgICAyMTg1LCAzOTIsIDIxODMsIDM4OSwgMjE4MCwgMjE3NywgNDEwLCAyMTk0LCA0MDIsIDQyMiwgMTQ2MywgMTQ2MSwgMTQ1OSwgMTQ1NiwgMTQ3MCwgMjQ1NSwgNzk5LCAyNDMzLCAyNDMwLCA3NzksXG4gICAgICAgIDc3NiwgNzczLCAyMzk3LCAyMzk0LCAyMzkwLCA3MzQsIDcyOCwgNzI0LCA3NDYsIDE3MTcsIDIzNTYsIDIzNTQsIDIzNTEsIDIzNDgsIDE2NTgsIDY3NywgNjc1LCA2NzMsIDY3MCwgNjY3LCA2ODgsXG4gICAgICAgIDE2ODUsIDE2ODMsIDI2MDYsIDI1ODksIDI1ODYsIDI1NTksIDI1NTYsIDI1NTIsIDkyNywgMjUyMywgMjUyMSwgMjUxOCwgMjUxNSwgMTc4NCwgMjUzMiwgODk1LCA4OTMsIDg5MCwgMjcxOCxcbiAgICAgICAgMjcwOSwgMjcwNywgMjY4OSwgMjY4NywgMjY4NCwgMjY2MywgMjY2MiwgMjY2MCwgMjY1OCwgMTgyNSwgMjY2NywgMjc2OSwgMTg1MiwgMjc2MCwgMjc1OCwgMTQyLCAxNDEsIDExMzksIDExMzgsXG4gICAgICAgIDEzNCwgMTMyLCAxMjksIDEyNiwgMTk4MiwgMTEyOSwgMTEyOCwgMTEyNiwgMTEzMSwgMTEzLCAxMTEsIDEwOCwgMTA1LCAxOTcyLCAxMDEsIDE5NzAsIDEyMCwgMTE4LCAxMTUsIDExMDksIDExMDgsXG4gICAgICAgIDExMDYsIDExMDQsIDEyMywgMTExMywgMTExMSwgODIsIDc5LCAxOTUxLCA3NSwgMTk0OSwgNzIsIDE5NDYsIDkyLCA4OSwgODYsIDE5NTYsIDEwNzcsIDEwNzYsIDEwNzQsIDEwNzIsIDk4LFxuICAgICAgICAxMDY5LCA5NiwgMTA4NCwgMTA4MiwgMTA3OSwgMTA4OCwgMTk2OCwgMTk2NywgNDgsIDQ1LCAxOTE2LCA0MiwgMTkxNCwgMzksIDE5MTEsIDE5MDgsIDYwLCA1NywgNTQsIDE5MjMsIDUwLCAxOTIwLFxuICAgICAgICAxMDMxLCAxMDMwLCAxMDI4LCAxMDI2LCA2NywgMTAyMywgNjUsIDEwMjAsIDYyLCAxMDQxLCAxMDM5LCAxMDM2LCAxMDMzLCA2OSwgMTA0NiwgMTA0NCwgMTk0NCwgMTk0MywgMTk0MSwgMTEsIDksXG4gICAgICAgIDE4NjgsIDcsIDE4NjUsIDE4NjIsIDE4NTksIDIwLCAxODc4LCAxNiwgMTg3NSwgMTMsIDE4NzIsIDk3MCwgOTY4LCA5NjYsIDk2MywgMjksIDk2MCwgMjYsIDIzLCA5ODMsIDk4MSwgOTc4LCA5NzUsXG4gICAgICAgIDMzLCA5NzEsIDMxLCA5OTAsIDk4OCwgOTg1LCAxOTA2LCAxOTA0LCAxOTAyLCA5OTMsIDM1MSwgMjE0NSwgMTM4MywgMzMxLCAzMzAsIDMyOCwgMzI2LCAyMTM3LCAzMjMsIDIxMzUsIDMzOSxcbiAgICAgICAgMTM3MiwgMTM3MCwgMjk0LCAyOTMsIDI5MSwgMjg5LCAyMTIyLCAyODYsIDIxMjAsIDI4MywgMjExNywgMzA5LCAzMDMsIDMxNywgMTM0OCwgMTM0NiwgMTM0NCwgMjQ1LCAyNDQsIDI0MiwgMjA5MCxcbiAgICAgICAgMjM5LCAyMDg4LCAyMzYsIDIwODUsIDIwODIsIDI2MCwgMjA5OSwgMjQ5LCAyNzAsIDEzMDcsIDEzMDUsIDEzMDMsIDEzMDAsIDEzMTQsIDE4OSwgMjAzOCwgMTg2LCAyMDM2LCAxODMsIDIwMzMsXG4gICAgICAgIDIwMzAsIDIwMjYsIDIwNiwgMTk4LCAyMDQ3LCAxOTQsIDIxNiwgMTI0NywgMTI0NSwgMTI0MywgMTI0MCwgMjI3LCAxMjM3LCAxMjU1LCAyMzEwLCAyMzAyLCAyMzAwLCAyMjg2LCAyMjg0LFxuICAgICAgICAyMjgxLCA1NjUsIDU2MywgNTYxLCA1NTgsIDU3NSwgMTU4OSwgMjI2MSwgMjI1OSwgMjI1NiwgMjI1MywgMTU0MiwgNTIxLCA1MTksIDUxNywgNTE0LCAyMjcwLCA1MTEsIDUzMywgMTU2OSxcbiAgICAgICAgMTU2NywgMjIyMywgMjIyMSwgMjIxOCwgMjIxNSwgMTQ4MywgMjIxMSwgMTQ4MCwgNDU5LCA0NTYsIDQ1MywgMjIzMiwgNDQ5LCA0NzQsIDQ5MSwgMTUyNywgMTUyNSwgMTUyMiwgMjQ3NSwgMjQ2NyxcbiAgICAgICAgMjQ2NSwgMjQ1MSwgMjQ0OSwgMjQ0NiwgODAxLCA4MDAsIDI0MjYsIDI0MjQsIDI0MjEsIDI0MTgsIDE3MjMsIDI0MzUsIDc4MCwgNzc4LCA3NzUsIDIzODcsIDIzODUsIDIzODIsIDIzNzksXG4gICAgICAgIDE2OTUsIDIzNzUsIDE2OTMsIDIzOTYsIDczNSwgNzMzLCA3MzAsIDcyNywgNzQ5LCAxNzE4LCAyNjE2LCAyNjE1LCAyNjA0LCAyNjAzLCAyNjAxLCAyNTg0LCAyNTgzLCAyNTgxLCAyNTc5LFxuICAgICAgICAxODAwLCAyNTkxLCAyNTUwLCAyNTQ5LCAyNTQ3LCAyNTQ1LCAxNzkyLCAyNTQyLCAxNzkwLCAyNTU4LCA5MjksIDI3MTksIDE4NDEsIDI3MTAsIDI3MDgsIDE4MzMsIDE4MzEsIDI2OTAsIDI2ODgsXG4gICAgICAgIDI2ODYsIDE4MTUsIDE4MDksIDE4MDgsIDE3NzQsIDE3NTYsIDE3NTQsIDE3MzcsIDE3MzYsIDE3MzQsIDE3MzksIDE4MTYsIDE3MTEsIDE2NzYsIDE2NzQsIDYzMywgNjI5LCAxNjM4LCAxNjM2LFxuICAgICAgICAxNjMzLCAxNjQxLCA1OTgsIDE2MDUsIDE2MDQsIDE2MDIsIDE2MDAsIDYwNSwgMTYwOSwgMTYwNywgMjMyNywgODg3LCA4NTMsIDE3NzUsIDgyMiwgODIwLCAxNzU3LCAxNzU1LCAxNTg0LCA1MjQsXG4gICAgICAgIDE1NjAsIDE1NTgsIDQ2OCwgNDY0LCAxNTE0LCAxNTExLCAxNTA4LCAxNTE5LCA0MDgsIDQwNCwgNDAwLCAxNDUyLCAxNDQ3LCAxNDQ0LCA0MTcsIDE0NTgsIDE0NTUsIDIyMDgsIDM2NCwgMzYxLFxuICAgICAgICAzNTgsIDIxNTQsIDE0MDEsIDE0MDAsIDEzOTgsIDEzOTYsIDM3NCwgMTM5MywgMzcxLCAxNDA4LCAxNDA2LCAxNDAzLCAxNDEzLCAyMTczLCAyMTcyLCA3NzIsIDcyNiwgNzIzLCAxNzEyLCA2NzIsXG4gICAgICAgIDY2OSwgNjY2LCA2ODIsIDE2NzgsIDE2NzUsIDYyNSwgNjIzLCA2MjEsIDYxOCwgMjMzMSwgNjM2LCA2MzIsIDE2MzksIDE2MzcsIDE2MzUsIDkyMCwgOTE4LCA4ODQsIDg4MCwgODg5LCA4NDksXG4gICAgICAgIDg0OCwgODQ3LCA4NDYsIDI0OTcsIDg1NSwgODUyLCAxNzc2LCAyNjQxLCAyNzQyLCAyNzg3LCAxMzgwLCAzMzQsIDEzNjcsIDEzNjUsIDMwMSwgMjk3LCAxMzQwLCAxMzM4LCAxMzM1LCAxMzQzLFxuICAgICAgICAyNTUsIDI1MSwgMjQ3LCAxMjk2LCAxMjkxLCAxMjg4LCAyNjUsIDEzMDIsIDEyOTksIDIxMTMsIDIwNCwgMTk2LCAxOTIsIDIwNDIsIDEyMzIsIDEyMzAsIDEyMjQsIDIxNCwgMTIyMCwgMjEwLFxuICAgICAgICAxMjQyLCAxMjM5LCAxMjM1LCAxMjUwLCAyMDc3LCAyMDc1LCAxNTEsIDE0OCwgMTk5MywgMTQ0LCAxOTkwLCAxMTYzLCAxMTYyLCAxMTYwLCAxMTU4LCAxMTU1LCAxNjEsIDExNTIsIDE1NyxcbiAgICAgICAgMTE3MywgMTE3MSwgMTE2OCwgMTE2NSwgMTY4LCAxMTgxLCAxMTc4LCAyMDIxLCAyMDIwLCAyMDE4LCAyMDIzLCA1ODUsIDU2MCwgNTU3LCAxNTg1LCA1MTYsIDUwOSwgMTU2MiwgMTU1OSwgNDU4LFxuICAgICAgICA0NDcsIDIyMjcsIDQ3MiwgMTUxNiwgMTUxMywgMTUxMCwgMzk4LCAzOTYsIDM5MywgMzkwLCAyMTgxLCAzODYsIDIxNzgsIDQwNywgMTQ1MywgMTQ1MSwgMTQ0OSwgMTQ0NiwgNDIwLCAxNDYwLFxuICAgICAgICAyMjA5LCA3NjksIDc2NCwgNzIwLCA3MTIsIDIzOTEsIDcyOSwgMTcxMywgNjY0LCA2NjMsIDY2MSwgNjU5LCAyMzUyLCA2NTYsIDIzNDksIDY3MSwgMTY3OSwgMTY3NywgMjU1MywgOTIyLCA5MTksXG4gICAgICAgIDI1MTksIDI1MTYsIDg4NSwgODgzLCA4ODEsIDI2ODUsIDI2NjEsIDI2NTksIDI3NjcsIDI3NTYsIDI3NTUsIDE0MCwgMTEzNywgMTEzNiwgMTMwLCAxMjcsIDExMjUsIDExMjQsIDExMjIsIDExMjcsXG4gICAgICAgIDEwOSwgMTA2LCAxMDIsIDExMDMsIDExMDIsIDExMDAsIDEwOTgsIDExNiwgMTEwNywgMTEwNSwgMTk4MCwgODAsIDc2LCA3MywgMTk0NywgMTA2OCwgMTA2NywgMTA2NSwgMTA2MywgOTAsIDEwNjAsXG4gICAgICAgIDg3LCAxMDc1LCAxMDczLCAxMDcwLCAxMDgwLCAxOTY2LCAxOTY1LCA0NiwgNDMsIDQwLCAxOTEyLCAzNiwgMTkwOSwgMTAxOSwgMTAxOCwgMTAxNiwgMTAxNCwgNTgsIDEwMTEsIDU1LCAxMDA4LFxuICAgICAgICA1MSwgMTAyOSwgMTAyNywgMTAyNCwgMTAyMSwgNjMsIDEwMzcsIDEwMzQsIDE5NDAsIDE5MzksIDE5MzcsIDE5NDIsIDgsIDE4NjYsIDQsIDE4NjMsIDEsIDE4NjAsIDk1NiwgOTU0LCA5NTIsXG4gICAgICAgIDk0OSwgOTQ2LCAxNywgMTQsIDk2OSwgOTY3LCA5NjQsIDk2MSwgMjcsIDk1NywgMjQsIDk3OSwgOTc2LCA5NzIsIDE5MDEsIDE5MDAsIDE4OTgsIDE4OTYsIDk4NiwgMTkwNSwgMTkwMywgMzUwLFxuICAgICAgICAzNDksIDEzODEsIDMyOSwgMzI3LCAzMjQsIDEzNjgsIDEzNjYsIDI5MiwgMjkwLCAyODcsIDI4NCwgMjExOCwgMzA0LCAxMzQxLCAxMzM5LCAxMzM3LCAxMzQ1LCAyNDMsIDI0MCwgMjM3LCAyMDg2LFxuICAgICAgICAyMzMsIDIwODMsIDI1NCwgMTI5NywgMTI5NSwgMTI5MywgMTI5MCwgMTMwNCwgMjExNCwgMTkwLCAxODcsIDE4NCwgMjAzNCwgMTgwLCAyMDMxLCAxNzcsIDIwMjcsIDE5OSwgMTIzMywgMTIzMSxcbiAgICAgICAgMTIyOSwgMTIyNiwgMjE3LCAxMjIzLCAxMjQxLCAyMDc4LCAyMDc2LCA1ODQsIDU1NSwgNTU0LCA1NTIsIDU1MCwgMjI4MiwgNTYyLCAxNTg2LCA1MDcsIDUwNiwgNTA0LCA1MDIsIDIyNTcsIDQ5OSxcbiAgICAgICAgMjI1NCwgNTE1LCAxNTYzLCAxNTYxLCA0NDUsIDQ0MywgNDQxLCAyMjE5LCA0MzgsIDIyMTYsIDQzNSwgMjIxMiwgNDYwLCA0NTQsIDQ3NSwgMTUxNywgMTUxNSwgMTUxMiwgMjQ0NywgNzk4LFxuICAgICAgICA3OTcsIDI0MjIsIDI0MTksIDc3MCwgNzY4LCA3NjYsIDIzODMsIDIzODAsIDIzNzYsIDcyMSwgNzE5LCA3MTcsIDcxNCwgNzMxLCAxNzE0LCAyNjAyLCAyNTgyLCAyNTgwLCAyNTQ4LCAyNTQ2LFxuICAgICAgICAyNTQzLCA5MjMsIDkyMSwgMjcxNywgMjcwNiwgMjcwNSwgMjY4MywgMjY4MiwgMjY4MCwgMTc3MSwgMTc1MiwgMTc1MCwgMTczMywgMTczMiwgMTczMSwgMTczNSwgMTgxNCwgMTcwNywgMTY3MCxcbiAgICAgICAgMTY2OCwgMTYzMSwgMTYyOSwgMTYyNiwgMTYzNCwgMTU5OSwgMTU5OCwgMTU5NiwgMTU5NCwgMTYwMywgMTYwMSwgMjMyNiwgMTc3MiwgMTc1MywgMTc1MSwgMTU4MSwgMTU1NCwgMTU1MiwgMTUwNCxcbiAgICAgICAgMTUwMSwgMTQ5OCwgMTUwOSwgMTQ0MiwgMTQzNywgMTQzNCwgNDAxLCAxNDQ4LCAxNDQ1LCAyMjA2LCAxMzkyLCAxMzkxLCAxMzg5LCAxMzg3LCAxMzg0LCAzNTksIDEzOTksIDEzOTcsIDEzOTQsXG4gICAgICAgIDE0MDQsIDIxNzEsIDIxNzAsIDE3MDgsIDE2NzIsIDE2NjksIDYxOSwgMTYzMiwgMTYzMCwgMTYyOCwgMTc3MywgMTM3OCwgMTM2MywgMTM2MSwgMTMzMywgMTMyOCwgMTMzNiwgMTI4NiwgMTI4MSxcbiAgICAgICAgMTI3OCwgMjQ4LCAxMjkyLCAxMjg5LCAyMTExLCAxMjE4LCAxMjE2LCAxMjEwLCAxOTcsIDEyMDYsIDE5MywgMTIyOCwgMTIyNSwgMTIyMSwgMTIzNiwgMjA3MywgMjA3MSwgMTE1MSwgMTE1MCxcbiAgICAgICAgMTE0OCwgMTE0NiwgMTUyLCAxMTQzLCAxNDksIDExNDAsIDE0NSwgMTE2MSwgMTE1OSwgMTE1NiwgMTE1MywgMTU4LCAxMTY5LCAxMTY2LCAyMDE3LCAyMDE2LCAyMDE0LCAyMDE5LCAxNTgyLFxuICAgICAgICA1MTAsIDE1NTYsIDE1NTMsIDQ1MiwgNDQ4LCAxNTA2LCAxNTAwLCAzOTQsIDM5MSwgMzg3LCAxNDQzLCAxNDQxLCAxNDM5LCAxNDM2LCAxNDUwLCAyMjA3LCA3NjUsIDcxNiwgNzEzLCAxNzA5LFxuICAgICAgICA2NjIsIDY2MCwgNjU3LCAxNjczLCAxNjcxLCA5MTYsIDkxNCwgODc5LCA4NzgsIDg3NywgODgyLCAxMTM1LCAxMTM0LCAxMTIxLCAxMTIwLCAxMTE4LCAxMTIzLCAxMDk3LCAxMDk2LCAxMDk0LFxuICAgICAgICAxMDkyLCAxMDMsIDExMDEsIDEwOTksIDE5NzksIDEwNTksIDEwNTgsIDEwNTYsIDEwNTQsIDc3LCAxMDUxLCA3NCwgMTA2NiwgMTA2NCwgMTA2MSwgMTA3MSwgMTk2NCwgMTk2MywgMTAwNyxcbiAgICAgICAgMTAwNiwgMTAwNCwgMTAwMiwgOTk5LCA0MSwgOTk2LCAzNywgMTAxNywgMTAxNSwgMTAxMiwgMTAwOSwgNTIsIDEwMjUsIDEwMjIsIDE5MzYsIDE5MzUsIDE5MzMsIDE5MzgsIDk0MiwgOTQwLFxuICAgICAgICA5MzgsIDkzNSwgOTMyLCA1LCAyLCA5NTUsIDk1MywgOTUwLCA5NDcsIDE4LCA5NDMsIDE1LCA5NjUsIDk2MiwgOTU4LCAxODk1LCAxODk0LCAxODkyLCAxODkwLCA5NzMsIDE4OTksIDE4OTcsXG4gICAgICAgIDEzNzksIDMyNSwgMTM2NCwgMTM2MiwgMjg4LCAyODUsIDEzMzQsIDEzMzIsIDEzMzAsIDI0MSwgMjM4LCAyMzQsIDEyODcsIDEyODUsIDEyODMsIDEyODAsIDEyOTQsIDIxMTIsIDE4OCwgMTg1LFxuICAgICAgICAxODEsIDE3OCwgMjAyOCwgMTIxOSwgMTIxNywgMTIxNSwgMTIxMiwgMjAwLCAxMjA5LCAxMjI3LCAyMDc0LCAyMDcyLCA1ODMsIDU1MywgNTUxLCAxNTgzLCA1MDUsIDUwMywgNTAwLCA1MTMsXG4gICAgICAgIDE1NTcsIDE1NTUsIDQ0NCwgNDQyLCA0MzksIDQzNiwgMjIxMywgNDU1LCA0NTEsIDE1MDcsIDE1MDUsIDE1MDIsIDc5NiwgNzYzLCA3NjIsIDc2MCwgNzY3LCA3MTEsIDcxMCwgNzA4LCA3MDYsXG4gICAgICAgIDIzNzcsIDcxOCwgNzE1LCAxNzEwLCAyNTQ0LCA5MTcsIDkxNSwgMjY4MSwgMTYyNywgMTU5NywgMTU5NSwgMjMyNSwgMTc2OSwgMTc0OSwgMTc0NywgMTQ5OSwgMTQzOCwgMTQzNSwgMjIwNCxcbiAgICAgICAgMTM5MCwgMTM4OCwgMTM4NSwgMTM5NSwgMjE2OSwgMjE2NywgMTcwNCwgMTY2NSwgMTY2MiwgMTYyNSwgMTYyMywgMTYyMCwgMTc3MCwgMTMyOSwgMTI4MiwgMTI3OSwgMjEwOSwgMTIxNCwgMTIwNyxcbiAgICAgICAgMTIyMiwgMjA2OCwgMjA2NSwgMTE0OSwgMTE0NywgMTE0NCwgMTE0MSwgMTQ2LCAxMTU3LCAxMTU0LCAyMDEzLCAyMDExLCAyMDA4LCAyMDE1LCAxNTc5LCAxNTQ5LCAxNTQ2LCAxNDk1LCAxNDg3LFxuICAgICAgICAxNDMzLCAxNDMxLCAxNDI4LCAxNDI1LCAzODgsIDE0NDAsIDIyMDUsIDE3MDUsIDY1OCwgMTY2NywgMTY2NCwgMTExOSwgMTA5NSwgMTA5MywgMTk3OCwgMTA1NywgMTA1NSwgMTA1MiwgMTA2MixcbiAgICAgICAgMTk2MiwgMTk2MCwgMTAwNSwgMTAwMywgMTAwMCwgOTk3LCAzOCwgMTAxMywgMTAxMCwgMTkzMiwgMTkzMCwgMTkyNywgMTkzNCwgOTQxLCA5MzksIDkzNiwgOTMzLCA2LCA5MzAsIDMsIDk1MSxcbiAgICAgICAgOTQ4LCA5NDQsIDE4ODksIDE4ODcsIDE4ODQsIDE4ODEsIDk1OSwgMTg5MywgMTg5MSwgMzUsIDEzNzcsIDEzNjAsIDEzNTgsIDEzMjcsIDEzMjUsIDEzMjIsIDEzMzEsIDEyNzcsIDEyNzUsXG4gICAgICAgIDEyNzIsIDEyNjksIDIzNSwgMTI4NCwgMjExMCwgMTIwNSwgMTIwNCwgMTIwMSwgMTE5OCwgMTgyLCAxMTk1LCAxNzksIDEyMTMsIDIwNzAsIDIwNjcsIDE1ODAsIDUwMSwgMTU1MSwgMTU0OCxcbiAgICAgICAgNDQwLCA0MzcsIDE0OTcsIDE0OTQsIDE0OTAsIDE1MDMsIDc2MSwgNzA5LCA3MDcsIDE3MDYsIDkxMywgOTEyLCAyMTk4LCAxMzg2LCAyMTY0LCAyMTYxLCAxNjIxLCAxNzY2LCAyMTAzLCAxMjA4LFxuICAgICAgICAyMDU4LCAyMDU0LCAxMTQ1LCAxMTQyLCAyMDA1LCAyMDAyLCAxOTk5LCAyMDA5LCAxNDg4LCAxNDI5LCAxNDI2LCAyMjAwLCAxNjk4LCAxNjU5LCAxNjU2LCAxOTc1LCAxMDUzLCAxOTU3LCAxOTU0LFxuICAgICAgICAxMDAxLCA5OTgsIDE5MjQsIDE5MjEsIDE5MTgsIDE5MjgsIDkzNywgOTM0LCA5MzEsIDE4NzksIDE4NzYsIDE4NzMsIDE4NzAsIDk0NSwgMTg4NSwgMTg4MiwgMTMyMywgMTI3MywgMTI3MCxcbiAgICAgICAgMjEwNSwgMTIwMiwgMTE5OSwgMTE5NiwgMTIxMSwgMjA2MSwgMjA1NywgMTU3NiwgMTU0MywgMTU0MCwgMTQ4NCwgMTQ4MSwgMTQ3OCwgMTQ5MSwgMTcwMFxuICAgIF0pO1xuICAgIHJldHVybiBQREY0MTdDb21tb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUERGNDE3Q29tbW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417;\n// import com.google.zxing.BarcodeFormat;\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\n// import com.google.zxing.FormatException;\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n// import com.google.zxing.Result;\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\n// import com.google.zxing.common.DecoderResult;\n// import com.google.zxing.multi.MultipleBarcodeReader;\n// import com.google.zxing.pdf417.decoder.PDF417ScanningDecoder;\n// import com.google.zxing.pdf417.detector.Detector;\n// import com.google.zxing.pdf417.detector.PDF417DetectorResult;\nvar PDF417Common_1 = __webpack_require__(/*! ./PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\nvar Integer_1 = __webpack_require__(/*! ../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nvar Detector_1 = __webpack_require__(/*! ./detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js\");\nvar PDF417ScanningDecoder_1 = __webpack_require__(/*! ./decoder/PDF417ScanningDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js\");\n// import java.util.ArrayList;\n// import java.util.List;\n// import java.util.Map;\n/**\n * This implementation can detect and decode PDF417 codes in an image.\n *\n * @author Guenther Grau\n */\nvar PDF417Reader = /** @class */ (function () {\n    function PDF417Reader() {\n    }\n    // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);\n    /**\n     * Locates and decodes a PDF417 code in an image.\n     *\n     * @return a String representing the content encoded by the PDF417 code\n     * @throws NotFoundException if a PDF417 code cannot be found,\n     * @throws FormatException if a PDF417 cannot be decoded\n     * @throws ChecksumException\n     */\n    // @Override\n    PDF417Reader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var result = PDF417Reader.decode(image, hints, false);\n        if (result == null || result.length === 0 || result[0] == null) {\n            throw NotFoundException_1.default.getNotFoundInstance();\n        }\n        return result[0];\n    };\n    /**\n     *\n     * @param BinaryBitmap\n     * @param image\n     * @throws NotFoundException\n     */\n    //   @Override\n    PDF417Reader.prototype.decodeMultiple = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        try {\n            return PDF417Reader.decode(image, hints, true);\n        }\n        catch (ignored) {\n            if (ignored instanceof FormatException_1.default || ignored instanceof ChecksumException_1.default) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            throw ignored;\n        }\n    };\n    /**\n     *\n     * @param image\n     * @param hints\n     * @param multiple\n     *\n     * @throws NotFoundException\n     * @throws FormatExceptionß\n     * @throws ChecksumException\n     */\n    PDF417Reader.decode = function (image, hints, multiple) {\n        var e_1, _a;\n        var results = new Array();\n        var detectorResult = Detector_1.default.detectMultiple(image, hints, multiple);\n        try {\n            for (var _b = __values(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var points = _c.value;\n                var decoderResult = PDF417ScanningDecoder_1.default.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));\n                var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.PDF_417);\n                result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());\n                var pdf417ResultMetadata = decoderResult.getOther();\n                if (pdf417ResultMetadata != null) {\n                    result.putMetadata(ResultMetadataType_1.default.PDF417_EXTRA_METADATA, pdf417ResultMetadata);\n                }\n                results.push(result);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return results.map(function (x) { return x; });\n    };\n    PDF417Reader.getMaxWidth = function (p1, p2) {\n        if (p1 == null || p2 == null) {\n            return 0;\n        }\n        return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n    };\n    PDF417Reader.getMinWidth = function (p1, p2) {\n        if (p1 == null || p2 == null) {\n            return Integer_1.default.MAX_VALUE;\n        }\n        return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n    };\n    PDF417Reader.getMaxCodewordWidth = function (p) {\n        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /\n            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /\n            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));\n    };\n    PDF417Reader.getMinCodewordWidth = function (p) {\n        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /\n            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /\n            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));\n    };\n    // @Override\n    PDF417Reader.prototype.reset = function () {\n        // nothing needs to be reset\n    };\n    return PDF417Reader;\n}());\nexports[\"default\"] = PDF417Reader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvUERGNDE3UmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxnSkFBb0I7QUFDcEQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEhBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdKQUFnQjtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQywwSUFBaUI7QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsc0pBQXVCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLDBKQUFxQjtBQUM5Qyw4QkFBOEIsbUJBQU8sQ0FBQyxrTEFBaUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixVQUFVO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3BkZjQxNy9QREY0MTdSZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTc7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5CYXJjb2RlRm9ybWF0O1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuQ2hlY2tzdW1FeGNlcHRpb247XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkZvcm1hdEV4Y2VwdGlvbjtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Gb3JtYXRFeGNlcHRpb25cIik7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5Ob3RGb3VuZEV4Y2VwdGlvbjtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuUmVzdWx0O1xudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5EZWNvZGVyUmVzdWx0O1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcubXVsdGkuTXVsdGlwbGVCYXJjb2RlUmVhZGVyO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuUERGNDE3U2Nhbm5pbmdEZWNvZGVyO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRldGVjdG9yLkRldGVjdG9yO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRldGVjdG9yLlBERjQxN0RldGVjdG9yUmVzdWx0O1xudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4vUERGNDE3Q29tbW9uXCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0ludGVnZXJcIik7XG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbnZhciBQREY0MTdTY2FubmluZ0RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXIvUERGNDE3U2Nhbm5pbmdEZWNvZGVyXCIpO1xuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4vLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4vLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbi8qKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUERGNDE3IGNvZGVzIGluIGFuIGltYWdlLlxuICpcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICovXG52YXIgUERGNDE3UmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBERjQxN1JlYWRlcigpIHtcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgLypmaW5hbCBSZXN1bHRbXSovIEVNUFRZX1JFU1VMVF9BUlJBWTogUmVzdWx0W10gPSBuZXcgUmVzdWx0KFswXSk7XG4gICAgLyoqXG4gICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIFBERjQxNyBjb2RlIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgUERGNDE3IGNvZGVcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgUERGNDE3IGNvZGUgY2Fubm90IGJlIGZvdW5kLFxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUERGNDE3IGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAqL1xuICAgIC8vIEBPdmVycmlkZVxuICAgIFBERjQxN1JlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFBERjQxN1JlYWRlci5kZWNvZGUoaW1hZ2UsIGhpbnRzLCBmYWxzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQubGVuZ3RoID09PSAwIHx8IHJlc3VsdFswXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBCaW5hcnlCaXRtYXBcbiAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICovXG4gICAgLy8gICBAT3ZlcnJpZGVcbiAgICBQREY0MTdSZWFkZXIucHJvdG90eXBlLmRlY29kZU11bHRpcGxlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQREY0MTdSZWFkZXIuZGVjb2RlKGltYWdlLCBoaW50cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCB8fCBpZ25vcmVkIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0LmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGlnbm9yZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGltYWdlXG4gICAgICogQHBhcmFtIGhpbnRzXG4gICAgICogQHBhcmFtIG11bHRpcGxlXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb27Dn1xuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgKi9cbiAgICBQREY0MTdSZWFkZXIuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cywgbXVsdGlwbGUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IERldGVjdG9yXzEuZGVmYXVsdC5kZXRlY3RNdWx0aXBsZShpbWFnZSwgaGludHMsIG11bHRpcGxlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVyUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyXzEuZGVmYXVsdC5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQuZ2V0Qml0cygpLCBwb2ludHNbNF0sIHBvaW50c1s1XSwgcG9pbnRzWzZdLCBwb2ludHNbN10sIFBERjQxN1JlYWRlci5nZXRNaW5Db2Rld29yZFdpZHRoKHBvaW50cyksIFBERjQxN1JlYWRlci5nZXRNYXhDb2Rld29yZFdpZHRoKHBvaW50cykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUERGXzQxNyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCkpO1xuICAgICAgICAgICAgICAgIHZhciBwZGY0MTdSZXN1bHRNZXRhZGF0YSA9IGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAocGRmNDE3UmVzdWx0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5QREY0MTdfRVhUUkFfTUVUQURBVEEsIHBkZjQxN1Jlc3VsdE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH07XG4gICAgUERGNDE3UmVhZGVyLmdldE1heFdpZHRoID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICBpZiAocDEgPT0gbnVsbCB8fCBwMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICB9O1xuICAgIFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgaWYgKHAxID09IG51bGwgfHwgcDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICB9O1xuICAgIFBERjQxN1JlYWRlci5nZXRNYXhDb2Rld29yZFdpZHRoID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoTWF0aC5tYXgoUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQgL1xuICAgICAgICAgICAgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiksIE1hdGgubWF4KFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzFdLCBwWzVdKSwgUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbN10sIHBbM10pICogUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pKSk7XG4gICAgfTtcbiAgICBQREY0MTdSZWFkZXIuZ2V0TWluQ29kZXdvcmRXaWR0aCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKE1hdGgubWluKFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzBdLCBwWzRdKSwgUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbNl0sIHBbMl0pICogUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pLCBNYXRoLm1pbihQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFsxXSwgcFs1XSksIFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzddLCBwWzNdKSAqIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xuICAgIH07XG4gICAgLy8gQE92ZXJyaWRlXG4gICAgUERGNDE3UmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm90aGluZyBuZWVkcyB0byBiZSByZXNldFxuICAgIH07XG4gICAgcmV0dXJuIFBERjQxN1JlYWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417;\n/**\n * @author Guenther Grau\n */\nvar PDF417ResultMetadata = /** @class */ (function () {\n    function PDF417ResultMetadata() {\n        this.segmentCount = -1;\n        this.fileSize = -1;\n        this.timestamp = -1;\n        this.checksum = -1;\n    }\n    /**\n     * The Segment ID represents the segment of the whole file distributed over different symbols.\n     *\n     * @return File segment index\n     */\n    PDF417ResultMetadata.prototype.getSegmentIndex = function () {\n        return this.segmentIndex;\n    };\n    PDF417ResultMetadata.prototype.setSegmentIndex = function (segmentIndex) {\n        this.segmentIndex = segmentIndex;\n    };\n    /**\n     * Is the same for each related PDF417 symbol\n     *\n     * @return File ID\n     */\n    PDF417ResultMetadata.prototype.getFileId = function () {\n        return this.fileId;\n    };\n    PDF417ResultMetadata.prototype.setFileId = function (fileId) {\n        this.fileId = fileId;\n    };\n    /**\n     * @return always null\n     * @deprecated use dedicated already parsed fields\n     */\n    //   @Deprecated\n    PDF417ResultMetadata.prototype.getOptionalData = function () {\n        return this.optionalData;\n    };\n    /**\n     * @param optionalData old optional data format as int array\n     * @deprecated parse and use new fields\n     */\n    //   @Deprecated\n    PDF417ResultMetadata.prototype.setOptionalData = function (optionalData) {\n        this.optionalData = optionalData;\n    };\n    /**\n     * @return true if it is the last segment\n     */\n    PDF417ResultMetadata.prototype.isLastSegment = function () {\n        return this.lastSegment;\n    };\n    PDF417ResultMetadata.prototype.setLastSegment = function (lastSegment) {\n        this.lastSegment = lastSegment;\n    };\n    /**\n     * @return count of segments, -1 if not set\n     */\n    PDF417ResultMetadata.prototype.getSegmentCount = function () {\n        return this.segmentCount;\n    };\n    PDF417ResultMetadata.prototype.setSegmentCount = function (segmentCount /*int*/) {\n        this.segmentCount = segmentCount;\n    };\n    PDF417ResultMetadata.prototype.getSender = function () {\n        return this.sender || null;\n    };\n    PDF417ResultMetadata.prototype.setSender = function (sender) {\n        this.sender = sender;\n    };\n    PDF417ResultMetadata.prototype.getAddressee = function () {\n        return this.addressee || null;\n    };\n    PDF417ResultMetadata.prototype.setAddressee = function (addressee) {\n        this.addressee = addressee;\n    };\n    /**\n     * Filename of the encoded file\n     *\n     * @return filename\n     */\n    PDF417ResultMetadata.prototype.getFileName = function () {\n        return this.fileName;\n    };\n    PDF417ResultMetadata.prototype.setFileName = function (fileName) {\n        this.fileName = fileName;\n    };\n    /**\n     * filesize in bytes of the encoded file\n     *\n     * @return filesize in bytes, -1 if not set\n     */\n    PDF417ResultMetadata.prototype.getFileSize = function () {\n        return this.fileSize;\n    };\n    PDF417ResultMetadata.prototype.setFileSize = function (fileSize /*long*/) {\n        this.fileSize = fileSize;\n    };\n    /**\n     * 16-bit CRC checksum using CCITT-16\n     *\n     * @return crc checksum, -1 if not set\n     */\n    PDF417ResultMetadata.prototype.getChecksum = function () {\n        return this.checksum;\n    };\n    PDF417ResultMetadata.prototype.setChecksum = function (checksum /*int*/) {\n        this.checksum = checksum;\n    };\n    /**\n     * unix epock timestamp, elapsed seconds since 1970-01-01\n     *\n     * @return elapsed seconds, -1 if not set\n     */\n    PDF417ResultMetadata.prototype.getTimestamp = function () {\n        return this.timestamp;\n    };\n    PDF417ResultMetadata.prototype.setTimestamp = function (timestamp /*long*/) {\n        this.timestamp = timestamp;\n    };\n    return PDF417ResultMetadata;\n}());\nexports[\"default\"] = PDF417ResultMetadata;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvUERGNDE3UmVzdWx0TWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L1BERjQxN1Jlc3VsdE1ldGFkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3O1xuLyoqXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIFBERjQxN1Jlc3VsdE1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBERjQxN1Jlc3VsdE1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLmZpbGVTaXplID0gLTE7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gLTE7XG4gICAgICAgIHRoaXMuY2hlY2tzdW0gPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIFNlZ21lbnQgSUQgcmVwcmVzZW50cyB0aGUgc2VnbWVudCBvZiB0aGUgd2hvbGUgZmlsZSBkaXN0cmlidXRlZCBvdmVyIGRpZmZlcmVudCBzeW1ib2xzLlxuICAgICAqXG4gICAgICogQHJldHVybiBGaWxlIHNlZ21lbnQgaW5kZXhcbiAgICAgKi9cbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg7XG4gICAgfTtcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24gKHNlZ21lbnRJbmRleCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzIHRoZSBzYW1lIGZvciBlYWNoIHJlbGF0ZWQgUERGNDE3IHN5bWJvbFxuICAgICAqXG4gICAgICogQHJldHVybiBGaWxlIElEXG4gICAgICovXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldEZpbGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZUlkO1xuICAgIH07XG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldEZpbGVJZCA9IGZ1bmN0aW9uIChmaWxlSWQpIHtcbiAgICAgICAgdGhpcy5maWxlSWQgPSBmaWxlSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFsd2F5cyBudWxsXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGRlZGljYXRlZCBhbHJlYWR5IHBhcnNlZCBmaWVsZHNcbiAgICAgKi9cbiAgICAvLyAgIEBEZXByZWNhdGVkXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldE9wdGlvbmFsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWxEYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbmFsRGF0YSBvbGQgb3B0aW9uYWwgZGF0YSBmb3JtYXQgYXMgaW50IGFycmF5XG4gICAgICogQGRlcHJlY2F0ZWQgcGFyc2UgYW5kIHVzZSBuZXcgZmllbGRzXG4gICAgICovXG4gICAgLy8gICBARGVwcmVjYXRlZFxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRPcHRpb25hbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uYWxEYXRhKSB7XG4gICAgICAgIHRoaXMub3B0aW9uYWxEYXRhID0gb3B0aW9uYWxEYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0cnVlIGlmIGl0IGlzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgKi9cbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuaXNMYXN0U2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlZ21lbnQ7XG4gICAgfTtcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0TGFzdFNlZ21lbnQgPSBmdW5jdGlvbiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgdGhpcy5sYXN0U2VnbWVudCA9IGxhc3RTZWdtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBjb3VudCBvZiBzZWdtZW50cywgLTEgaWYgbm90IHNldFxuICAgICAqL1xuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5nZXRTZWdtZW50Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRDb3VudDtcbiAgICB9O1xuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRTZWdtZW50Q291bnQgPSBmdW5jdGlvbiAoc2VnbWVudENvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgdGhpcy5zZWdtZW50Q291bnQgPSBzZWdtZW50Q291bnQ7XG4gICAgfTtcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0U2VuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kZXIgfHwgbnVsbDtcbiAgICB9O1xuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRTZW5kZXIgPSBmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgIH07XG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldEFkZHJlc3NlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc2VlIHx8IG51bGw7XG4gICAgfTtcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0QWRkcmVzc2VlID0gZnVuY3Rpb24gKGFkZHJlc3NlZSkge1xuICAgICAgICB0aGlzLmFkZHJlc3NlZSA9IGFkZHJlc3NlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbGVuYW1lIG9mIHRoZSBlbmNvZGVkIGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4gZmlsZW5hbWVcbiAgICAgKi9cbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RmlsZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lO1xuICAgIH07XG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldEZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGZpbGVzaXplIGluIGJ5dGVzIG9mIHRoZSBlbmNvZGVkIGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4gZmlsZXNpemUgaW4gYnl0ZXMsIC0xIGlmIG5vdCBzZXRcbiAgICAgKi9cbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RmlsZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVTaXplO1xuICAgIH07XG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldEZpbGVTaXplID0gZnVuY3Rpb24gKGZpbGVTaXplIC8qbG9uZyovKSB7XG4gICAgICAgIHRoaXMuZmlsZVNpemUgPSBmaWxlU2l6ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDE2LWJpdCBDUkMgY2hlY2tzdW0gdXNpbmcgQ0NJVFQtMTZcbiAgICAgKlxuICAgICAqIEByZXR1cm4gY3JjIGNoZWNrc3VtLCAtMSBpZiBub3Qgc2V0XG4gICAgICovXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldENoZWNrc3VtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bTtcbiAgICB9O1xuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRDaGVja3N1bSA9IGZ1bmN0aW9uIChjaGVja3N1bSAvKmludCovKSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVuaXggZXBvY2sgdGltZXN0YW1wLCBlbGFwc2VkIHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMVxuICAgICAqXG4gICAgICogQHJldHVybiBlbGFwc2VkIHNlY29uZHMsIC0xIGlmIG5vdCBzZXRcbiAgICAgKi9cbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XG4gICAgfTtcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKHRpbWVzdGFtcCAvKmxvbmcqLykge1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9O1xuICAgIHJldHVybiBQREY0MTdSZXN1bHRNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdSZXN1bHRNZXRhZGF0YTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n/**\n * @author Guenther Grau\n */\nvar BarcodeMetadata = /** @class */ (function () {\n    function BarcodeMetadata(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {\n        this.columnCount = columnCount;\n        this.errorCorrectionLevel = errorCorrectionLevel;\n        this.rowCountUpperPart = rowCountUpperPart;\n        this.rowCountLowerPart = rowCountLowerPart;\n        this.rowCount = rowCountUpperPart + rowCountLowerPart;\n    }\n    BarcodeMetadata.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n    BarcodeMetadata.prototype.getErrorCorrectionLevel = function () {\n        return this.errorCorrectionLevel;\n    };\n    BarcodeMetadata.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n    BarcodeMetadata.prototype.getRowCountUpperPart = function () {\n        return this.rowCountUpperPart;\n    };\n    BarcodeMetadata.prototype.getRowCountLowerPart = function () {\n        return this.rowCountLowerPart;\n    };\n    return BarcodeMetadata;\n}());\nexports[\"default\"] = BarcodeMetadata;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9CYXJjb2RlTWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvQmFyY29kZU1ldGFkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XG4vKipcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICovXG52YXIgQmFyY29kZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhcmNvZGVNZXRhZGF0YShjb2x1bW5Db3VudCwgcm93Q291bnRVcHBlclBhcnQsIHJvd0NvdW50TG93ZXJQYXJ0LCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgdGhpcy5yb3dDb3VudFVwcGVyUGFydCA9IHJvd0NvdW50VXBwZXJQYXJ0O1xuICAgICAgICB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0ID0gcm93Q291bnRMb3dlclBhcnQ7XG4gICAgICAgIHRoaXMucm93Q291bnQgPSByb3dDb3VudFVwcGVyUGFydCArIHJvd0NvdW50TG93ZXJQYXJ0O1xuICAgIH1cbiAgICBCYXJjb2RlTWV0YWRhdGEucHJvdG90eXBlLmdldENvbHVtbkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5Db3VudDtcbiAgICB9O1xuICAgIEJhcmNvZGVNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgIH07XG4gICAgQmFyY29kZU1ldGFkYXRhLnByb3RvdHlwZS5nZXRSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnQ7XG4gICAgfTtcbiAgICBCYXJjb2RlTWV0YWRhdGEucHJvdG90eXBlLmdldFJvd0NvdW50VXBwZXJQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudFVwcGVyUGFydDtcbiAgICB9O1xuICAgIEJhcmNvZGVNZXRhZGF0YS5wcm90b3R5cGUuZ2V0Um93Q291bnRMb3dlclBhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0O1xuICAgIH07XG4gICAgcmV0dXJuIEJhcmNvZGVNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXJjb2RlTWV0YWRhdGE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\n// import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.HashMap;\n// import java.util.Map;\n// import java.util.Map.Entry;\n/**\n * @author Guenther Grau\n */\nvar BarcodeValue = /** @class */ (function () {\n    function BarcodeValue() {\n        this.values = new Map();\n    }\n    /**\n     * Add an occurrence of a value\n     */\n    BarcodeValue.prototype.setValue = function (value) {\n        value = Math.trunc(value);\n        var confidence = this.values.get(value);\n        if (confidence == null) {\n            confidence = 0;\n        }\n        confidence++;\n        this.values.set(value, confidence);\n    };\n    /**\n     * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.\n     * @return an array of int, containing the values with the highest occurrence, or null, if no value was set\n     */\n    BarcodeValue.prototype.getValue = function () {\n        var e_1, _a;\n        var maxConfidence = -1;\n        var result = new Array();\n        var _loop_1 = function (key, value) {\n            var entry = {\n                getKey: function () { return key; },\n                getValue: function () { return value; },\n            };\n            if (entry.getValue() > maxConfidence) {\n                maxConfidence = entry.getValue();\n                result = [];\n                result.push(entry.getKey());\n            }\n            else if (entry.getValue() === maxConfidence) {\n                result.push(entry.getKey());\n            }\n        };\n        try {\n            for (var _b = __values(this.values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];\n                _loop_1(key, value);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return PDF417Common_1.default.toIntArray(result);\n    };\n    BarcodeValue.prototype.getConfidence = function (value) {\n        return this.values.get(value);\n    };\n    return BarcodeValue;\n}());\nexports[\"default\"] = BarcodeValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9CYXJjb2RlVmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsaUpBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQsd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvQmFyY29kZVZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuUERGNDE3Q29tbW9uO1xudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uO1xuLy8gaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwO1xuLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4vLyBpbXBvcnQgamF2YS51dGlsLk1hcC5FbnRyeTtcbi8qKlxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gKi9cbnZhciBCYXJjb2RlVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFyY29kZVZhbHVlKCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIG9jY3VycmVuY2Ugb2YgYSB2YWx1ZVxuICAgICAqL1xuICAgIEJhcmNvZGVWYWx1ZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICAgICAgdmFyIGNvbmZpZGVuY2UgPSB0aGlzLnZhbHVlcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAoY29uZmlkZW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWRlbmNlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25maWRlbmNlKys7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldCh2YWx1ZSwgY29uZmlkZW5jZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBtYXhpbXVtIG9jY3VycmVuY2Ugb2YgYSBzZXQgdmFsdWUgYW5kIHJldHVybnMgYWxsIHZhbHVlcyB3aGljaCB3ZXJlIHNldCB3aXRoIHRoaXMgb2NjdXJyZW5jZS5cbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGludCwgY29udGFpbmluZyB0aGUgdmFsdWVzIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZSwgb3IgbnVsbCwgaWYgbm8gdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIEJhcmNvZGVWYWx1ZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgbWF4Q29uZmlkZW5jZSA9IC0xO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleTsgfSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudHJ5LmdldFZhbHVlKCkgPiBtYXhDb25maWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgbWF4Q29uZmlkZW5jZSA9IGVudHJ5LmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuZ2V0VmFsdWUoKSA9PT0gbWF4Q29uZmlkZW5jZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LmdldEtleSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy52YWx1ZXMuZW50cmllcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZChfYy52YWx1ZSwgMiksIGtleSA9IF9kWzBdLCB2YWx1ZSA9IF9kWzFdO1xuICAgICAgICAgICAgICAgIF9sb29wXzEoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC50b0ludEFycmF5KHJlc3VsdCk7XG4gICAgfTtcbiAgICBCYXJjb2RlVmFsdWUucHJvdG90eXBlLmdldENvbmZpZGVuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmdldCh2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFyY29kZVZhbHVlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhcmNvZGVWYWx1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n// import com.google.zxing.ResultPoint;\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * @author Guenther Grau\n */\nvar BoundingBox = /** @class */ (function () {\n    function BoundingBox(image, topLeft, bottomLeft, topRight, bottomRight) {\n        if (image instanceof BoundingBox) {\n            this.constructor_2(image);\n        }\n        else {\n            this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);\n        }\n    }\n    /**\n     *\n     * @param image\n     * @param topLeft\n     * @param bottomLeft\n     * @param topRight\n     * @param bottomRight\n     *\n     * @throws NotFoundException\n     */\n    BoundingBox.prototype.constructor_1 = function (image, topLeft, bottomLeft, topRight, bottomRight) {\n        var leftUnspecified = topLeft == null || bottomLeft == null;\n        var rightUnspecified = topRight == null || bottomRight == null;\n        if (leftUnspecified && rightUnspecified) {\n            throw new NotFoundException_1.default();\n        }\n        if (leftUnspecified) {\n            topLeft = new ResultPoint_1.default(0, topRight.getY());\n            bottomLeft = new ResultPoint_1.default(0, bottomRight.getY());\n        }\n        else if (rightUnspecified) {\n            topRight = new ResultPoint_1.default(image.getWidth() - 1, topLeft.getY());\n            bottomRight = new ResultPoint_1.default(image.getWidth() - 1, bottomLeft.getY());\n        }\n        this.image = image;\n        this.topLeft = topLeft;\n        this.bottomLeft = bottomLeft;\n        this.topRight = topRight;\n        this.bottomRight = bottomRight;\n        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));\n        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));\n        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));\n        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));\n    };\n    BoundingBox.prototype.constructor_2 = function (boundingBox) {\n        this.image = boundingBox.image;\n        this.topLeft = boundingBox.getTopLeft();\n        this.bottomLeft = boundingBox.getBottomLeft();\n        this.topRight = boundingBox.getTopRight();\n        this.bottomRight = boundingBox.getBottomRight();\n        this.minX = boundingBox.getMinX();\n        this.maxX = boundingBox.getMaxX();\n        this.minY = boundingBox.getMinY();\n        this.maxY = boundingBox.getMaxY();\n    };\n    /**\n     * @throws NotFoundException\n     */\n    BoundingBox.merge = function (leftBox, rightBox) {\n        if (leftBox == null) {\n            return rightBox;\n        }\n        if (rightBox == null) {\n            return leftBox;\n        }\n        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);\n    };\n    /**\n     * @throws NotFoundException\n     */\n    BoundingBox.prototype.addMissingRows = function (missingStartRows, missingEndRows, isLeft) {\n        var newTopLeft = this.topLeft;\n        var newBottomLeft = this.bottomLeft;\n        var newTopRight = this.topRight;\n        var newBottomRight = this.bottomRight;\n        if (missingStartRows > 0) {\n            var top_1 = isLeft ? this.topLeft : this.topRight;\n            var newMinY = Math.trunc(top_1.getY() - missingStartRows);\n            if (newMinY < 0) {\n                newMinY = 0;\n            }\n            var newTop = new ResultPoint_1.default(top_1.getX(), newMinY);\n            if (isLeft) {\n                newTopLeft = newTop;\n            }\n            else {\n                newTopRight = newTop;\n            }\n        }\n        if (missingEndRows > 0) {\n            var bottom = isLeft ? this.bottomLeft : this.bottomRight;\n            var newMaxY = Math.trunc(bottom.getY() + missingEndRows);\n            if (newMaxY >= this.image.getHeight()) {\n                newMaxY = this.image.getHeight() - 1;\n            }\n            var newBottom = new ResultPoint_1.default(bottom.getX(), newMaxY);\n            if (isLeft) {\n                newBottomLeft = newBottom;\n            }\n            else {\n                newBottomRight = newBottom;\n            }\n        }\n        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);\n    };\n    BoundingBox.prototype.getMinX = function () {\n        return this.minX;\n    };\n    BoundingBox.prototype.getMaxX = function () {\n        return this.maxX;\n    };\n    BoundingBox.prototype.getMinY = function () {\n        return this.minY;\n    };\n    BoundingBox.prototype.getMaxY = function () {\n        return this.maxY;\n    };\n    BoundingBox.prototype.getTopLeft = function () {\n        return this.topLeft;\n    };\n    BoundingBox.prototype.getTopRight = function () {\n        return this.topRight;\n    };\n    BoundingBox.prototype.getBottomLeft = function () {\n        return this.bottomLeft;\n    };\n    BoundingBox.prototype.getBottomRight = function () {\n        return this.bottomRight;\n    };\n    return BoundingBox;\n}());\nexports[\"default\"] = BoundingBox;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9Cb3VuZGluZ0JveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsdUpBQXlCO0FBQzNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMklBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9Cb3VuZGluZ0JveC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlcjtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLk5vdEZvdW5kRXhjZXB0aW9uO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5SZXN1bHRQb2ludDtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xuLyoqXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIEJvdW5kaW5nQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94KGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpIHtcbiAgICAgICAgaWYgKGltYWdlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JfMihpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXzEoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgKiBAcGFyYW0gdG9wTGVmdFxuICAgICAqIEBwYXJhbSBib3R0b21MZWZ0XG4gICAgICogQHBhcmFtIHRvcFJpZ2h0XG4gICAgICogQHBhcmFtIGJvdHRvbVJpZ2h0XG4gICAgICpcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICovXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yXzEgPSBmdW5jdGlvbiAoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCkge1xuICAgICAgICB2YXIgbGVmdFVuc3BlY2lmaWVkID0gdG9wTGVmdCA9PSBudWxsIHx8IGJvdHRvbUxlZnQgPT0gbnVsbDtcbiAgICAgICAgdmFyIHJpZ2h0VW5zcGVjaWZpZWQgPSB0b3BSaWdodCA9PSBudWxsIHx8IGJvdHRvbVJpZ2h0ID09IG51bGw7XG4gICAgICAgIGlmIChsZWZ0VW5zcGVjaWZpZWQgJiYgcmlnaHRVbnNwZWNpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KDAsIHRvcFJpZ2h0LmdldFkoKSk7XG4gICAgICAgICAgICBib3R0b21MZWZ0ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCgwLCBib3R0b21SaWdodC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChpbWFnZS5nZXRXaWR0aCgpIC0gMSwgdG9wTGVmdC5nZXRZKCkpO1xuICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGltYWdlLmdldFdpZHRoKCkgLSAxLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnRvcExlZnQgPSB0b3BMZWZ0O1xuICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBib3R0b21MZWZ0O1xuICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gdG9wUmlnaHQ7XG4gICAgICAgIHRoaXMuYm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcbiAgICAgICAgdGhpcy5taW5YID0gTWF0aC50cnVuYyhNYXRoLm1pbih0b3BMZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRYKCkpKTtcbiAgICAgICAgdGhpcy5tYXhYID0gTWF0aC50cnVuYyhNYXRoLm1heCh0b3BSaWdodC5nZXRYKCksIGJvdHRvbVJpZ2h0LmdldFgoKSkpO1xuICAgICAgICB0aGlzLm1pblkgPSBNYXRoLnRydW5jKE1hdGgubWluKHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRZKCkpKTtcbiAgICAgICAgdGhpcy5tYXhZID0gTWF0aC50cnVuYyhNYXRoLm1heChib3R0b21MZWZ0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WSgpKSk7XG4gICAgfTtcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29uc3RydWN0b3JfMiA9IGZ1bmN0aW9uIChib3VuZGluZ0JveCkge1xuICAgICAgICB0aGlzLmltYWdlID0gYm91bmRpbmdCb3guaW1hZ2U7XG4gICAgICAgIHRoaXMudG9wTGVmdCA9IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKTtcbiAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gYm91bmRpbmdCb3guZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgIHRoaXMubWluWCA9IGJvdW5kaW5nQm94LmdldE1pblgoKTtcbiAgICAgICAgdGhpcy5tYXhYID0gYm91bmRpbmdCb3guZ2V0TWF4WCgpO1xuICAgICAgICB0aGlzLm1pblkgPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7XG4gICAgICAgIHRoaXMubWF4WSA9IGJvdW5kaW5nQm94LmdldE1heFkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgKi9cbiAgICBCb3VuZGluZ0JveC5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0Qm94LCByaWdodEJveCkge1xuICAgICAgICBpZiAobGVmdEJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHRCb3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0Qm94ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0Qm94O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobGVmdEJveC5pbWFnZSwgbGVmdEJveC50b3BMZWZ0LCBsZWZ0Qm94LmJvdHRvbUxlZnQsIHJpZ2h0Qm94LnRvcFJpZ2h0LCByaWdodEJveC5ib3R0b21SaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICovXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZE1pc3NpbmdSb3dzID0gZnVuY3Rpb24gKG1pc3NpbmdTdGFydFJvd3MsIG1pc3NpbmdFbmRSb3dzLCBpc0xlZnQpIHtcbiAgICAgICAgdmFyIG5ld1RvcExlZnQgPSB0aGlzLnRvcExlZnQ7XG4gICAgICAgIHZhciBuZXdCb3R0b21MZWZ0ID0gdGhpcy5ib3R0b21MZWZ0O1xuICAgICAgICB2YXIgbmV3VG9wUmlnaHQgPSB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICB2YXIgbmV3Qm90dG9tUmlnaHQgPSB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgICAgICBpZiAobWlzc2luZ1N0YXJ0Um93cyA+IDApIHtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IGlzTGVmdCA/IHRoaXMudG9wTGVmdCA6IHRoaXMudG9wUmlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3TWluWSA9IE1hdGgudHJ1bmModG9wXzEuZ2V0WSgpIC0gbWlzc2luZ1N0YXJ0Um93cyk7XG4gICAgICAgICAgICBpZiAobmV3TWluWSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdNaW5ZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdUb3AgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHRvcF8xLmdldFgoKSwgbmV3TWluWSk7XG4gICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgbmV3VG9wTGVmdCA9IG5ld1RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1RvcFJpZ2h0ID0gbmV3VG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXNzaW5nRW5kUm93cyA+IDApIHtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBpc0xlZnQgPyB0aGlzLmJvdHRvbUxlZnQgOiB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgICAgICAgICAgdmFyIG5ld01heFkgPSBNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkgKyBtaXNzaW5nRW5kUm93cyk7XG4gICAgICAgICAgICBpZiAobmV3TWF4WSA+PSB0aGlzLmltYWdlLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgbmV3TWF4WSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0JvdHRvbSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoYm90dG9tLmdldFgoKSwgbmV3TWF4WSk7XG4gICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgbmV3Qm90dG9tTGVmdCA9IG5ld0JvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0JvdHRvbVJpZ2h0ID0gbmV3Qm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy5pbWFnZSwgbmV3VG9wTGVmdCwgbmV3Qm90dG9tTGVmdCwgbmV3VG9wUmlnaHQsIG5ld0JvdHRvbVJpZ2h0KTtcbiAgICB9O1xuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5YO1xuICAgIH07XG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heFg7XG4gICAgfTtcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWTtcbiAgICB9O1xuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRNYXhZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhZO1xuICAgIH07XG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFRvcExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcExlZnQ7XG4gICAgfTtcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0VG9wUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcFJpZ2h0O1xuICAgIH07XG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEJvdHRvbUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgfTtcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0Qm90dG9tUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kaW5nQm94O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJvdW5kaW5nQm94O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n/**\n * @author Guenther Grau\n */\nvar Codeword = /** @class */ (function () {\n    function Codeword(startX, endX, bucket, value) {\n        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;\n        this.startX = Math.trunc(startX);\n        this.endX = Math.trunc(endX);\n        this.bucket = Math.trunc(bucket);\n        this.value = Math.trunc(value);\n    }\n    Codeword.prototype.hasValidRowNumber = function () {\n        return this.isValidRowNumber(this.rowNumber);\n    };\n    Codeword.prototype.isValidRowNumber = function (rowNumber) {\n        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;\n    };\n    Codeword.prototype.setRowNumberAsRowIndicatorColumn = function () {\n        this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));\n    };\n    Codeword.prototype.getWidth = function () {\n        return this.endX - this.startX;\n    };\n    Codeword.prototype.getStartX = function () {\n        return this.startX;\n    };\n    Codeword.prototype.getEndX = function () {\n        return this.endX;\n    };\n    Codeword.prototype.getBucket = function () {\n        return this.bucket;\n    };\n    Codeword.prototype.getValue = function () {\n        return this.value;\n    };\n    Codeword.prototype.getRowNumber = function () {\n        return this.rowNumber;\n    };\n    Codeword.prototype.setRowNumber = function (rowNumber) {\n        this.rowNumber = rowNumber;\n    };\n    //   @Override\n    Codeword.prototype.toString = function () {\n        return this.rowNumber + '|' + this.value;\n    };\n    Codeword.BARCODE_ROW_UNKNOWN = -1;\n    return Codeword;\n}());\nexports[\"default\"] = Codeword;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9Db2Rld29yZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvQ29kZXdvcmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlcjtcbi8qKlxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gKi9cbnZhciBDb2Rld29yZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2Rld29yZChzdGFydFgsIGVuZFgsIGJ1Y2tldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOO1xuICAgICAgICB0aGlzLnN0YXJ0WCA9IE1hdGgudHJ1bmMoc3RhcnRYKTtcbiAgICAgICAgdGhpcy5lbmRYID0gTWF0aC50cnVuYyhlbmRYKTtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBNYXRoLnRydW5jKGJ1Y2tldCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICB9XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmhhc1ZhbGlkUm93TnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkUm93TnVtYmVyKHRoaXMucm93TnVtYmVyKTtcbiAgICB9O1xuICAgIENvZGV3b3JkLnByb3RvdHlwZS5pc1ZhbGlkUm93TnVtYmVyID0gZnVuY3Rpb24gKHJvd051bWJlcikge1xuICAgICAgICByZXR1cm4gcm93TnVtYmVyICE9PSBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOICYmIHRoaXMuYnVja2V0ID09PSAocm93TnVtYmVyICUgMykgKiAzO1xuICAgIH07XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJvd051bWJlciA9IE1hdGgudHJ1bmMoKE1hdGgudHJ1bmModGhpcy52YWx1ZSAvIDMwKSkgKiAzICsgTWF0aC50cnVuYyh0aGlzLmJ1Y2tldCAvIDMpKTtcbiAgICB9O1xuICAgIENvZGV3b3JkLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kWCAtIHRoaXMuc3RhcnRYO1xuICAgIH07XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmdldFN0YXJ0WCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRYO1xuICAgIH07XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmdldEVuZFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFg7XG4gICAgfTtcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuZ2V0QnVja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXQ7XG4gICAgfTtcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmdldFJvd051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyO1xuICAgIH07XG4gICAgQ29kZXdvcmQucHJvdG90eXBlLnNldFJvd051bWJlciA9IGZ1bmN0aW9uIChyb3dOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgfTtcbiAgICAvLyAgIEBPdmVycmlkZVxuICAgIENvZGV3b3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyICsgJ3wnICsgdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV04gPSAtMTtcbiAgICByZXR1cm4gQ29kZXdvcmQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29kZXdvcmQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js":
/*!*********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.FormatException;\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n// import com.google.zxing.common.CharacterSetECI;\nvar CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\n// import com.google.zxing.common.DecoderResult;\nvar DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\");\n// import com.google.zxing.pdf417.PDF417ResultMetadata;\nvar PDF417ResultMetadata_1 = __webpack_require__(/*! ../PDF417ResultMetadata */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js\");\n// import java.io.ByteArrayOutputStream;\n// import java.math.BigInteger;\n// import java.nio.charset.Charset;\n// import java.nio.charset.StandardCharsets;\n// import java.util.Arrays;\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar Long_1 = __webpack_require__(/*! ../../util/Long */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Long.js\");\nvar ByteArrayOutputStream_1 = __webpack_require__(/*! ../../util/ByteArrayOutputStream */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\n/*private*/ var Mode;\n(function (Mode) {\n    Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n    Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n    Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n    Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n    Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n    Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n})(Mode || (Mode = {}));\n/**\n * Indirectly access the global BigInt constructor, it\n * allows browsers that doesn't support BigInt to run\n * the library without breaking due to \"undefined BigInt\"\n * errors.\n */\nfunction getBigIntConstructor() {\n    if (typeof window !== 'undefined') {\n        return window['BigInt'] || null;\n    }\n    if (typeof global !== 'undefined') {\n        return global['BigInt'] || null;\n    }\n    if (typeof self !== 'undefined') {\n        return self['BigInt'] || null;\n    }\n    throw new Error('Can\\'t search globals for BigInt!');\n}\n/**\n * Used to store the BigInt constructor.\n */\nvar BigInteger;\n/**\n * This function creates a bigint value. It allows browsers\n * that doesn't support BigInt to run the rest of the library\n * by not directly accessing the BigInt constructor.\n */\nfunction createBigInt(num) {\n    if (typeof BigInteger === 'undefined') {\n        BigInteger = getBigIntConstructor();\n    }\n    if (BigInteger === null) {\n        throw new Error('BigInt is not supported!');\n    }\n    return BigInteger(num);\n}\nfunction getEXP900() {\n    // in Java - array with length = 16\n    var EXP900 = [];\n    EXP900[0] = createBigInt(1);\n    var nineHundred = createBigInt(900);\n    EXP900[1] = nineHundred;\n    // in Java - array with length = 16\n    for (var i /*int*/ = 2; i < 16; i++) {\n        EXP900[i] = EXP900[i - 1] * nineHundred;\n    }\n    return EXP900;\n}\n/**\n * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author Guenther Grau\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    //   private DecodedBitStreamParser() {\n    // }\n    /**\n     *\n     * @param codewords\n     * @param ecLevel\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.decode = function (codewords, ecLevel) {\n        // pass encoding to result (will be used for decode symbols in byte mode)\n        var result = new StringBuilder_1.default('');\n        // let encoding: Charset = StandardCharsets.ISO_8859_1;\n        var encoding = CharacterSetECI_1.default.ISO8859_1;\n        /**\n         * @note the next command is specific from this TypeScript library\n         * because TS can't properly cast some values to char and\n         * convert it to string later correctly due to encoding\n         * differences from Java version. As reported here:\n         * https://github.com/zxing-js/library/pull/264/files#r382831593\n         */\n        result.enableDecoding(encoding);\n        // Get compaction mode\n        var codeIndex = 1;\n        var code = codewords[codeIndex++];\n        var resultMetadata = new PDF417ResultMetadata_1.default();\n        while (codeIndex < codewords[0]) {\n            switch (code) {\n                case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                    result.append(/*(char)*/ codewords[codeIndex++]);\n                    break;\n                case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                    codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.ECI_CHARSET:\n                    var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]);\n                    // encoding = Charset.forName(charsetECI.getName());\n                    break;\n                case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:\n                    // Can't do anything with generic ECI; skip its 2 characters\n                    codeIndex += 2;\n                    break;\n                case DecodedBitStreamParser.ECI_USER_DEFINED:\n                    // Can't do anything with user ECI; skip its 1 character\n                    codeIndex++;\n                    break;\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n                    break;\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                    // Should not see these outside a macro block\n                    throw new FormatException_1.default();\n                default:\n                    // Default to text compaction. During testing numerous barcodes\n                    // appeared to be missing the starting mode. In these cases defaulting\n                    // to text compaction seems to work.\n                    codeIndex--;\n                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n                    break;\n            }\n            if (codeIndex < codewords.length) {\n                code = codewords[codeIndex++];\n            }\n            else {\n                throw FormatException_1.default.getFormatInstance();\n            }\n        }\n        if (result.length() === 0) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);\n        decoderResult.setOther(resultMetadata);\n        return decoderResult;\n    };\n    /**\n     *\n     * @param int\n     * @param param1\n     * @param codewords\n     * @param int\n     * @param codeIndex\n     * @param PDF417ResultMetadata\n     * @param resultMetadata\n     *\n     * @throws FormatException\n     */\n    // @SuppressWarnings(\"deprecation\")\n    DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {\n        if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n            // we must have at least two bytes left for the segment index\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);\n        for (var i /*int*/ = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n            segmentIndexArray[i] = codewords[codeIndex];\n        }\n        resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));\n        var fileId = new StringBuilder_1.default();\n        codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);\n        resultMetadata.setFileId(fileId.toString());\n        var optionalFieldsStart = -1;\n        if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n            optionalFieldsStart = codeIndex + 1;\n        }\n        while (codeIndex < codewords[0]) {\n            switch (codewords[codeIndex]) {\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    codeIndex++;\n                    switch (codewords[codeIndex]) {\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n                            var fileName = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);\n                            resultMetadata.setFileName(fileName.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n                            var sender = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);\n                            resultMetadata.setSender(sender.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n                            var addressee = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);\n                            resultMetadata.setAddressee(addressee.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n                            var segmentCount = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);\n                            resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n                            var timestamp = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);\n                            resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n                            var checksum = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);\n                            resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n                            var fileSize = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);\n                            resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));\n                            break;\n                        default:\n                            throw FormatException_1.default.getFormatInstance();\n                    }\n                    break;\n                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                    codeIndex++;\n                    resultMetadata.setLastSegment(true);\n                    break;\n                default:\n                    throw FormatException_1.default.getFormatInstance();\n            }\n        }\n        // copy optional fields to additional options\n        if (optionalFieldsStart !== -1) {\n            var optionalFieldsLength = codeIndex - optionalFieldsStart;\n            if (resultMetadata.isLastSegment()) {\n                // do not include terminator\n                optionalFieldsLength--;\n            }\n            resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n        }\n        return codeIndex;\n    };\n    /**\n     * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n     * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n     * well as selected control characters.\n     *\n     * @param codewords The array of codewords (data + error)\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     */\n    DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {\n        // 2 character per codeword\n        var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n        // Used to hold the byte compaction value if there is a mode shift\n        var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n        var index = 0;\n        var end = false;\n        while ((codeIndex < codewords[0]) && !end) {\n            var code = codewords[codeIndex++];\n            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                textCompactionData[index] = code / 30;\n                textCompactionData[index + 1] = code % 30;\n                index += 2;\n            }\n            else {\n                switch (code) {\n                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                        // reinitialize text compaction mode to alpha sub mode\n                        textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;\n                        break;\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                        codeIndex--;\n                        end = true;\n                        break;\n                    case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                        // The Mode Shift codeword 913 shall cause a temporary\n                        // switch from Text Compaction mode to Byte Compaction mode.\n                        // This switch shall be in effect for only the next codeword,\n                        // after which the mode shall revert to the prevailing sub-mode\n                        // of the Text Compaction mode. Codeword 913 is only available\n                        // in Text Compaction mode; its use is described in 5.4.2.4.\n                        textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n                        code = codewords[codeIndex++];\n                        byteCompactionData[index] = code;\n                        index++;\n                        break;\n                }\n            }\n        }\n        DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n        return codeIndex;\n    };\n    /**\n     * The Text Compaction mode includes all the printable ASCII characters\n     * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n     * (9: e), LF or line feed (10: e), and CR or carriage\n     * return (13: e). The Text Compaction mode also includes various latch\n     * and shift characters which are used exclusively within the mode. The Text\n     * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n     * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n     * switches are defined in 5.4.2.3.\n     *\n     * @param textCompactionData The text compaction data.\n     * @param byteCompactionData The byte compaction data if there\n     *                           was a mode shift.\n     * @param length             The size of the text compaction and byte compaction data.\n     * @param result             The decoded data is appended to the result.\n     */\n    DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {\n        // Beginning from an initial state of the Alpha sub-mode\n        // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n        // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n        // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n        var subMode = Mode.ALPHA;\n        var priorToShiftMode = Mode.ALPHA;\n        var i = 0;\n        while (i < length) {\n            var subModeCh = textCompactionData[i];\n            var ch = /*char*/ '';\n            switch (subMode) {\n                case Mode.ALPHA:\n                    // Alpha (alphabetic: uppercase)\n                    if (subModeCh < 26) {\n                        // Upper case Alpha Character\n                        // Note: 65 = 'A' ASCII -> there is byte code of symbol\n                        ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.LL:\n                                subMode = Mode.LOWER;\n                                break;\n                            case DecodedBitStreamParser.ML:\n                                subMode = Mode.MIXED;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.LOWER:\n                    // Lower (alphabetic: lowercase)\n                    if (subModeCh < 26) {\n                        ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.AS:\n                                // Shift to alpha\n                                priorToShiftMode = subMode;\n                                subMode = Mode.ALPHA_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.ML:\n                                subMode = Mode.MIXED;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                // TODO Does this need to use the current character encoding? See other occurrences below\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.MIXED:\n                    // Mixed (punctuation: e)\n                    if (subModeCh < DecodedBitStreamParser.PL) {\n                        ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PL:\n                                subMode = Mode.PUNCT;\n                                break;\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.LL:\n                                subMode = Mode.LOWER;\n                                break;\n                            case DecodedBitStreamParser.AL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.PUNCT:\n                    // Punctuation\n                    if (subModeCh < DecodedBitStreamParser.PAL) {\n                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PAL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.ALPHA_SHIFT:\n                    // Restore sub-mode\n                    subMode = priorToShiftMode;\n                    if (subModeCh < 26) {\n                        ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.PUNCT_SHIFT:\n                    // Restore sub-mode\n                    subMode = priorToShiftMode;\n                    if (subModeCh < DecodedBitStreamParser.PAL) {\n                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PAL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                // PS before Shift-to-Byte is used as a padding character,\n                                // see 5.4.2.4 of the specification\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n            }\n            // if (ch !== 0) {\n            if (ch !== '') {\n                // Append decoded character to result\n                result.append(ch);\n            }\n            i++;\n        }\n    };\n    /**\n     * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n     * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n     * character set support.\n     *\n     * @param mode      The byte compaction mode i.e. 901 or 924\n     * @param codewords The array of codewords (data + error)\n     * @param encoding  Currently active character encoding\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     */\n    DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {\n        var decodedBytes = new ByteArrayOutputStream_1.default();\n        var count = 0;\n        var value = /*long*/ 0;\n        var end = false;\n        switch (mode) {\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                // Total number of Byte Compaction characters to be encoded\n                // is not a multiple of 6\n                var byteCompactedCodewords = new Int32Array(6);\n                var nextCode = codewords[codeIndex++];\n                while ((codeIndex < codewords[0]) && !end) {\n                    byteCompactedCodewords[count++] = nextCode;\n                    // Base 900\n                    value = 900 * value + nextCode;\n                    nextCode = codewords[codeIndex++];\n                    // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n                    switch (nextCode) {\n                        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                        default:\n                            if ((count % 5 === 0) && (count > 0)) {\n                                // Decode every 5 codewords\n                                // Convert to Base 256\n                                for (var j /*int*/ = 0; j < 6; ++j) {\n                                    /* @note\n                                     * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                                     * So the next bitwise operation could not be done with simple numbers\n                                     */\n                                    decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                                }\n                                value = 0;\n                                count = 0;\n                            }\n                            break;\n                    }\n                }\n                // if the end of all codewords is reached the last codeword needs to be added\n                if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                    byteCompactedCodewords[count++] = nextCode;\n                }\n                // If Byte Compaction mode is invoked with codeword 901,\n                // the last group of codewords is interpreted directly\n                // as one byte per codeword, without compaction.\n                for (var i /*int*/ = 0; i < count; i++) {\n                    decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);\n                }\n                break;\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                // Total number of Byte Compaction characters to be encoded\n                // is an integer multiple of 6\n                while (codeIndex < codewords[0] && !end) {\n                    var code = codewords[codeIndex++];\n                    if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                        count++;\n                        // Base 900\n                        value = 900 * value + code;\n                    }\n                    else {\n                        switch (code) {\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                                codeIndex--;\n                                end = true;\n                                break;\n                        }\n                    }\n                    if ((count % 5 === 0) && (count > 0)) {\n                        // Decode every 5 codewords\n                        // Convert to Base 256\n                        /* @note\n                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                         * So the next bitwise operation could not be done with simple numbers\n                        */\n                        for (var j /*int*/ = 0; j < 6; ++j) {\n                            decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                        }\n                        value = 0;\n                        count = 0;\n                    }\n                }\n                break;\n        }\n        result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));\n        return codeIndex;\n    };\n    /**\n     * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n     *\n     * @param codewords The array of codewords (data + error)\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex /*int*/, result) {\n        var count = 0;\n        var end = false;\n        var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);\n        while (codeIndex < codewords[0] && !end) {\n            var code = codewords[codeIndex++];\n            if (codeIndex === codewords[0]) {\n                end = true;\n            }\n            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                numericCodewords[count] = code;\n                count++;\n            }\n            else {\n                switch (code) {\n                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                        codeIndex--;\n                        end = true;\n                        break;\n                }\n            }\n            if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n                // Re-invoking Numeric Compaction mode (by using codeword 902\n                // while in Numeric Compaction mode) serves  to terminate the\n                // current Numeric Compaction mode grouping as described in 5.4.4.2,\n                // and then to start a new one grouping.\n                result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));\n                count = 0;\n            }\n        }\n        return codeIndex;\n    };\n    /**\n     * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n     *\n     * @param codewords The array of codewords\n     * @param count     The number of codewords\n     * @return The decoded string representing the Numeric data.\n     *\n     * EXAMPLE\n     * Encode the fifteen digit numeric string 000213298174000\n     * Prefix the numeric string with a 1 and set the initial value of\n     * t = 1 000 213 298 174 000\n     * Calculate codeword 0\n     * d0 = 1 000 213 298 174 000 mod 900 = 200\n     *\n     * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n     * Calculate codeword 1\n     * d1 = 1 111 348 109 082 mod 900 = 282\n     *\n     * t = 1 111 348 109 082 div 900 = 1 234 831 232\n     * Calculate codeword 2\n     * d2 = 1 234 831 232 mod 900 = 632\n     *\n     * t = 1 234 831 232 div 900 = 1 372 034\n     * Calculate codeword 3\n     * d3 = 1 372 034 mod 900 = 434\n     *\n     * t = 1 372 034 div 900 = 1 524\n     * Calculate codeword 4\n     * d4 = 1 524 mod 900 = 624\n     *\n     * t = 1 524 div 900 = 1\n     * Calculate codeword 5\n     * d5 = 1 mod 900 = 1\n     * t = 1 div 900 = 0\n     * Codeword sequence is: 1, 624, 434, 632, 282, 200\n     *\n     * Decode the above codewords involves\n     *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n     * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n     *\n     * Remove leading 1 =>  Result is 000213298174000\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {\n        var result = createBigInt(0);\n        for (var i /*int*/ = 0; i < count; i++) {\n            result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);\n        }\n        var resultString = result.toString();\n        if (resultString.charAt(0) !== '1') {\n            throw new FormatException_1.default();\n        }\n        return resultString.substring(1);\n    };\n    DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;\n    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;\n    DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;\n    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n    DecodedBitStreamParser.ECI_USER_DEFINED = 925;\n    DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;\n    DecodedBitStreamParser.ECI_CHARSET = 927;\n    DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n    DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n    DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;\n    DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n    DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n    DecodedBitStreamParser.PL = 25;\n    DecodedBitStreamParser.LL = 27;\n    DecodedBitStreamParser.AS = 27;\n    DecodedBitStreamParser.ML = 28;\n    DecodedBitStreamParser.AL = 28;\n    DecodedBitStreamParser.PS = 29;\n    DecodedBitStreamParser.PAL = 29;\n    DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n    DecodedBitStreamParser.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n    /**\n     * Table containing values for the exponent of 900.\n     * This is used in the numeric compaction decode algorithm.\n     */\n    DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n    DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n    return DecodedBitStreamParser;\n}());\nexports[\"default\"] = DecodedBitStreamParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9EZWNvZGVkQml0U3RyZWFtUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxtSkFBdUI7QUFDdkQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxpS0FBOEI7QUFDOUQ7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyw2SkFBNEI7QUFDMUQ7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxpS0FBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQywySUFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMseUpBQTBCO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLDZJQUFvQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsdUlBQWlCO0FBQ3RDLDhCQUE4QixtQkFBTyxDQUFDLHlLQUFrQztBQUN4RSx1QkFBdUIsbUJBQU8sQ0FBQywySkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBeUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuRm9ybWF0RXhjZXB0aW9uO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5DaGFyYWN0ZXJTZXRFQ0k7XG52YXIgQ2hhcmFjdGVyU2V0RUNJXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0NoYXJhY3RlclNldEVDSVwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5EZWNvZGVyUmVzdWx0O1xudmFyIERlY29kZXJSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGVjb2RlclJlc3VsdFwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5QREY0MTdSZXN1bHRNZXRhZGF0YTtcbnZhciBQREY0MTdSZXN1bHRNZXRhZGF0YV8xID0gcmVxdWlyZShcIi4uL1BERjQxN1Jlc3VsdE1ldGFkYXRhXCIpO1xuLy8gaW1wb3J0IGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtO1xuLy8gaW1wb3J0IGphdmEubWF0aC5CaWdJbnRlZ2VyO1xuLy8gaW1wb3J0IGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldDtcbi8vIGltcG9ydCBqYXZhLm5pby5jaGFyc2V0LlN0YW5kYXJkQ2hhcnNldHM7XG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0FycmF5c1wiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XG52YXIgTG9uZ18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvTG9uZ1wiKTtcbnZhciBCeXRlQXJyYXlPdXRwdXRTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0J5dGVBcnJheU91dHB1dFN0cmVhbVwiKTtcbnZhciBTdHJpbmdFbmNvZGluZ18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nRW5jb2RpbmdcIik7XG4vKnByaXZhdGUqLyB2YXIgTW9kZTtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIE1vZGVbTW9kZVtcIkFMUEhBXCJdID0gMF0gPSBcIkFMUEhBXCI7XG4gICAgTW9kZVtNb2RlW1wiTE9XRVJcIl0gPSAxXSA9IFwiTE9XRVJcIjtcbiAgICBNb2RlW01vZGVbXCJNSVhFRFwiXSA9IDJdID0gXCJNSVhFRFwiO1xuICAgIE1vZGVbTW9kZVtcIlBVTkNUXCJdID0gM10gPSBcIlBVTkNUXCI7XG4gICAgTW9kZVtNb2RlW1wiQUxQSEFfU0hJRlRcIl0gPSA0XSA9IFwiQUxQSEFfU0hJRlRcIjtcbiAgICBNb2RlW01vZGVbXCJQVU5DVF9TSElGVFwiXSA9IDVdID0gXCJQVU5DVF9TSElGVFwiO1xufSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XG4vKipcbiAqIEluZGlyZWN0bHkgYWNjZXNzIHRoZSBnbG9iYWwgQmlnSW50IGNvbnN0cnVjdG9yLCBpdFxuICogYWxsb3dzIGJyb3dzZXJzIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW5cbiAqIHRoZSBsaWJyYXJ5IHdpdGhvdXQgYnJlYWtpbmcgZHVlIHRvIFwidW5kZWZpbmVkIEJpZ0ludFwiXG4gKiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldEJpZ0ludENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93WydCaWdJbnQnXSB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFsnQmlnSW50J10gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZlsnQmlnSW50J10gfHwgbnVsbDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHNlYXJjaCBnbG9iYWxzIGZvciBCaWdJbnQhJyk7XG59XG4vKipcbiAqIFVzZWQgdG8gc3RvcmUgdGhlIEJpZ0ludCBjb25zdHJ1Y3Rvci5cbiAqL1xudmFyIEJpZ0ludGVnZXI7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIGJpZ2ludCB2YWx1ZS4gSXQgYWxsb3dzIGJyb3dzZXJzXG4gKiB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBCaWdJbnQgdG8gcnVuIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5XG4gKiBieSBub3QgZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBCaWdJbnQgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpZ0ludChudW0pIHtcbiAgICBpZiAodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIEJpZ0ludGVnZXIgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpO1xuICAgIH1cbiAgICBpZiAoQmlnSW50ZWdlciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50ZWdlcihudW0pO1xufVxuZnVuY3Rpb24gZ2V0RVhQOTAwKCkge1xuICAgIC8vIGluIEphdmEgLSBhcnJheSB3aXRoIGxlbmd0aCA9IDE2XG4gICAgdmFyIEVYUDkwMCA9IFtdO1xuICAgIEVYUDkwMFswXSA9IGNyZWF0ZUJpZ0ludCgxKTtcbiAgICB2YXIgbmluZUh1bmRyZWQgPSBjcmVhdGVCaWdJbnQoOTAwKTtcbiAgICBFWFA5MDBbMV0gPSBuaW5lSHVuZHJlZDtcbiAgICAvLyBpbiBKYXZhIC0gYXJyYXkgd2l0aCBsZW5ndGggPSAxNlxuICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIEVYUDkwMFtpXSA9IEVYUDkwMFtpIC0gMV0gKiBuaW5lSHVuZHJlZDtcbiAgICB9XG4gICAgcmV0dXJuIEVYUDkwMDtcbn1cbi8qKlxuICogPHA+VGhpcyBjbGFzcyBjb250YWlucyB0aGUgbWV0aG9kcyBmb3IgZGVjb2RpbmcgdGhlIFBERjQxNyBjb2Rld29yZHMuPC9wPlxuICpcbiAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcbiAgICB9XG4gICAgLy8gICBwcml2YXRlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIoKSB7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGV3b3Jkc1xuICAgICAqIEBwYXJhbSBlY0xldmVsXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgZWNMZXZlbCkge1xuICAgICAgICAvLyBwYXNzIGVuY29kaW5nIHRvIHJlc3VsdCAod2lsbCBiZSB1c2VkIGZvciBkZWNvZGUgc3ltYm9scyBpbiBieXRlIG1vZGUpXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoJycpO1xuICAgICAgICAvLyBsZXQgZW5jb2Rpbmc6IENoYXJzZXQgPSBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzE7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuSVNPODg1OV8xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5vdGUgdGhlIG5leHQgY29tbWFuZCBpcyBzcGVjaWZpYyBmcm9tIHRoaXMgVHlwZVNjcmlwdCBsaWJyYXJ5XG4gICAgICAgICAqIGJlY2F1c2UgVFMgY2FuJ3QgcHJvcGVybHkgY2FzdCBzb21lIHZhbHVlcyB0byBjaGFyIGFuZFxuICAgICAgICAgKiBjb252ZXJ0IGl0IHRvIHN0cmluZyBsYXRlciBjb3JyZWN0bHkgZHVlIHRvIGVuY29kaW5nXG4gICAgICAgICAqIGRpZmZlcmVuY2VzIGZyb20gSmF2YSB2ZXJzaW9uLiBBcyByZXBvcnRlZCBoZXJlOlxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20venhpbmctanMvbGlicmFyeS9wdWxsLzI2NC9maWxlcyNyMzgyODMxNTkzXG4gICAgICAgICAqL1xuICAgICAgICByZXN1bHQuZW5hYmxlRGVjb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAvLyBHZXQgY29tcGFjdGlvbiBtb2RlXG4gICAgICAgIHZhciBjb2RlSW5kZXggPSAxO1xuICAgICAgICB2YXIgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgIHZhciByZXN1bHRNZXRhZGF0YSA9IG5ldyBQREY0MTdSZXN1bHRNZXRhZGF0YV8xLmRlZmF1bHQoKTtcbiAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuYnl0ZUNvbXBhY3Rpb24oY29kZSwgY29kZXdvcmRzLCBlbmNvZGluZywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGNvZGV3b3Jkc1tjb2RlSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5FQ0lfQ0hBUlNFVDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJzZXRFQ0kgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LmdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUoY29kZXdvcmRzW2NvZGVJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuY29kaW5nID0gQ2hhcnNldC5mb3JOYW1lKGNoYXJzZXRFQ0kuZ2V0TmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkVDSV9HRU5FUkFMX1BVUlBPU0U6XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggZ2VuZXJpYyBFQ0k7IHNraXAgaXRzIDIgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkVDSV9VU0VSX0RFRklORUQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggdXNlciBFQ0k7IHNraXAgaXRzIDEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlTWFjcm9CbG9jayhjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBzZWUgdGhlc2Ugb3V0c2lkZSBhIG1hY3JvIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0ZXh0IGNvbXBhY3Rpb24uIER1cmluZyB0ZXN0aW5nIG51bWVyb3VzIGJhcmNvZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmVkIHRvIGJlIG1pc3NpbmcgdGhlIHN0YXJ0aW5nIG1vZGUuIEluIHRoZXNlIGNhc2VzIGRlZmF1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGV4dCBjb21wYWN0aW9uIHNlZW1zIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPCBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJSZXN1bHRfMS5kZWZhdWx0KG51bGwsIHJlc3VsdC50b1N0cmluZygpLCBudWxsLCBlY0xldmVsKTtcbiAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRPdGhlcihyZXN1bHRNZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50XG4gICAgICogQHBhcmFtIHBhcmFtMVxuICAgICAqIEBwYXJhbSBjb2Rld29yZHNcbiAgICAgKiBAcGFyYW0gaW50XG4gICAgICogQHBhcmFtIGNvZGVJbmRleFxuICAgICAqIEBwYXJhbSBQREY0MTdSZXN1bHRNZXRhZGF0YVxuICAgICAqIEBwYXJhbSByZXN1bHRNZXRhZGF0YVxuICAgICAqXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgKi9cbiAgICAvLyBAU3VwcHJlc3NXYXJuaW5ncyhcImRlcHJlY2F0aW9uXCIpXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVNYWNyb0Jsb2NrID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSkge1xuICAgICAgICBpZiAoY29kZUluZGV4ICsgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTID4gY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICAvLyB3ZSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGJ5dGVzIGxlZnQgZm9yIHRoZSBzZWdtZW50IGluZGV4XG4gICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleEFycmF5ID0gbmV3IEludDMyQXJyYXkoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUzsgaSsrLCBjb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgc2VnbWVudEluZGV4QXJyYXlbaV0gPSBjb2Rld29yZHNbY29kZUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50SW5kZXgoSW50ZWdlcl8xLmRlZmF1bHQucGFyc2VJbnQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCYXNlOTAwdG9CYXNlMTAoc2VnbWVudEluZGV4QXJyYXksIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUykpKTtcbiAgICAgICAgdmFyIGZpbGVJZCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCBmaWxlSWQpO1xuICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlSWQoZmlsZUlkLnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgb3B0aW9uYWxGaWVsZHNTdGFydCA9IC0xO1xuICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGVJbmRleF0gPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEKSB7XG4gICAgICAgICAgICBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gY29kZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3Jkc1tjb2RlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRzW2NvZGVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9OQU1FOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZU5hbWUoZmlsZU5hbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZGVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHNlbmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0U2VuZGVyKHNlbmRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQUREUkVTU0VFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzZWUgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgYWRkcmVzc2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRBZGRyZXNzZWUoYWRkcmVzc2VlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRUdNRU5UX0NPVU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50Q291bnQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgc2VnbWVudENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50Q291bnQoSW50ZWdlcl8xLmRlZmF1bHQucGFyc2VJbnQoc2VnbWVudENvdW50LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0VGltZXN0YW1wKExvbmdfMS5kZWZhdWx0LnBhcnNlTG9uZyh0aW1lc3RhbXAudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9DSEVDS1NVTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgY2hlY2tzdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldENoZWNrc3VtKEludGVnZXJfMS5kZWZhdWx0LnBhcnNlSW50KGNoZWNrc3VtLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9TSVpFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlU2l6ZSA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0RmlsZVNpemUoTG9uZ18xLmRlZmF1bHQucGFyc2VMb25nKGZpbGVTaXplLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldExhc3RTZWdtZW50KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvcHRpb25hbCBmaWVsZHMgdG8gYWRkaXRpb25hbCBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25hbEZpZWxkc1N0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsRmllbGRzTGVuZ3RoID0gY29kZUluZGV4IC0gb3B0aW9uYWxGaWVsZHNTdGFydDtcbiAgICAgICAgICAgIGlmIChyZXN1bHRNZXRhZGF0YS5pc0xhc3RTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxGaWVsZHNMZW5ndGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldE9wdGlvbmFsRGF0YShBcnJheXNfMS5kZWZhdWx0LmNvcHlPZlJhbmdlKGNvZGV3b3Jkcywgb3B0aW9uYWxGaWVsZHNTdGFydCwgb3B0aW9uYWxGaWVsZHNTdGFydCArIG9wdGlvbmFsRmllbGRzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRleHQgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjEuNSkgcGVybWl0cyBhbGwgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgdG8gYmVcbiAgICAgKiBlbmNvZGVkLCBpLmUuIHZhbHVlcyAzMiAtIDEyNiBpbmNsdXNpdmUgaW4gYWNjb3JkYW5jZSB3aXRoIElTTy9JRUMgNjQ2IChJUlYpLCBhc1xuICAgICAqIHdlbGwgYXMgc2VsZWN0ZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24gPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAvLyAyIGNoYXJhY3RlciBwZXIgY29kZXdvcmRcbiAgICAgICAgdmFyIHRleHRDb21wYWN0aW9uRGF0YSA9IG5ldyBJbnQzMkFycmF5KChjb2Rld29yZHNbMF0gLSBjb2RlSW5kZXgpICogMik7XG4gICAgICAgIC8vIFVzZWQgdG8gaG9sZCB0aGUgYnl0ZSBjb21wYWN0aW9uIHZhbHVlIGlmIHRoZXJlIGlzIGEgbW9kZSBzaGlmdFxuICAgICAgICB2YXIgYnl0ZUNvbXBhY3Rpb25EYXRhID0gbmV3IEludDMyQXJyYXkoKGNvZGV3b3Jkc1swXSAtIGNvZGVJbmRleCkgKiAyKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkgJiYgIWVuZCkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IGNvZGUgLyAzMDtcbiAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXggKyAxXSA9IGNvZGUgJSAzMDtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlaW5pdGlhbGl6ZSB0ZXh0IGNvbXBhY3Rpb24gbW9kZSB0byBhbHBoYSBzdWIgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4KytdID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIE1vZGUgU2hpZnQgY29kZXdvcmQgOTEzIHNoYWxsIGNhdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSBUZXh0IENvbXBhY3Rpb24gbW9kZSB0byBCeXRlIENvbXBhY3Rpb24gbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc3dpdGNoIHNoYWxsIGJlIGluIGVmZmVjdCBmb3Igb25seSB0aGUgbmV4dCBjb2Rld29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHdoaWNoIHRoZSBtb2RlIHNoYWxsIHJldmVydCB0byB0aGUgcHJldmFpbGluZyBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlLiBDb2Rld29yZCA5MTMgaXMgb25seSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIFRleHQgQ29tcGFjdGlvbiBtb2RlOyBpdHMgdXNlIGlzIGRlc2NyaWJlZCBpbiA1LjQuMi40LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUNvbXBhY3Rpb25EYXRhW2luZGV4XSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlVGV4dENvbXBhY3Rpb24odGV4dENvbXBhY3Rpb25EYXRhLCBieXRlQ29tcGFjdGlvbkRhdGEsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gY29kZUluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlIGluY2x1ZGVzIGFsbCB0aGUgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICAgKiAoaS5lLiB2YWx1ZXMgZnJvbSAzMiB0byAxMjYpIGFuZCB0aHJlZSBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnM6IEhUIG9yIHRhYlxuICAgICAqICg5OiBlKSwgTEYgb3IgbGluZSBmZWVkICgxMDogZSksIGFuZCBDUiBvciBjYXJyaWFnZVxuICAgICAqIHJldHVybiAoMTM6IGUpLiBUaGUgVGV4dCBDb21wYWN0aW9uIG1vZGUgYWxzbyBpbmNsdWRlcyB2YXJpb3VzIGxhdGNoXG4gICAgICogYW5kIHNoaWZ0IGNoYXJhY3RlcnMgd2hpY2ggYXJlIHVzZWQgZXhjbHVzaXZlbHkgd2l0aGluIHRoZSBtb2RlLiBUaGUgVGV4dFxuICAgICAqIENvbXBhY3Rpb24gbW9kZSBlbmNvZGVzIHVwIHRvIDIgY2hhcmFjdGVycyBwZXIgY29kZXdvcmQuIFRoZSBjb21wYWN0aW9uIHJ1bGVzXG4gICAgICogZm9yIGNvbnZlcnRpbmcgZGF0YSBpbnRvIFBERjQxNyBjb2Rld29yZHMgYXJlIGRlZmluZWQgaW4gNS40LjIuMi4gVGhlIHN1Yi1tb2RlXG4gICAgICogc3dpdGNoZXMgYXJlIGRlZmluZWQgaW4gNS40LjIuMy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0Q29tcGFjdGlvbkRhdGEgVGhlIHRleHQgY29tcGFjdGlvbiBkYXRhLlxuICAgICAqIEBwYXJhbSBieXRlQ29tcGFjdGlvbkRhdGEgVGhlIGJ5dGUgY29tcGFjdGlvbiBkYXRhIGlmIHRoZXJlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgYSBtb2RlIHNoaWZ0LlxuICAgICAqIEBwYXJhbSBsZW5ndGggICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIHRleHQgY29tcGFjdGlvbiBhbmQgYnl0ZSBjb21wYWN0aW9uIGRhdGEuXG4gICAgICogQHBhcmFtIHJlc3VsdCAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVUZXh0Q29tcGFjdGlvbiA9IGZ1bmN0aW9uICh0ZXh0Q29tcGFjdGlvbkRhdGEsIGJ5dGVDb21wYWN0aW9uRGF0YSwgbGVuZ3RoLCByZXN1bHQpIHtcbiAgICAgICAgLy8gQmVnaW5uaW5nIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSBvZiB0aGUgQWxwaGEgc3ViLW1vZGVcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgY29tcGFjdGlvbiBtb2RlIGZvciBQREY0MTcgaW4gZWZmZWN0IGF0IHRoZSBzdGFydCBvZiBlYWNoIHN5bWJvbCBzaGFsbCBhbHdheXMgYmUgVGV4dFxuICAgICAgICAvLyBDb21wYWN0aW9uIG1vZGUgQWxwaGEgc3ViLW1vZGUgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSkuIEEgbGF0Y2ggY29kZXdvcmQgZnJvbSBhbm90aGVyIG1vZGUgdG8gdGhlIFRleHRcbiAgICAgICAgLy8gQ29tcGFjdGlvbiBtb2RlIHNoYWxsIGFsd2F5cyBzd2l0Y2ggdG8gdGhlIFRleHQgQ29tcGFjdGlvbiBBbHBoYSBzdWItbW9kZS5cbiAgICAgICAgdmFyIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xuICAgICAgICB2YXIgcHJpb3JUb1NoaWZ0TW9kZSA9IE1vZGUuQUxQSEE7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzdWJNb2RlQ2ggPSB0ZXh0Q29tcGFjdGlvbkRhdGFbaV07XG4gICAgICAgICAgICB2YXIgY2ggPSAvKmNoYXIqLyAnJztcbiAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTFBIQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxwaGEgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcHBlciBjYXNlIEFscGhhIENoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogNjUgPSAnQScgQVNDSUkgLT4gdGhlcmUgaXMgYnl0ZSBjb2RlIG9mIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAvKihjaGFyKSgnQScgKyBzdWJNb2RlQ2gpICovIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkxMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5MT1dFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5NSVhFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuUFVOQ1RfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlLkxPV0VSOlxuICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciAoYWxwaGFiZXRpYzogbG93ZXJjYXNlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ2EnICsgc3ViTW9kZUNoKSovIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBhbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEFfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuTUlYRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBEb2VzIHRoaXMgbmVlZCB0byB1c2UgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGVuY29kaW5nPyBTZWUgb3RoZXIgb2NjdXJyZW5jZXMgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5NSVhFRDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZWQgKHB1bmN0dWF0aW9uOiBlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1JWEVEX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuUFVOQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTEw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkxPV0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIHB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5QVU5DVF9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUuUFVOQ1Q6XG4gICAgICAgICAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBVTkNUX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTFBIQV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gcHJpb3JUb1NoaWZ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdBJyArIHN1Yk1vZGVDaCkqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5QVU5DVF9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gcHJpb3JUb1NoaWZ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFVOQ1RfQ0hBUlNbc3ViTW9kZUNoXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBBTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUyBiZWZvcmUgU2hpZnQtdG8tQnl0ZSBpcyB1c2VkIGFzIGEgcGFkZGluZyBjaGFyYWN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSA1LjQuMi40IG9mIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChjaCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGNoICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBkZWNvZGVkIGNoYXJhY3RlciB0byByZXN1bHRcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQnl0ZSBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuMykgcGVybWl0cyBhbGwgMjU2IHBvc3NpYmxlIDgtYml0IGJ5dGUgdmFsdWVzIHRvIGJlIGVuY29kZWQuXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbGwgQVNDSUkgY2hhcmFjdGVycyB2YWx1ZSAwIHRvIDEyNyBpbmNsdXNpdmUgYW5kIHByb3ZpZGVzIGZvciBpbnRlcm5hdGlvbmFsXG4gICAgICogY2hhcmFjdGVyIHNldCBzdXBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGUgICAgICBUaGUgYnl0ZSBjb21wYWN0aW9uIG1vZGUgaS5lLiA5MDEgb3IgOTI0XG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICogQHBhcmFtIGVuY29kaW5nICBDdXJyZW50bHkgYWN0aXZlIGNoYXJhY3RlciBlbmNvZGluZ1xuICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICogQHJldHVybiBUaGUgbmV4dCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmJ5dGVDb21wYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIGNvZGV3b3JkcywgZW5jb2RpbmcsIGNvZGVJbmRleCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBkZWNvZGVkQnl0ZXMgPSBuZXcgQnl0ZUFycmF5T3V0cHV0U3RyZWFtXzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSAvKmxvbmcqLyAwO1xuICAgICAgICB2YXIgZW5kID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBCeXRlIENvbXBhY3Rpb24gY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IGEgbXVsdGlwbGUgb2YgNlxuICAgICAgICAgICAgICAgIHZhciBieXRlQ29tcGFjdGVkQ29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoNik7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkgJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2NvdW50KytdID0gbmV4dENvZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gOTAwICogdmFsdWUgKyBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBwZXJoYXBzIGl0IHNob3VsZCBiZSBvayB0byBjaGVjayBvbmx5IG5leHRDb2RlID49IFRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmV4dENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgNSA9PT0gMCkgJiYgKGNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gQmFzZSAyNTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiAvKmludCovID0gMDsgaiA8IDY7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQG5vdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEphdmFTY3JpcHQgc3RvcmVzIG51bWJlcnMgYXMgNjQgYml0cyBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBidXQgYWxsIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIDMyIGJpdHMgYmluYXJ5IG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbyB0aGUgbmV4dCBiaXR3aXNlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgZG9uZSB3aXRoIHNpbXBsZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIE51bWJlcihjcmVhdGVCaWdJbnQodmFsdWUpID4+IGNyZWF0ZUJpZ0ludCg4ICogKDUgLSBqKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVuZCBvZiBhbGwgY29kZXdvcmRzIGlzIHJlYWNoZWQgdGhlIGxhc3QgY29kZXdvcmQgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICBpZiAoY29kZUluZGV4ID09PSBjb2Rld29yZHNbMF0gJiYgbmV4dENvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbY291bnQrK10gPSBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgQnl0ZSBDb21wYWN0aW9uIG1vZGUgaXMgaW52b2tlZCB3aXRoIGNvZGV3b3JkIDkwMSxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBncm91cCBvZiBjb2Rld29yZHMgaXMgaW50ZXJwcmV0ZWQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBhcyBvbmUgYnl0ZSBwZXIgY29kZXdvcmQsIHdpdGhvdXQgY29tcGFjdGlvbi5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXMud3JpdGUoLyooYnl0ZSkqLyBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgQnl0ZSBDb21wYWN0aW9uIGNoYXJhY3RlcnMgdG8gYmUgZW5jb2RlZFxuICAgICAgICAgICAgICAgIC8vIGlzIGFuIGludGVnZXIgbXVsdGlwbGUgb2YgNlxuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0gJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDkwMCAqIHZhbHVlICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY291bnQgJSA1ID09PSAwKSAmJiAoY291bnQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEJhc2UgMjU2XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBAbm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvIHRoZSBuZXh0IGJpdHdpc2Ugb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBkb25lIHdpdGggc2ltcGxlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIC8qaW50Ki8gPSAwOyBqIDwgNjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gTnVtYmVyKGNyZWF0ZUJpZ0ludCh2YWx1ZSkgPj4gY3JlYXRlQmlnSW50KDggKiAoNSAtIGopKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShkZWNvZGVkQnl0ZXMudG9CeXRlQXJyYXkoKSwgZW5jb2RpbmcpKTtcbiAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjQpIHBlcm1pdHMgZWZmaWNpZW50IGVuY29kaW5nIG9mIG51bWVyaWMgZGF0YSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLm51bWVyaWNDb21wYWN0aW9uID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgY29kZUluZGV4IC8qaW50Ki8sIHJlc3VsdCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgZW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBudW1lcmljQ29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQVhfTlVNRVJJQ19DT0RFV09SRFMpO1xuICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdICYmICFlbmQpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcbiAgICAgICAgICAgICAgICBudW1lcmljQ29kZXdvcmRzW2NvdW50XSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjb3VudCAlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID09PSAwIHx8IGNvZGUgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0ggfHwgZW5kKSAmJiBjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbnZva2luZyBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSAoYnkgdXNpbmcgY29kZXdvcmQgOTAyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgaW4gTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUpIHNlcnZlcyAgdG8gdGVybWluYXRlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgZ3JvdXBpbmcgYXMgZGVzY3JpYmVkIGluIDUuNC40LjIsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gdG8gc3RhcnQgYSBuZXcgb25lIGdyb3VwaW5nLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCYXNlOTAwdG9CYXNlMTAobnVtZXJpY0NvZGV3b3JkcywgY291bnQpKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBsaXN0IG9mIE51bWVyaWMgQ29tcGFjdGVkIGNvZGV3b3JkcyBmcm9tIEJhc2UgOTAwIHRvIEJhc2UgMTAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHNcbiAgICAgKiBAcGFyYW0gY291bnQgICAgIFRoZSBudW1iZXIgb2YgY29kZXdvcmRzXG4gICAgICogQHJldHVybiBUaGUgZGVjb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBOdW1lcmljIGRhdGEuXG4gICAgICpcbiAgICAgKiBFWEFNUExFXG4gICAgICogRW5jb2RlIHRoZSBmaWZ0ZWVuIGRpZ2l0IG51bWVyaWMgc3RyaW5nIDAwMDIxMzI5ODE3NDAwMFxuICAgICAqIFByZWZpeCB0aGUgbnVtZXJpYyBzdHJpbmcgd2l0aCBhIDEgYW5kIHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDBcbiAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgMFxuICAgICAqIGQwID0gMSAwMDAgMjEzIDI5OCAxNzQgMDAwIG1vZCA5MDAgPSAyMDBcbiAgICAgKlxuICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDAgZGl2IDkwMCA9IDEgMTExIDM0OCAxMDkgMDgyXG4gICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDFcbiAgICAgKiBkMSA9IDEgMTExIDM0OCAxMDkgMDgyIG1vZCA5MDAgPSAyODJcbiAgICAgKlxuICAgICAqIHQgPSAxIDExMSAzNDggMTA5IDA4MiBkaXYgOTAwID0gMSAyMzQgODMxIDIzMlxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAyXG4gICAgICogZDIgPSAxIDIzNCA4MzEgMjMyIG1vZCA5MDAgPSA2MzJcbiAgICAgKlxuICAgICAqIHQgPSAxIDIzNCA4MzEgMjMyIGRpdiA5MDAgPSAxIDM3MiAwMzRcbiAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgM1xuICAgICAqIGQzID0gMSAzNzIgMDM0IG1vZCA5MDAgPSA0MzRcbiAgICAgKlxuICAgICAqIHQgPSAxIDM3MiAwMzQgZGl2IDkwMCA9IDEgNTI0XG4gICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDRcbiAgICAgKiBkNCA9IDEgNTI0IG1vZCA5MDAgPSA2MjRcbiAgICAgKlxuICAgICAqIHQgPSAxIDUyNCBkaXYgOTAwID0gMVxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA1XG4gICAgICogZDUgPSAxIG1vZCA5MDAgPSAxXG4gICAgICogdCA9IDEgZGl2IDkwMCA9IDBcbiAgICAgKiBDb2Rld29yZCBzZXF1ZW5jZSBpczogMSwgNjI0LCA0MzQsIDYzMiwgMjgyLCAyMDBcbiAgICAgKlxuICAgICAqIERlY29kZSB0aGUgYWJvdmUgY29kZXdvcmRzIGludm9sdmVzXG4gICAgICogICAxIHggOTAwIHBvd2VyIG9mIDUgKyA2MjQgeCA5MDAgcG93ZXIgb2YgNCArIDQzNCB4IDkwMCBwb3dlciBvZiAzICtcbiAgICAgKiA2MzIgeCA5MDAgcG93ZXIgb2YgMiArIDI4MiB4IDkwMCBwb3dlciBvZiAxICsgMjAwIHggOTAwIHBvd2VyIG9mIDAgPSAxMDAwMjEzMjk4MTc0MDAwXG4gICAgICpcbiAgICAgKiBSZW1vdmUgbGVhZGluZyAxID0+ICBSZXN1bHQgaXMgMDAwMjEzMjk4MTc0MDAwXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQmFzZTkwMHRvQmFzZTEwID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgY291bnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpZ0ludCgwKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkVYUDkwMFtjb3VudCAtIGkgLSAxXSAqIGNyZWF0ZUJpZ0ludChjb2Rld29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5jaGFyQXQoMCkgIT09ICcxJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICB9O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDA7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAyO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNiA9IDkyNDtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkVDSV9VU0VSX0RFRklORUQgPSA5MjU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5FQ0lfR0VORVJBTF9QVVJQT1NFID0gOTI2O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRUNJX0NIQVJTRVQgPSA5Mjc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSyA9IDkyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRCA9IDkyMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SID0gOTIyO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERSA9IDkxMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BWF9OVU1FUklDX0NPREVXT1JEUyA9IDE1O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfTkFNRSA9IDA7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VHTUVOVF9DT1VOVCA9IDE7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUCA9IDI7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VOREVSID0gMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9BRERSRVNTRUUgPSA0O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfU0laRSA9IDU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU0gPSA2O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUEwgPSAyNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkxMID0gMjc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BUyA9IDI3O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUwgPSAyODtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFMID0gMjg7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QUyA9IDI5O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUEFMID0gMjk7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QVU5DVF9DSEFSUyA9ICc7PD5AW1xcXFxdX2B+IVxcclxcdCw6XFxuLS4kL1wifCooKT97fVxcJyc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NSVhFRF9DSEFSUyA9ICcwMTIzNDU2Nzg5JlxcclxcdCw6Iy0uJC8rJSo9Xic7XG4gICAgLyoqXG4gICAgICogVGFibGUgY29udGFpbmluZyB2YWx1ZXMgZm9yIHRoZSBleHBvbmVudCBvZiA5MDAuXG4gICAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBudW1lcmljIGNvbXBhY3Rpb24gZGVjb2RlIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkVYUDkwMCA9IGdldEJpZ0ludENvbnN0cnVjdG9yKCkgPyBnZXRFWFA5MDAoKSA6IFtdO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyA9IDI7XG4gICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\nvar Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResult = /** @class */ (function () {\n    function DetectionResult(barcodeMetadata, boundingBox) {\n        /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;\n        this.barcodeMetadata = barcodeMetadata;\n        this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n        this.boundingBox = boundingBox;\n        // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n    }\n    DetectionResult.prototype.getDetectionResultColumns = function () {\n        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n        var unadjustedCodewordCount = PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE;\n        var previousUnadjustedCount;\n        do {\n            previousUnadjustedCount = unadjustedCodewordCount;\n            unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n        return this.detectionResultColumns;\n    };\n    DetectionResult.prototype.adjustIndicatorColumnRowNumbers = function (detectionResultColumn) {\n        if (detectionResultColumn != null) {\n            detectionResultColumn\n                .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n        }\n    };\n    // TODO ensure that no detected codewords with unknown row number are left\n    // we should be able to estimate the row height and use it as a hint for the row number\n    // we should also fill the rows top to bottom and bottom to top\n    /**\n     * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n     * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n     */\n    DetectionResult.prototype.adjustRowNumbersAndGetCount = function () {\n        var unadjustedCount = this.adjustRowNumbersByRow();\n        if (unadjustedCount === 0) {\n            return 0;\n        }\n        for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {\n            var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n            for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                if (!codewords[codewordsRow].hasValidRowNumber()) {\n                    this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.prototype.adjustRowNumbersByRow = function () {\n        this.adjustRowNumbersFromBothRI();\n        // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n        // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n        // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n        // number starts and ends.\n        var unadjustedCount = this.adjustRowNumbersFromLRI();\n        return unadjustedCount + this.adjustRowNumbersFromRRI();\n    };\n    DetectionResult.prototype.adjustRowNumbersFromBothRI = function () {\n        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n            return;\n        }\n        var LRIcodewords = this.detectionResultColumns[0].getCodewords();\n        var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {\n            if (LRIcodewords[codewordsRow] != null &&\n                RRIcodewords[codewordsRow] != null &&\n                LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n                for (var barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {\n                    var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword == null) {\n                        continue;\n                    }\n                    codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n                    if (!codeword.hasValidRowNumber()) {\n                        this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n                    }\n                }\n            }\n        }\n    };\n    DetectionResult.prototype.adjustRowNumbersFromRRI = function () {\n        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n            return 0;\n        }\n        var unadjustedCount = 0;\n        var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n            var invalidRowCounts = 0;\n            for (var barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword != null) {\n                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                    if (!codeword.hasValidRowNumber()) {\n                        unadjustedCount++;\n                    }\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.prototype.adjustRowNumbersFromLRI = function () {\n        if (this.detectionResultColumns[0] == null) {\n            return 0;\n        }\n        var unadjustedCount = 0;\n        var codewords = this.detectionResultColumns[0].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n            var invalidRowCounts = 0;\n            for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword != null) {\n                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                    if (!codeword.hasValidRowNumber()) {\n                        unadjustedCount++;\n                    }\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.adjustRowNumberIfValid = function (rowIndicatorRowNumber, invalidRowCounts, codeword) {\n        if (codeword == null) {\n            return invalidRowCounts;\n        }\n        if (!codeword.hasValidRowNumber()) {\n            if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n                codeword.setRowNumber(rowIndicatorRowNumber);\n                invalidRowCounts = 0;\n            }\n            else {\n                ++invalidRowCounts;\n            }\n        }\n        return invalidRowCounts;\n    };\n    DetectionResult.prototype.adjustRowNumbers = function (barcodeColumn, codewordsRow, codewords) {\n        var e_1, _a;\n        if (this.detectionResultColumns[barcodeColumn - 1] == null) {\n            return;\n        }\n        var codeword = codewords[codewordsRow];\n        var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n        var nextColumnCodewords = previousColumnCodewords;\n        if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n            nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n        }\n        // let otherCodewords: Codeword[] = new Codeword[14];\n        var otherCodewords = new Array(14);\n        otherCodewords[2] = previousColumnCodewords[codewordsRow];\n        otherCodewords[3] = nextColumnCodewords[codewordsRow];\n        if (codewordsRow > 0) {\n            otherCodewords[0] = codewords[codewordsRow - 1];\n            otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n            otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n        }\n        if (codewordsRow > 1) {\n            otherCodewords[8] = codewords[codewordsRow - 2];\n            otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n            otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n        }\n        if (codewordsRow < codewords.length - 1) {\n            otherCodewords[1] = codewords[codewordsRow + 1];\n            otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n            otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n        }\n        if (codewordsRow < codewords.length - 2) {\n            otherCodewords[9] = codewords[codewordsRow + 2];\n            otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n            otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n        }\n        try {\n            for (var otherCodewords_1 = __values(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {\n                var otherCodeword = otherCodewords_1_1.value;\n                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return)) _a.call(otherCodewords_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * @return true, if row number was adjusted, false otherwise\n     */\n    DetectionResult.adjustRowNumber = function (codeword, otherCodeword) {\n        if (otherCodeword == null) {\n            return false;\n        }\n        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n            codeword.setRowNumber(otherCodeword.getRowNumber());\n            return true;\n        }\n        return false;\n    };\n    DetectionResult.prototype.getBarcodeColumnCount = function () {\n        return this.barcodeColumnCount;\n    };\n    DetectionResult.prototype.getBarcodeRowCount = function () {\n        return this.barcodeMetadata.getRowCount();\n    };\n    DetectionResult.prototype.getBarcodeECLevel = function () {\n        return this.barcodeMetadata.getErrorCorrectionLevel();\n    };\n    DetectionResult.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n    DetectionResult.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n    DetectionResult.prototype.setDetectionResultColumn = function (barcodeColumn, detectionResultColumn) {\n        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n    };\n    DetectionResult.prototype.getDetectionResultColumn = function (barcodeColumn) {\n        return this.detectionResultColumns[barcodeColumn];\n    };\n    // @Override\n    DetectionResult.prototype.toString = function () {\n        var rowIndicatorColumn = this.detectionResultColumns[0];\n        if (rowIndicatorColumn == null) {\n            rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n        }\n        // try (\n        var formatter = new Formatter_1.default();\n        // ) {\n        for (var codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {\n            formatter.format('CW %3d:', codewordsRow);\n            for (var barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {\n                if (this.detectionResultColumns[barcodeColumn] == null) {\n                    formatter.format('    |   ');\n                    continue;\n                }\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword == null) {\n                    formatter.format('    |   ');\n                    continue;\n                }\n                formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());\n            }\n            formatter.format('%n');\n        }\n        return formatter.toString();\n        // }\n    };\n    return DetectionResult;\n}());\nexports[\"default\"] = DetectionResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9EZXRlY3Rpb25SZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlKQUFpQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxpSkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZDQUE2QztBQUN6RjtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0NBQW9DO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQ0FBMEM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHFFQUFxRTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELCtGQUErRjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILDBCQUEwQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseURBQXlEO0FBQ3BHO0FBQ0EsZ0RBQWdELDZDQUE2QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3BkZjQxNy9kZWNvZGVyL0RldGVjdGlvblJlc3VsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcbnZhciBQREY0MTdDb21tb25fMSA9IHJlcXVpcmUoXCIuLi9QREY0MTdDb21tb25cIik7XG52YXIgRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9Gb3JtYXR0ZXJcIik7XG4vKipcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICovXG52YXIgRGV0ZWN0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldGVjdGlvblJlc3VsdChiYXJjb2RlTWV0YWRhdGEsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIC8qZmluYWwqLyB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVAgPSAyO1xuICAgICAgICB0aGlzLmJhcmNvZGVNZXRhZGF0YSA9IGJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgPSBiYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICAvLyB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMl07XG4gICAgICAgIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1ucyA9IG5ldyBBcnJheSh0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDIpO1xuICAgIH1cbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldERldGVjdGlvblJlc3VsdENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0pO1xuICAgICAgICB0aGlzLmFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0pO1xuICAgICAgICB2YXIgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPSBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERTtcbiAgICAgICAgdmFyIHByZXZpb3VzVW5hZGp1c3RlZENvdW50O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCA9IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50O1xuICAgICAgICAgICAgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPSB0aGlzLmFkanVzdFJvd051bWJlcnNBbmRHZXRDb3VudCgpO1xuICAgICAgICB9IHdoaWxlICh1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA+IDAgJiYgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPCBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnM7XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnMgPSBmdW5jdGlvbiAoZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKSB7XG4gICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHRDb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uXG4gICAgICAgICAgICAgICAgLmFkanVzdENvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyh0aGlzLmJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE8gZW5zdXJlIHRoYXQgbm8gZGV0ZWN0ZWQgY29kZXdvcmRzIHdpdGggdW5rbm93biByb3cgbnVtYmVyIGFyZSBsZWZ0XG4gICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gZXN0aW1hdGUgdGhlIHJvdyBoZWlnaHQgYW5kIHVzZSBpdCBhcyBhIGhpbnQgZm9yIHRoZSByb3cgbnVtYmVyXG4gICAgLy8gd2Ugc2hvdWxkIGFsc28gZmlsbCB0aGUgcm93cyB0b3AgdG8gYm90dG9tIGFuZCBib3R0b20gdG8gdG9wXG4gICAgLyoqXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgY29kZXdvcmRzIHdoaWNoIGRvbid0IGhhdmUgYSB2YWxpZCByb3cgbnVtYmVyLiBOb3RlIHRoYXQgdGhlIGNvdW50IGlzIG5vdCBhY2N1cmF0ZSBhcyBjb2Rld29yZHNcbiAgICAgKiB3aWxsIGJlIGNvdW50ZWQgc2V2ZXJhbCB0aW1lcy4gSXQganVzdCBzZXJ2ZXMgYXMgYW4gaW5kaWNhdG9yIHRvIHNlZSB3aGVuIHdlIGNhbiBzdG9wIGFkanVzdGluZyByb3cgbnVtYmVyc1xuICAgICAqL1xuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzQnlSb3coKTtcbiAgICAgICAgaWYgKHVuYWRqdXN0ZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMTsgYmFyY29kZUNvbHVtbisrKSB7XG4gICAgICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICB9O1xuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuYWRqdXN0Um93TnVtYmVyc0J5Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkanVzdFJvd051bWJlcnNGcm9tQm90aFJJKCk7XG4gICAgICAgIC8vIFRPRE8gd2Ugc2hvdWxkIG9ubHkgZG8gZnVsbCByb3cgYWRqdXN0bWVudHMgaWYgcm93IG51bWJlcnMgb2YgbGVmdCBhbmQgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW4gbWF0Y2guXG4gICAgICAgIC8vIE1heWJlIGl0J3MgZXZlbiBiZXR0ZXIgdG8gY2FsY3VsYXRlZCB0aGUgaGVpZ2h0IChyb3dzOiBkKSBhbmQgZGl2aWRlIGl0IGJ5IHRoZSBudW1iZXIgb2YgYmFyY29kZVxuICAgICAgICAvLyByb3dzLiBUaGlzLCB0b2dldGhlciB3aXRoIHRoZSBMUkkgYW5kIFJSSSByb3cgbnVtYmVycyBzaG91bGQgYWxsb3cgdXMgdG8gZ2V0IGEgZ29vZCBlc3RpbWF0ZSB3aGVyZSBhIHJvd1xuICAgICAgICAvLyBudW1iZXIgc3RhcnRzIGFuZCBlbmRzLlxuICAgICAgICB2YXIgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSgpO1xuICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50ICsgdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbVJSSSgpO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSA9PSBudWxsIHx8IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTFJJY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdLmdldENvZGV3b3JkcygpO1xuICAgICAgICB2YXIgUlJJY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgTFJJY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgIGlmIChMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgUlJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpID09PSBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPD0gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQ7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmFkanVzdFJvd051bWJlcnNGcm9tUlJJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuYWRqdXN0ZWRDb3VudCA9IDA7XG4gICAgICAgIHZhciBjb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JSb3dOdW1iZXIgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgIHZhciBpbnZhbGlkUm93Q291bnRzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMTsgYmFyY29kZUNvbHVtbiA+IDAgJiYgaW52YWxpZFJvd0NvdW50cyA8IHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUDsgYmFyY29kZUNvbHVtbi0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXJJZlZhbGlkKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmFkanVzdFJvd051bWJlcnNGcm9tTFJJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmFkanVzdGVkQ291bnQgPSAwO1xuICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdLmdldENvZGV3b3JkcygpO1xuICAgICAgICBmb3IgKHZhciBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd0luZGljYXRvclJvd051bWJlciA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgdmFyIGludmFsaWRSb3dDb3VudHMgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMSAmJiBpbnZhbGlkUm93Q291bnRzIDwgdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkUm93Q291bnRzID0gRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlcklmVmFsaWQocm93SW5kaWNhdG9yUm93TnVtYmVyLCBpbnZhbGlkUm93Q291bnRzLCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5hZGp1c3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICB9O1xuICAgIERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXJJZlZhbGlkID0gZnVuY3Rpb24gKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpIHtcbiAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkLmlzVmFsaWRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihyb3dJbmRpY2F0b3JSb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RSb3dOdW1iZXJzID0gZnVuY3Rpb24gKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgIHZhciBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uIC0gMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgIHZhciBuZXh0Q29sdW1uQ29kZXdvcmRzID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHM7XG4gICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5leHRDb2x1bW5Db2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxldCBvdGhlckNvZGV3b3JkczogQ29kZXdvcmRbXSA9IG5ldyBDb2Rld29yZFsxNF07XG4gICAgICAgIHZhciBvdGhlckNvZGV3b3JkcyA9IG5ldyBBcnJheSgxNCk7XG4gICAgICAgIG90aGVyQ29kZXdvcmRzWzJdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgb3RoZXJDb2Rld29yZHNbM10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPiAwKSB7XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1swXSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAxXTtcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzRdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s1XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA+IDEpIHtcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzhdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTBdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMl07XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMV0gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMV0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s2XSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbN10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbOV0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzEzXSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG90aGVyQ29kZXdvcmRzXzEgPSBfX3ZhbHVlcyhvdGhlckNvZGV3b3JkcyksIG90aGVyQ29kZXdvcmRzXzFfMSA9IG90aGVyQ29kZXdvcmRzXzEubmV4dCgpOyAhb3RoZXJDb2Rld29yZHNfMV8xLmRvbmU7IG90aGVyQ29kZXdvcmRzXzFfMSA9IG90aGVyQ29kZXdvcmRzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQ29kZXdvcmQgPSBvdGhlckNvZGV3b3Jkc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXIoY29kZXdvcmQsIG90aGVyQ29kZXdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvdGhlckNvZGV3b3Jkc18xXzEgJiYgIW90aGVyQ29kZXdvcmRzXzFfMS5kb25lICYmIChfYSA9IG90aGVyQ29kZXdvcmRzXzEucmV0dXJuKSkgX2EuY2FsbChvdGhlckNvZGV3b3Jkc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0cnVlLCBpZiByb3cgbnVtYmVyIHdhcyBhZGp1c3RlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlciA9IGZ1bmN0aW9uIChjb2Rld29yZCwgb3RoZXJDb2Rld29yZCkge1xuICAgICAgICBpZiAob3RoZXJDb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyQ29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSAmJiBvdGhlckNvZGV3b3JkLmdldEJ1Y2tldCgpID09PSBjb2Rld29yZC5nZXRCdWNrZXQoKSkge1xuICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyKG90aGVyQ29kZXdvcmQuZ2V0Um93TnVtYmVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5nZXRCYXJjb2RlQ29sdW1uQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudDtcbiAgICB9O1xuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuZ2V0QmFyY29kZVJvd0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKTtcbiAgICB9O1xuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuZ2V0QmFyY29kZUVDTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5zZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChib3VuZGluZ0JveCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveDtcbiAgICB9O1xuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gZnVuY3Rpb24gKGJhcmNvZGVDb2x1bW4sIGRldGVjdGlvblJlc3VsdENvbHVtbikge1xuICAgICAgICB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0gPSBkZXRlY3Rpb25SZXN1bHRDb2x1bW47XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldERldGVjdGlvblJlc3VsdENvbHVtbiA9IGZ1bmN0aW9uIChiYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl07XG4gICAgfTtcbiAgICAvLyBAT3ZlcnJpZGVcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93SW5kaWNhdG9yQ29sdW1uID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdO1xuICAgICAgICBpZiAocm93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJvd0luZGljYXRvckNvbHVtbiA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyeSAoXG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyApIHtcbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Q29kZXdvcmRzKCkubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnQ1cgJTNkOicsIGNvZGV3b3Jkc1Jvdyk7XG4gICAgICAgICAgICBmb3IgKHZhciBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAwOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgIHwgICAnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAgICB8ICAgJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgJTNkfCUzZCcsIGNvZGV3b3JkLmdldFJvd051bWJlcigpLCBjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgICAgICAvLyB9XG4gICAgfTtcbiAgICByZXR1cm4gRGV0ZWN0aW9uUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERldGVjdGlvblJlc3VsdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import java.util.Formatter;\nvar Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js\");\nvar BoundingBox_1 = __webpack_require__(/*! ./BoundingBox */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResultColumn = /** @class */ (function () {\n    function DetectionResultColumn(boundingBox) {\n        this.boundingBox = new BoundingBox_1.default(boundingBox);\n        // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n    }\n    /*final*/ DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {\n        var codeword = this.getCodeword(imageRow);\n        if (codeword != null) {\n            return codeword;\n        }\n        for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n            var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n            if (nearImageRow >= 0) {\n                codeword = this.codewords[nearImageRow];\n                if (codeword != null) {\n                    return codeword;\n                }\n            }\n            nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n            if (nearImageRow < this.codewords.length) {\n                codeword = this.codewords[nearImageRow];\n                if (codeword != null) {\n                    return codeword;\n                }\n            }\n        }\n        return null;\n    };\n    /*final int*/ DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {\n        return imageRow - this.boundingBox.getMinY();\n    };\n    /*final void*/ DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {\n        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n    };\n    /*final*/ DetectionResultColumn.prototype.getCodeword = function (imageRow) {\n        return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n    };\n    /*final*/ DetectionResultColumn.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n    /*final*/ DetectionResultColumn.prototype.getCodewords = function () {\n        return this.codewords;\n    };\n    // @Override\n    DetectionResultColumn.prototype.toString = function () {\n        var e_1, _a;\n        var formatter = new Formatter_1.default();\n        var row = 0;\n        try {\n            for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value;\n                if (codeword == null) {\n                    formatter.format('%3d:    |   %n', row++);\n                    continue;\n                }\n                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return formatter.toString();\n    };\n    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n    return DetectionResultColumn;\n}());\nexports[\"default\"] = DetectionResultColumn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9EZXRlY3Rpb25SZXN1bHRDb2x1bW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlKQUFzQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyxzSkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUErQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XG4vLyBpbXBvcnQgamF2YS51dGlsLkZvcm1hdHRlcjtcbnZhciBGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0Zvcm1hdHRlclwiKTtcbnZhciBCb3VuZGluZ0JveF8xID0gcmVxdWlyZShcIi4vQm91bmRpbmdCb3hcIik7XG4vKipcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICovXG52YXIgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldGVjdGlvblJlc3VsdENvbHVtbihib3VuZGluZ0JveCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94XzEuZGVmYXVsdChib3VuZGluZ0JveCk7XG4gICAgICAgIC8vIHRoaXMuY29kZXdvcmRzID0gbmV3IENvZGV3b3JkW2JvdW5kaW5nQm94LmdldE1heFkoKSAtIGJvdW5kaW5nQm94LmdldE1pblkoKSArIDFdO1xuICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IG5ldyBBcnJheShib3VuZGluZ0JveC5nZXRNYXhZKCkgLSBib3VuZGluZ0JveC5nZXRNaW5ZKCkgKyAxKTtcbiAgICB9XG4gICAgLypmaW5hbCovIERldGVjdGlvblJlc3VsdENvbHVtbi5wcm90b3R5cGUuZ2V0Q29kZXdvcmROZWFyYnkgPSBmdW5jdGlvbiAoaW1hZ2VSb3cpIHtcbiAgICAgICAgdmFyIGNvZGV3b3JkID0gdGhpcy5nZXRDb2Rld29yZChpbWFnZVJvdyk7XG4gICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZXdvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBEZXRlY3Rpb25SZXN1bHRDb2x1bW4uTUFYX05FQVJCWV9ESVNUQU5DRTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmVhckltYWdlUm93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdykgLSBpO1xuICAgICAgICAgICAgaWYgKG5lYXJJbWFnZVJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWFySW1hZ2VSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KSArIGk7XG4gICAgICAgICAgICBpZiAobmVhckltYWdlUm93IDwgdGhpcy5jb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKmZpbmFsIGludCovIERldGVjdGlvblJlc3VsdENvbHVtbi5wcm90b3R5cGUuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXggPSBmdW5jdGlvbiAoaW1hZ2VSb3cpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlUm93IC0gdGhpcy5ib3VuZGluZ0JveC5nZXRNaW5ZKCk7XG4gICAgfTtcbiAgICAvKmZpbmFsIHZvaWQqLyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ucHJvdG90eXBlLnNldENvZGV3b3JkID0gZnVuY3Rpb24gKGltYWdlUm93LCBjb2Rld29yZCkge1xuICAgICAgICB0aGlzLmNvZGV3b3Jkc1t0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KV0gPSBjb2Rld29yZDtcbiAgICB9O1xuICAgIC8qZmluYWwqLyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ucHJvdG90eXBlLmdldENvZGV3b3JkID0gZnVuY3Rpb24gKGltYWdlUm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3Jkc1t0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KV07XG4gICAgfTtcbiAgICAvKmZpbmFsKi8gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7XG4gICAgfTtcbiAgICAvKmZpbmFsKi8gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS5nZXRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICB9O1xuICAgIC8vIEBPdmVycmlkZVxuICAgIERldGVjdGlvblJlc3VsdENvbHVtbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuY29kZXdvcmRzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyUzZDogICAgfCAgICVuJywgcm93KyspO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTNkOiAlM2R8JTNkJW4nLCByb3crKywgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCksIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLk1BWF9ORUFSQllfRElTVEFOQ0UgPSA1O1xuICAgIHJldHVybiBEZXRlY3Rpb25SZXN1bHRDb2x1bW47XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js":
/*!********************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js ***!
  \********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\nvar BarcodeMetadata_1 = __webpack_require__(/*! ./BarcodeMetadata */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js\");\nvar DetectionResultColumn_1 = __webpack_require__(/*! ./DetectionResultColumn */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js\");\nvar BarcodeValue_1 = __webpack_require__(/*! ./BarcodeValue */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResultRowIndicatorColumn = /** @class */ (function (_super) {\n    __extends(DetectionResultRowIndicatorColumn, _super);\n    function DetectionResultRowIndicatorColumn(boundingBox, isLeft) {\n        var _this = _super.call(this, boundingBox) || this;\n        _this._isLeft = isLeft;\n        return _this;\n    }\n    DetectionResultRowIndicatorColumn.prototype.setRowNumbers = function () {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value /*Codeword*/;\n                if (codeword != null) {\n                    codeword.setRowNumberAsRowIndicatorColumn();\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    // TODO implement properly\n    // TODO maybe we should add missing codewords to store the correct row number to make\n    // finding row numbers for other columns easier\n    // use row height count to make detection of invalid row numbers more reliable\n    DetectionResultRowIndicatorColumn.prototype.adjustCompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {\n        var codewords = this.getCodewords();\n        this.setRowNumbers();\n        this.removeIncorrectCodewords(codewords, barcodeMetadata);\n        var boundingBox = this.getBoundingBox();\n        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n        // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and\n        // taller rows\n        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n        var barcodeRow = -1;\n        var maxRowHeight = 1;\n        var currentRowHeight = 0;\n        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var codeword = codewords[codewordsRow];\n            //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;\n            //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {\n            //        SimpleLog.log(LEVEL.WARNING,\n            //            \"Removing codeword, rowNumberSkew too high, codeword[\" + codewordsRow + \"]: Expected Row: \" +\n            //                expectedRowNumber + \", RealRow: \" + codeword.getRowNumber() + \", value: \" + codeword.getValue());\n            //        codewords[codewordsRow] = null;\n            //      }\n            var rowDifference = codeword.getRowNumber() - barcodeRow;\n            // TODO improve handling with case where first row indicator doesn't start with 0\n            if (rowDifference === 0) {\n                currentRowHeight++;\n            }\n            else if (rowDifference === 1) {\n                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                currentRowHeight = 1;\n                barcodeRow = codeword.getRowNumber();\n            }\n            else if (rowDifference < 0 ||\n                codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||\n                rowDifference > codewordsRow) {\n                codewords[codewordsRow] = null;\n            }\n            else {\n                var checkedRows = void 0;\n                if (maxRowHeight > 2) {\n                    checkedRows = (maxRowHeight - 2) * rowDifference;\n                }\n                else {\n                    checkedRows = rowDifference;\n                }\n                var closePreviousCodewordFound = checkedRows >= codewordsRow;\n                for (var i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {\n                    // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.\n                    // This should hopefully get rid of most problems already.\n                    closePreviousCodewordFound = codewords[codewordsRow - i] != null;\n                }\n                if (closePreviousCodewordFound) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    barcodeRow = codeword.getRowNumber();\n                    currentRowHeight = 1;\n                }\n            }\n        }\n        // return (int) (averageRowHeight + 0.5);\n    };\n    DetectionResultRowIndicatorColumn.prototype.getRowHeights = function () {\n        var e_2, _a;\n        var barcodeMetadata = this.getBarcodeMetadata();\n        if (barcodeMetadata == null) {\n            return null;\n        }\n        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);\n        var result = new Int32Array(barcodeMetadata.getRowCount());\n        try {\n            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value /*Codeword*/;\n                if (codeword != null) {\n                    var rowNumber = codeword.getRowNumber();\n                    if (rowNumber >= result.length) {\n                        // We have more rows than the barcode metadata allows for, ignore them.\n                        continue;\n                    }\n                    result[rowNumber]++;\n                } // else throw exception?\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return result;\n    };\n    // TODO maybe we should add missing codewords to store the correct row number to make\n    // finding row numbers for other columns easier\n    // use row height count to make detection of invalid row numbers more reliable\n    DetectionResultRowIndicatorColumn.prototype.adjustIncompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {\n        var boundingBox = this.getBoundingBox();\n        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n        var codewords = this.getCodewords();\n        var barcodeRow = -1;\n        var maxRowHeight = 1;\n        var currentRowHeight = 0;\n        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var codeword = codewords[codewordsRow];\n            codeword.setRowNumberAsRowIndicatorColumn();\n            var rowDifference = codeword.getRowNumber() - barcodeRow;\n            // TODO improve handling with case where first row indicator doesn't start with 0\n            if (rowDifference === 0) {\n                currentRowHeight++;\n            }\n            else if (rowDifference === 1) {\n                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                currentRowHeight = 1;\n                barcodeRow = codeword.getRowNumber();\n            }\n            else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\n                codewords[codewordsRow] = null;\n            }\n            else {\n                barcodeRow = codeword.getRowNumber();\n                currentRowHeight = 1;\n            }\n        }\n        // return (int) (averageRowHeight + 0.5);\n    };\n    DetectionResultRowIndicatorColumn.prototype.getBarcodeMetadata = function () {\n        var e_3, _a;\n        var codewords = this.getCodewords();\n        var barcodeColumnCount = new BarcodeValue_1.default();\n        var barcodeRowCountUpperPart = new BarcodeValue_1.default();\n        var barcodeRowCountLowerPart = new BarcodeValue_1.default();\n        var barcodeECLevel = new BarcodeValue_1.default();\n        try {\n            for (var codewords_1 = __values(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {\n                var codeword = codewords_1_1.value /*Codeword*/;\n                if (codeword == null) {\n                    continue;\n                }\n                codeword.setRowNumberAsRowIndicatorColumn();\n                var rowIndicatorValue = codeword.getValue() % 30;\n                var codewordRowNumber = codeword.getRowNumber();\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);\n                        break;\n                    case 1:\n                        barcodeECLevel.setValue(rowIndicatorValue / 3);\n                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);\n                        break;\n                    case 2:\n                        barcodeColumnCount.setValue(rowIndicatorValue + 1);\n                        break;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (codewords_1_1 && !codewords_1_1.done && (_a = codewords_1.return)) _a.call(codewords_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        // Maybe we should check if we have ambiguous values?\n        if ((barcodeColumnCount.getValue().length === 0) ||\n            (barcodeRowCountUpperPart.getValue().length === 0) ||\n            (barcodeRowCountLowerPart.getValue().length === 0) ||\n            (barcodeECLevel.getValue().length === 0) ||\n            barcodeColumnCount.getValue()[0] < 1 ||\n            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_1.default.MIN_ROWS_IN_BARCODE ||\n            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_1.default.MAX_ROWS_IN_BARCODE) {\n            return null;\n        }\n        var barcodeMetadata = new BarcodeMetadata_1.default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);\n        this.removeIncorrectCodewords(codewords, barcodeMetadata);\n        return barcodeMetadata;\n    };\n    DetectionResultRowIndicatorColumn.prototype.removeIncorrectCodewords = function (codewords, barcodeMetadata) {\n        // Remove codewords which do not match the metadata\n        // TODO Maybe we should keep the incorrect codewords for the start and end positions?\n        for (var codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {\n            var codeword = codewords[codewordRow];\n            if (codewords[codewordRow] == null) {\n                continue;\n            }\n            var rowIndicatorValue = codeword.getValue() % 30;\n            var codewordRowNumber = codeword.getRowNumber();\n            if (codewordRowNumber > barcodeMetadata.getRowCount()) {\n                codewords[codewordRow] = null;\n                continue;\n            }\n            if (!this._isLeft) {\n                codewordRowNumber += 2;\n            }\n            switch (codewordRowNumber % 3) {\n                case 0:\n                    if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n                case 1:\n                    if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||\n                        rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n                case 2:\n                    if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n            }\n        }\n    };\n    DetectionResultRowIndicatorColumn.prototype.isLeft = function () {\n        return this._isLeft;\n    };\n    // @Override\n    DetectionResultRowIndicatorColumn.prototype.toString = function () {\n        return 'IsLeft: ' + this._isLeft + '\\n' + _super.prototype.toString.call(this);\n    };\n    return DetectionResultRowIndicatorColumn;\n}(DetectionResultColumn_1.default));\nexports[\"default\"] = DetectionResultRowIndicatorColumn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9EZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlKQUFpQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyw4SkFBbUI7QUFDbkQsOEJBQThCLG1CQUFPLENBQUMsMEtBQXlCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLHdKQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBaUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHFCQUFxQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5QREY0MTdDb21tb247XG52YXIgUERGNDE3Q29tbW9uXzEgPSByZXF1aXJlKFwiLi4vUERGNDE3Q29tbW9uXCIpO1xudmFyIEJhcmNvZGVNZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vQmFyY29kZU1ldGFkYXRhXCIpO1xudmFyIERldGVjdGlvblJlc3VsdENvbHVtbl8xID0gcmVxdWlyZShcIi4vRGV0ZWN0aW9uUmVzdWx0Q29sdW1uXCIpO1xudmFyIEJhcmNvZGVWYWx1ZV8xID0gcmVxdWlyZShcIi4vQmFyY29kZVZhbHVlXCIpO1xuLyoqXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbihib3VuZGluZ0JveCwgaXNMZWZ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvdW5kaW5nQm94KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faXNMZWZ0ID0gaXNMZWZ0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUuc2V0Um93TnVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZ2V0Q29kZXdvcmRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gX2MudmFsdWUgLypDb2Rld29yZCovO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE8gaW1wbGVtZW50IHByb3Blcmx5XG4gICAgLy8gVE9ETyBtYXliZSB3ZSBzaG91bGQgYWRkIG1pc3NpbmcgY29kZXdvcmRzIHRvIHN0b3JlIHRoZSBjb3JyZWN0IHJvdyBudW1iZXIgdG8gbWFrZVxuICAgIC8vIGZpbmRpbmcgcm93IG51bWJlcnMgZm9yIG90aGVyIGNvbHVtbnMgZWFzaWVyXG4gICAgLy8gdXNlIHJvdyBoZWlnaHQgY291bnQgdG8gbWFrZSBkZXRlY3Rpb24gb2YgaW52YWxpZCByb3cgbnVtYmVycyBtb3JlIHJlbGlhYmxlXG4gICAgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLnByb3RvdHlwZS5hZGp1c3RDb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMgPSBmdW5jdGlvbiAoYmFyY29kZU1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICB0aGlzLnNldFJvd051bWJlcnMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xuICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKHRvcC5nZXRZKCkpKTtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmMoYm90dG9tLmdldFkoKSkpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGJlIGNhcmVmdWwgdXNpbmcgdGhlIGF2ZXJhZ2Ugcm93IGhlaWdodC4gQmFyY29kZSBjb3VsZCBiZSBza2V3ZWQgc28gdGhhdCB3ZSBoYXZlIHNtYWxsZXIgYW5kXG4gICAgICAgIC8vIHRhbGxlciByb3dzXG4gICAgICAgIC8vIGZsb2F0IGF2ZXJhZ2VSb3dIZWlnaHQgPSAobGFzdFJvdyAtIGZpcnN0Um93KSAvIC8qKGZsb2F0KSovIGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgYmFyY29kZVJvdyA9IC0xO1xuICAgICAgICB2YXIgbWF4Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRSb3dIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBjb2Rld29yZHNSb3cgLyppbnQqLyA9IGZpcnN0Um93OyBjb2Rld29yZHNSb3cgPCBsYXN0Um93OyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgLy8gICAgICBmbG9hdCBleHBlY3RlZFJvd051bWJlciA9IChjb2Rld29yZHNSb3cgLSBmaXJzdFJvdykgLyBhdmVyYWdlUm93SGVpZ2h0O1xuICAgICAgICAgICAgLy8gICAgICBpZiAoTWF0aC5hYnMoY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgLSBleHBlY3RlZFJvd051bWJlcikgPiAyKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgU2ltcGxlTG9nLmxvZyhMRVZFTC5XQVJOSU5HLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBcIlJlbW92aW5nIGNvZGV3b3JkLCByb3dOdW1iZXJTa2V3IHRvbyBoaWdoLCBjb2Rld29yZFtcIiArIGNvZGV3b3Jkc1JvdyArIFwiXTogRXhwZWN0ZWQgUm93OiBcIiArXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBleHBlY3RlZFJvd051bWJlciArIFwiLCBSZWFsUm93OiBcIiArIGNvZGV3b3JkLmdldFJvd051bWJlcigpICsgXCIsIHZhbHVlOiBcIiArIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgLy8gICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgIC8vICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd0RpZmZlcmVuY2UgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGJhcmNvZGVSb3c7XG4gICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgaGFuZGxpbmcgd2l0aCBjYXNlIHdoZXJlIGZpcnN0IHJvdyBpbmRpY2F0b3IgZG9lc24ndCBzdGFydCB3aXRoIDBcbiAgICAgICAgICAgIGlmIChyb3dEaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG1heFJvd0hlaWdodCA9IE1hdGgubWF4KG1heFJvd0hlaWdodCwgY3VycmVudFJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA8IDAgfHxcbiAgICAgICAgICAgICAgICBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSA+PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSB8fFxuICAgICAgICAgICAgICAgIHJvd0RpZmZlcmVuY2UgPiBjb2Rld29yZHNSb3cpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZFJvd3MgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKG1heFJvd0hlaWdodCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFJvd3MgPSAobWF4Um93SGVpZ2h0IC0gMikgKiByb3dEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFJvd3MgPSByb3dEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQgPSBjaGVja2VkUm93cyA+PSBjb2Rld29yZHNSb3c7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMTsgaSA8PSBjaGVja2VkUm93cyAmJiAhY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIChoZWlnaHQgKiByb3dEaWZmZXJlbmNlKSBudW1iZXIgb2YgY29kZXdvcmRzIG1pc3NpbmcuIEZvciBub3cgd2UgYXNzdW1lIGhlaWdodCA9IDEuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGhvcGVmdWxseSBnZXQgcmlkIG9mIG1vc3QgcHJvYmxlbXMgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93IC0gaV0gIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiAoaW50KSAoYXZlcmFnZVJvd0hlaWdodCArIDAuNSk7XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4ucHJvdG90eXBlLmdldFJvd0hlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgYmFyY29kZU1ldGFkYXRhID0gdGhpcy5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgaWYgKGJhcmNvZGVNZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkanVzdEluY29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZ2V0Q29kZXdvcmRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gX2MudmFsdWUgLypDb2Rld29yZCovO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG1vcmUgcm93cyB0aGFuIHRoZSBiYXJjb2RlIG1ldGFkYXRhIGFsbG93cyBmb3IsIGlnbm9yZSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jvd051bWJlcl0rKztcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2UgdGhyb3cgZXhjZXB0aW9uP1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcbiAgICAvLyBmaW5kaW5nIHJvdyBudW1iZXJzIGZvciBvdGhlciBjb2x1bW5zIGVhc2llclxuICAgIC8vIHVzZSByb3cgaGVpZ2h0IGNvdW50IHRvIG1ha2UgZGV0ZWN0aW9uIG9mIGludmFsaWQgcm93IG51bWJlcnMgbW9yZSByZWxpYWJsZVxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUuYWRqdXN0SW5jb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMgPSBmdW5jdGlvbiAoYmFyY29kZU1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBib3VuZGluZ0JveCA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKSA6IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIHZhciBib3R0b20gPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmModG9wLmdldFkoKSkpO1xuICAgICAgICB2YXIgbGFzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpKSk7XG4gICAgICAgIC8vIGZsb2F0IGF2ZXJhZ2VSb3dIZWlnaHQgPSAobGFzdFJvdyAtIGZpcnN0Um93KSAvIC8qKGZsb2F0KSovIGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgdmFyIGJhcmNvZGVSb3cgPSAtMTtcbiAgICAgICAgdmFyIG1heFJvd0hlaWdodCA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSBmaXJzdFJvdzsgY29kZXdvcmRzUm93IDwgbGFzdFJvdzsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCk7XG4gICAgICAgICAgICB2YXIgcm93RGlmZmVyZW5jZSA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gYmFyY29kZVJvdztcbiAgICAgICAgICAgIC8vIFRPRE8gaW1wcm92ZSBoYW5kbGluZyB3aXRoIGNhc2Ugd2hlcmUgZmlyc3Qgcm93IGluZGljYXRvciBkb2Vzbid0IHN0YXJ0IHdpdGggMFxuICAgICAgICAgICAgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbWF4Um93SGVpZ2h0ID0gTWF0aC5tYXgobWF4Um93SGVpZ2h0LCBjdXJyZW50Um93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSA+PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gKGludCkgKGF2ZXJhZ2VSb3dIZWlnaHQgKyAwLjUpO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLnByb3RvdHlwZS5nZXRCYXJjb2RlTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgdmFyIGJhcmNvZGVDb2x1bW5Db3VudCA9IG5ldyBCYXJjb2RlVmFsdWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHZhciBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQgPSBuZXcgQmFyY29kZVZhbHVlXzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0ID0gbmV3IEJhcmNvZGVWYWx1ZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIGJhcmNvZGVFQ0xldmVsID0gbmV3IEJhcmNvZGVWYWx1ZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc18xID0gX192YWx1ZXMoY29kZXdvcmRzKSwgY29kZXdvcmRzXzFfMSA9IGNvZGV3b3Jkc18xLm5leHQoKTsgIWNvZGV3b3Jkc18xXzEuZG9uZTsgY29kZXdvcmRzXzFfMSA9IGNvZGV3b3Jkc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IGNvZGV3b3Jkc18xXzEudmFsdWUgLypDb2Rld29yZCovO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXJBc1Jvd0luZGljYXRvckNvbHVtbigpO1xuICAgICAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmRSb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZFJvd051bWJlciArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3JkUm93TnVtYmVyICUgMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgKiAzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZUVDTGV2ZWwuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAlIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVDb2x1bW5Db3VudC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzXzFfMSAmJiAhY29kZXdvcmRzXzFfMS5kb25lICYmIChfYSA9IGNvZGV3b3Jkc18xLnJldHVybikpIF9hLmNhbGwoY29kZXdvcmRzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBoYXZlIGFtYmlndW91cyB2YWx1ZXM/XG4gICAgICAgIGlmICgoYmFyY29kZUNvbHVtbkNvdW50LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgKGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgIChiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAoYmFyY29kZUVDTGV2ZWwuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICBiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSA8IDEgfHxcbiAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdICsgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0gPCBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1JTl9ST1dTX0lOX0JBUkNPREUgfHxcbiAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdICsgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0gPiBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1BWF9ST1dTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXJjb2RlTWV0YWRhdGEgPSBuZXcgQmFyY29kZU1ldGFkYXRhXzEuZGVmYXVsdChiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKClbMF0sIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlRUNMZXZlbC5nZXRWYWx1ZSgpWzBdKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gYmFyY29kZU1ldGFkYXRhO1xuICAgIH07XG4gICAgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLnByb3RvdHlwZS5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMgPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvZGV3b3JkcyB3aGljaCBkbyBub3QgbWF0Y2ggdGhlIG1ldGFkYXRhXG4gICAgICAgIC8vIFRPRE8gTWF5YmUgd2Ugc2hvdWxkIGtlZXAgdGhlIGluY29ycmVjdCBjb2Rld29yZHMgZm9yIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucz9cbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3JkUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRSb3crKykge1xuICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3JkUm93XTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcbiAgICAgICAgICAgIHZhciBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkUm93TnVtYmVyID4gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRSb3dOdW1iZXIgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRSb3dOdW1iZXIgJSAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yVmFsdWUgKiAzICsgMSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50VXBwZXJQYXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmMocm93SW5kaWNhdG9yVmFsdWUgLyAzKSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGljYXRvclZhbHVlICUgMyAhPT0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50TG93ZXJQYXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICsgMSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldENvbHVtbkNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4ucHJvdG90eXBlLmlzTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGVmdDtcbiAgICB9O1xuICAgIC8vIEBPdmVycmlkZVxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnSXNMZWZ0OiAnICsgdGhpcy5faXNMZWZ0ICsgJ1xcbicgKyBfc3VwZXIucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uO1xufShEZXRlY3Rpb25SZXN1bHRDb2x1bW5fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\nvar Float_1 = __webpack_require__(/*! ../../util/Float */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Float.js\");\n/**\n * @author Guenther Grau\n * @author creatale GmbH (christoph.schulz@creatale.de)\n */\nvar PDF417CodewordDecoder = /** @class */ (function () {\n    function PDF417CodewordDecoder() {\n    }\n    /* @note\n     * this action have to be performed before first use of class\n     * - static constructor\n     * working with 32bit float (based from Java logic)\n    */\n    PDF417CodewordDecoder.initialize = function () {\n        // Pre-computes the symbol ratio table.\n        for ( /*int*/var i = 0; i < PDF417Common_1.default.SYMBOL_TABLE.length; i++) {\n            var currentSymbol = PDF417Common_1.default.SYMBOL_TABLE[i];\n            var currentBit = currentSymbol & 0x1;\n            for ( /*int*/var j = 0; j < PDF417Common_1.default.BARS_IN_MODULE; j++) {\n                var size = 0.0;\n                while ((currentSymbol & 0x1) === currentBit) {\n                    size += 1.0;\n                    currentSymbol >>= 1;\n                }\n                currentBit = currentSymbol & 0x1;\n                if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {\n                    PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common_1.default.BARS_IN_MODULE);\n                }\n                PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common_1.default.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common_1.default.MODULES_IN_CODEWORD);\n            }\n        }\n        this.bSymbolTableReady = true;\n    };\n    PDF417CodewordDecoder.getDecodedValue = function (moduleBitCount) {\n        var decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));\n        if (decodedValue !== -1) {\n            return decodedValue;\n        }\n        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);\n    };\n    PDF417CodewordDecoder.sampleBitCounts = function (moduleBitCount) {\n        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);\n        var result = new Int32Array(PDF417Common_1.default.BARS_IN_MODULE);\n        var bitCountIndex = 0;\n        var sumPreviousBits = 0;\n        for ( /*int*/var i = 0; i < PDF417Common_1.default.MODULES_IN_CODEWORD; i++) {\n            var sampleIndex = bitCountSum / (2 * PDF417Common_1.default.MODULES_IN_CODEWORD) +\n                (i * bitCountSum) / PDF417Common_1.default.MODULES_IN_CODEWORD;\n            if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {\n                sumPreviousBits += moduleBitCount[bitCountIndex];\n                bitCountIndex++;\n            }\n            result[bitCountIndex]++;\n        }\n        return result;\n    };\n    PDF417CodewordDecoder.getDecodedCodewordValue = function (moduleBitCount) {\n        var decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);\n        return PDF417Common_1.default.getCodeword(decodedValue) === -1 ? -1 : decodedValue;\n    };\n    PDF417CodewordDecoder.getBitValue = function (moduleBitCount) {\n        var result = /*long*/ 0;\n        for (var /*int*/ i = 0; i < moduleBitCount.length; i++) {\n            for ( /*int*/var bit = 0; bit < moduleBitCount[i]; bit++) {\n                result = (result << 1) | (i % 2 === 0 ? 1 : 0);\n            }\n        }\n        return Math.trunc(result);\n    };\n    // working with 32bit float (as in Java)\n    PDF417CodewordDecoder.getClosestDecodedValue = function (moduleBitCount) {\n        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);\n        var bitCountRatios = new Array(PDF417Common_1.default.BARS_IN_MODULE);\n        if (bitCountSum > 1) {\n            for (var /*int*/ i = 0; i < bitCountRatios.length; i++) {\n                bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);\n            }\n        }\n        var bestMatchError = Float_1.default.MAX_VALUE;\n        var bestMatch = -1;\n        if (!this.bSymbolTableReady) {\n            PDF417CodewordDecoder.initialize();\n        }\n        for ( /*int*/var j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {\n            var error = 0.0;\n            var ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];\n            for ( /*int*/var k = 0; k < PDF417Common_1.default.BARS_IN_MODULE; k++) {\n                var diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);\n                error += Math.fround(diff * diff);\n                if (error >= bestMatchError) {\n                    break;\n                }\n            }\n            if (error < bestMatchError) {\n                bestMatchError = error;\n                bestMatch = PDF417Common_1.default.SYMBOL_TABLE[j];\n            }\n        }\n        return bestMatch;\n    };\n    // flag that the table is ready for use\n    PDF417CodewordDecoder.bSymbolTableReady = false;\n    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common_1.default.SYMBOL_TABLE.length).map(function (x) { return x = new Array(PDF417Common_1.default.BARS_IN_MODULE); });\n    return PDF417CodewordDecoder;\n}());\nexports[\"default\"] = PDF417CodewordDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9QREY0MTdDb2Rld29yZERlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVLQUFpQztBQUMzRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlKQUFpQjtBQUM5QyxjQUFjLG1CQUFPLENBQUMseUlBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQTJDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRCxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtDQUErQztBQUMvRTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsOERBQThEO0FBQ2hMO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3BkZjQxNy9kZWNvZGVyL1BERjQxN0NvZGV3b3JkRGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlcjtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3Rvci5NYXRoVXRpbHM7XG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5QREY0MTdDb21tb247XG52YXIgUERGNDE3Q29tbW9uXzEgPSByZXF1aXJlKFwiLi4vUERGNDE3Q29tbW9uXCIpO1xudmFyIEZsb2F0XzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9GbG9hdFwiKTtcbi8qKlxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gKiBAYXV0aG9yIGNyZWF0YWxlIEdtYkggKGNocmlzdG9waC5zY2h1bHpAY3JlYXRhbGUuZGUpXG4gKi9cbnZhciBQREY0MTdDb2Rld29yZERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUERGNDE3Q29kZXdvcmREZWNvZGVyKCkge1xuICAgIH1cbiAgICAvKiBAbm90ZVxuICAgICAqIHRoaXMgYWN0aW9uIGhhdmUgdG8gYmUgcGVyZm9ybWVkIGJlZm9yZSBmaXJzdCB1c2Ugb2YgY2xhc3NcbiAgICAgKiAtIHN0YXRpYyBjb25zdHJ1Y3RvclxuICAgICAqIHdvcmtpbmcgd2l0aCAzMmJpdCBmbG9hdCAoYmFzZWQgZnJvbSBKYXZhIGxvZ2ljKVxuICAgICovXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByZS1jb21wdXRlcyB0aGUgc3ltYm9sIHJhdGlvIHRhYmxlLlxuICAgICAgICBmb3IgKCAvKmludCovdmFyIGkgPSAwOyBpIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3ltYm9sID0gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEVbaV07XG4gICAgICAgICAgICB2YXIgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICBmb3IgKCAvKmludCovdmFyIGogPSAwOyBqIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAwLjA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50U3ltYm9sICYgMHgxKSA9PT0gY3VycmVudEJpdCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN5bWJvbCA+Pj0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XG4gICAgICAgICAgICAgICAgaWYgKCFQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV0gPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV1bUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSAtIGogLSAxXSA9IE1hdGguZnJvdW5kKHNpemUgLyBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYlN5bWJvbFRhYmxlUmVhZHkgPSB0cnVlO1xuICAgIH07XG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRWYWx1ZSA9IGZ1bmN0aW9uIChtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICB2YXIgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRDb2Rld29yZFZhbHVlKFBERjQxN0NvZGV3b3JkRGVjb2Rlci5zYW1wbGVCaXRDb3VudHMobW9kdWxlQml0Q291bnQpKTtcbiAgICAgICAgaWYgKGRlY29kZWRWYWx1ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXRDbG9zZXN0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KTtcbiAgICB9O1xuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5zYW1wbGVCaXRDb3VudHMgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgdmFyIGJpdENvdW50U3VtID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgIHZhciBiaXRDb3VudEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHN1bVByZXZpb3VzQml0cyA9IDA7XG4gICAgICAgIGZvciAoIC8qaW50Ki92YXIgaSA9IDA7IGkgPCBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNhbXBsZUluZGV4ID0gYml0Q291bnRTdW0gLyAoMiAqIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRCkgK1xuICAgICAgICAgICAgICAgIChpICogYml0Q291bnRTdW0pIC8gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NT0RVTEVTX0lOX0NPREVXT1JEO1xuICAgICAgICAgICAgaWYgKHN1bVByZXZpb3VzQml0cyArIG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdIDw9IHNhbXBsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgc3VtUHJldmlvdXNCaXRzICs9IG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdO1xuICAgICAgICAgICAgICAgIGJpdENvdW50SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtiaXRDb3VudEluZGV4XSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0RGVjb2RlZENvZGV3b3JkVmFsdWUgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgdmFyIGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXRCaXRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgIHJldHVybiBQREY0MTdDb21tb25fMS5kZWZhdWx0LmdldENvZGV3b3JkKGRlY29kZWRWYWx1ZSkgPT09IC0xID8gLTEgOiBkZWNvZGVkVmFsdWU7XG4gICAgfTtcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Qml0VmFsdWUgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IC8qbG9uZyovIDA7XG4gICAgICAgIGZvciAodmFyIC8qaW50Ki8gaSA9IDA7IGkgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICggLyppbnQqL3ZhciBiaXQgPSAwOyBiaXQgPCBtb2R1bGVCaXRDb3VudFtpXTsgYml0KyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDEpIHwgKGkgJSAyID09PSAwID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKHJlc3VsdCk7XG4gICAgfTtcbiAgICAvLyB3b3JraW5nIHdpdGggMzJiaXQgZmxvYXQgKGFzIGluIEphdmEpXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldENsb3Nlc3REZWNvZGVkVmFsdWUgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgdmFyIGJpdENvdW50U3VtID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICB2YXIgYml0Q291bnRSYXRpb3MgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgIGlmIChiaXRDb3VudFN1bSA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qaW50Ki8gaSA9IDA7IGkgPCBiaXRDb3VudFJhdGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpdENvdW50UmF0aW9zW2ldID0gTWF0aC5mcm91bmQobW9kdWxlQml0Q291bnRbaV0gLyBiaXRDb3VudFN1bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlc3RNYXRjaEVycm9yID0gRmxvYXRfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICBpZiAoIXRoaXMuYlN5bWJvbFRhYmxlUmVhZHkpIHtcbiAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggLyppbnQqL3ZhciBqID0gMDsgaiA8IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IDAuMDtcbiAgICAgICAgICAgIHZhciByYXRpb1RhYmxlUm93ID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtqXTtcbiAgICAgICAgICAgIGZvciAoIC8qaW50Ki92YXIgayA9IDA7IGsgPCBQREY0MTdDb21tb25fMS5kZWZhdWx0LkJBUlNfSU5fTU9EVUxFOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguZnJvdW5kKHJhdGlvVGFibGVSb3dba10gLSBiaXRDb3VudFJhdGlvc1trXSk7XG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gTWF0aC5mcm91bmQoZGlmZiAqIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciA+PSBiZXN0TWF0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICB9O1xuICAgIC8vIGZsYWcgdGhhdCB0aGUgdGFibGUgaXMgcmVhZHkgZm9yIHVzZVxuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5iU3ltYm9sVGFibGVSZWFkeSA9IGZhbHNlO1xuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEUubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7IH0pO1xuICAgIHJldHVybiBQREY0MTdDb2Rld29yZERlY29kZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUERGNDE3Q29kZXdvcmREZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\n// import com.google.zxing.FormatException;\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\n// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\nvar ErrorCorrection_1 = __webpack_require__(/*! ./ec/ErrorCorrection */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js\");\n// local\nvar BoundingBox_1 = __webpack_require__(/*! ./BoundingBox */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js\");\nvar DetectionResultRowIndicatorColumn_1 = __webpack_require__(/*! ./DetectionResultRowIndicatorColumn */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js\");\nvar DetectionResult_1 = __webpack_require__(/*! ./DetectionResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js\");\nvar DetectionResultColumn_1 = __webpack_require__(/*! ./DetectionResultColumn */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js\");\nvar Codeword_1 = __webpack_require__(/*! ./Codeword */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js\");\nvar BarcodeValue_1 = __webpack_require__(/*! ./BarcodeValue */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js\");\nvar PDF417CodewordDecoder_1 = __webpack_require__(/*! ./PDF417CodewordDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js\");\nvar DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js\");\n// utils\nvar Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js\");\n// import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n/**\n * @author Guenther Grau\n */\nvar PDF417ScanningDecoder = /** @class */ (function () {\n    function PDF417ScanningDecoder() {\n    }\n    /**\n     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n     *\n     * columns. That way width can be deducted from the pattern column.\n     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n     * than it should be. This can happen if the scanner used a bad blackpoint.\n     *\n     * @param BitMatrix\n     * @param image\n     * @param ResultPoint\n     * @param imageTopLeft\n     * @param ResultPoint\n     * @param imageBottomLeft\n     * @param ResultPoint\n     * @param imageTopRight\n     * @param ResultPoint\n     * @param imageBottomRight\n     * @param int\n     * @param minCodewordWidth\n     * @param int\n     * @param maxCodewordWidth\n     *\n     * @throws NotFoundException\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n        var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n        var leftRowIndicatorColumn = null;\n        var rightRowIndicatorColumn = null;\n        var detectionResult;\n        for (var firstPass /*boolean*/ = true;; firstPass = false) {\n            if (imageTopLeft != null) {\n                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n            }\n            if (imageTopRight != null) {\n                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n            }\n            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (detectionResult == null) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            var resultBox = detectionResult.getBoundingBox();\n            if (firstPass && resultBox != null &&\n                (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                boundingBox = resultBox;\n            }\n            else {\n                break;\n            }\n        }\n        detectionResult.setBoundingBox(boundingBox);\n        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n        var leftToRight = leftRowIndicatorColumn != null;\n        for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n            var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n                continue;\n            }\n            var detectionResultColumn = void 0;\n            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n            }\n            else {\n                detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n            }\n            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n            var startColumn = -1;\n            var previousStartColumn = startColumn;\n            // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n            for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                    if (previousStartColumn === -1) {\n                        continue;\n                    }\n                    startColumn = previousStartColumn;\n                }\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    detectionResultColumn.setCodeword(imageRow, codeword);\n                    previousStartColumn = startColumn;\n                    minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                    maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                }\n            }\n        }\n        return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n    };\n    /**\n     *\n     * @param leftRowIndicatorColumn\n     * @param rightRowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n            return null;\n        }\n        var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n        if (barcodeMetadata == null) {\n            return null;\n        }\n        var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n        return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n    };\n    /**\n     *\n     * @param rowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n        var e_1, _a;\n        if (rowIndicatorColumn == null) {\n            return null;\n        }\n        var rowHeights = rowIndicatorColumn.getRowHeights();\n        if (rowHeights == null) {\n            return null;\n        }\n        var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n        var missingStartRows = 0;\n        try {\n            for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n                var rowHeight = rowHeights_1_1.value /*int*/;\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var codewords = rowIndicatorColumn.getCodewords();\n        for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n            missingStartRows--;\n        }\n        var missingEndRows = 0;\n        for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n            missingEndRows += maxRowHeight - rowHeights[row];\n            if (rowHeights[row] > 0) {\n                break;\n            }\n        }\n        for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n            missingEndRows--;\n        }\n        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n    };\n    PDF417ScanningDecoder.getMax = function (values) {\n        var e_2, _a;\n        var maxValue = -1;\n        try {\n            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n                var value = values_1_1.value /*int*/;\n                maxValue = Math.max(maxValue, value);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return maxValue;\n    };\n    PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        var leftBarcodeMetadata;\n        if (leftRowIndicatorColumn == null ||\n            (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n        }\n        var rightBarcodeMetadata;\n        if (rightRowIndicatorColumn == null ||\n            (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return leftBarcodeMetadata;\n        }\n        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&\n            leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&\n            leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n            return null;\n        }\n        return leftBarcodeMetadata;\n    };\n    PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n        for (var i /*int*/ = 0; i < 2; i++) {\n            var increment = i === 0 ? 1 : -1;\n            var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n            for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&\n                imageRow >= boundingBox.getMinY(); imageRow += increment) {\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    rowIndicatorColumn.setCodeword(imageRow, codeword);\n                    if (leftToRight) {\n                        startColumn = codeword.getStartX();\n                    }\n                    else {\n                        startColumn = codeword.getEndX();\n                    }\n                }\n            }\n        }\n        return rowIndicatorColumn;\n    };\n    /**\n     *\n     * @param detectionResult\n     * @param BarcodeValue\n     * @param param2\n     * @param param3\n     * @param barcodeMatrix\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n        var barcodeMatrix01 = barcodeMatrix[0][1];\n        var numberOfCodewords = barcodeMatrix01.getValue();\n        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *\n            detectionResult.getBarcodeRowCount() -\n            PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n        if (numberOfCodewords.length === 0) {\n            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n        else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n            // The calculated one is more reliable as it is derived from the row indicator columns\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n    };\n    /**\n     *\n     * @param detectionResult\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n        var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n        var erasures /*Collection<Integer>*/ = new Array();\n        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n        var ambiguousIndexValuesList = /*List<int[]>*/ [];\n        var ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n        for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n            for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n                var values = barcodeMatrix[row][column + 1].getValue();\n                var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                if (values.length === 0) {\n                    erasures.push(codewordIndex);\n                }\n                else if (values.length === 1) {\n                    codewords[codewordIndex] = values[0];\n                }\n                else {\n                    ambiguousIndexesList.push(codewordIndex);\n                    ambiguousIndexValuesList.push(values);\n                }\n            }\n        }\n        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n        for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n            ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n        }\n        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n    };\n    /**\n     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n     * so decoding the normal barcodes is not affected by this.\n     *\n     * @param erasureArray contains the indexes of erasures\n     * @param ambiguousIndexes array with the indexes that have more than one most likely value\n     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n     * be the same length as the ambiguousIndexes array\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n        var tries = 100;\n        while (tries-- > 0) {\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n            }\n            try {\n                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n            }\n            catch (err) {\n                var ignored = err instanceof ChecksumException_1.default;\n                if (!ignored) {\n                    throw err;\n                }\n            }\n            if (ambiguousIndexCount.length === 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                    ambiguousIndexCount[i]++;\n                    break;\n                }\n                else {\n                    ambiguousIndexCount[i] = 0;\n                    if (i === ambiguousIndexCount.length - 1) {\n                        throw ChecksumException_1.default.getChecksumInstance();\n                    }\n                }\n            }\n        }\n        throw ChecksumException_1.default.getChecksumInstance();\n    };\n    PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n        var e_3, _a, e_4, _b;\n        // let barcodeMatrix: BarcodeValue[][] =\n        // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n                barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n            }\n        }\n        var column = 0;\n        try {\n            for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var detectionResultColumn = _d.value /*DetectionResultColumn*/;\n                if (detectionResultColumn != null) {\n                    try {\n                        for (var _e = (e_4 = void 0, __values(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var codeword = _f.value /*Codeword*/;\n                            if (codeword != null) {\n                                var rowNumber = codeword.getRowNumber();\n                                if (rowNumber >= 0) {\n                                    if (rowNumber >= barcodeMatrix.length) {\n                                        // We have more rows than the barcode metadata allows for, ignore them.\n                                        continue;\n                                    }\n                                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                                }\n                            }\n                        }\n                    }\n                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_4) throw e_4.error; }\n                    }\n                }\n                column++;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return barcodeMatrix;\n    };\n    PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n    };\n    PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n        var e_5, _a;\n        var offset = leftToRight ? 1 : -1;\n        var codeword = null;\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n        if (codeword != null) {\n            return leftToRight ? codeword.getStartX() : codeword.getEndX();\n        }\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        var skippedColumns = 0;\n        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            barcodeColumn -= offset;\n            try {\n                for (var _b = (e_5 = void 0, __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var previousRowCodeword = _c.value /*Codeword*/;\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +\n                            offset *\n                                skippedColumns *\n                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            skippedColumns++;\n        }\n        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n    };\n    PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n        // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n        // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n        // for the current position\n        var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        if (moduleBitCount == null) {\n            return null;\n        }\n        var endColumn;\n        var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n        if (leftToRight) {\n            endColumn = startColumn + codewordBitCount;\n        }\n        else {\n            for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n                var tmpCount = moduleBitCount[i];\n                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n            }\n            endColumn = startColumn;\n            startColumn = endColumn - codewordBitCount;\n        }\n        // TODO implement check for width and correction of black and white bars\n        // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n        // should probably done only for codewords with a lot more than 17 bits.\n        // The following fixes 10-1.png, which has wide black bars and small white bars\n        //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n        //      if (i % 2 === 0) {\n        //        moduleBitCount[i]--;\n        //      } else {\n        //        moduleBitCount[i]++;\n        //      }\n        //    }\n        // We could also use the width of surrounding codewords for more accurate results, but this seems\n        // sufficient for now\n        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n            // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n            // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n            return null;\n        }\n        var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n        var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n        if (codeword === -1) {\n            return null;\n        }\n        return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n    };\n    PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n        var imageColumn = startColumn;\n        var moduleBitCount = new Int32Array(8);\n        var moduleNumber = 0;\n        var increment = leftToRight ? 1 : -1;\n        var previousPixelValue = leftToRight;\n        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&\n            moduleNumber < moduleBitCount.length) {\n            if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                moduleBitCount[moduleNumber]++;\n                imageColumn += increment;\n            }\n            else {\n                moduleNumber++;\n                previousPixelValue = !previousPixelValue;\n            }\n        }\n        if (moduleNumber === moduleBitCount.length ||\n            ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&\n                moduleNumber === moduleBitCount.length - 1)) {\n            return moduleBitCount;\n        }\n        return null;\n    };\n    PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n        return 2 << barcodeECLevel;\n    };\n    PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n        var correctedStartColumn = codewordStartColumn;\n        var increment = leftToRight ? -1 : 1;\n        // there should be no black pixels before the start column. If there are, then we need to start earlier.\n        for (var i /*int*/ = 0; i < 2; i++) {\n            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&\n                leftToRight === image.get(correctedStartColumn, imageRow)) {\n                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                    return codewordStartColumn;\n                }\n                correctedStartColumn += increment;\n            }\n            increment = -increment;\n            leftToRight = !leftToRight;\n        }\n        return correctedStartColumn;\n    };\n    PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&\n            codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n    };\n    /**\n     * @throws FormatException,\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n        if (codewords.length === 0) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var numECCodewords = 1 << (ecLevel + 1);\n        var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n        // Decode the codewords\n        var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n        decoderResult.setErrorsCorrected(correctedErrorsCount);\n        decoderResult.setErasures(erasures.length);\n        return decoderResult;\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place.</p>\n     *\n     * @param codewords   data and error correction codewords\n     * @param erasures positions of any known erasures\n     * @param numECCodewords number of error correction codewords that are available in codewords\n     * @throws ChecksumException if error correction fails\n     */\n    PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n        if (erasures != null &&\n            erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||\n            numECCodewords < 0 ||\n            numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n            // Too many errors or EC Codewords is corrupted\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n    };\n    /**\n     * Verify that all is OK with the codeword array.\n     * @throws FormatException\n     */\n    PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n        if (codewords.length < 4) {\n            // Codeword array size should be at least 4 allowing for\n            // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n            throw FormatException_1.default.getFormatInstance();\n        }\n        // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n        // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n        // codewords, but excluding the number of error correction codewords.\n        var numberOfCodewords = codewords[0];\n        if (numberOfCodewords > codewords.length) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        if (numberOfCodewords === 0) {\n            // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n            if (numECCodewords < codewords.length) {\n                codewords[0] = codewords.length - numECCodewords;\n            }\n            else {\n                throw FormatException_1.default.getFormatInstance();\n            }\n        }\n    };\n    PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n        var result = new Int32Array(8);\n        var previousValue = 0;\n        var i = result.length - 1;\n        while (true) {\n            if ((codeword & 0x1) !== previousValue) {\n                previousValue = codeword & 0x1;\n                i--;\n                if (i < 0) {\n                    break;\n                }\n            }\n            result[i]++;\n            codeword >>= 1;\n        }\n        return result;\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n        if (codeword instanceof Int32Array) {\n            return this.getCodewordBucketNumber_Int32Array(codeword);\n        }\n        return this.getCodewordBucketNumber_number(codeword);\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n    };\n    PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n        var formatter = new Formatter_1.default();\n        // try (let formatter = new Formatter()) {\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            formatter.format('Row %2d: ', row);\n            for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                var barcodeValue = barcodeMatrix[row][column];\n                if (barcodeValue.getValue().length === 0) {\n                    formatter.format('        ', null);\n                }\n                else {\n                    formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                }\n            }\n            formatter.format('%n');\n        }\n        return formatter.toString();\n        // }\n    };\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n    return PDF417ScanningDecoder;\n}());\nexports[\"default\"] = PDF417ScanningDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9QREY0MTdTY2FubmluZ0RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLG1KQUF1QjtBQUN2RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVLQUFpQztBQUMzRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlKQUFpQjtBQUM5QztBQUNBLHdCQUF3QixtQkFBTyxDQUFDLG9LQUFzQjtBQUN0RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHNKQUFlO0FBQzNDLDBDQUEwQyxtQkFBTyxDQUFDLGtNQUFxQztBQUN2Rix3QkFBd0IsbUJBQU8sQ0FBQyw4SkFBbUI7QUFDbkQsOEJBQThCLG1CQUFPLENBQUMsMEtBQXlCO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLGdKQUFZO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLHdKQUFnQjtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQywwS0FBeUI7QUFDL0QsK0JBQStCLG1CQUFPLENBQUMsNEtBQTBCO0FBQ2pFO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaUpBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdDQUF3QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxtQ0FBbUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHNCQUFzQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQWdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsOENBQThDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0JBQWtCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQTRDO0FBQzlFLHlDQUF5QyxrREFBa0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4Q0FBOEMsZ0JBQWdCLGdFQUFnRTtBQUN2SyxrQ0FBa0MsNEJBQTRCO0FBQzlELDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxVQUFVO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxVQUFVO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSixVQUFVO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0EseUNBQXlDLG9DQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuQ2hlY2tzdW1FeGNlcHRpb247XG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkZvcm1hdEV4Y2VwdGlvbjtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Gb3JtYXRFeGNlcHRpb25cIik7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5Ob3RGb3VuZEV4Y2VwdGlvbjtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLmRldGVjdG9yLk1hdGhVdGlscztcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzXCIpO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcbnZhciBQREY0MTdDb21tb25fMSA9IHJlcXVpcmUoXCIuLi9QREY0MTdDb21tb25cIik7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlci5lYy5FcnJvckNvcnJlY3Rpb247XG52YXIgRXJyb3JDb3JyZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9lYy9FcnJvckNvcnJlY3Rpb25cIik7XG4vLyBsb2NhbFxudmFyIEJvdW5kaW5nQm94XzEgPSByZXF1aXJlKFwiLi9Cb3VuZGluZ0JveFwiKTtcbnZhciBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW5fMSA9IHJlcXVpcmUoXCIuL0RldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtblwiKTtcbnZhciBEZXRlY3Rpb25SZXN1bHRfMSA9IHJlcXVpcmUoXCIuL0RldGVjdGlvblJlc3VsdFwiKTtcbnZhciBEZXRlY3Rpb25SZXN1bHRDb2x1bW5fMSA9IHJlcXVpcmUoXCIuL0RldGVjdGlvblJlc3VsdENvbHVtblwiKTtcbnZhciBDb2Rld29yZF8xID0gcmVxdWlyZShcIi4vQ29kZXdvcmRcIik7XG52YXIgQmFyY29kZVZhbHVlXzEgPSByZXF1aXJlKFwiLi9CYXJjb2RlVmFsdWVcIik7XG52YXIgUERGNDE3Q29kZXdvcmREZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9QREY0MTdDb2Rld29yZERlY29kZXJcIik7XG52YXIgRGVjb2RlZEJpdFN0cmVhbVBhcnNlcl8xID0gcmVxdWlyZShcIi4vRGVjb2RlZEJpdFN0cmVhbVBhcnNlclwiKTtcbi8vIHV0aWxzXG52YXIgRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9Gb3JtYXR0ZXJcIik7XG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcbi8vIGltcG9ydCBqYXZhLnV0aWwuRm9ybWF0dGVyO1xuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuLyoqXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIFBERjQxN1NjYW5uaW5nRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQREY0MTdTY2FubmluZ0RlY29kZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBUT0RPIGRvbid0IHBhc3MgaW4gbWluQ29kZXdvcmRXaWR0aCBhbmQgbWF4Q29kZXdvcmRXaWR0aCwgcGFzcyBpbiBiYXJjb2RlIGNvbHVtbnMgZm9yIHN0YXJ0IGFuZCBzdG9wIHBhdHRlcm5cbiAgICAgKlxuICAgICAqIGNvbHVtbnMuIFRoYXQgd2F5IHdpZHRoIGNhbiBiZSBkZWR1Y3RlZCBmcm9tIHRoZSBwYXR0ZXJuIGNvbHVtbi5cbiAgICAgKiBUaGlzIGFwcHJvYWNoIGFsc28gYWxsb3dzIHRvIGRldGVjdCBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGJhcmNvZGUsIGUuZy4gaWYgYSBiYXIgdHlwZSAod2hpdGUgb3IgYmxhY2spIGlzIHdpZGVyXG4gICAgICogdGhhbiBpdCBzaG91bGQgYmUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2Nhbm5lciB1c2VkIGEgYmFkIGJsYWNrcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gQml0TWF0cml4XG4gICAgICogQHBhcmFtIGltYWdlXG4gICAgICogQHBhcmFtIFJlc3VsdFBvaW50XG4gICAgICogQHBhcmFtIGltYWdlVG9wTGVmdFxuICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAqIEBwYXJhbSBpbWFnZUJvdHRvbUxlZnRcbiAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgKiBAcGFyYW0gaW1hZ2VUb3BSaWdodFxuICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAqIEBwYXJhbSBpbWFnZUJvdHRvbVJpZ2h0XG4gICAgICogQHBhcmFtIGludFxuICAgICAqIEBwYXJhbSBtaW5Db2Rld29yZFdpZHRoXG4gICAgICogQHBhcmFtIGludFxuICAgICAqIEBwYXJhbSBtYXhDb2Rld29yZFdpZHRoXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICovXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94XzEuZGVmYXVsdChpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQpO1xuICAgICAgICB2YXIgbGVmdFJvd0luZGljYXRvckNvbHVtbiA9IG51bGw7XG4gICAgICAgIHZhciByaWdodFJvd0luZGljYXRvckNvbHVtbiA9IG51bGw7XG4gICAgICAgIHZhciBkZXRlY3Rpb25SZXN1bHQ7XG4gICAgICAgIGZvciAodmFyIGZpcnN0UGFzcyAvKmJvb2xlYW4qLyA9IHRydWU7OyBmaXJzdFBhc3MgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGltYWdlVG9wTGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGVmdFJvd0luZGljYXRvckNvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBpbWFnZVRvcExlZnQsIHRydWUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlVG9wUmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIGltYWdlVG9wUmlnaHQsIGZhbHNlLCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5tZXJnZShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdEJveCA9IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UGFzcyAmJiByZXN1bHRCb3ggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIChyZXN1bHRCb3guZ2V0TWluWSgpIDwgYm91bmRpbmdCb3guZ2V0TWluWSgpIHx8IHJlc3VsdEJveC5nZXRNYXhZKCkgPiBib3VuZGluZ0JveC5nZXRNYXhZKCkpKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmdCb3ggPSByZXN1bHRCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0Qm91bmRpbmdCb3goYm91bmRpbmdCb3gpO1xuICAgICAgICB2YXIgbWF4QmFyY29kZUNvbHVtbiA9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDE7XG4gICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oMCwgbGVmdFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4obWF4QmFyY29kZUNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICB2YXIgbGVmdFRvUmlnaHQgPSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uICE9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW5Db3VudCAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbkNvdW50IDw9IG1heEJhcmNvZGVDb2x1bW47IGJhcmNvZGVDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyY29kZUNvbHVtbiA9IGxlZnRUb1JpZ2h0ID8gYmFyY29kZUNvbHVtbkNvdW50IDogbWF4QmFyY29kZUNvbHVtbiAtIGJhcmNvZGVDb2x1bW5Db3VudDtcbiAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pICE9PSAvKiBudWxsICovIHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgdGhlIG9wcG9zaXRlIHJvdyBpbmRpY2F0b3IgY29sdW1uLCB3aGljaCBkb2Vzbid0IG5lZWQgdG8gYmUgZGVjb2RlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYmFyY29kZUNvbHVtbiA9PT0gMCB8fCBiYXJjb2RlQ29sdW1uID09PSBtYXhCYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbl8xLmRlZmF1bHQoYm91bmRpbmdCb3gsIGJhcmNvZGVDb2x1bW4gPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdENvbHVtbl8xLmRlZmF1bHQoYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uLCBkZXRlY3Rpb25SZXN1bHRDb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gLTE7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgLy8gVE9ETyBzdGFydCBhdCBhIHJvdyBmb3Igd2hpY2ggd2Uga25vdyB0aGUgc3RhcnQgcG9zaXRpb24sIHRoZW4gZGV0ZWN0IHVwd2FyZHMgYW5kIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICAgICAgICAgICAgZm9yICh2YXIgaW1hZ2VSb3cgLyppbnQqLyA9IGJvdW5kaW5nQm94LmdldE1pblkoKTsgaW1hZ2VSb3cgPD0gYm91bmRpbmdCb3guZ2V0TWF4WSgpOyBpbWFnZVJvdysrKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0U3RhcnRDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydENvbHVtbiA8IDAgfHwgc3RhcnRDb2x1bW4gPiBib3VuZGluZ0JveC5nZXRNYXhYKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhcnRDb2x1bW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IHByZXZpb3VzU3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZChpbWFnZSwgYm91bmRpbmdCb3guZ2V0TWluWCgpLCBib3VuZGluZ0JveC5nZXRNYXhYKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbi5zZXRDb2Rld29yZChpbWFnZVJvdywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIG1pbkNvZGV3b3JkV2lkdGggPSBNYXRoLm1pbihtaW5Db2Rld29yZFdpZHRoLCBjb2Rld29yZC5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29kZXdvcmRXaWR0aCA9IE1hdGgubWF4KG1heENvZGV3b3JkV2lkdGgsIGNvZGV3b3JkLmdldFdpZHRoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHQoZGV0ZWN0aW9uUmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgKiBAcGFyYW0gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgKi9cbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIubWVyZ2UgPSBmdW5jdGlvbiAobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pIHtcbiAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCAmJiByaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFyY29kZU1ldGFkYXRhID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJhcmNvZGVNZXRhZGF0YShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgIGlmIChiYXJjb2RlTWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3hfMS5kZWZhdWx0Lm1lcmdlKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uKSwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdEJvdW5kaW5nQm94KHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSk7XG4gICAgICAgIHJldHVybiBuZXcgRGV0ZWN0aW9uUmVzdWx0XzEuZGVmYXVsdChiYXJjb2RlTWV0YWRhdGEsIGJvdW5kaW5nQm94KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGljYXRvckNvbHVtblxuICAgICAqXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAqL1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChyb3dJbmRpY2F0b3JDb2x1bW4pIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChyb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvd0hlaWdodHMgPSByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Um93SGVpZ2h0cygpO1xuICAgICAgICBpZiAocm93SGVpZ2h0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4Um93SGVpZ2h0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1heChyb3dIZWlnaHRzKTtcbiAgICAgICAgdmFyIG1pc3NpbmdTdGFydFJvd3MgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm93SGVpZ2h0c18xID0gX192YWx1ZXMocm93SGVpZ2h0cyksIHJvd0hlaWdodHNfMV8xID0gcm93SGVpZ2h0c18xLm5leHQoKTsgIXJvd0hlaWdodHNfMV8xLmRvbmU7IHJvd0hlaWdodHNfMV8xID0gcm93SGVpZ2h0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSByb3dIZWlnaHRzXzFfMS52YWx1ZSAvKmludCovO1xuICAgICAgICAgICAgICAgIG1pc3NpbmdTdGFydFJvd3MgKz0gbWF4Um93SGVpZ2h0IC0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlaWdodHNfMV8xICYmICFyb3dIZWlnaHRzXzFfMS5kb25lICYmIChfYSA9IHJvd0hlaWdodHNfMS5yZXR1cm4pKSBfYS5jYWxsKHJvd0hlaWdodHNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHJvd0luZGljYXRvckNvbHVtbi5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgZm9yICh2YXIgcm93IC8qaW50Ki8gPSAwOyBtaXNzaW5nU3RhcnRSb3dzID4gMCAmJiBjb2Rld29yZHNbcm93XSA9PSBudWxsOyByb3crKykge1xuICAgICAgICAgICAgbWlzc2luZ1N0YXJ0Um93cy0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaXNzaW5nRW5kUm93cyA9IDA7XG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gcm93SGVpZ2h0cy5sZW5ndGggLSAxOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgICAgICAgIG1pc3NpbmdFbmRSb3dzICs9IG1heFJvd0hlaWdodCAtIHJvd0hlaWdodHNbcm93XTtcbiAgICAgICAgICAgIGlmIChyb3dIZWlnaHRzW3Jvd10gPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcm93IC8qaW50Ki8gPSBjb2Rld29yZHMubGVuZ3RoIC0gMTsgbWlzc2luZ0VuZFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdy0tKSB7XG4gICAgICAgICAgICBtaXNzaW5nRW5kUm93cy0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Qm91bmRpbmdCb3goKS5hZGRNaXNzaW5nUm93cyhtaXNzaW5nU3RhcnRSb3dzLCBtaXNzaW5nRW5kUm93cywgcm93SW5kaWNhdG9yQ29sdW1uLmlzTGVmdCgpKTtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRNYXggPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHZhbHVlc18xID0gX192YWx1ZXModmFsdWVzKSwgdmFsdWVzXzFfMSA9IHZhbHVlc18xLm5leHQoKTsgIXZhbHVlc18xXzEuZG9uZTsgdmFsdWVzXzFfMSA9IHZhbHVlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc18xXzEudmFsdWUgLyppbnQqLztcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNfMV8xICYmICF2YWx1ZXNfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVzXzEucmV0dXJuKSkgX2EuY2FsbCh2YWx1ZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgIH07XG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldEJhcmNvZGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbikge1xuICAgICAgICB2YXIgbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgKGxlZnRCYXJjb2RlTWV0YWRhdGEgPSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLmdldEJhcmNvZGVNZXRhZGF0YSgpKSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmlnaHRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgIGlmIChyaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmlnaHRCYXJjb2RlTWV0YWRhdGEgPSByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAhPT0gcmlnaHRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAmJlxuICAgICAgICAgICAgbGVmdEJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpICE9PSByaWdodEJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpICYmXG4gICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0QmFyY29kZU1ldGFkYXRhO1xuICAgIH07XG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbiA9IGZ1bmN0aW9uIChpbWFnZSwgYm91bmRpbmdCb3gsIHN0YXJ0UG9pbnQsIGxlZnRUb1JpZ2h0LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XG4gICAgICAgIHZhciByb3dJbmRpY2F0b3JDb2x1bW4gPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uXzEuZGVmYXVsdChib3VuZGluZ0JveCwgbGVmdFRvUmlnaHQpO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50ID0gaSA9PT0gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IE1hdGgudHJ1bmMoTWF0aC50cnVuYyhzdGFydFBvaW50LmdldFgoKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW1hZ2VSb3cgLyppbnQqLyA9IE1hdGgudHJ1bmMoTWF0aC50cnVuYyhzdGFydFBvaW50LmdldFkoKSkpOyBpbWFnZVJvdyA8PSBib3VuZGluZ0JveC5nZXRNYXhZKCkgJiZcbiAgICAgICAgICAgICAgICBpbWFnZVJvdyA+PSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93ICs9IGluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZChpbWFnZSwgMCwgaW1hZ2UuZ2V0V2lkdGgoKSwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdywgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kaWNhdG9yQ29sdW1uLnNldENvZGV3b3JkKGltYWdlUm93LCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gY29kZXdvcmQuZ2V0RW5kWCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dJbmRpY2F0b3JDb2x1bW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcbiAgICAgKiBAcGFyYW0gQmFyY29kZVZhbHVlXG4gICAgICogQHBhcmFtIHBhcmFtMlxuICAgICAqIEBwYXJhbSBwYXJhbTNcbiAgICAgKiBAcGFyYW0gYmFyY29kZU1hdHJpeFxuICAgICAqXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAqL1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RDb2Rld29yZENvdW50ID0gZnVuY3Rpb24gKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZU1hdHJpeCkge1xuICAgICAgICB2YXIgYmFyY29kZU1hdHJpeDAxID0gYmFyY29kZU1hdHJpeFswXVsxXTtcbiAgICAgICAgdmFyIG51bWJlck9mQ29kZXdvcmRzID0gYmFyY29kZU1hdHJpeDAxLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKlxuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpIC1cbiAgICAgICAgICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXROdW1iZXJPZkVDQ29kZVdvcmRzKGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlRUNMZXZlbCgpKTtcbiAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA8IDEgfHwgY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzID4gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyY29kZU1hdHJpeDAxLnNldFZhbHVlKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtYmVyT2ZDb2Rld29yZHNbMF0gIT09IGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcykge1xuICAgICAgICAgICAgLy8gVGhlIGNhbGN1bGF0ZWQgb25lIGlzIG1vcmUgcmVsaWFibGUgYXMgaXQgaXMgZGVyaXZlZCBmcm9tIHRoZSByb3cgaW5kaWNhdG9yIGNvbHVtbnNcbiAgICAgICAgICAgIGJhcmNvZGVNYXRyaXgwMS5zZXRWYWx1ZShjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgKi9cbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlRGVjb2RlclJlc3VsdCA9IGZ1bmN0aW9uIChkZXRlY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIGJhcmNvZGVNYXRyaXggPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlQmFyY29kZU1hdHJpeChkZXRlY3Rpb25SZXN1bHQpO1xuICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRDb3VudChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVNYXRyaXgpO1xuICAgICAgICB2YXIgZXJhc3VyZXMgLypDb2xsZWN0aW9uPEludGVnZXI+Ki8gPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IG5ldyBJbnQzMkFycmF5KGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSAqIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSk7XG4gICAgICAgIHZhciBhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QgPSAvKkxpc3Q8aW50W10+Ki8gW107XG4gICAgICAgIHZhciBhbWJpZ3VvdXNJbmRleGVzTGlzdCA9IC8qQ29sbGVjdGlvbjxJbnRlZ2VyPiovIG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciByb3cgLyppbnQqLyA9IDA7IHJvdyA8IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKTsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uICsgMV0uZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmRJbmRleCA9IHJvdyAqIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIGNvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcmFzdXJlcy5wdXNoKGNvZGV3b3JkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZEluZGV4XSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4ZXNMaXN0LnB1c2goY29kZXdvcmRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4VmFsdWVzTGlzdC5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhbWJpZ3VvdXNJbmRleFZhbHVlcyA9IG5ldyBBcnJheShhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhbWJpZ3VvdXNJbmRleFZhbHVlc1tpXSA9IGFtYmlndW91c0luZGV4VmFsdWVzTGlzdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzKGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlRUNMZXZlbCgpLCBjb2Rld29yZHMsIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQudG9JbnRBcnJheShlcmFzdXJlcyksIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQudG9JbnRBcnJheShhbWJpZ3VvdXNJbmRleGVzTGlzdCksIGFtYmlndW91c0luZGV4VmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGRlYWxzIHdpdGggdGhlIGZhY3QsIHRoYXQgdGhlIGRlY29kaW5nIHByb2Nlc3MgZG9lc24ndCBhbHdheXMgeWllbGQgYSBzaW5nbGUgbW9zdCBsaWtlbHkgdmFsdWUuIFRoZVxuICAgICAqIGN1cnJlbnQgZXJyb3IgY29ycmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGRlYWwgd2l0aCBlcmFzdXJlcyB2ZXJ5IHdlbGwsIHNvIGl0J3MgYmV0dGVyIHRvIHByb3ZpZGUgYSB2YWx1ZVxuICAgICAqIGZvciB0aGVzZSBhbWJpZ3VvdXMgY29kZXdvcmRzIGluc3RlYWQgb2YgdHJlYXRpbmcgaXQgYXMgYW4gZXJhc3VyZS4gVGhlIHByb2JsZW0gaXMgdGhhdCB3ZSBkb24ndCBrbm93IHdoaWNoIG9mXG4gICAgICogdGhlIGFtYmlndW91cyB2YWx1ZXMgdG8gY2hvb3NlLiBXZSB0cnkgZGVjb2RlIHVzaW5nIHRoZSBmaXJzdCB2YWx1ZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHVzZSBhbm90aGVyIG9mIHRoZVxuICAgICAqIGFtYmlndW91cyB2YWx1ZXMgYW5kIHRyeSB0byBkZWNvZGUgYWdhaW4uIFRoaXMgdXN1YWxseSBvbmx5IGhhcHBlbnMgb24gdmVyeSBoYXJkIHRvIHJlYWQgYW5kIGRlY29kZSBiYXJjb2RlcyxcbiAgICAgKiBzbyBkZWNvZGluZyB0aGUgbm9ybWFsIGJhcmNvZGVzIGlzIG5vdCBhZmZlY3RlZCBieSB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVyYXN1cmVBcnJheSBjb250YWlucyB0aGUgaW5kZXhlcyBvZiBlcmFzdXJlc1xuICAgICAqIEBwYXJhbSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5IHdpdGggdGhlIGluZGV4ZXMgdGhhdCBoYXZlIG1vcmUgdGhhbiBvbmUgbW9zdCBsaWtlbHkgdmFsdWVcbiAgICAgKiBAcGFyYW0gYW1iaWd1b3VzSW5kZXhWYWx1ZXMgdHdvIGRpbWVuc2lvbmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGFtYmlndW91cyB2YWx1ZXMuIFRoZSBmaXJzdCBkaW1lbnNpb24gbXVzdFxuICAgICAqIGJlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgYW1iaWd1b3VzSW5kZXhlcyBhcnJheVxuICAgICAqXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICovXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzID0gZnVuY3Rpb24gKGVjTGV2ZWwsIGNvZGV3b3JkcywgZXJhc3VyZUFycmF5LCBhbWJpZ3VvdXNJbmRleGVzLCBhbWJpZ3VvdXNJbmRleFZhbHVlcykge1xuICAgICAgICB2YXIgYW1iaWd1b3VzSW5kZXhDb3VudCA9IG5ldyBJbnQzMkFycmF5KGFtYmlndW91c0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHRyaWVzID0gMTAwO1xuICAgICAgICB3aGlsZSAodHJpZXMtLSA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRzW2FtYmlndW91c0luZGV4ZXNbaV1dID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV1bYW1iaWd1b3VzSW5kZXhDb3VudFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZGVjb2RlQ29kZXdvcmRzKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZUFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlZCA9IGVyciBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNJbmRleENvdW50W2ldIDwgYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleENvdW50W2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0LmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVCYXJjb2RlTWF0cml4ID0gZnVuY3Rpb24gKGRldGVjdGlvblJlc3VsdCkge1xuICAgICAgICB2YXIgZV8zLCBfYSwgZV80LCBfYjtcbiAgICAgICAgLy8gbGV0IGJhcmNvZGVNYXRyaXg6IEJhcmNvZGVWYWx1ZVtdW10gPVxuICAgICAgICAvLyBuZXcgQmFyY29kZVZhbHVlW2RldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKV1bZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMl07XG4gICAgICAgIHZhciBiYXJjb2RlTWF0cml4ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBcnJheShkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAyKTsgfSk7XG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW5fMSAvKmludCovID0gMDsgY29sdW1uXzEgPCBiYXJjb2RlTWF0cml4W3Jvd10ubGVuZ3RoOyBjb2x1bW5fMSsrKSB7XG4gICAgICAgICAgICAgICAgYmFyY29kZU1hdHJpeFtyb3ddW2NvbHVtbl8xXSA9IG5ldyBCYXJjb2RlVmFsdWVfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW5zKCkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRldGVjdGlvblJlc3VsdENvbHVtbiA9IF9kLnZhbHVlIC8qRGV0ZWN0aW9uUmVzdWx0Q29sdW1uKi87XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdENvbHVtbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzQgPSB2b2lkIDAsIF9fdmFsdWVzKGRldGVjdGlvblJlc3VsdENvbHVtbi5nZXRDb2Rld29yZHMoKSkpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gX2YudmFsdWUgLypDb2Rld29yZCovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IGJhcmNvZGVNYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBtb3JlIHJvd3MgdGhhbiB0aGUgYmFyY29kZSBtZXRhZGF0YSBhbGxvd3MgZm9yLCBpZ25vcmUgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXhbcm93TnVtYmVyXVtjb2x1bW5dLnNldFZhbHVlKGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFyY29kZU1hdHJpeDtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbiA9IGZ1bmN0aW9uIChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGJhcmNvZGVDb2x1bW4gPj0gMCAmJiBiYXJjb2RlQ29sdW1uIDw9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDE7XG4gICAgfTtcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0U3RhcnRDb2x1bW4gPSBmdW5jdGlvbiAoZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpIHtcbiAgICAgICAgdmFyIGVfNSwgX2E7XG4gICAgICAgIHZhciBvZmZzZXQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGNvZGV3b3JkID0gbnVsbDtcbiAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikuZ2V0Q29kZXdvcmROZWFyYnkoaW1hZ2VSb3cpO1xuICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gY29kZXdvcmQuZ2V0U3RhcnRYKCkgOiBjb2Rld29yZC5nZXRFbmRYKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmROZWFyYnkoaW1hZ2VSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2tpcHBlZENvbHVtbnMgPSAwO1xuICAgICAgICB3aGlsZSAoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiAtIG9mZnNldCkpIHtcbiAgICAgICAgICAgIGJhcmNvZGVDb2x1bW4gLT0gb2Zmc2V0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IChlXzUgPSB2b2lkIDAsIF9fdmFsdWVzKGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikuZ2V0Q29kZXdvcmRzKCkpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNSb3dDb2Rld29yZCA9IF9jLnZhbHVlIC8qQ29kZXdvcmQqLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93Q29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsZWZ0VG9SaWdodCA/IHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0RW5kWCgpIDogcHJldmlvdXNSb3dDb2Rld29yZC5nZXRTdGFydFgoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRDb2x1bW5zICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0RW5kWCgpIC0gcHJldmlvdXNSb3dDb2Rld29yZC5nZXRTdGFydFgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwcGVkQ29sdW1ucysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1pblgoKSA6IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1heFgoKTtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZCA9IGZ1bmN0aW9uIChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRTdGFydENvbHVtbihpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpO1xuICAgICAgICAvLyB3ZSB1c3VhbGx5IGtub3cgZmFpcmx5IGV4YWN0IG5vdyBob3cgbG9uZyBhIGNvZGV3b3JkIGlzLiBXZSBzaG91bGQgcHJvdmlkZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGV4cGVjdGVkIGxlbmd0aFxuICAgICAgICAvLyBhbmQgdHJ5IHRvIGFkanVzdCB0aGUgcmVhZCBwaXhlbHMsIGUuZy4gcmVtb3ZlIHNpbmdsZSBwaXhlbCBlcnJvcnMgb3IgdHJ5IHRvIGN1dCBvZmYgZXhjZWVkaW5nIHBpeGVscy5cbiAgICAgICAgLy8gbWluIGFuZCBtYXhDb2Rld29yZFdpZHRoIHNob3VsZCBub3QgYmUgdXNlZCBhcyB0aGV5IGFyZSBjYWxjdWxhdGVkIGZvciB0aGUgd2hvbGUgYmFyY29kZSBhbiBjYW4gYmUgaW5hY2N1cmF0ZVxuICAgICAgICAvLyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgdmFyIG1vZHVsZUJpdENvdW50ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1vZHVsZUJpdENvdW50KGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdyk7XG4gICAgICAgIGlmIChtb2R1bGVCaXRDb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kQ29sdW1uO1xuICAgICAgICB2YXIgY29kZXdvcmRCaXRDb3VudCA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgaWYgKGxlZnRUb1JpZ2h0KSB7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIGNvZGV3b3JkQml0Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcENvdW50ID0gbW9kdWxlQml0Q291bnRbaV07XG4gICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbaV0gPSBtb2R1bGVCaXRDb3VudFttb2R1bGVCaXRDb3VudC5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldID0gdG1wQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uIC0gY29kZXdvcmRCaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBjaGVjayBmb3Igd2lkdGggYW5kIGNvcnJlY3Rpb24gb2YgYmxhY2sgYW5kIHdoaXRlIGJhcnNcbiAgICAgICAgLy8gdXNlIHN0YXJ0IChhbmQgbWF5YmUgc3RvcCBwYXR0ZXJuKSB0byBkZXRlcm1pbmUgaWYgYmxhY2sgYmFycyBhcmUgd2lkZXIgdGhhbiB3aGl0ZSBiYXJzLiBJZiBzbywgYWRqdXN0LlxuICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgZG9uZSBvbmx5IGZvciBjb2Rld29yZHMgd2l0aCBhIGxvdCBtb3JlIHRoYW4gMTcgYml0cy5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmaXhlcyAxMC0xLnBuZywgd2hpY2ggaGFzIHdpZGUgYmxhY2sgYmFycyBhbmQgc21hbGwgd2hpdGUgYmFyc1xuICAgICAgICAvLyAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgLy8gICAgICAgIG1vZHVsZUJpdENvdW50W2ldLS07XG4gICAgICAgIC8vICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgIG1vZHVsZUJpdENvdW50W2ldKys7XG4gICAgICAgIC8vICAgICAgfVxuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vIFdlIGNvdWxkIGFsc28gdXNlIHRoZSB3aWR0aCBvZiBzdXJyb3VuZGluZyBjb2Rld29yZHMgZm9yIG1vcmUgYWNjdXJhdGUgcmVzdWx0cywgYnV0IHRoaXMgc2VlbXNcbiAgICAgICAgLy8gc3VmZmljaWVudCBmb3Igbm93XG4gICAgICAgIGlmICghUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNoZWNrQ29kZXdvcmRTa2V3KGNvZGV3b3JkQml0Q291bnQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB0cnkgdG8gdXNlIHRoZSBzdGFydFggYW5kIGVuZFggcG9zaXRpb24gb2YgdGhlIGNvZGV3b3JkIGluIHRoZSBzYW1lIGNvbHVtbiBpbiB0aGUgcHJldmlvdXMgcm93LFxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBiaXQgY291bnQgZnJvbSBpdCBhbmQgbm9ybWFsaXplIGl0IHRvIDguIFRoaXMgd291bGQgaGVscCB3aXRoIHNpbmdsZSBwaXhlbCBlcnJvcnMuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyXzEuZGVmYXVsdC5nZXREZWNvZGVkVmFsdWUobW9kdWxlQml0Q291bnQpO1xuICAgICAgICB2YXIgY29kZXdvcmQgPSBQREY0MTdDb21tb25fMS5kZWZhdWx0LmdldENvZGV3b3JkKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgIGlmIChjb2Rld29yZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29kZXdvcmRfMS5kZWZhdWx0KHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4sIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcihkZWNvZGVkVmFsdWUpLCBjb2Rld29yZCk7XG4gICAgfTtcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TW9kdWxlQml0Q291bnQgPSBmdW5jdGlvbiAoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KSB7XG4gICAgICAgIHZhciBpbWFnZUNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICB2YXIgbW9kdWxlQml0Q291bnQgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgdmFyIG1vZHVsZU51bWJlciA9IDA7XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHByZXZpb3VzUGl4ZWxWYWx1ZSA9IGxlZnRUb1JpZ2h0O1xuICAgICAgICB3aGlsZSAoKGxlZnRUb1JpZ2h0ID8gaW1hZ2VDb2x1bW4gPCBtYXhDb2x1bW4gOiBpbWFnZUNvbHVtbiA+PSBtaW5Db2x1bW4pICYmXG4gICAgICAgICAgICBtb2R1bGVOdW1iZXIgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaW1hZ2VDb2x1bW4sIGltYWdlUm93KSA9PT0gcHJldmlvdXNQaXhlbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlTnVtYmVyXSsrO1xuICAgICAgICAgICAgICAgIGltYWdlQ29sdW1uICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUGl4ZWxWYWx1ZSA9ICFwcmV2aW91c1BpeGVsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZU51bWJlciA9PT0gbW9kdWxlQml0Q291bnQubGVuZ3RoIHx8XG4gICAgICAgICAgICAoKGltYWdlQ29sdW1uID09PSAobGVmdFRvUmlnaHQgPyBtYXhDb2x1bW4gOiBtaW5Db2x1bW4pKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlciA9PT0gbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVCaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXROdW1iZXJPZkVDQ29kZVdvcmRzID0gZnVuY3Rpb24gKGJhcmNvZGVFQ0xldmVsKSB7XG4gICAgICAgIHJldHVybiAyIDw8IGJhcmNvZGVFQ0xldmVsO1xuICAgIH07XG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4gPSBmdW5jdGlvbiAoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgY29kZXdvcmRTdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcbiAgICAgICAgdmFyIGNvcnJlY3RlZFN0YXJ0Q29sdW1uID0gY29kZXdvcmRTdGFydENvbHVtbjtcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IGxlZnRUb1JpZ2h0ID8gLTEgOiAxO1xuICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgbm8gYmxhY2sgcGl4ZWxzIGJlZm9yZSB0aGUgc3RhcnQgY29sdW1uLiBJZiB0aGVyZSBhcmUsIHRoZW4gd2UgbmVlZCB0byBzdGFydCBlYXJsaWVyLlxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGxlZnRUb1JpZ2h0ID8gY29ycmVjdGVkU3RhcnRDb2x1bW4gPj0gbWluQ29sdW1uIDogY29ycmVjdGVkU3RhcnRDb2x1bW4gPCBtYXhDb2x1bW4pICYmXG4gICAgICAgICAgICAgICAgbGVmdFRvUmlnaHQgPT09IGltYWdlLmdldChjb3JyZWN0ZWRTdGFydENvbHVtbiwgaW1hZ2VSb3cpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvZGV3b3JkU3RhcnRDb2x1bW4gLSBjb3JyZWN0ZWRTdGFydENvbHVtbikgPiBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZFN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3JyZWN0ZWRTdGFydENvbHVtbiArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSAtaW5jcmVtZW50O1xuICAgICAgICAgICAgbGVmdFRvUmlnaHQgPSAhbGVmdFRvUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFN0YXJ0Q29sdW1uO1xuICAgIH07XG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNoZWNrQ29kZXdvcmRTa2V3ID0gZnVuY3Rpb24gKGNvZGV3b3JkU2l6ZSwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICByZXR1cm4gbWluQ29kZXdvcmRXaWR0aCAtIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUgPD0gY29kZXdvcmRTaXplICYmXG4gICAgICAgICAgICBjb2Rld29yZFNpemUgPD0gbWF4Q29kZXdvcmRXaWR0aCArIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbixcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICovXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZUNvZGV3b3JkcyA9IGZ1bmN0aW9uIChjb2Rld29yZHMsIGVjTGV2ZWwsIGVyYXN1cmVzKSB7XG4gICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bUVDQ29kZXdvcmRzID0gMSA8PCAoZWNMZXZlbCArIDEpO1xuICAgICAgICB2YXIgY29ycmVjdGVkRXJyb3JzQ291bnQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY29ycmVjdEVycm9ycyhjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci52ZXJpZnlDb2Rld29yZENvdW50KGNvZGV3b3JkcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAvLyBEZWNvZGUgdGhlIGNvZGV3b3Jkc1xuICAgICAgICB2YXIgZGVjb2RlclJlc3VsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMS5kZWZhdWx0LmRlY29kZShjb2Rld29yZHMsICcnICsgZWNMZXZlbCk7XG4gICAgICAgIGRlY29kZXJSZXN1bHQuc2V0RXJyb3JzQ29ycmVjdGVkKGNvcnJlY3RlZEVycm9yc0NvdW50KTtcbiAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcmFzdXJlcyhlcmFzdXJlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGVjb2RlclJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZS48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRzICAgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgKiBAcGFyYW0gZXJhc3VyZXMgcG9zaXRpb25zIG9mIGFueSBrbm93biBlcmFzdXJlc1xuICAgICAqIEBwYXJhbSBudW1FQ0NvZGV3b3JkcyBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMgdGhhdCBhcmUgYXZhaWxhYmxlIGluIGNvZGV3b3Jkc1xuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jb3JyZWN0RXJyb3JzID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgZXJhc3VyZXMsIG51bUVDQ29kZXdvcmRzKSB7XG4gICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsICYmXG4gICAgICAgICAgICBlcmFzdXJlcy5sZW5ndGggPiBudW1FQ0NvZGV3b3JkcyAvIDIgKyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VSUk9SUyB8fFxuICAgICAgICAgICAgbnVtRUNDb2Rld29yZHMgPCAwIHx8XG4gICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRUNfQ09ERVdPUkRTKSB7XG4gICAgICAgICAgICAvLyBUb28gbWFueSBlcnJvcnMgb3IgRUMgQ29kZXdvcmRzIGlzIGNvcnJ1cHRlZFxuICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0LmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbi5kZWNvZGUoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3JkcywgZXJhc3VyZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoYXQgYWxsIGlzIE9LIHdpdGggdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICovXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLnZlcmlmeUNvZGV3b3JkQ291bnQgPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3Jkcykge1xuICAgICAgICBpZiAoY29kZXdvcmRzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIC8vIENvZGV3b3JkIGFycmF5IHNpemUgc2hvdWxkIGJlIGF0IGxlYXN0IDQgYWxsb3dpbmcgZm9yXG4gICAgICAgICAgICAvLyBDb3VudCBDVywgQXQgbGVhc3Qgb25lIERhdGEgQ1csIEVycm9yIENvcnJlY3Rpb24gQ1csIEVycm9yIENvcnJlY3Rpb24gQ1dcbiAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZmlyc3QgY29kZXdvcmQsIHRoZSBTeW1ib2wgTGVuZ3RoIERlc2NyaXB0b3IsIHNoYWxsIGFsd2F5cyBlbmNvZGUgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhXG4gICAgICAgIC8vIGNvZGV3b3JkcyBpbiB0aGUgc3ltYm9sLCBpbmNsdWRpbmcgdGhlIFN5bWJvbCBMZW5ndGggRGVzY3JpcHRvciBpdHNlbGYsIGRhdGEgY29kZXdvcmRzIGFuZCBwYWRcbiAgICAgICAgLy8gY29kZXdvcmRzLCBidXQgZXhjbHVkaW5nIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG4gICAgICAgIHZhciBudW1iZXJPZkNvZGV3b3JkcyA9IGNvZGV3b3Jkc1swXTtcbiAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzID4gY29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3JkcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgLSA4IChBbGxvdyBmb3IgYXQgbGVhc3QgbGV2ZWwgMyBFcnJvciBDb3JyZWN0aW9uICg4IEVycm9yIENvZGV3b3JkcylcbiAgICAgICAgICAgIGlmIChudW1FQ0NvZGV3b3JkcyA8IGNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZHNbMF0gPSBjb2Rld29yZHMubGVuZ3RoIC0gbnVtRUNDb2Rld29yZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRCaXRDb3VudEZvckNvZGV3b3JkID0gZnVuY3Rpb24gKGNvZGV3b3JkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSAwO1xuICAgICAgICB2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKChjb2Rld29yZCAmIDB4MSkgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY29kZXdvcmQgJiAweDE7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaV0rKztcbiAgICAgICAgICAgIGNvZGV3b3JkID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIgPSBmdW5jdGlvbiAoY29kZXdvcmQpIHtcbiAgICAgICAgaWYgKGNvZGV3b3JkIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfSW50MzJBcnJheShjb2Rld29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfbnVtYmVyKGNvZGV3b3JkKTtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9udW1iZXIgPSBmdW5jdGlvbiAoY29kZXdvcmQpIHtcbiAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcihQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Qml0Q291bnRGb3JDb2Rld29yZChjb2Rld29yZCkpO1xuICAgIH07XG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldENvZGV3b3JkQnVja2V0TnVtYmVyX0ludDMyQXJyYXkgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIChtb2R1bGVCaXRDb3VudFswXSAtIG1vZHVsZUJpdENvdW50WzJdICsgbW9kdWxlQml0Q291bnRbNF0gLSBtb2R1bGVCaXRDb3VudFs2XSArIDkpICUgOTtcbiAgICB9O1xuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci50b1N0cmluZyA9IGZ1bmN0aW9uIChiYXJjb2RlTWF0cml4KSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyB0cnkgKGxldCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCkpIHtcbiAgICAgICAgZm9yICh2YXIgcm93IC8qaW50Ki8gPSAwOyByb3cgPCBiYXJjb2RlTWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJ1JvdyAlMmQ6ICcsIHJvdyk7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gLyppbnQqLyA9IDA7IGNvbHVtbiA8IGJhcmNvZGVNYXRyaXhbcm93XS5sZW5ndGg7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhcmNvZGVWYWx1ZSA9IGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW5dO1xuICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgICAgICAnLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyU0ZCglMmQpJywgYmFyY29kZVZhbHVlLmdldFZhbHVlKClbMF0sIGJhcmNvZGVWYWx1ZS5nZXRDb25maWRlbmNlKGJhcmNvZGVWYWx1ZS5nZXRWYWx1ZSgpWzBdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIH1cbiAgICB9O1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFID0gMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FUlJPUlMgPSAzO1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VDX0NPREVXT1JEUyA9IDUxMjtcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbiA9IG5ldyBFcnJvckNvcnJlY3Rpb25fMS5kZWZhdWx0KCk7XG4gICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = __webpack_require__(/*! ../../../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar ModulusPoly_1 = __webpack_require__(/*! ./ModulusPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js\");\nvar ModulusGF_1 = __webpack_require__(/*! ./ModulusGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\nvar ErrorCorrection = /** @class */ (function () {\n    function ErrorCorrection() {\n        this.field = ModulusGF_1.default.PDF417_GF;\n    }\n    /**\n     * @param received received codewords\n     * @param numECCodewords number of those codewords used for EC\n     * @param erasures location of erasures\n     * @return number of errors\n     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n     */\n    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n        var e_1, _a;\n        var poly = new ModulusPoly_1.default(this.field, received);\n        var S = new Int32Array(numECCodewords);\n        var error = false;\n        for (var i /*int*/ = numECCodewords; i > 0; i--) {\n            var evaluation = poly.evaluateAt(this.field.exp(i));\n            S[numECCodewords - i] = evaluation;\n            if (evaluation !== 0) {\n                error = true;\n            }\n        }\n        if (!error) {\n            return 0;\n        }\n        var knownErrors = this.field.getOne();\n        if (erasures != null) {\n            try {\n                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n                    var erasure = erasures_1_1.value;\n                    var b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        var syndrome = new ModulusPoly_1.default(this.field, S);\n        // syndrome = syndrome.multiply(knownErrors);\n        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n        var sigma = sigmaOmega[0];\n        var omega = sigmaOmega[1];\n        // sigma = sigma.multiply(knownErrors);\n        var errorLocations = this.findErrorLocations(sigma);\n        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n        for (var i /*int*/ = 0; i < errorLocations.length; i++) {\n            var position = received.length - 1 - this.field.log(errorLocations[i]);\n            if (position < 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n        }\n        return errorLocations.length;\n    };\n    /**\n     *\n     * @param ModulusPoly\n     * @param a\n     * @param ModulusPoly\n     * @param b\n     * @param int\n     * @param R\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n        // Assume a's degree is >= b's\n        if (a.getDegree() < b.getDegree()) {\n            var temp = a;\n            a = b;\n            b = temp;\n        }\n        var rLast = a;\n        var r = b;\n        var tLast = this.field.getZero();\n        var t = this.field.getOne();\n        // Run Euclidean algorithm until r's degree is less than R/2\n        while (r.getDegree() >= Math.round(R / 2)) {\n            var rLastLast = rLast;\n            var tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\n            if (rLast.isZero()) {\n                // Oops, Euclidean algorithm already terminated?\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            r = rLastLast;\n            var q = this.field.getZero();\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n            var dltInverse = this.field.inverse(denominatorLeadingTerm);\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                var degreeDiff = r.getDegree() - rLast.getDegree();\n                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n            }\n            t = q.multiply(tLast).subtract(tLastLast).negative();\n        }\n        var sigmaTildeAtZero = t.getCoefficient(0);\n        if (sigmaTildeAtZero === 0) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        var inverse = this.field.inverse(sigmaTildeAtZero);\n        var sigma = t.multiply(inverse);\n        var omega = r.multiply(inverse);\n        return [sigma, omega];\n    };\n    /**\n     *\n     * @param errorLocator\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n        // This is a direct application of Chien's search\n        var numErrors = errorLocator.getDegree();\n        var result = new Int32Array(numErrors);\n        var e = 0;\n        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n            if (errorLocator.evaluateAt(i) === 0) {\n                result[e] = this.field.inverse(i);\n                e++;\n            }\n        }\n        if (e !== numErrors) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return result;\n    };\n    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n        var errorLocatorDegree = errorLocator.getDegree();\n        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n            formalDerivativeCoefficients[errorLocatorDegree - i] =\n                this.field.multiply(i, errorLocator.getCoefficient(i));\n        }\n        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);\n        // This is directly applying Forney's Formula\n        var s = errorLocations.length;\n        var result = new Int32Array(s);\n        for (var i /*int*/ = 0; i < s; i++) {\n            var xiInverse = this.field.inverse(errorLocations[i]);\n            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n            result[i] = this.field.multiply(numerator, denominator);\n        }\n        return result;\n    };\n    return ErrorCorrection;\n}());\nexports[\"default\"] = ErrorCorrection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9FcnJvckNvcnJlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDBKQUE0QjtBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBZTtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxxSkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixvQkFBb0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQ0FBMkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9FcnJvckNvcnJlY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuZWM7XG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5DaGVja3N1bUV4Y2VwdGlvbjtcbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xudmFyIE1vZHVsdXNQb2x5XzEgPSByZXF1aXJlKFwiLi9Nb2R1bHVzUG9seVwiKTtcbnZhciBNb2R1bHVzR0ZfMSA9IHJlcXVpcmUoXCIuL01vZHVsdXNHRlwiKTtcbi8qKlxuICogPHA+UERGNDE3IGVycm9yIGNvcnJlY3Rpb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICpcbiAqIDxwPlRoaXMgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVlZCVFMiU4MCU5M1NvbG9tb25fZXJyb3JfY29ycmVjdGlvbiNFeGFtcGxlXCI+ZXhhbXBsZTwvYT5cbiAqIGlzIHF1aXRlIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBhbGdvcml0aG0uPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLlJlZWRTb2xvbW9uRGVjb2RlclxuICovXG52YXIgRXJyb3JDb3JyZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IE1vZHVsdXNHRl8xLmRlZmF1bHQuUERGNDE3X0dGO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZWQgcmVjZWl2ZWQgY29kZXdvcmRzXG4gICAgICogQHBhcmFtIG51bUVDQ29kZXdvcmRzIG51bWJlciBvZiB0aG9zZSBjb2Rld29yZHMgdXNlZCBmb3IgRUNcbiAgICAgKiBAcGFyYW0gZXJhc3VyZXMgbG9jYXRpb24gb2YgZXJhc3VyZXNcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcnJvcnNcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9ycyBjYW5ub3QgYmUgY29ycmVjdGVkLCBtYXliZSBiZWNhdXNlIG9mIHRvbyBtYW55IGVycm9yc1xuICAgICAqL1xuICAgIEVycm9yQ29ycmVjdGlvbi5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlY2VpdmVkLCBudW1FQ0NvZGV3b3JkcywgZXJhc3VyZXMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBwb2x5ID0gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdCh0aGlzLmZpZWxkLCByZWNlaXZlZCk7XG4gICAgICAgIHZhciBTID0gbmV3IEludDMyQXJyYXkobnVtRUNDb2Rld29yZHMpO1xuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gbnVtRUNDb2Rld29yZHM7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBldmFsdWF0aW9uID0gcG9seS5ldmFsdWF0ZUF0KHRoaXMuZmllbGQuZXhwKGkpKTtcbiAgICAgICAgICAgIFNbbnVtRUNDb2Rld29yZHMgLSBpXSA9IGV2YWx1YXRpb247XG4gICAgICAgICAgICBpZiAoZXZhbHVhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIga25vd25FcnJvcnMgPSB0aGlzLmZpZWxkLmdldE9uZSgpO1xuICAgICAgICBpZiAoZXJhc3VyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlcmFzdXJlc18xID0gX192YWx1ZXMoZXJhc3VyZXMpLCBlcmFzdXJlc18xXzEgPSBlcmFzdXJlc18xLm5leHQoKTsgIWVyYXN1cmVzXzFfMS5kb25lOyBlcmFzdXJlc18xXzEgPSBlcmFzdXJlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJhc3VyZSA9IGVyYXN1cmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmZpZWxkLmV4cChyZWNlaXZlZC5sZW5ndGggLSAxIC0gZXJhc3VyZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCAoMSAtIGJ4KSB0ZXJtOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IG5ldyBNb2R1bHVzUG9seV8xLmRlZmF1bHQodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoW3RoaXMuZmllbGQuc3VidHJhY3QoMCwgYiksIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGtub3duRXJyb3JzID0ga25vd25FcnJvcnMubXVsdGlwbHkodGVybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcmFzdXJlc18xXzEgJiYgIWVyYXN1cmVzXzFfMS5kb25lICYmIChfYSA9IGVyYXN1cmVzXzEucmV0dXJuKSkgX2EuY2FsbChlcmFzdXJlc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzeW5kcm9tZSA9IG5ldyBNb2R1bHVzUG9seV8xLmRlZmF1bHQodGhpcy5maWVsZCwgUyk7XG4gICAgICAgIC8vIHN5bmRyb21lID0gc3luZHJvbWUubXVsdGlwbHkoa25vd25FcnJvcnMpO1xuICAgICAgICB2YXIgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChudW1FQ0NvZGV3b3JkcywgMSksIHN5bmRyb21lLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgIHZhciBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XG4gICAgICAgIHZhciBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XG4gICAgICAgIC8vIHNpZ21hID0gc2lnbWEubXVsdGlwbHkoa25vd25FcnJvcnMpO1xuICAgICAgICB2YXIgZXJyb3JMb2NhdGlvbnMgPSB0aGlzLmZpbmRFcnJvckxvY2F0aW9ucyhzaWdtYSk7XG4gICAgICAgIHZhciBlcnJvck1hZ25pdHVkZXMgPSB0aGlzLmZpbmRFcnJvck1hZ25pdHVkZXMob21lZ2EsIHNpZ21hLCBlcnJvckxvY2F0aW9ucyk7XG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcmVjZWl2ZWQubGVuZ3RoIC0gMSAtIHRoaXMuZmllbGQubG9nKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjZWl2ZWRbcG9zaXRpb25dID0gdGhpcy5maWVsZC5zdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XG4gICAgICogQHBhcmFtIGFcbiAgICAgKiBAcGFyYW0gTW9kdWx1c1BvbHlcbiAgICAgKiBAcGFyYW0gYlxuICAgICAqIEBwYXJhbSBpbnRcbiAgICAgKiBAcGFyYW0gUlxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgKi9cbiAgICBFcnJvckNvcnJlY3Rpb24ucHJvdG90eXBlLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobSA9IGZ1bmN0aW9uIChhLCBiLCBSKSB7XG4gICAgICAgIC8vIEFzc3VtZSBhJ3MgZGVncmVlIGlzID49IGInc1xuICAgICAgICBpZiAoYS5nZXREZWdyZWUoKSA8IGIuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJMYXN0ID0gYTtcbiAgICAgICAgdmFyIHIgPSBiO1xuICAgICAgICB2YXIgdExhc3QgPSB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmZpZWxkLmdldE9uZSgpO1xuICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gTWF0aC5yb3VuZChSIC8gMikpIHtcbiAgICAgICAgICAgIHZhciByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgIHZhciB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcbiAgICAgICAgICAgIGlmIChyTGFzdC5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgICAgdmFyIGRsdEludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSByTGFzdC5nZXREZWdyZWUoKSAmJiAhci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWdyZWVEaWZmID0gci5nZXREZWdyZWUoKSAtIHJMYXN0LmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgcSA9IHEuYWRkKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIHIgPSByLnN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IHEubXVsdGlwbHkodExhc3QpLnN1YnRyYWN0KHRMYXN0TGFzdCkubmVnYXRpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgIGlmIChzaWdtYVRpbGRlQXRaZXJvID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKHNpZ21hVGlsZGVBdFplcm8pO1xuICAgICAgICB2YXIgc2lnbWEgPSB0Lm11bHRpcGx5KGludmVyc2UpO1xuICAgICAgICB2YXIgb21lZ2EgPSByLm11bHRpcGx5KGludmVyc2UpO1xuICAgICAgICByZXR1cm4gW3NpZ21hLCBvbWVnYV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvckxvY2F0b3JcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICovXG4gICAgRXJyb3JDb3JyZWN0aW9uLnByb3RvdHlwZS5maW5kRXJyb3JMb2NhdGlvbnMgPSBmdW5jdGlvbiAoZXJyb3JMb2NhdG9yKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcbiAgICAgICAgdmFyIG51bUVycm9ycyA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KG51bUVycm9ycyk7XG4gICAgICAgIHZhciBlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMTsgaSA8IHRoaXMuZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVycm9yTG9jYXRvci5ldmFsdWF0ZUF0KGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VdID0gdGhpcy5maWVsZC5pbnZlcnNlKGkpO1xuICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZSAhPT0gbnVtRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFcnJvckNvcnJlY3Rpb24ucHJvdG90eXBlLmZpbmRFcnJvck1hZ25pdHVkZXMgPSBmdW5jdGlvbiAoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRvciwgZXJyb3JMb2NhdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9yTG9jYXRvckRlZ3JlZSA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgdmFyIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShlcnJvckxvY2F0b3JEZWdyZWUpO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAxOyBpIDw9IGVycm9yTG9jYXRvckRlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzW2Vycm9yTG9jYXRvckRlZ3JlZSAtIGldID1cbiAgICAgICAgICAgICAgICB0aGlzLmZpZWxkLm11bHRpcGx5KGksIGVycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hbERlcml2YXRpdmUgPSBuZXcgTW9kdWx1c1BvbHlfMS5kZWZhdWx0KHRoaXMuZmllbGQsIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHMpO1xuICAgICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgICAgdmFyIHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShzKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhpSW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCBlcnJvckV2YWx1YXRvci5ldmFsdWF0ZUF0KHhpSW52ZXJzZSkpO1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gdGhpcy5maWVsZC5pbnZlcnNlKGZvcm1hbERlcml2YXRpdmUuZXZhbHVhdGVBdCh4aUludmVyc2UpKTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckNvcnJlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb3JyZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ArithmeticException_1 = __webpack_require__(/*! ../../../ArithmeticException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js\");\nvar ModulusBase = /** @class */ (function () {\n    function ModulusBase() {\n    }\n    ModulusBase.prototype.add = function (a, b) {\n        return (a + b) % this.modulus;\n    };\n    ModulusBase.prototype.subtract = function (a, b) {\n        return (this.modulus + a - b) % this.modulus;\n    };\n    ModulusBase.prototype.exp = function (a) {\n        return this.expTable[a];\n    };\n    ModulusBase.prototype.log = function (a) {\n        if (a === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return this.logTable[a];\n    };\n    ModulusBase.prototype.inverse = function (a) {\n        if (a === 0) {\n            throw new ArithmeticException_1.default();\n        }\n        return this.expTable[this.modulus - this.logTable[a] - 1];\n    };\n    ModulusBase.prototype.multiply = function (a, b) {\n        if (a === 0 || b === 0) {\n            return 0;\n        }\n        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];\n    };\n    ModulusBase.prototype.getSize = function () {\n        return this.modulus;\n    };\n    ModulusBase.prototype.equals = function (o) {\n        return o === this;\n    };\n    return ModulusBase;\n}());\nexports[\"default\"] = ModulusBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzQmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyx3S0FBbUM7QUFDNUUsNEJBQTRCLG1CQUFPLENBQUMsOEpBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3BkZjQxNy9kZWNvZGVyL2VjL01vZHVsdXNCYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbnZhciBBcml0aG1ldGljRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vQXJpdGhtZXRpY0V4Y2VwdGlvblwiKTtcbnZhciBNb2R1bHVzQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2R1bHVzQmFzZSgpIHtcbiAgICB9XG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSArIGIpICUgdGhpcy5tb2R1bHVzO1xuICAgIH07XG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZHVsdXMgKyBhIC0gYikgJSB0aGlzLm1vZHVsdXM7XG4gICAgfTtcbiAgICBNb2R1bHVzQmFzZS5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgfTtcbiAgICBNb2R1bHVzQmFzZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gICAgfTtcbiAgICBNb2R1bHVzQmFzZS5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLm1vZHVsdXMgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XG4gICAgfTtcbiAgICBNb2R1bHVzQmFzZS5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVsodGhpcy5sb2dUYWJsZVthXSArIHRoaXMubG9nVGFibGVbYl0pICUgKHRoaXMubW9kdWx1cyAtIDEpXTtcbiAgICB9O1xuICAgIE1vZHVsdXNCYXNlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bHVzO1xuICAgIH07XG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvID09PSB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZHVsdXNCYXNlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsdXNCYXNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2012 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = __webpack_require__(/*! ../../PDF417Common */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js\");\nvar ModulusPoly_1 = __webpack_require__(/*! ./ModulusPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ModulusBase_1 = __webpack_require__(/*! ./ModulusBase */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js\");\n/**\n * <p>A field based on powers of a generator integer, modulo some modulus.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.GenericGF\n */\nvar ModulusGF = /** @class */ (function (_super) {\n    __extends(ModulusGF, _super);\n    // private /*final*/ modulus: /*int*/ number;\n    function ModulusGF(modulus, generator) {\n        var _this = _super.call(this) || this;\n        _this.modulus = modulus;\n        _this.expTable = new Int32Array(modulus);\n        _this.logTable = new Int32Array(modulus);\n        var x = /*int*/ 1;\n        for (var i /*int*/ = 0; i < modulus; i++) {\n            _this.expTable[i] = x;\n            x = (x * generator) % modulus;\n        }\n        for (var i /*int*/ = 0; i < modulus - 1; i++) {\n            _this.logTable[_this.expTable[i]] = i;\n        }\n        // logTable[0] == 0 but this should never be used\n        _this.zero = new ModulusPoly_1.default(_this, new Int32Array([0]));\n        _this.one = new ModulusPoly_1.default(_this, new Int32Array([1]));\n        return _this;\n    }\n    ModulusGF.prototype.getZero = function () {\n        return this.zero;\n    };\n    ModulusGF.prototype.getOne = function () {\n        return this.one;\n    };\n    ModulusGF.prototype.buildMonomial = function (degree, coefficient) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return this.zero;\n        }\n        var coefficients = new Int32Array(degree + 1);\n        coefficients[0] = coefficient;\n        return new ModulusPoly_1.default(this, coefficients);\n    };\n    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common_1.default.NUMBER_OF_CODEWORDS, 3);\n    return ModulusGF;\n}(ModulusBase_1.default));\nexports[\"default\"] = ModulusGF;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzR0YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0pBQW9CO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLHlKQUFlO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLHdLQUFtQztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RlY29kZXIvZWMvTW9kdWx1c0dGLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlci5lYztcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5QREY0MTdDb21tb247XG52YXIgUERGNDE3Q29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vUERGNDE3Q29tbW9uXCIpO1xudmFyIE1vZHVsdXNQb2x5XzEgPSByZXF1aXJlKFwiLi9Nb2R1bHVzUG9seVwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgTW9kdWx1c0Jhc2VfMSA9IHJlcXVpcmUoXCIuL01vZHVsdXNCYXNlXCIpO1xuLyoqXG4gKiA8cD5BIGZpZWxkIGJhc2VkIG9uIHBvd2VycyBvZiBhIGdlbmVyYXRvciBpbnRlZ2VyLCBtb2R1bG8gc29tZSBtb2R1bHVzLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5HZW5lcmljR0ZcbiAqL1xudmFyIE1vZHVsdXNHRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9kdWx1c0dGLCBfc3VwZXIpO1xuICAgIC8vIHByaXZhdGUgLypmaW5hbCovIG1vZHVsdXM6IC8qaW50Ki8gbnVtYmVyO1xuICAgIGZ1bmN0aW9uIE1vZHVsdXNHRihtb2R1bHVzLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubW9kdWx1cyA9IG1vZHVsdXM7XG4gICAgICAgIF90aGlzLmV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgIF90aGlzLmxvZ1RhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XG4gICAgICAgIHZhciB4ID0gLyppbnQqLyAxO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWx1czsgaSsrKSB7XG4gICAgICAgICAgICBfdGhpcy5leHBUYWJsZVtpXSA9IHg7XG4gICAgICAgICAgICB4ID0gKHggKiBnZW5lcmF0b3IpICUgbW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWx1cyAtIDE7IGkrKykge1xuICAgICAgICAgICAgX3RoaXMubG9nVGFibGVbX3RoaXMuZXhwVGFibGVbaV1dID0gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgIF90aGlzLnplcm8gPSBuZXcgTW9kdWx1c1BvbHlfMS5kZWZhdWx0KF90aGlzLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgX3RoaXMub25lID0gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdChfdGhpcywgbmV3IEludDMyQXJyYXkoWzFdKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9kdWx1c0dGLnByb3RvdHlwZS5nZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgIH07XG4gICAgTW9kdWx1c0dGLnByb3RvdHlwZS5nZXRPbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICB9O1xuICAgIE1vZHVsdXNHRi5wcm90b3R5cGUuYnVpbGRNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZGVncmVlICsgMSk7XG4gICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdCh0aGlzLCBjb2VmZmljaWVudHMpO1xuICAgIH07XG4gICAgTW9kdWx1c0dGLlBERjQxN19HRiA9IG5ldyBNb2R1bHVzR0YoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5OVU1CRVJfT0ZfQ09ERVdPUkRTLCAzKTtcbiAgICByZXR1cm4gTW9kdWx1c0dGO1xufShNb2R1bHVzQmFzZV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsdXNHRjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package com.google.zxing.pdf417.decoder.ec;\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar System_1 = __webpack_require__(/*! ../../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\n/**\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.GenericGFPoly\n */\nvar ModulusPoly = /** @class */ (function () {\n    function ModulusPoly(field, coefficients) {\n        if (coefficients.length === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        this.field = field;\n        var coefficientsLength = /*int*/ coefficients.length;\n        if (coefficientsLength > 1 && coefficients[0] === 0) {\n            // Leading term must be non-zero for anything except the constant polynomial \"0\"\n            var firstNonZero = /*int*/ 1;\n            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                firstNonZero++;\n            }\n            if (firstNonZero === coefficientsLength) {\n                this.coefficients = new Int32Array([0]);\n            }\n            else {\n                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n            }\n        }\n        else {\n            this.coefficients = coefficients;\n        }\n    }\n    ModulusPoly.prototype.getCoefficients = function () {\n        return this.coefficients;\n    };\n    /**\n     * @return degree of this polynomial\n     */\n    ModulusPoly.prototype.getDegree = function () {\n        return this.coefficients.length - 1;\n    };\n    /**\n     * @return true iff this polynomial is the monomial \"0\"\n     */\n    ModulusPoly.prototype.isZero = function () {\n        return this.coefficients[0] === 0;\n    };\n    /**\n     * @return coefficient of x^degree term in this polynomial\n     */\n    ModulusPoly.prototype.getCoefficient = function (degree) {\n        return this.coefficients[this.coefficients.length - 1 - degree];\n    };\n    /**\n     * @return evaluation of this polynomial at a given point\n     */\n    ModulusPoly.prototype.evaluateAt = function (a) {\n        var e_1, _a;\n        if (a === 0) {\n            // Just return the x^0 coefficient\n            return this.getCoefficient(0);\n        }\n        if (a === 1) {\n            // Just the sum of the coefficients\n            var sum = /*int*/ 0;\n            try {\n                for (var _b = __values(this.coefficients), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var coefficient = _c.value /*int*/;\n                    sum = this.field.add(sum, coefficient);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return sum;\n        }\n        var result = /*int*/ this.coefficients[0];\n        var size = /*int*/ this.coefficients.length;\n        for (var i /*int*/ = 1; i < size; i++) {\n            result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);\n        }\n        return result;\n    };\n    ModulusPoly.prototype.add = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');\n        }\n        if (this.isZero()) {\n            return other;\n        }\n        if (other.isZero()) {\n            return this;\n        }\n        var smallerCoefficients = this.coefficients;\n        var largerCoefficients = other.coefficients;\n        if (smallerCoefficients.length > largerCoefficients.length) {\n            var temp = smallerCoefficients;\n            smallerCoefficients = largerCoefficients;\n            largerCoefficients = temp;\n        }\n        var sumDiff = new Int32Array(largerCoefficients.length);\n        var lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;\n        // Copy high-order terms only found in higher-degree polynomial's coefficients\n        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n        for (var i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {\n            sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n        }\n        return new ModulusPoly(this.field, sumDiff);\n    };\n    ModulusPoly.prototype.subtract = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');\n        }\n        if (other.isZero()) {\n            return this;\n        }\n        return this.add(other.negative());\n    };\n    ModulusPoly.prototype.multiply = function (other) {\n        if (other instanceof ModulusPoly) {\n            return this.multiplyOther(other);\n        }\n        return this.multiplyScalar(other);\n    };\n    ModulusPoly.prototype.multiplyOther = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');\n        }\n        if (this.isZero() || other.isZero()) {\n            // return this.field.getZero();\n            return new ModulusPoly(this.field, new Int32Array([0]));\n        }\n        var aCoefficients = this.coefficients;\n        var aLength = /*int*/ aCoefficients.length;\n        var bCoefficients = other.coefficients;\n        var bLength = /*int*/ bCoefficients.length;\n        var product = new Int32Array(aLength + bLength - 1);\n        for (var i /*int*/ = 0; i < aLength; i++) {\n            var aCoeff = /*int*/ aCoefficients[i];\n            for (var j /*int*/ = 0; j < bLength; j++) {\n                product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n            }\n        }\n        return new ModulusPoly(this.field, product);\n    };\n    ModulusPoly.prototype.negative = function () {\n        var size = /*int*/ this.coefficients.length;\n        var negativeCoefficients = new Int32Array(size);\n        for (var i /*int*/ = 0; i < size; i++) {\n            negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);\n        }\n        return new ModulusPoly(this.field, negativeCoefficients);\n    };\n    ModulusPoly.prototype.multiplyScalar = function (scalar) {\n        if (scalar === 0) {\n            return new ModulusPoly(this.field, new Int32Array([0]));\n        }\n        if (scalar === 1) {\n            return this;\n        }\n        var size = /*int*/ this.coefficients.length;\n        var product = new Int32Array(size);\n        for (var i /*int*/ = 0; i < size; i++) {\n            product[i] = this.field.multiply(this.coefficients[i], scalar);\n        }\n        return new ModulusPoly(this.field, product);\n    };\n    ModulusPoly.prototype.multiplyByMonomial = function (degree, coefficient) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return new ModulusPoly(this.field, new Int32Array([0]));\n        }\n        var size = /*int*/ this.coefficients.length;\n        var product = new Int32Array(size + degree);\n        for (var i /*int*/ = 0; i < size; i++) {\n            product[i] = this.field.multiply(this.coefficients[i], coefficient);\n        }\n        return new ModulusPoly(this.field, product);\n    };\n    /*\n    ModulusPoly[] divide(other: ModulusPoly) {\n      if (!field.equals(other.field)) {\n        throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n      }\n      if (other.isZero()) {\n        throw new IllegalArgumentException(\"Divide by 0\");\n      }\n  \n      let quotient: ModulusPoly = field.getZero();\n      let remainder: ModulusPoly = this;\n  \n      let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());\n      let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);\n  \n      while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n        let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();\n        let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n        let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);\n        let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);\n        quotient = quotient.add(iterationQuotient);\n        remainder = remainder.subtract(term);\n      }\n  \n      return new ModulusPoly[] { quotient, remainder };\n    }\n    */\n    // @Override\n    ModulusPoly.prototype.toString = function () {\n        var result = new StringBuilder_1.default( /*8 * this.getDegree()*/); // dynamic string size in JS\n        for (var degree /*int*/ = this.getDegree(); degree >= 0; degree--) {\n            var coefficient = /*int*/ this.getCoefficient(degree);\n            if (coefficient !== 0) {\n                if (coefficient < 0) {\n                    result.append(' - ');\n                    coefficient = -coefficient;\n                }\n                else {\n                    if (result.length() > 0) {\n                        result.append(' + ');\n                    }\n                }\n                if (degree === 0 || coefficient !== 1) {\n                    result.append(coefficient);\n                }\n                if (degree !== 0) {\n                    if (degree === 1) {\n                        result.append('x');\n                    }\n                    else {\n                        result.append('x^');\n                        result.append(degree);\n                    }\n                }\n            }\n        }\n        return result.toString();\n    };\n    return ModulusPoly;\n}());\nexports[\"default\"] = ModulusPoly;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzUG9seS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLHdLQUFtQztBQUM1RSxlQUFlLG1CQUFPLENBQUMsOElBQXNCO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLDRKQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzUG9seS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlci5lYztcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9TeXN0ZW1cIik7XG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbi8qKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGUG9seVxuICovXG52YXIgTW9kdWx1c1BvbHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kdWx1c1BvbHkoZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgICAgICBpZiAoY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHZhciBjb2VmZmljaWVudHNMZW5ndGggPSAvKmludCovIGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChjb2VmZmljaWVudHNMZW5ndGggPiAxICYmIGNvZWZmaWNpZW50c1swXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9uWmVybyA9IC8qaW50Ki8gMTtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoY29lZmZpY2llbnRzTGVuZ3RoIC0gZmlyc3ROb25aZXJvKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb2VmZmljaWVudHMsIGZpcnN0Tm9uWmVybywgdGhpcy5jb2VmZmljaWVudHMsIDAsIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcbiAgICAgKi9cbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuZ2V0RGVncmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhpcyBwb2x5bm9taWFsIGlzIHRoZSBtb25vbWlhbCBcIjBcIlxuICAgICAqL1xuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1swXSA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gY29lZmZpY2llbnQgb2YgeF5kZWdyZWUgdGVybSBpbiB0aGlzIHBvbHlub21pYWxcbiAgICAgKi9cbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnQgPSBmdW5jdGlvbiAoZGVncmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1t0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gZGVncmVlXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxuICAgICAqL1xuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5ldmFsdWF0ZUF0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAvLyBKdXN0IHJldHVybiB0aGUgeF4wIGNvZWZmaWNpZW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIHZhciBzdW0gPSAvKmludCovIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jb2VmZmljaWVudHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IF9jLnZhbHVlIC8qaW50Ki87XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHRoaXMuZmllbGQuYWRkKHN1bSwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHNbMF07XG4gICAgICAgIHZhciBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmllbGQuYWRkKHRoaXMuZmllbGQubXVsdGlwbHkoYSwgcmVzdWx0KSwgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbWFsbGVyQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIHZhciBsYXJnZXJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gc21hbGxlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW1EaWZmID0gbmV3IEludDMyQXJyYXkobGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBsZW5ndGhEaWZmID0gLyppbnQqLyBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShsYXJnZXJDb2VmZmljaWVudHMsIDAsIHN1bURpZmYsIDAsIGxlbmd0aERpZmYpO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW1EaWZmW2ldID0gdGhpcy5maWVsZC5hZGQoc21hbGxlckNvZWZmaWNpZW50c1tpIC0gbGVuZ3RoRGlmZl0sIGxhcmdlckNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcbiAgICB9O1xuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0aXZlKCkpO1xuICAgIH07XG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIE1vZHVsdXNQb2x5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU90aGVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihvdGhlcik7XG4gICAgfTtcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUubXVsdGlwbHlPdGhlciA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpIHx8IG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIHZhciBhTGVuZ3RoID0gLyppbnQqLyBhQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgIHZhciBiTGVuZ3RoID0gLyppbnQqLyBiQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShhTGVuZ3RoICsgYkxlbmd0aCAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYUNvZWZmID0gLyppbnQqLyBhQ29lZmZpY2llbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiAvKmludCovID0gMDsgaiA8IGJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaSArIGpdID0gdGhpcy5maWVsZC5hZGQocHJvZHVjdFtpICsgal0sIHRoaXMuZmllbGQubXVsdGlwbHkoYUNvZWZmLCBiQ29lZmZpY2llbnRzW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICB9O1xuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5uZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5lZ2F0aXZlQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlQ29lZmZpY2llbnRzW2ldID0gdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZWdhdGl2ZUNvZWZmaWNpZW50cyk7XG4gICAgfTtcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICAgIGlmIChzY2FsYXIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIHNjYWxhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICB9O1xuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5tdWx0aXBseUJ5TW9ub21pYWwgPSBmdW5jdGlvbiAoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplICsgZGVncmVlKTtcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIGNvZWZmaWNpZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgIH07XG4gICAgLypcbiAgICBNb2R1bHVzUG9seVtdIGRpdmlkZShvdGhlcjogTW9kdWx1c1BvbHkpIHtcbiAgICAgIGlmICghZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJEaXZpZGUgYnkgMFwiKTtcbiAgICAgIH1cbiAgXG4gICAgICBsZXQgcXVvdGllbnQ6IE1vZHVsdXNQb2x5ID0gZmllbGQuZ2V0WmVybygpO1xuICAgICAgbGV0IHJlbWFpbmRlcjogTW9kdWx1c1BvbHkgPSB0aGlzO1xuICBcbiAgICAgIGxldCBkZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gb3RoZXIuZ2V0Q29lZmZpY2llbnQob3RoZXIuZ2V0RGVncmVlKCkpO1xuICAgICAgbGV0IGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgXG4gICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgbGV0IGRlZ3JlZURpZmZlcmVuY2U6IC8qaW50LyBudW1iZXIgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcbiAgICAgICAgbGV0IHNjYWxlOiAvKmludC8gbnVtYmVyID0gZmllbGQubXVsdGlwbHkocmVtYWluZGVyLmdldENvZWZmaWNpZW50KHJlbWFpbmRlci5nZXREZWdyZWUoKSksIGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgbGV0IHRlcm06IE1vZHVsdXNQb2x5ID0gb3RoZXIubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgICAgbGV0IGl0ZXJhdGlvblF1b3RpZW50OiBNb2R1bHVzUG9seSA9IGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZChpdGVyYXRpb25RdW90aWVudCk7XG4gICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5zdWJ0cmFjdCh0ZXJtKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5W10geyBxdW90aWVudCwgcmVtYWluZGVyIH07XG4gICAgfVxuICAgICovXG4gICAgLy8gQE92ZXJyaWRlXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCAvKjggKiB0aGlzLmdldERlZ3JlZSgpKi8pOyAvLyBkeW5hbWljIHN0cmluZyBzaXplIGluIEpTXG4gICAgICAgIGZvciAodmFyIGRlZ3JlZSAvKmludCovID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XG4gICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSAvKmludCovIHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIC0gJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyArICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgPT09IDAgfHwgY29lZmZpY2llbnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjb2VmZmljaWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgneF4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoZGVncmVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kdWx1c1BvbHk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9kdWx1c1BvbHk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n* Copyright 2009 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import com.google.zxing.NotFoundException;\n// import com.google.zxing.ResultPoint;\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar System_1 = __webpack_require__(/*! ../../util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar PDF417DetectorResult_1 = __webpack_require__(/*! ./PDF417DetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js\");\n// import java.util.ArrayList;\n// import java.util.Arrays;\n// import java.util.List;\n// import java.util.Map;\n/**\n * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\n * PDF417 Code is rotated or skewed, or partially obscured.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Guenther Grau\n */\nvar Detector = /** @class */ (function () {\n    function Detector() {\n    }\n    /**\n     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\n     *\n     * @param image barcode image to decode\n     * @param hints optional hints to detector\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n     * be found and returned\n     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\n     * @throws NotFoundException if no PDF417 Code can be found\n     */\n    Detector.detectMultiple = function (image, hints, multiple) {\n        // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n        // different binarizers\n        // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n        var bitMatrix = image.getBlackMatrix();\n        var barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n        if (!barcodeCoordinates.length) {\n            bitMatrix = bitMatrix.clone();\n            bitMatrix.rotate180();\n            barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n        }\n        return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);\n    };\n    /**\n     * Detects PDF417 codes in an image. Only checks 0 degree rotation\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n     * be found and returned\n     * @param bitMatrix bit matrix to detect barcodes in\n     * @return List of ResultPoint arrays containing the coordinates of found barcodes\n     */\n    Detector.detect = function (multiple, bitMatrix) {\n        var e_1, _a;\n        var barcodeCoordinates = new Array();\n        var row = 0;\n        var column = 0;\n        var foundBarcodeInRow = false;\n        while (row < bitMatrix.getHeight()) {\n            var vertices = Detector.findVertices(bitMatrix, row, column);\n            if (vertices[0] == null && vertices[3] == null) {\n                if (!foundBarcodeInRow) {\n                    // we didn't find any barcode so that's the end of searching\n                    break;\n                }\n                // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n                // below the lowest barcode we found so far.\n                foundBarcodeInRow = false;\n                column = 0;\n                try {\n                    for (var barcodeCoordinates_1 = (e_1 = void 0, __values(barcodeCoordinates)), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {\n                        var barcodeCoordinate = barcodeCoordinates_1_1.value;\n                        if (barcodeCoordinate[1] != null) {\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n                        }\n                        if (barcodeCoordinate[3] != null) {\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                row += Detector.ROW_STEP;\n                continue;\n            }\n            foundBarcodeInRow = true;\n            barcodeCoordinates.push(vertices);\n            if (!multiple) {\n                break;\n            }\n            // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n            // start pattern of the barcode just found.\n            if (vertices[2] != null) {\n                column = Math.trunc(vertices[2].getX());\n                row = Math.trunc(vertices[2].getY());\n            }\n            else {\n                column = Math.trunc(vertices[4].getX());\n                row = Math.trunc(vertices[4].getY());\n            }\n        }\n        return barcodeCoordinates;\n    };\n    /**\n     * Locate the vertices and the codewords area of a black blob using the Start\n     * and Stop patterns as locators.\n     *\n     * @param matrix the scanned barcode image.\n     * @return an array containing the vertices:\n     *           vertices[0] x, y top left barcode\n     *           vertices[1] x, y bottom left barcode\n     *           vertices[2] x, y top right barcode\n     *           vertices[3] x, y bottom right barcode\n     *           vertices[4] x, y top left codeword area\n     *           vertices[5] x, y bottom left codeword area\n     *           vertices[6] x, y top right codeword area\n     *           vertices[7] x, y bottom right codeword area\n     */\n    Detector.findVertices = function (matrix, startRow, startColumn) {\n        var height = matrix.getHeight();\n        var width = matrix.getWidth();\n        // const result = new ResultPoint[8];\n        var result = new Array(8);\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);\n        if (result[4] != null) {\n            startColumn = Math.trunc(result[4].getX());\n            startRow = Math.trunc(result[4].getY());\n        }\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);\n        return result;\n    };\n    Detector.copyToResult = function (result, tmpResult, destinationIndexes) {\n        for (var i = 0; i < destinationIndexes.length; i++) {\n            result[destinationIndexes[i]] = tmpResult[i];\n        }\n    };\n    Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {\n        // const result = new ResultPoint[4];\n        var result = new Array(4);\n        var found = false;\n        var counters = new Int32Array(pattern.length);\n        for (; startRow < height; startRow += Detector.ROW_STEP) {\n            var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n            if (loc != null) {\n                while (startRow > 0) {\n                    var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n                    if (previousRowLoc != null) {\n                        loc = previousRowLoc;\n                    }\n                    else {\n                        startRow++;\n                        break;\n                    }\n                }\n                result[0] = new ResultPoint_1.default(loc[0], startRow);\n                result[1] = new ResultPoint_1.default(loc[1], startRow);\n                found = true;\n                break;\n            }\n        }\n        var stopRow = startRow + 1;\n        // Last row of the current symbol that contains pattern\n        if (found) {\n            var skippedRowCount = 0;\n            var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\n            for (; stopRow < height; stopRow++) {\n                var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\n                // a found pattern is only considered to belong to the same barcode if the start and end positions\n                // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n                // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n                // larger drift and don't check for skipped rows.\n                if (loc != null &&\n                    Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT &&\n                    Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {\n                    previousRowLoc = loc;\n                    skippedRowCount = 0;\n                }\n                else {\n                    if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {\n                        break;\n                    }\n                    else {\n                        skippedRowCount++;\n                    }\n                }\n            }\n            stopRow -= skippedRowCount + 1;\n            result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);\n            result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);\n        }\n        if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {\n            Arrays_1.default.fill(result, null);\n        }\n        return result;\n    };\n    /**\n     * @param matrix row of black/white values to search\n     * @param column x position to start search\n     * @param row y position to start search\n     * @param width the number of pixels to search on this row\n     * @param pattern pattern of counts of number of black and white pixels that are\n     *                 being searched for as a pattern\n     * @param counters array of counters, as long as pattern, to re-use\n     * @return start/end horizontal offset of guard pattern, as an array of two ints.\n     */\n    Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {\n        Arrays_1.default.fillWithin(counters, 0, counters.length, 0);\n        var patternStart = column;\n        var pixelDrift = 0;\n        // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {\n            patternStart--;\n        }\n        var x = patternStart;\n        var counterPosition = 0;\n        var patternLength = pattern.length;\n        for (var isWhite = whiteFirst; x < width; x++) {\n            var pixel = matrix.get(x, row);\n            if (pixel !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n                        return new Int32Array([patternStart, x]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        if (counterPosition === patternLength - 1 &&\n            Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n            return new Int32Array([patternStart, x - 1]);\n        }\n        return null;\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white\n     * values matches a given target pattern. This is reported as the ratio of\n     * the total variance from the expected pattern proportions across all\n     * pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this\n            // is too small to reliably match, so fail:\n            return /*Float.POSITIVE_INFINITY*/ Infinity;\n        }\n        // We're going to fake floating-point math in integers. We just need to use more bits.\n        // Scale up patternLength so that intermediate values below like scaledCounter will have\n        // more \"significant digits\".\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\n    Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\n    Detector.MAX_AVG_VARIANCE = 0.42;\n    Detector.MAX_INDIVIDUAL_VARIANCE = 0.8;\n    // B S B S B S B S Bar/Space pattern\n    // 11111111 0 1 0 1 0 1 000\n    Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);\n    // 1111111 0 1 000 1 0 1 00 1\n    Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\n    Detector.MAX_PIXEL_DRIFT = 3;\n    Detector.MAX_PATTERN_DRIFT = 5;\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n    Detector.SKIPPED_ROW_COUNT_MAX = 25;\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n    Detector.ROW_STEP = 5;\n    Detector.BARCODE_MIN_HEIGHT = 10;\n    return Detector;\n}());\nexports[\"default\"] = Detector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGV0ZWN0b3IvRGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDJJQUFtQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsMklBQW1CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQywySUFBbUI7QUFDMUMsNkJBQTZCLG1CQUFPLENBQUMseUtBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3Siw4QkFBOEI7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3BkZjQxNy9kZXRlY3Rvci9EZXRlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4qIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLk5vdEZvdW5kRXhjZXB0aW9uO1xuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuUmVzdWx0UG9pbnQ7XG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRQb2ludFwiKTtcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N5c3RlbVwiKTtcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0FycmF5c1wiKTtcbnZhciBQREY0MTdEZXRlY3RvclJlc3VsdF8xID0gcmVxdWlyZShcIi4vUERGNDE3RGV0ZWN0b3JSZXN1bHRcIik7XG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbi8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBQREY0MTcgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGVcbiAqIFBERjQxNyBDb2RlIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICpcbiAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gKi9cbnZhciBEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXRlY3RvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+RGV0ZWN0cyBhIFBERjQxNyBDb2RlIGluIGFuIGltYWdlLiBPbmx5IGNoZWNrcyAwIGFuZCAxODAgZGVncmVlIHJvdGF0aW9ucy48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2UgYmFyY29kZSBpbWFnZSB0byBkZWNvZGVcbiAgICAgKiBAcGFyYW0gaGludHMgb3B0aW9uYWwgaGludHMgdG8gZGV0ZWN0b3JcbiAgICAgKiBAcGFyYW0gbXVsdGlwbGUgaWYgdHJ1ZSwgdGhlbiB0aGUgaW1hZ2UgaXMgc2VhcmNoZWQgZm9yIG11bHRpcGxlIGNvZGVzLiBJZiBmYWxzZSwgdGhlbiBhdCBtb3N0IG9uZSBjb2RlIHdpbGxcbiAgICAgKiBiZSBmb3VuZCBhbmQgcmV0dXJuZWRcbiAgICAgKiBAcmV0dXJuIHtAbGluayBQREY0MTdEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFBERjQxNyBjb2RlXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBQREY0MTcgQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5kZXRlY3RNdWx0aXBsZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMsIG11bHRpcGxlKSB7XG4gICAgICAgIC8vIFRPRE8gZGV0ZWN0aW9uIGltcHJvdmVtZW50LCB0cnlIYXJkZXIgY291bGQgdHJ5IHNldmVyYWwgZGlmZmVyZW50IGx1bWluYW5jZSB0aHJlc2hvbGRzL2JsYWNrcG9pbnRzIG9yIGV2ZW5cbiAgICAgICAgLy8gZGlmZmVyZW50IGJpbmFyaXplcnNcbiAgICAgICAgLy8gYm9vbGVhbiB0cnlIYXJkZXIgPSBoaW50cyAhPSBudWxsICYmIGhpbnRzLmNvbnRhaW5zS2V5KERlY29kZUhpbnRUeXBlLlRSWV9IQVJERVIpO1xuICAgICAgICB2YXIgYml0TWF0cml4ID0gaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKTtcbiAgICAgICAgdmFyIGJhcmNvZGVDb29yZGluYXRlcyA9IERldGVjdG9yLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgaWYgKCFiYXJjb2RlQ29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBiaXRNYXRyaXggPSBiaXRNYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgIGJpdE1hdHJpeC5yb3RhdGUxODAoKTtcbiAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcyA9IERldGVjdG9yLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBERjQxN0RldGVjdG9yUmVzdWx0XzEuZGVmYXVsdChiaXRNYXRyaXgsIGJhcmNvZGVDb29yZGluYXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIFBERjQxNyBjb2RlcyBpbiBhbiBpbWFnZS4gT25seSBjaGVja3MgMCBkZWdyZWUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0gbXVsdGlwbGUgaWYgdHJ1ZSwgdGhlbiB0aGUgaW1hZ2UgaXMgc2VhcmNoZWQgZm9yIG11bHRpcGxlIGNvZGVzLiBJZiBmYWxzZSwgdGhlbiBhdCBtb3N0IG9uZSBjb2RlIHdpbGxcbiAgICAgKiBiZSBmb3VuZCBhbmQgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gYml0TWF0cml4IGJpdCBtYXRyaXggdG8gZGV0ZWN0IGJhcmNvZGVzIGluXG4gICAgICogQHJldHVybiBMaXN0IG9mIFJlc3VsdFBvaW50IGFycmF5cyBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBmb3VuZCBiYXJjb2Rlc1xuICAgICAqL1xuICAgIERldGVjdG9yLmRldGVjdCA9IGZ1bmN0aW9uIChtdWx0aXBsZSwgYml0TWF0cml4KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgYmFyY29kZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICB2YXIgY29sdW1uID0gMDtcbiAgICAgICAgdmFyIGZvdW5kQmFyY29kZUluUm93ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChyb3cgPCBiaXRNYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IERldGVjdG9yLmZpbmRWZXJ0aWNlcyhiaXRNYXRyaXgsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1swXSA9PSBudWxsICYmIHZlcnRpY2VzWzNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kQmFyY29kZUluUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBmaW5kIGFueSBiYXJjb2RlIHNvIHRoYXQncyB0aGUgZW5kIG9mIHNlYXJjaGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IGZpbmQgYSBiYXJjb2RlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBjb2x1bW4gYW5kIHJvdy4gVHJ5IGFnYWluIGZyb20gdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICAvLyBiZWxvdyB0aGUgbG93ZXN0IGJhcmNvZGUgd2UgZm91bmQgc28gZmFyLlxuICAgICAgICAgICAgICAgIGZvdW5kQmFyY29kZUluUm93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiYXJjb2RlQ29vcmRpbmF0ZXNfMSA9IChlXzEgPSB2b2lkIDAsIF9fdmFsdWVzKGJhcmNvZGVDb29yZGluYXRlcykpLCBiYXJjb2RlQ29vcmRpbmF0ZXNfMV8xID0gYmFyY29kZUNvb3JkaW5hdGVzXzEubmV4dCgpOyAhYmFyY29kZUNvb3JkaW5hdGVzXzFfMS5kb25lOyBiYXJjb2RlQ29vcmRpbmF0ZXNfMV8xID0gYmFyY29kZUNvb3JkaW5hdGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFyY29kZUNvb3JkaW5hdGUgPSBiYXJjb2RlQ29vcmRpbmF0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKE1hdGgubWF4KHJvdywgYmFyY29kZUNvb3JkaW5hdGVbMV0uZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZUNvb3JkaW5hdGVbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgubWF4KHJvdywgTWF0aC50cnVuYyhiYXJjb2RlQ29vcmRpbmF0ZVszXS5nZXRZKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlc18xXzEgJiYgIWJhcmNvZGVDb29yZGluYXRlc18xXzEuZG9uZSAmJiAoX2EgPSBiYXJjb2RlQ29vcmRpbmF0ZXNfMS5yZXR1cm4pKSBfYS5jYWxsKGJhcmNvZGVDb29yZGluYXRlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvdyArPSBEZXRlY3Rvci5ST1dfU1RFUDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kQmFyY29kZUluUm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcy5wdXNoKHZlcnRpY2VzKTtcbiAgICAgICAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW4sIHRoZW4gY29udGludWUgdGhlIHNlYXJjaCBmb3IgdGhlIG5leHQgYmFyY29kZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBhdHRlcm4gb2YgdGhlIGJhcmNvZGUganVzdCBmb3VuZC5cbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1syXS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgudHJ1bmModmVydGljZXNbMl0uZ2V0WSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgudHJ1bmModmVydGljZXNbNF0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhcmNvZGVDb29yZGluYXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvY2F0ZSB0aGUgdmVydGljZXMgYW5kIHRoZSBjb2Rld29yZHMgYXJlYSBvZiBhIGJsYWNrIGJsb2IgdXNpbmcgdGhlIFN0YXJ0XG4gICAgICogYW5kIFN0b3AgcGF0dGVybnMgYXMgbG9jYXRvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWF0cml4IHRoZSBzY2FubmVkIGJhcmNvZGUgaW1hZ2UuXG4gICAgICogQHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2ZXJ0aWNlczpcbiAgICAgKiAgICAgICAgICAgdmVydGljZXNbMF0geCwgeSB0b3AgbGVmdCBiYXJjb2RlXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzFdIHgsIHkgYm90dG9tIGxlZnQgYmFyY29kZVxuICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1syXSB4LCB5IHRvcCByaWdodCBiYXJjb2RlXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzNdIHgsIHkgYm90dG9tIHJpZ2h0IGJhcmNvZGVcbiAgICAgKiAgICAgICAgICAgdmVydGljZXNbNF0geCwgeSB0b3AgbGVmdCBjb2Rld29yZCBhcmVhXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzVdIHgsIHkgYm90dG9tIGxlZnQgY29kZXdvcmQgYXJlYVxuICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s2XSB4LCB5IHRvcCByaWdodCBjb2Rld29yZCBhcmVhXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzddIHgsIHkgYm90dG9tIHJpZ2h0IGNvZGV3b3JkIGFyZWFcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5maW5kVmVydGljZXMgPSBmdW5jdGlvbiAobWF0cml4LCBzdGFydFJvdywgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHRQb2ludFs4XTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgRGV0ZWN0b3IuY29weVRvUmVzdWx0KHJlc3VsdCwgRGV0ZWN0b3IuZmluZFJvd3NXaXRoUGF0dGVybihtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgRGV0ZWN0b3IuU1RBUlRfUEFUVEVSTiksIERldGVjdG9yLklOREVYRVNfU1RBUlRfUEFUVEVSTik7XG4gICAgICAgIGlmIChyZXN1bHRbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKHJlc3VsdFs0XS5nZXRYKCkpO1xuICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLnRydW5jKHJlc3VsdFs0XS5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIERldGVjdG9yLmNvcHlUb1Jlc3VsdChyZXN1bHQsIERldGVjdG9yLmZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIERldGVjdG9yLlNUT1BfUEFUVEVSTiksIERldGVjdG9yLklOREVYRVNfU1RPUF9QQVRURVJOKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERldGVjdG9yLmNvcHlUb1Jlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHRtcFJlc3VsdCwgZGVzdGluYXRpb25JbmRleGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdGluYXRpb25JbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbZGVzdGluYXRpb25JbmRleGVzW2ldXSA9IHRtcFJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGV0ZWN0b3IuZmluZFJvd3NXaXRoUGF0dGVybiA9IGZ1bmN0aW9uIChtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgcGF0dGVybikge1xuICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbNF07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY291bnRlcnMgPSBuZXcgSW50MzJBcnJheShwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgIGZvciAoOyBzdGFydFJvdyA8IGhlaWdodDsgc3RhcnRSb3cgKz0gRGV0ZWN0b3IuUk9XX1NURVApIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBEZXRlY3Rvci5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChsb2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydFJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUm93TG9jID0gRGV0ZWN0b3IuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHN0YXJ0Q29sdW1uLCAtLXN0YXJ0Um93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93TG9jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyA9IHByZXZpb3VzUm93TG9jO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3crKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQobG9jWzBdLCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsb2NbMV0sIHN0YXJ0Um93KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3BSb3cgPSBzdGFydFJvdyArIDE7XG4gICAgICAgIC8vIExhc3Qgcm93IG9mIHRoZSBjdXJyZW50IHN5bWJvbCB0aGF0IGNvbnRhaW5zIHBhdHRlcm5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgc2tpcHBlZFJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1Jvd0xvYyA9IEludDMyQXJyYXkuZnJvbShbTWF0aC50cnVuYyhyZXN1bHRbMF0uZ2V0WCgpKSwgTWF0aC50cnVuYyhyZXN1bHRbMV0uZ2V0WCgpKV0pO1xuICAgICAgICAgICAgZm9yICg7IHN0b3BSb3cgPCBoZWlnaHQ7IHN0b3BSb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSBEZXRlY3Rvci5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgcHJldmlvdXNSb3dMb2NbMF0sIHN0b3BSb3csIHdpZHRoLCBmYWxzZSwgcGF0dGVybiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIGEgZm91bmQgcGF0dGVybiBpcyBvbmx5IGNvbnNpZGVyZWQgdG8gYmVsb25nIHRvIHRoZSBzYW1lIGJhcmNvZGUgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZGlmZmVyIHRvbyBtdWNoLiBQYXR0ZXJuIGRyaWZ0IHNob3VsZCBiZSBub3QgYmlnZ2VyIHRoYW4gdHdvIGZvciBjb25zZWN1dGl2ZSByb3dzLiBXaXRoXG4gICAgICAgICAgICAgICAgLy8gYSBoaWdoZXIgbnVtYmVyIG9mIHNraXBwZWQgcm93cyBkcmlmdCBjb3VsZCBiZSBsYXJnZXIuIFRvIGtlZXAgaXQgc2ltcGxlIGZvciBub3csIHdlIGFsbG93IGEgc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICAvLyBsYXJnZXIgZHJpZnQgYW5kIGRvbid0IGNoZWNrIGZvciBza2lwcGVkIHJvd3MuXG4gICAgICAgICAgICAgICAgaWYgKGxvYyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHByZXZpb3VzUm93TG9jWzBdIC0gbG9jWzBdKSA8IERldGVjdG9yLk1BWF9QQVRURVJOX0RSSUZUICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHByZXZpb3VzUm93TG9jWzFdIC0gbG9jWzFdKSA8IERldGVjdG9yLk1BWF9QQVRURVJOX0RSSUZUKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUm93TG9jID0gbG9jO1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUm93Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBwZWRSb3dDb3VudCA+IERldGVjdG9yLlNLSVBQRURfUk9XX0NPVU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkUm93Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BSb3cgLT0gc2tpcHBlZFJvd0NvdW50ICsgMTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocHJldmlvdXNSb3dMb2NbMF0sIHN0b3BSb3cpO1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwcmV2aW91c1Jvd0xvY1sxXSwgc3RvcFJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BSb3cgLSBzdGFydFJvdyA8IERldGVjdG9yLkJBUkNPREVfTUlOX0hFSUdIVCkge1xuICAgICAgICAgICAgQXJyYXlzXzEuZGVmYXVsdC5maWxsKHJlc3VsdCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtYXRyaXggcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0gY29sdW1uIHggcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICogQHBhcmFtIHJvdyB5IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAqIEBwYXJhbSB3aWR0aCB0aGUgbnVtYmVyIG9mIHBpeGVscyB0byBzZWFyY2ggb24gdGhpcyByb3dcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZVxuICAgICAqICAgICAgICAgICAgICAgICBiZWluZyBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIGNvdW50ZXJzIGFycmF5IG9mIGNvdW50ZXJzLCBhcyBsb25nIGFzIHBhdHRlcm4sIHRvIHJlLXVzZVxuICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzLlxuICAgICAqL1xuICAgIERldGVjdG9yLmZpbmRHdWFyZFBhdHRlcm4gPSBmdW5jdGlvbiAobWF0cml4LCBjb2x1bW4sIHJvdywgd2lkdGgsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XG4gICAgICAgIEFycmF5c18xLmRlZmF1bHQuZmlsbFdpdGhpbihjb3VudGVycywgMCwgY291bnRlcnMubGVuZ3RoLCAwKTtcbiAgICAgICAgdmFyIHBhdHRlcm5TdGFydCA9IGNvbHVtbjtcbiAgICAgICAgdmFyIHBpeGVsRHJpZnQgPSAwO1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYmxhY2sgcGl4ZWxzIGxlZnQgb2YgdGhlIGN1cnJlbnQgcGl4ZWwgc2hpZnQgdG8gdGhlIGxlZnQsIGJ1dCBvbmx5IGZvciBNQVhfUElYRUxfRFJJRlQgcGl4ZWxzXG4gICAgICAgIHdoaWxlIChtYXRyaXguZ2V0KHBhdHRlcm5TdGFydCwgcm93KSAmJiBwYXR0ZXJuU3RhcnQgPiAwICYmIHBpeGVsRHJpZnQrKyA8IERldGVjdG9yLk1BWF9QSVhFTF9EUklGVCkge1xuICAgICAgICAgICAgcGF0dGVyblN0YXJ0LS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSBwYXR0ZXJuU3RhcnQ7XG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpc1doaXRlID0gd2hpdGVGaXJzdDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IG1hdHJpeC5nZXQoeCwgcm93KTtcbiAgICAgICAgICAgIGlmIChwaXhlbCAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEZXRlY3Rvci5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgRGV0ZWN0b3IuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgRGV0ZWN0b3IuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoY291bnRlcnMsIDIsIGNvdW50ZXJzLCAwLCBjb3VudGVyUG9zaXRpb24gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxICYmXG4gICAgICAgICAgICBEZXRlY3Rvci5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgRGV0ZWN0b3IuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgRGV0ZWN0b3IuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGhvdyBjbG9zZWx5IGEgc2V0IG9mIG9ic2VydmVkIGNvdW50cyBvZiBydW5zIG9mIGJsYWNrL3doaXRlXG4gICAgICogdmFsdWVzIG1hdGNoZXMgYSBnaXZlbiB0YXJnZXQgcGF0dGVybi4gVGhpcyBpcyByZXBvcnRlZCBhcyB0aGUgcmF0aW8gb2ZcbiAgICAgKiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVybiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsXG4gICAgICogcGF0dGVybiBlbGVtZW50cywgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xuICAgICAqIEBwYXJhbSBwYXR0ZXJuIGV4cGVjdGVkIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gbWF4SW5kaXZpZHVhbFZhcmlhbmNlIFRoZSBtb3N0IGFueSBjb3VudGVyIGNhbiBkaWZmZXIgYmVmb3JlIHdlIGdpdmUgdXBcbiAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXG4gICAgICovXG4gICAgRGV0ZWN0b3IucGF0dGVybk1hdGNoVmFyaWFuY2UgPSBmdW5jdGlvbiAoY291bnRlcnMsIHBhdHRlcm4sIG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICB2YXIgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIHBhdHRlcm5MZW5ndGggKz0gcGF0dGVybltpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG90YWwgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgb25lIHBpeGVsIHBlciB1bml0IG9mIGJhciB3aWR0aCwgYXNzdW1lIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIHRvbyBzbWFsbCB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcbiAgICAgICAgICAgIHJldHVybiAvKkZsb2F0LlBPU0lUSVZFX0lORklOSVRZKi8gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmFrZSBmbG9hdGluZy1wb2ludCBtYXRoIGluIGludGVnZXJzLiBXZSBqdXN0IG5lZWQgdG8gdXNlIG1vcmUgYml0cy5cbiAgICAgICAgLy8gU2NhbGUgdXAgcGF0dGVybkxlbmd0aCBzbyB0aGF0IGludGVybWVkaWF0ZSB2YWx1ZXMgYmVsb3cgbGlrZSBzY2FsZWRDb3VudGVyIHdpbGwgaGF2ZVxuICAgICAgICAvLyBtb3JlIFwic2lnbmlmaWNhbnQgZGlnaXRzXCIuXG4gICAgICAgIHZhciB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XG4gICAgICAgIG1heEluZGl2aWR1YWxWYXJpYW5jZSAqPSB1bml0QmFyV2lkdGg7XG4gICAgICAgIHZhciB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNbeF07XG4gICAgICAgICAgICB2YXIgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XG4gICAgICAgICAgICBpZiAodmFyaWFuY2UgPiBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLypGbG9hdC5QT1NJVElWRV9JTkZJTklUWSovIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxWYXJpYW5jZSArPSB2YXJpYW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xuICAgIH07XG4gICAgRGV0ZWN0b3IuSU5ERVhFU19TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFswLCA0LCAxLCA1XSk7XG4gICAgRGV0ZWN0b3IuSU5ERVhFU19TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzYsIDIsIDcsIDNdKTtcbiAgICBEZXRlY3Rvci5NQVhfQVZHX1ZBUklBTkNFID0gMC40MjtcbiAgICBEZXRlY3Rvci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuODtcbiAgICAvLyBCIFMgQiBTIEIgUyBCIFMgQmFyL1NwYWNlIHBhdHRlcm5cbiAgICAvLyAxMTExMTExMSAwIDEgMCAxIDAgMSAwMDBcbiAgICBEZXRlY3Rvci5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFs4LCAxLCAxLCAxLCAxLCAxLCAxLCAzXSk7XG4gICAgLy8gMTExMTExMSAwIDEgMDAwIDEgMCAxIDAwIDFcbiAgICBEZXRlY3Rvci5TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzcsIDEsIDEsIDMsIDEsIDEsIDEsIDIsIDFdKTtcbiAgICBEZXRlY3Rvci5NQVhfUElYRUxfRFJJRlQgPSAzO1xuICAgIERldGVjdG9yLk1BWF9QQVRURVJOX0RSSUZUID0gNTtcbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBsb3csIHRoZW4gd2UgZG9uJ3QgZGV0ZWN0IHRoZSBjb3JyZWN0IGhlaWdodCBvZiB0aGUgYmFyIGlmIHRoZSBzdGFydCBwYXR0ZXJucyBhcmUgZGFtYWdlZC5cbiAgICAvLyBpZiB3ZSBzZXQgdGhlIHZhbHVlIHRvbyBoaWdoLCB0aGVuIHdlIG1pZ2h0IGRldGVjdCB0aGUgc3RhcnQgcGF0dGVybiBmcm9tIGEgbmVpZ2hib3IgYmFyY29kZS5cbiAgICBEZXRlY3Rvci5TS0lQUEVEX1JPV19DT1VOVF9NQVggPSAyNTtcbiAgICAvLyBBIFBERjQ3MSBiYXJjb2RlIHNob3VsZCBoYXZlIGF0IGxlYXN0IDMgcm93cywgd2l0aCBlYWNoIHJvdyBiZWluZyA+PSAzIHRpbWVzIHRoZSBtb2R1bGUgd2lkdGguIFRoZXJlZm9yZSBpdCBzaG91bGQgYmUgYXQgbGVhc3RcbiAgICAvLyA5IHBpeGVscyB0YWxsLiBUbyBiZSBjb25zZXJ2YXRpdmUsIHdlIHVzZSBhYm91dCBoYWxmIHRoZSBzaXplIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGl0LlxuICAgIERldGVjdG9yLlJPV19TVEVQID0gNTtcbiAgICBEZXRlY3Rvci5CQVJDT0RFX01JTl9IRUlHSFQgPSAxMDtcbiAgICByZXR1cm4gRGV0ZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0b3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import java.util.List;\n/**\n * @author Guenther Grau\n */\nvar PDF417DetectorResult = /** @class */ (function () {\n    function PDF417DetectorResult(bits, points) {\n        this.bits = bits;\n        this.points = points;\n    }\n    PDF417DetectorResult.prototype.getBits = function () {\n        return this.bits;\n    };\n    PDF417DetectorResult.prototype.getPoints = function () {\n        return this.points;\n    };\n    return PDF417DetectorResult;\n}());\nexports[\"default\"] = PDF417DetectorResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9wZGY0MTcvZGV0ZWN0b3IvUERGNDE3RGV0ZWN0b3JSZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcGRmNDE3L2RldGVjdG9yL1BERjQxN0RldGVjdG9yUmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuLyoqXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAqL1xudmFyIFBERjQxN0RldGVjdG9yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBERjQxN0RldGVjdG9yUmVzdWx0KGJpdHMsIHBvaW50cykge1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB9XG4gICAgUERGNDE3RGV0ZWN0b3JSZXN1bHQucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgfTtcbiAgICBQREY0MTdEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgfTtcbiAgICByZXR1cm4gUERGNDE3RGV0ZWN0b3JSZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUERGNDE3RGV0ZWN0b3JSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar Result_1 = __webpack_require__(/*! ../Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nvar ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\n// import DetectorResult from '../common/DetectorResult';\nvar Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js\");\nvar QRCodeDecoderMetaData_1 = __webpack_require__(/*! ./decoder/QRCodeDecoderMetaData */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js\");\nvar Detector_1 = __webpack_require__(/*! ./detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js\");\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\nvar QRCodeReader = /** @class */ (function () {\n    function QRCodeReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    QRCodeReader.prototype.getDecoder = function () {\n        return this.decoder;\n    };\n    /**\n     * Locates and decodes a QR code in an image.\n     *\n     * @return a representing: string the content encoded by the QR code\n     * @throws NotFoundException if a QR code cannot be found\n     * @throws FormatException if a QR code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    /*@Override*/\n    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n    //   return this.decode(image, null)\n    // }\n    /*@Override*/\n    QRCodeReader.prototype.decode = function (image, hints) {\n        var decoderResult;\n        var points;\n        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n            points = QRCodeReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n            points = detectorResult.getPoints();\n        }\n        // If the code was mirrored: swap the bottom-left and the top-right points.\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n            decoderResult.getOther().applyMirroredCorrection(points);\n        }\n        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments !== null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel !== null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        if (decoderResult.hasStructuredAppend()) {\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n        }\n        return result;\n    };\n    /*@Override*/\n    QRCodeReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n     */\n    QRCodeReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack === null || rightBottomBlack === null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        // Sanity check!\n        if (left >= right || top >= bottom) {\n            throw new NotFoundException_1.default();\n        }\n        if (bottom - top !== right - left) {\n            // Special case, where bottom-right module wasn't black so we found something else in the last row\n            // Assume it's a square, so use height as the width\n            right = left + (bottom - top);\n            if (right >= image.getWidth()) {\n                // Abort if that would not make sense -- off image\n                throw new NotFoundException_1.default();\n            }\n        }\n        var matrixWidth = Math.round((right - left + 1) / moduleSize);\n        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        if (matrixHeight !== matrixWidth) {\n            // Only possibly decode square regions\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n        top += nudge;\n        left += nudge;\n        // But careful that this does not sample off the edge\n        // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n        // This is positive by how much the inner x loop below would be too large\n        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n        if (nudgedTooFarRight > 0) {\n            if (nudgedTooFarRight > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            left -= nudgedTooFarRight;\n        }\n        // See logic above\n        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n        if (nudgedTooFarDown > 0) {\n            if (nudgedTooFarDown > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            top -= nudgedTooFarDown;\n        }\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    QRCodeReader.moduleSize = function (leftTopBlack, image) {\n        var height = image.getHeight();\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        var inBlack = true;\n        var transitions = 0;\n        while (x < width && y < height) {\n            if (inBlack !== image.get(x, y)) {\n                if (++transitions === 5) {\n                    break;\n                }\n                inBlack = !inBlack;\n            }\n            x++;\n            y++;\n        }\n        if (x === width || y === height) {\n            throw new NotFoundException_1.default();\n        }\n        return (x - leftTopBlack[0]) / 7.0;\n    };\n    QRCodeReader.NO_POINTS = new Array();\n    return QRCodeReader;\n}());\nexports[\"default\"] = QRCodeReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvUVJDb2RlUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsa0pBQXFCO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLDhJQUFtQjtBQUNsRCwwQkFBMEIsbUJBQU8sQ0FBQyxvSkFBc0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLDhIQUFXO0FBQ2xDLDJCQUEyQixtQkFBTyxDQUFDLHNKQUF1QjtBQUMxRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNKQUFtQjtBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxrTEFBaUM7QUFDdkUsaUJBQWlCLG1CQUFPLENBQUMsMEpBQXFCO0FBQzlDLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL1FSQ29kZVJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUgeyovXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcbi8vIGltcG9ydCBEZXRlY3RvclJlc3VsdCBmcm9tICcuLi9jb21tb24vRGV0ZWN0b3JSZXN1bHQnO1xudmFyIERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXIvRGVjb2RlclwiKTtcbnZhciBRUkNvZGVEZWNvZGVyTWV0YURhdGFfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXIvUVJDb2RlRGVjb2Rlck1ldGFEYXRhXCIpO1xudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbi8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIFFSIENvZGVzIGluIGFuIGltYWdlLlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBRUkNvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUVJDb2RlUmVhZGVyKCkge1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2Rlcl8xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgUVJDb2RlUmVhZGVyLnByb3RvdHlwZS5nZXREZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIFFSIGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgcmVwcmVzZW50aW5nOiBzdHJpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgUVIgY29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBRUiBjb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBCaW5hcnlCaXRtYXApOiBSZXN1bHQgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24gKi8ge1xuICAgIC8vICAgcmV0dXJuIHRoaXMuZGVjb2RlKGltYWdlLCBudWxsKVxuICAgIC8vIH1cbiAgICAvKkBPdmVycmlkZSovXG4gICAgUVJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgIHZhciBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB2YXIgcG9pbnRzO1xuICAgICAgICBpZiAoaGludHMgIT09IHVuZGVmaW5lZCAmJiBoaW50cyAhPT0gbnVsbCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuUFVSRV9CQVJDT0RFKSkge1xuICAgICAgICAgICAgdmFyIGJpdHMgPSBRUkNvZGVSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGVCaXRNYXRyaXgoYml0cywgaGludHMpO1xuICAgICAgICAgICAgcG9pbnRzID0gUVJDb2RlUmVhZGVyLk5PX1BPSU5UUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IG5ldyBEZXRlY3Rvcl8xLmRlZmF1bHQoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KGhpbnRzKTtcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlQml0TWF0cml4KGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKSwgaGludHMpO1xuICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvZGUgd2FzIG1pcnJvcmVkOiBzd2FwIHRoZSBib3R0b20tbGVmdCBhbmQgdGhlIHRvcC1yaWdodCBwb2ludHMuXG4gICAgICAgIGlmIChkZWNvZGVyUmVzdWx0LmdldE90aGVyKCkgaW5zdGFuY2VvZiBRUkNvZGVEZWNvZGVyTWV0YURhdGFfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LmdldE90aGVyKCkuYXBwbHlNaXJyb3JlZENvcnJlY3Rpb24ocG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgdW5kZWZpbmVkLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlFSX0NPREUsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlY0xldmVsID0gZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCk7XG4gICAgICAgIGlmIChlY0xldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBlY0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb2RlclJlc3VsdC5oYXNTdHJ1Y3R1cmVkQXBwZW5kKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LlNUUlVDVFVSRURfQVBQRU5EX1NFUVVFTkNFLCBkZWNvZGVyUmVzdWx0LmdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcigpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWSwgZGVjb2RlclJlc3VsdC5nZXRTdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgUVJDb2RlUmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcbiAgICAgKiB3aGljaCBjb250YWlucyBvbmx5IGFuIHVucm90YXRlZCwgdW5za2V3ZWQsIGltYWdlIG9mIGEgY29kZSwgd2l0aCBzb21lIHdoaXRlIGJvcmRlclxuICAgICAqIGFyb3VuZCBpdC4gVGhpcyBpcyBhIHNwZWNpYWxpemVkIG1ldGhvZCB0aGF0IHdvcmtzIGV4Y2VwdGlvbmFsbHkgZmFzdCBpbiB0aGlzIHNwZWNpYWxcbiAgICAgKiBjYXNlLlxuICAgICAqXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFJlYWRlciNleHRyYWN0UHVyZUJpdHMoQml0TWF0cml4KVxuICAgICAqL1xuICAgIFFSQ29kZVJlYWRlci5leHRyYWN0UHVyZUJpdHMgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgdmFyIGxlZnRUb3BCbGFjayA9IGltYWdlLmdldFRvcExlZnRPbkJpdCgpO1xuICAgICAgICB2YXIgcmlnaHRCb3R0b21CbGFjayA9IGltYWdlLmdldEJvdHRvbVJpZ2h0T25CaXQoKTtcbiAgICAgICAgaWYgKGxlZnRUb3BCbGFjayA9PT0gbnVsbCB8fCByaWdodEJvdHRvbUJsYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7XG4gICAgICAgIHZhciB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgIHZhciBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xuICAgICAgICB2YXIgbGVmdCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcmlnaHRCb3R0b21CbGFja1swXTtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIVxuICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSAtIHRvcCAhPT0gcmlnaHQgLSBsZWZ0KSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UsIHdoZXJlIGJvdHRvbS1yaWdodCBtb2R1bGUgd2Fzbid0IGJsYWNrIHNvIHdlIGZvdW5kIHNvbWV0aGluZyBlbHNlIGluIHRoZSBsYXN0IHJvd1xuICAgICAgICAgICAgLy8gQXNzdW1lIGl0J3MgYSBzcXVhcmUsIHNvIHVzZSBoZWlnaHQgYXMgdGhlIHdpZHRoXG4gICAgICAgICAgICByaWdodCA9IGxlZnQgKyAoYm90dG9tIC0gdG9wKTtcbiAgICAgICAgICAgIGlmIChyaWdodCA+PSBpbWFnZS5nZXRXaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhhdCB3b3VsZCBub3QgbWFrZSBzZW5zZSAtLSBvZmYgaW1hZ2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdHJpeFdpZHRoID0gTWF0aC5yb3VuZCgocmlnaHQgLSBsZWZ0ICsgMSkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgdmFyIG1hdHJpeEhlaWdodCA9IE1hdGgucm91bmQoKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdHJpeEhlaWdodCAhPT0gbWF0cml4V2lkdGgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcG9zc2libHkgZGVjb2RlIHNxdWFyZSByZWdpb25zXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCBpbiB0aGUgXCJib3JkZXJcIiBieSBoYWxmIHRoZSBtb2R1bGUgd2lkdGggc28gdGhhdCB3ZSBzdGFydFxuICAgICAgICAvLyBzYW1wbGluZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb2R1bGUuIEp1c3QgaW4gY2FzZSB0aGUgaW1hZ2UgaXMgYVxuICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxuICAgICAgICB2YXIgbnVkZ2UgPSAvKihpbnQpICovIE1hdGguZmxvb3IobW9kdWxlU2l6ZSAvIDIuMCk7XG4gICAgICAgIHRvcCArPSBudWRnZTtcbiAgICAgICAgbGVmdCArPSBudWRnZTtcbiAgICAgICAgLy8gQnV0IGNhcmVmdWwgdGhhdCB0aGlzIGRvZXMgbm90IHNhbXBsZSBvZmYgdGhlIGVkZ2VcbiAgICAgICAgLy8gXCJyaWdodFwiIGlzIHRoZSBmYXJ0aGVzdC1yaWdodCB2YWxpZCBwaXhlbCBsb2NhdGlvbiAtLSByaWdodCsxIGlzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgICAvLyBUaGlzIGlzIHBvc2l0aXZlIGJ5IGhvdyBtdWNoIHRoZSBpbm5lciB4IGxvb3AgYmVsb3cgd291bGQgYmUgdG9vIGxhcmdlXG4gICAgICAgIHZhciBudWRnZWRUb29GYXJSaWdodCA9IGxlZnQgKyAvKihpbnQpICovIE1hdGguZmxvb3IoKG1hdHJpeFdpZHRoIC0gMSkgKiBtb2R1bGVTaXplKSAtIHJpZ2h0O1xuICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiBudWRnZSkge1xuICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgd2F5IGZpdHM7IGFib3J0XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCAtPSBudWRnZWRUb29GYXJSaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgbG9naWMgYWJvdmVcbiAgICAgICAgdmFyIG51ZGdlZFRvb0ZhckRvd24gPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoKG1hdHJpeEhlaWdodCAtIDEpICogbW9kdWxlU2l6ZSkgLSBib3R0b207XG4gICAgICAgIGlmIChudWRnZWRUb29GYXJEb3duID4gMCkge1xuICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhckRvd24gPiBudWRnZSkge1xuICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgd2F5IGZpdHM7IGFib3J0XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wIC09IG51ZGdlZFRvb0ZhckRvd247XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcbiAgICAgICAgdmFyIGJpdHMgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChtYXRyaXhXaWR0aCwgbWF0cml4SGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXRyaXhIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIGlPZmZzZXQgPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeSAqIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXRyaXhXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChsZWZ0ICsgLyooaW50KSAqLyBNYXRoLmZsb29yKHggKiBtb2R1bGVTaXplKSwgaU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH07XG4gICAgUVJDb2RlUmVhZGVyLm1vZHVsZVNpemUgPSBmdW5jdGlvbiAobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB4ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICB2YXIgeSA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgdmFyIGluQmxhY2sgPSB0cnVlO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbnMgPSAwO1xuICAgICAgICB3aGlsZSAoeCA8IHdpZHRoICYmIHkgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChpbkJsYWNrICE9PSBpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKyt0cmFuc2l0aW9ucyA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5CbGFjayA9ICFpbkJsYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgeSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID09PSB3aWR0aCB8fCB5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHggLSBsZWZ0VG9wQmxhY2tbMF0pIC8gNy4wO1xuICAgIH07XG4gICAgUVJDb2RlUmVhZGVyLk5PX1BPSU5UUyA9IG5ldyBBcnJheSgpO1xuICAgIHJldHVybiBRUkNvZGVSZWFkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUVJDb2RlUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nvar EncodeHintType_1 = __webpack_require__(/*! ../EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar ErrorCorrectionLevel_1 = __webpack_require__(/*! ./decoder/ErrorCorrectionLevel */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js\");\nvar Encoder_1 = __webpack_require__(/*! ./encoder/Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar IllegalStateException_1 = __webpack_require__(/*! ../IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\n/*import java.util.Map;*/\n/**\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar QRCodeWriter = /** @class */ (function () {\n    function QRCodeWriter() {\n    }\n    /*@Override*/\n    // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n    //     /*throws WriterException */ {\n    //   return encode(contents, format, width, height, null)\n    // }\n    /*@Override*/\n    QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n        if (contents.length === 0) {\n            throw new IllegalArgumentException_1.default('Found empty contents');\n        }\n        if (format !== BarcodeFormat_1.default.QR_CODE) {\n            throw new IllegalArgumentException_1.default('Can only encode QR_CODE, but got ' + format);\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException_1.default(\"Requested dimensions are too small: \" + width + \"x\" + height);\n        }\n        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;\n        var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n        if (hints !== null) {\n            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {\n                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());\n            }\n            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {\n                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);\n            }\n        }\n        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);\n        return QRCodeWriter.renderResult(code, width, height, quietZone);\n    };\n    // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n    // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n    QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n        var input = code.getMatrix();\n        if (input === null) {\n            throw new IllegalStateException_1.default();\n        }\n        var inputWidth = input.getWidth();\n        var inputHeight = input.getHeight();\n        var qrWidth = inputWidth + (quietZone * 2);\n        var qrHeight = inputHeight + (quietZone * 2);\n        var outputWidth = Math.max(width, qrWidth);\n        var outputHeight = Math.max(height, qrHeight);\n        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n        // handle all the padding from 100x100 (the actual QR) up to 200x160.\n        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n        var output = new BitMatrix_1.default(outputWidth, outputHeight);\n        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the barcode\n            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                if (input.get(inputX, inputY) === 1) {\n                    output.setRegion(outputX, outputY, multiple, multiple);\n                }\n            }\n        }\n        return output;\n    };\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n    return QRCodeWriter;\n}());\nexports[\"default\"] = QRCodeWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvUVJDb2RlV3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyw0SUFBa0I7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsOElBQW1CO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLGtKQUFxQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyxnTEFBZ0M7QUFDckUsZ0JBQWdCLG1CQUFPLENBQUMsc0pBQW1CO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLGtLQUE2QjtBQUN0RSw4QkFBOEIsbUJBQU8sQ0FBQyw0SkFBMEI7QUFDaEUsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9RUkNvZGVXcml0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlIHsqL1xudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xudmFyIEVuY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vRW5jb2RlSGludFR5cGVcIik7XG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcbnZhciBFcnJvckNvcnJlY3Rpb25MZXZlbF8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9FcnJvckNvcnJlY3Rpb25MZXZlbFwiKTtcbnZhciBFbmNvZGVyXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyL0VuY29kZXJcIik7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbi8qKlxuICogVGhpcyBvYmplY3QgcmVuZGVycyBhIFFSIENvZGUgYXMgYSBCaXRNYXRyaXggMkQgYXJyYXkgb2YgZ3JleXNjYWxlIHZhbHVlcy5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICovXG52YXIgUVJDb2RlV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFFSQ29kZVdyaXRlcigpIHtcbiAgICB9XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIC8vIHB1YmxpYyBlbmNvZGUoY29udGVudHM6IHN0cmluZywgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LCB3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pOiBCaXRNYXRyaXhcbiAgICAvLyAgICAgLyp0aHJvd3MgV3JpdGVyRXhjZXB0aW9uICovIHtcbiAgICAvLyAgIHJldHVybiBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgbnVsbClcbiAgICAvLyB9XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFFSQ29kZVdyaXRlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnRm91bmQgZW1wdHkgY29udGVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5RUl9DT0RFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQ2FuIG9ubHkgZW5jb2RlIFFSX0NPREUsIGJ1dCBnb3QgJyArIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdChcIlJlcXVlc3RlZCBkaW1lbnNpb25zIGFyZSB0b28gc21hbGw6IFwiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0Lkw7XG4gICAgICAgIHZhciBxdWlldFpvbmUgPSBRUkNvZGVXcml0ZXIuUVVJRVRfWk9ORV9TSVpFO1xuICAgICAgICBpZiAoaGludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTikpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsXzEuZGVmYXVsdC5mcm9tU3RyaW5nKGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1BUkdJTikpIHtcbiAgICAgICAgICAgICAgICBxdWlldFpvbmUgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5NQVJHSU4pLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IEVuY29kZXJfMS5kZWZhdWx0LmVuY29kZShjb250ZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgcmV0dXJuIFFSQ29kZVdyaXRlci5yZW5kZXJSZXN1bHQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVpZXRab25lKTtcbiAgICB9O1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgaW5wdXQgbWF0cml4IHVzZXMgMCA9PSB3aGl0ZSwgMSA9PSBibGFjaywgd2hpbGUgdGhlIG91dHB1dCBtYXRyaXggdXNlc1xuICAgIC8vIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICBRUkNvZGVXcml0ZXIucmVuZGVyUmVzdWx0ID0gZnVuY3Rpb24gKGNvZGUsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBxdWlldFpvbmUgLyppbnQqLykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb2RlLmdldE1hdHJpeCgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHFyV2lkdGggPSBpbnB1dFdpZHRoICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICB2YXIgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgdmFyIG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xuICAgICAgICB2YXIgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBxckhlaWdodCk7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xuICAgICAgICAvLyBQYWRkaW5nIGluY2x1ZGVzIGJvdGggdGhlIHF1aWV0IHpvbmUgYW5kIHRoZSBleHRyYSB3aGl0ZSBwaXhlbHMgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVlc3RlZFxuICAgICAgICAvLyBkaW1lbnNpb25zLiBGb3IgZXhhbXBsZSwgaWYgaW5wdXQgaXMgMjV4MjUgdGhlIFFSIHdpbGwgYmUgMzN4MzMgaW5jbHVkaW5nIHRoZSBxdWlldCB6b25lLlxuICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxuICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwYWRkaW5nIGZyb20gMTAweDEwMCAodGhlIGFjdHVhbCBRUikgdXAgdG8gMjAweDE2MC5cbiAgICAgICAgdmFyIGxlZnRQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgIHZhciBvdXRwdXQgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGNvbnRlbnRzIG9mIHRoaXMgcm93IG9mIHRoZSBiYXJjb2RlXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRSA9IDQ7XG4gICAgcmV0dXJuIFFSQ29kZVdyaXRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBRUkNvZGVXcml0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js":
/*!**************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Version_1 = __webpack_require__(/*! ./Version */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js\");\nvar FormatInformation_1 = __webpack_require__(/*! ./FormatInformation */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js\");\nvar DataMask_1 = __webpack_require__(/*! ./DataMask */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is not >= 21 and 1 mod 4\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 21 || (dimension & 0x03) !== 1) {\n            throw new FormatException_1.default();\n        }\n        this.bitMatrix = bitMatrix;\n    }\n    /**\n     * <p>Reads format information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link FormatInformation} encapsulating the QR Code's format info\n     * @throws FormatException if both format information locations cannot be parsed as\n     * the valid encoding of format information\n     */\n    BitMatrixParser.prototype.readFormatInformation = function () {\n        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n            return this.parsedFormatInfo;\n        }\n        // Read top-left format info bits\n        var formatInfoBits1 = 0;\n        for (var i = 0; i < 6; i++) {\n            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n        }\n        // .. and skip a bit in the timing pattern ...\n        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n        // .. and skip a bit in the timing pattern ...\n        for (var j = 5; j >= 0; j--) {\n            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n        }\n        // Read the top-right/bottom-left pattern too\n        var dimension = this.bitMatrix.getHeight();\n        var formatInfoBits2 = 0;\n        var jMin = dimension - 7;\n        for (var j = dimension - 1; j >= jMin; j--) {\n            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n        }\n        for (var i = dimension - 8; i < dimension; i++) {\n            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n        }\n        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n        if (this.parsedFormatInfo !== null) {\n            return this.parsedFormatInfo;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * <p>Reads version information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link Version} encapsulating the QR Code's version\n     * @throws FormatException if both version information locations cannot be parsed as\n     * the valid encoding of version information\n     */\n    BitMatrixParser.prototype.readVersion = function () {\n        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n            return this.parsedVersion;\n        }\n        var dimension = this.bitMatrix.getHeight();\n        var provisionalVersion = Math.floor((dimension - 17) / 4);\n        if (provisionalVersion <= 6) {\n            return Version_1.default.getVersionForNumber(provisionalVersion);\n        }\n        // Read top-right version info: 3 wide by 6 tall\n        var versionBits = 0;\n        var ijMin = dimension - 11;\n        for (var j = 5; j >= 0; j--) {\n            for (var i = dimension - 9; i >= ijMin; i--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        // Hmm, failed. Try bottom left: 6 wide by 3 tall\n        versionBits = 0;\n        for (var i = 5; i >= 0; i--) {\n            for (var j = dimension - 9; j >= ijMin; j--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        throw new FormatException_1.default();\n    };\n    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n     * correct order in order to reconstruct the codewords bytes contained within the\n     * QR Code.</p>\n     *\n     * @return bytes encoded within the QR Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var formatInfo = this.readFormatInformation();\n        var version = this.readVersion();\n        // Get the data mask for the format used in this QR Code. This will exclude\n        // some bits from reading as we wind through the bit matrix.\n        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        var functionPattern = version.buildFunctionPattern();\n        var readingUp = true;\n        var result = new Uint8Array(version.getTotalCodewords());\n        var resultOffset = 0;\n        var currentByte = 0;\n        var bitsRead = 0;\n        // Read columns in pairs, from right to left\n        for (var j = dimension - 1; j > 0; j -= 2) {\n            if (j === 6) {\n                // Skip whole column with vertical alignment pattern\n                // saves time and makes the other code proceed more cleanly\n                j--;\n            }\n            // Read alternatingly from bottom to top then top to bottom\n            for (var count = 0; count < dimension; count++) {\n                var i = readingUp ? dimension - 1 - count : count;\n                for (var col = 0; col < 2; col++) {\n                    // Ignore bits covered by the function pattern\n                    if (!functionPattern.get(j - col, i)) {\n                        // Read a bit\n                        bitsRead++;\n                        currentByte <<= 1;\n                        if (this.bitMatrix.get(j - col, i)) {\n                            currentByte |= 1;\n                        }\n                        // If we've made a whole byte, save it off\n                        if (bitsRead === 8) {\n                            result[resultOffset++] = /*(byte) */ currentByte;\n                            bitsRead = 0;\n                            currentByte = 0;\n                        }\n                    }\n                }\n            }\n            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n        }\n        if (resultOffset !== version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n     */\n    BitMatrixParser.prototype.remask = function () {\n        if (this.parsedFormatInfo === null) {\n            return; // We have no format information, and have no data mask\n        }\n        var dataMask = DataMask_1.default.values.get(this.parsedFormatInfo.getDataMask());\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    };\n    /**\n     * Prepare the parser for a mirrored operation.\n     * This flag has effect only on the {@link #readFormatInformation()} and the\n     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n     * {@link #mirror()} method should be called.\n     *\n     * @param mirror Whether to read version and format information mirrored.\n     */\n    BitMatrixParser.prototype.setMirror = function (isMirror) {\n        this.parsedVersion = null;\n        this.parsedFormatInfo = null;\n        this.isMirror = isMirror;\n    };\n    /** Mirror the bit matrix in order to attempt a second reading. */\n    BitMatrixParser.prototype.mirror = function () {\n        var bitMatrix = this.bitMatrix;\n        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                    bitMatrix.flip(y, x);\n                    bitMatrix.flip(x, y);\n                }\n            }\n        }\n    };\n    return BitMatrixParser;\n}());\nexports[\"default\"] = BitMatrixParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9CaXRNYXRyaXhQYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsOElBQVc7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsa0tBQXFCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGdKQUFZO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLG1KQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCLDJCQUEyQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQztBQUN6RSxRQUFRLHFCQUFxQiwwQkFBMEIsd0JBQXdCO0FBQy9FLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL0JpdE1hdHJpeFBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL1ZlcnNpb25cIik7XG52YXIgRm9ybWF0SW5mb3JtYXRpb25fMSA9IHJlcXVpcmUoXCIuL0Zvcm1hdEluZm9ybWF0aW9uXCIpO1xudmFyIERhdGFNYXNrXzEgPSByZXF1aXJlKFwiLi9EYXRhTWFza1wiKTtcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Gb3JtYXRFeGNlcHRpb25cIik7XG4vKipcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBCaXRNYXRyaXhQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJpdE1hdHJpeCB7QGxpbmsgQml0TWF0cml4fSB0byBwYXJzZVxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyBub3QgPj0gMjEgYW5kIDEgbW9kIDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaXRNYXRyaXhQYXJzZXIoYml0TWF0cml4KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGlmIChkaW1lbnNpb24gPCAyMSB8fCAoZGltZW5zaW9uICYgMHgwMykgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRNYXRyaXggPSBiaXRNYXRyaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPlJlYWRzIGZvcm1hdCBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAqXG4gICAgICogQHJldHVybiB7QGxpbmsgRm9ybWF0SW5mb3JtYXRpb259IGVuY2Fwc3VsYXRpbmcgdGhlIFFSIENvZGUncyBmb3JtYXQgaW5mb1xuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggZm9ybWF0IGluZm9ybWF0aW9uIGxvY2F0aW9ucyBjYW5ub3QgYmUgcGFyc2VkIGFzXG4gICAgICogdGhlIHZhbGlkIGVuY29kaW5nIG9mIGZvcm1hdCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZEZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsICYmIHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYWQgdG9wLWxlZnQgZm9ybWF0IGluZm8gYml0c1xuICAgICAgICB2YXIgZm9ybWF0SW5mb0JpdHMxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdChpLCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cbiAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDcsIDgsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgNywgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgLy8gLi4gYW5kIHNraXAgYSBiaXQgaW4gdGhlIHRpbWluZyBwYXR0ZXJuIC4uLlxuICAgICAgICBmb3IgKHZhciBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYWQgdGhlIHRvcC1yaWdodC9ib3R0b20tbGVmdCBwYXR0ZXJuIHRvb1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBmb3JtYXRJbmZvQml0czIgPSAwO1xuICAgICAgICB2YXIgak1pbiA9IGRpbWVuc2lvbiAtIDc7XG4gICAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSAxOyBqID49IGpNaW47IGotLSkge1xuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbWVuc2lvbiAtIDg7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMyID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb25fMS5kZWZhdWx0LmRlY29kZUZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm9CaXRzMSwgZm9ybWF0SW5mb0JpdHMyKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+UmVhZHMgdmVyc2lvbiBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxuICAgICAqXG4gICAgICogQHJldHVybiB7QGxpbmsgVmVyc2lvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIHZlcnNpb25cbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIHZlcnNpb24gaW5mb3JtYXRpb24gbG9jYXRpb25zIGNhbm5vdCBiZSBwYXJzZWQgYXNcbiAgICAgKiB0aGUgdmFsaWQgZW5jb2Rpbmcgb2YgdmVyc2lvbiBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgcHJvdmlzaW9uYWxWZXJzaW9uID0gTWF0aC5mbG9vcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XG4gICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24gPD0gNikge1xuICAgICAgICAgICAgcmV0dXJuIFZlcnNpb25fMS5kZWZhdWx0LmdldFZlcnNpb25Gb3JOdW1iZXIocHJvdmlzaW9uYWxWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHRvcC1yaWdodCB2ZXJzaW9uIGluZm86IDMgd2lkZSBieSA2IHRhbGxcbiAgICAgICAgdmFyIHZlcnNpb25CaXRzID0gMDtcbiAgICAgICAgdmFyIGlqTWluID0gZGltZW5zaW9uIC0gMTE7XG4gICAgICAgIGZvciAodmFyIGogPSA1OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRpbWVuc2lvbiAtIDk7IGkgPj0gaWpNaW47IGktLSkge1xuICAgICAgICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhlUGFyc2VkVmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyk7XG4gICAgICAgIGlmICh0aGVQYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoZVBhcnNlZFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gdGhlUGFyc2VkVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIbW0sIGZhaWxlZC4gVHJ5IGJvdHRvbSBsZWZ0OiA2IHdpZGUgYnkgMyB0YWxsXG4gICAgICAgIHZlcnNpb25CaXRzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gOTsgaiA+PSBpak1pbjsgai0tKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoZVBhcnNlZFZlcnNpb24gPSBWZXJzaW9uXzEuZGVmYXVsdC5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgICAgICBpZiAodGhlUGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGVQYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PT0gZGltZW5zaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICB9O1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUuY29weUJpdCA9IGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLywgdmVyc2lvbkJpdHMgLyppbnQqLykge1xuICAgICAgICB2YXIgYml0ID0gdGhpcy5pc01pcnJvciA/IHRoaXMuYml0TWF0cml4LmdldChqLCBpKSA6IHRoaXMuYml0TWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgcmV0dXJuIGJpdCA/ICh2ZXJzaW9uQml0cyA8PCAxKSB8IDB4MSA6IHZlcnNpb25CaXRzIDw8IDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5SZWFkcyB0aGUgYml0cyBpbiB0aGUge0BsaW5rIEJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIHRoZSBmaW5kZXIgcGF0dGVybiBpbiB0aGVcbiAgICAgKiBjb3JyZWN0IG9yZGVyIGluIG9yZGVyIHRvIHJlY29uc3RydWN0IHRoZSBjb2Rld29yZHMgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGVcbiAgICAgKiBRUiBDb2RlLjwvcD5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGlzIG5vdCByZWFkXG4gICAgICovXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZWFkQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm9ybWF0SW5mbyA9IHRoaXMucmVhZEZvcm1hdEluZm9ybWF0aW9uKCk7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbigpO1xuICAgICAgICAvLyBHZXQgdGhlIGRhdGEgbWFzayBmb3IgdGhlIGZvcm1hdCB1c2VkIGluIHRoaXMgUVIgQ29kZS4gVGhpcyB3aWxsIGV4Y2x1ZGVcbiAgICAgICAgLy8gc29tZSBiaXRzIGZyb20gcmVhZGluZyBhcyB3ZSB3aW5kIHRocm91Z2ggdGhlIGJpdCBtYXRyaXguXG4gICAgICAgIHZhciBkYXRhTWFzayA9IERhdGFNYXNrXzEuZGVmYXVsdC52YWx1ZXMuZ2V0KGZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKSk7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgZGF0YU1hc2sudW5tYXNrQml0TWF0cml4KHRoaXMuYml0TWF0cml4LCBkaW1lbnNpb24pO1xuICAgICAgICB2YXIgZnVuY3Rpb25QYXR0ZXJuID0gdmVyc2lvbi5idWlsZEZ1bmN0aW9uUGF0dGVybigpO1xuICAgICAgICB2YXIgcmVhZGluZ1VwID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSk7XG4gICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICB2YXIgYml0c1JlYWQgPSAwO1xuICAgICAgICAvLyBSZWFkIGNvbHVtbnMgaW4gcGFpcnMsIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gMTsgaiA+IDA7IGogLT0gMikge1xuICAgICAgICAgICAgaWYgKGogPT09IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdob2xlIGNvbHVtbiB3aXRoIHZlcnRpY2FsIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgLy8gc2F2ZXMgdGltZSBhbmQgbWFrZXMgdGhlIG90aGVyIGNvZGUgcHJvY2VlZCBtb3JlIGNsZWFubHlcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIGFsdGVybmF0aW5nbHkgZnJvbSBib3R0b20gdG8gdG9wIHRoZW4gdG9wIHRvIGJvdHRvbVxuICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IGRpbWVuc2lvbjsgY291bnQrKykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gcmVhZGluZ1VwID8gZGltZW5zaW9uIC0gMSAtIGNvdW50IDogY291bnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgMjsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGJpdHMgY292ZXJlZCBieSB0aGUgZnVuY3Rpb24gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uUGF0dGVybi5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgYSBiaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNSZWFkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdE1hdHJpeC5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgbWFkZSBhIHdob2xlIGJ5dGUsIHNhdmUgaXQgb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0c1JlYWQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gLyooYnl0ZSkgKi8gY3VycmVudEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1JlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHJlYWRpbmdVcCBePSB0cnVlOyAvLyByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyBzd2l0Y2ggZGlyZWN0aW9uc1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV2ZXJ0IHRoZSBtYXNrIHJlbW92YWwgZG9uZSB3aGlsZSByZWFkaW5nIHRoZSBjb2RlIHdvcmRzLiBUaGUgYml0IG1hdHJpeCBzaG91bGQgcmV2ZXJ0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKi9cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlbWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBoYXZlIG5vIGZvcm1hdCBpbmZvcm1hdGlvbiwgYW5kIGhhdmUgbm8gZGF0YSBtYXNrXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFNYXNrID0gRGF0YU1hc2tfMS5kZWZhdWx0LnZhbHVlcy5nZXQodGhpcy5wYXJzZWRGb3JtYXRJbmZvLmdldERhdGFNYXNrKCkpO1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHBhcnNlciBmb3IgYSBtaXJyb3JlZCBvcGVyYXRpb24uXG4gICAgICogVGhpcyBmbGFnIGhhcyBlZmZlY3Qgb25seSBvbiB0aGUge0BsaW5rICNyZWFkRm9ybWF0SW5mb3JtYXRpb24oKX0gYW5kIHRoZVxuICAgICAqIHtAbGluayAjcmVhZFZlcnNpb24oKX0uIEJlZm9yZSBwcm9jZWVkaW5nIHdpdGgge0BsaW5rICNyZWFkQ29kZXdvcmRzKCl9IHRoZVxuICAgICAqIHtAbGluayAjbWlycm9yKCl9IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pcnJvciBXaGV0aGVyIHRvIHJlYWQgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIG1pcnJvcmVkLlxuICAgICAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUuc2V0TWlycm9yID0gZnVuY3Rpb24gKGlzTWlycm9yKSB7XG4gICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNaXJyb3IgPSBpc01pcnJvcjtcbiAgICB9O1xuICAgIC8qKiBNaXJyb3IgdGhlIGJpdCBtYXRyaXggaW4gb3JkZXIgdG8gYXR0ZW1wdCBhIHNlY29uZCByZWFkaW5nLiAqL1xuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYml0TWF0cml4ID0gdGhpcy5iaXRNYXRyaXg7XG4gICAgICAgIGZvciAodmFyIHggPSAwLCB3aWR0aCA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHggKyAxLCBoZWlnaHQgPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0KHgsIHkpICE9PSBiaXRNYXRyaXguZ2V0KHksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHksIHgpO1xuICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguZmxpcCh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCaXRNYXRyaXhQYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQml0TWF0cml4UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n * is represented by an instance of this class.</p>\n *\n * @author Sean Owen\n */\nvar DataBlock = /** @class */ (function () {\n    function DataBlock(numDataCodewords /*int*/, codewords) {\n        this.numDataCodewords = numDataCodewords;\n        this.codewords = codewords;\n    }\n    /**\n     * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n     * method will separate the data into original blocks.</p>\n     *\n     * @param rawCodewords bytes as read directly from the QR Code\n     * @param version version of the QR Code\n     * @param ecLevel error-correction level of the QR Code\n     * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n     *         QR Code\n     */\n    DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {\n        var e_1, _a, e_2, _b;\n        if (rawCodewords.length !== version.getTotalCodewords()) {\n            throw new IllegalArgumentException_1.default();\n        }\n        // Figure out the number and size of data blocks used by this version and\n        // error correction level\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        // First count the total number of data blocks\n        var totalBlocks = 0;\n        var ecBlockArray = ecBlocks.getECBlocks();\n        try {\n            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\n                var ecBlock = ecBlockArray_1_1.value;\n                totalBlocks += ecBlock.getCount();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Now establish DataBlocks of the appropriate size and number of data codewords\n        var result = new Array(totalBlocks);\n        var numResultBlocks = 0;\n        try {\n            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\n                var ecBlock = ecBlockArray_2_1.value;\n                for (var i = 0; i < ecBlock.getCount(); i++) {\n                    var numDataCodewords = ecBlock.getDataCodewords();\n                    var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // All blocks have the same amount of data, except that the last n\n        // (where n may be 0) have 1 more byte. Figure out where these start.\n        var shorterBlocksTotalCodewords = result[0].codewords.length;\n        var longerBlocksStartAt = result.length - 1;\n        // TYPESCRIPTPORT: check length is correct here\n        while (longerBlocksStartAt >= 0) {\n            var numCodewords = result[longerBlocksStartAt].codewords.length;\n            if (numCodewords === shorterBlocksTotalCodewords) {\n                break;\n            }\n            longerBlocksStartAt--;\n        }\n        longerBlocksStartAt++;\n        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\n        // The last elements of result may be 1 element longer\n        // first fill out as many elements as all of them have\n        var rawCodewordsOffset = 0;\n        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n            for (var j = 0; j < numResultBlocks; j++) {\n                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n            }\n        }\n        // Fill out the last data block in the longer ones\n        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {\n            result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n        }\n        // Now add in error correction blocks\n        var max = result[0].codewords.length;\n        for (var i = shorterBlocksNumDataCodewords; i < max; i++) {\n            for (var j = 0; j < numResultBlocks; j++) {\n                var iOffset = j < longerBlocksStartAt ? i : i + 1;\n                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n            }\n        }\n        return result;\n    };\n    DataBlock.prototype.getNumDataCodewords = function () {\n        return this.numDataCodewords;\n    };\n    DataBlock.prototype.getCodewords = function () {\n        return this.codewords;\n    };\n    return DataBlock;\n}());\nexports[\"default\"] = DataBlock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9EYXRhQmxvY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csd0JBQXdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3Ryx3QkFBd0I7QUFDaEk7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0QsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RCw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL0RhdGFCbG9jay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGEgYmxvY2sgb2YgZGF0YSB3aXRoaW4gYSBRUiBDb2RlLiBRUiBDb2RlcyBtYXkgc3BsaXQgdGhlaXIgZGF0YSBpbnRvXG4gKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXG4gKiBpcyByZXByZXNlbnRlZCBieSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgRGF0YUJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzIC8qaW50Ki8sIGNvZGV3b3Jkcykge1xuICAgICAgICB0aGlzLm51bURhdGFDb2Rld29yZHMgPSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IGNvZGV3b3JkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+V2hlbiBRUiBDb2RlcyB1c2UgbXVsdGlwbGUgZGF0YSBibG9ja3MsIHRoZXkgYXJlIGFjdHVhbGx5IGludGVybGVhdmVkLlxuICAgICAqIFRoYXQgaXMsIHRoZSBmaXJzdCBieXRlIG9mIGRhdGEgYmxvY2sgMSB0byBuIGlzIHdyaXR0ZW4sIHRoZW4gdGhlIHNlY29uZCBieXRlcywgYW5kIHNvIG9uLiBUaGlzXG4gICAgICogbWV0aG9kIHdpbGwgc2VwYXJhdGUgdGhlIGRhdGEgaW50byBvcmlnaW5hbCBibG9ja3MuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhd0NvZGV3b3JkcyBieXRlcyBhcyByZWFkIGRpcmVjdGx5IGZyb20gdGhlIFFSIENvZGVcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIG9mIHRoZSBRUiBDb2RlXG4gICAgICogQHBhcmFtIGVjTGV2ZWwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbCBvZiB0aGUgUVIgQ29kZVxuICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcbiAgICAgKiAgICAgICAgIFFSIENvZGVcbiAgICAgKi9cbiAgICBEYXRhQmxvY2suZ2V0RGF0YUJsb2NrcyA9IGZ1bmN0aW9uIChyYXdDb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIGlmIChyYXdDb2Rld29yZHMubGVuZ3RoICE9PSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgbnVtYmVyIGFuZCBzaXplIG9mIGRhdGEgYmxvY2tzIHVzZWQgYnkgdGhpcyB2ZXJzaW9uIGFuZFxuICAgICAgICAvLyBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICAgIHZhciBlY0Jsb2NrcyA9IHZlcnNpb24uZ2V0RUNCbG9ja3NGb3JMZXZlbChlY0xldmVsKTtcbiAgICAgICAgLy8gRmlyc3QgY291bnQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIGJsb2Nrc1xuICAgICAgICB2YXIgdG90YWxCbG9ja3MgPSAwO1xuICAgICAgICB2YXIgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGVjQmxvY2tBcnJheV8xID0gX192YWx1ZXMoZWNCbG9ja0FycmF5KSwgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKTsgIWVjQmxvY2tBcnJheV8xXzEuZG9uZTsgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja0FycmF5XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0b3RhbEJsb2NrcyArPSBlY0Jsb2NrLmdldENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlY0Jsb2NrQXJyYXlfMV8xICYmICFlY0Jsb2NrQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gZWNCbG9ja0FycmF5XzEucmV0dXJuKSkgX2EuY2FsbChlY0Jsb2NrQXJyYXlfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XG4gICAgICAgIHZhciBudW1SZXN1bHRCbG9ja3MgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZWNCbG9ja0FycmF5XzIgPSBfX3ZhbHVlcyhlY0Jsb2NrQXJyYXkpLCBlY0Jsb2NrQXJyYXlfMl8xID0gZWNCbG9ja0FycmF5XzIubmV4dCgpOyAhZWNCbG9ja0FycmF5XzJfMS5kb25lOyBlY0Jsb2NrQXJyYXlfMl8xID0gZWNCbG9ja0FycmF5XzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjQmxvY2sgPSBlY0Jsb2NrQXJyYXlfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNCbG9jay5nZXRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHMgPSBlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUJsb2NrQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpICsgbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W251bVJlc3VsdEJsb2NrcysrXSA9IG5ldyBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcywgbmV3IFVpbnQ4QXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlY0Jsb2NrQXJyYXlfMl8xICYmICFlY0Jsb2NrQXJyYXlfMl8xLmRvbmUgJiYgKF9iID0gZWNCbG9ja0FycmF5XzIucmV0dXJuKSkgX2IuY2FsbChlY0Jsb2NrQXJyYXlfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gICAgICAgIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbW9yZSBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxuICAgICAgICB2YXIgc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgIHZhciBsb25nZXJCbG9ja3NTdGFydEF0ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBjaGVjayBsZW5ndGggaXMgY29ycmVjdCBoZXJlXG4gICAgICAgIHdoaWxlIChsb25nZXJCbG9ja3NTdGFydEF0ID49IDApIHtcbiAgICAgICAgICAgIHZhciBudW1Db2Rld29yZHMgPSByZXN1bHRbbG9uZ2VyQmxvY2tzU3RhcnRBdF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1Db2Rld29yZHMgPT09IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdC0tO1xuICAgICAgICB9XG4gICAgICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQrKztcbiAgICAgICAgdmFyIHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpO1xuICAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50cyBvZiByZXN1bHQgbWF5IGJlIDEgZWxlbWVudCBsb25nZXJcbiAgICAgICAgLy8gZmlyc3QgZmlsbCBvdXQgYXMgbWFueSBlbGVtZW50cyBhcyBhbGwgb2YgdGhlbSBoYXZlXG4gICAgICAgIHZhciByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xuICAgICAgICBmb3IgKHZhciBqID0gbG9uZ2VyQmxvY2tzU3RhcnRBdDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW3Nob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGFkZCBpbiBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrc1xuICAgICAgICB2YXIgbWF4ID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlPZmZzZXQgPSBqIDwgbG9uZ2VyQmxvY2tzU3RhcnRBdCA/IGkgOiBpICsgMTtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2lPZmZzZXRdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGF0YUJsb2NrLnByb3RvdHlwZS5nZXROdW1EYXRhQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1EYXRhQ29kZXdvcmRzO1xuICAgIH07XG4gICAgRGF0YUJsb2NrLnByb3RvdHlwZS5nZXRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICB9O1xuICAgIHJldHVybiBEYXRhQmxvY2s7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUJsb2NrO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataMaskValues = void 0;\nvar DataMaskValues;\n(function (DataMaskValues) {\n    DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));\n/**\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n * after the point they are unmasked anyway.</p>\n *\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n *\n * @author Sean Owen\n */\nvar DataMask = /** @class */ (function () {\n    // See ISO 18004:2006 6.8.1\n    function DataMask(value, isMasked) {\n        this.value = value;\n        this.isMasked = isMasked;\n    }\n    // End of enum constants.\n    /**\n     * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n     * make its bits ready to read.</p>\n     *\n     * @param bits representation of QR Code bits\n     * @param dimension dimension of QR Code, represented by bits, being unmasked\n     */\n    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\n        for (var i = 0; i < dimension; i++) {\n            for (var j = 0; j < dimension; j++) {\n                if (this.isMasked(i, j)) {\n                    bits.flip(j, i);\n                }\n            }\n        }\n    };\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\n    ]);\n    return DataMask;\n}());\nexports[\"default\"] = DataMask;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9EYXRhTWFzay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QyxzQkFBc0IsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsZ0NBQWdDO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCwwQkFBMEI7QUFDOUk7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILHFCQUFxQjtBQUN6STtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsMkJBQTJCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxnRUFBZ0U7QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsMkJBQTJCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILDJCQUEyQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxnREFBZ0Q7QUFDcEs7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9EYXRhTWFzay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhTWFza1ZhbHVlcyA9IHZvaWQgMDtcbnZhciBEYXRhTWFza1ZhbHVlcztcbihmdW5jdGlvbiAoRGF0YU1hc2tWYWx1ZXMpIHtcbiAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMDBcIl0gPSAwXSA9IFwiREFUQV9NQVNLXzAwMFwiO1xuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAwMVwiXSA9IDFdID0gXCJEQVRBX01BU0tfMDAxXCI7XG4gICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDEwXCJdID0gMl0gPSBcIkRBVEFfTUFTS18wMTBcIjtcbiAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTFcIl0gPSAzXSA9IFwiREFUQV9NQVNLXzAxMVwiO1xuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzEwMFwiXSA9IDRdID0gXCJEQVRBX01BU0tfMTAwXCI7XG4gICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTAxXCJdID0gNV0gPSBcIkRBVEFfTUFTS18xMDFcIjtcbiAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMTBcIl0gPSA2XSA9IFwiREFUQV9NQVNLXzExMFwiO1xuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzExMVwiXSA9IDddID0gXCJEQVRBX01BU0tfMTExXCI7XG59KShEYXRhTWFza1ZhbHVlcyA9IGV4cG9ydHMuRGF0YU1hc2tWYWx1ZXMgfHwgKGV4cG9ydHMuRGF0YU1hc2tWYWx1ZXMgPSB7fSkpO1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgZGF0YSBtYXNrcyBmb3IgdGhlIGRhdGEgYml0cyBpbiBhIFFSIGNvZGUsIHBlciBJU08gMTgwMDQ6MjAwNiA2LjguIEltcGxlbWVudGF0aW9uc1xuICogb2YgdGhpcyBjbGFzcyBjYW4gdW4tbWFzayBhIHJhdyBCaXRNYXRyaXguIEZvciBzaW1wbGljaXR5LCB0aGV5IHdpbGwgdW5tYXNrIHRoZSBlbnRpcmUgQml0TWF0cml4LFxuICogaW5jbHVkaW5nIGFyZWFzIHVzZWQgZm9yIGZpbmRlciBwYXR0ZXJucywgdGltaW5nIHBhdHRlcm5zLCBldGMuIFRoZXNlIGFyZWFzIHNob3VsZCBiZSB1bnVzZWRcbiAqIGFmdGVyIHRoZSBwb2ludCB0aGV5IGFyZSB1bm1hc2tlZCBhbnl3YXkuPC9wPlxuICpcbiAqIDxwPk5vdGUgdGhhdCB0aGUgZGlhZ3JhbSBpbiBzZWN0aW9uIDYuOC4xIGlzIG1pc2xlYWRpbmcgc2luY2UgaXQgaW5kaWNhdGVzIHRoYXQgaSBpcyBjb2x1bW4gcG9zaXRpb25cbiAqIGFuZCBqIGlzIHJvdyBwb3NpdGlvbi4gSW4gZmFjdCwgYXMgdGhlIHRleHQgc2F5cywgaSBpcyByb3cgcG9zaXRpb24gYW5kIGogaXMgY29sdW1uIHBvc2l0aW9uLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgRGF0YU1hc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VlIElTTyAxODAwNDoyMDA2IDYuOC4xXG4gICAgZnVuY3Rpb24gRGF0YU1hc2sodmFsdWUsIGlzTWFza2VkKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pc01hc2tlZCA9IGlzTWFza2VkO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZW51bSBjb25zdGFudHMuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHJldmVyc2UgdGhlIGRhdGEgbWFza2luZyBwcm9jZXNzIGFwcGxpZWQgdG8gYSBRUiBDb2RlIGFuZFxuICAgICAqIG1ha2UgaXRzIGJpdHMgcmVhZHkgdG8gcmVhZC48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYml0cyByZXByZXNlbnRhdGlvbiBvZiBRUiBDb2RlIGJpdHNcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGRpbWVuc2lvbiBvZiBRUiBDb2RlLCByZXByZXNlbnRlZCBieSBiaXRzLCBiZWluZyB1bm1hc2tlZFxuICAgICAqL1xuICAgIERhdGFNYXNrLnByb3RvdHlwZS51bm1hc2tCaXRNYXRyaXggPSBmdW5jdGlvbiAoYml0cywgZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdHMuZmxpcChqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFNYXNrLnZhbHVlcyA9IG5ldyBNYXAoW1xuICAgICAgICAvKipcbiAgICAgICAgICogMDAwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4ICsgeSkgbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAwLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuICgoaSArIGopICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAwMTogbWFzayBiaXRzIGZvciB3aGljaCB4IG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAxLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMSwgZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovKSB7IHJldHVybiAoaSAmIDB4MDEpID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMTA6IG1hc2sgYml0cyBmb3Igd2hpY2ggeSBtb2QgMyA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gaiAlIDMgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAxMTogbWFzayBiaXRzIGZvciB3aGljaCAoeCArIHkpIG1vZCAzID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDExLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMSwgZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovKSB7IHJldHVybiAoaSArIGopICUgMyA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTAwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4LzIgKyB5LzMpIG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMCwgZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovKSB7IHJldHVybiAoKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEwMTogbWFzayBiaXRzIGZvciB3aGljaCB4eSBtb2QgMiArIHh5IG1vZCAzID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgeHkgbW9kIDYgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAxLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuIChpICogaikgJSA2ID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMTA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHh5IG1vZCAyICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgeHkgbW9kIDYgPCAzXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChpICogaikgJSA2KSA8IDM7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDExMTogbWFzayBiaXRzIGZvciB3aGljaCAoKHgreSltb2QgMiArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0ICh4ICsgeSArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTEsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChpICsgaiArICgoaSAqIGopICUgMykpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICBdKTtcbiAgICByZXR1cm4gRGF0YU1hc2s7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YU1hc2s7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js":
/*!*********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar BitSource_1 = __webpack_require__(/*! ../../common/BitSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js\");\nvar CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\nvar DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\");\nvar StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\nvar Mode_1 = __webpack_require__(/*! ./Mode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var byteSegments = new Array(); // 1\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n        var symbolSequence = -1;\n        var parityData = -1;\n        try {\n            var currentCharacterSetECI = null;\n            var fc1InEffect = false;\n            var mode = void 0;\n            do {\n                // While still another segment to read...\n                if (bits.available() < 4) {\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                    mode = Mode_1.default.TERMINATOR;\n                }\n                else {\n                    var modeBits = bits.readBits(4);\n                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n                }\n                switch (mode) {\n                    case Mode_1.default.TERMINATOR:\n                        break;\n                    case Mode_1.default.FNC1_FIRST_POSITION:\n                    case Mode_1.default.FNC1_SECOND_POSITION:\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\n                        fc1InEffect = true;\n                        break;\n                    case Mode_1.default.STRUCTURED_APPEND:\n                        if (bits.available() < 16) {\n                            throw new FormatException_1.default();\n                        }\n                        // sequence number and parity is added later to the result metadata\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                        symbolSequence = bits.readBits(8);\n                        parityData = bits.readBits(8);\n                        break;\n                    case Mode_1.default.ECI:\n                        // Count doesn't apply to ECI\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\n                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n                        if (currentCharacterSetECI === null) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case Mode_1.default.HANZI:\n                        // First handle Hanzi mode which does not start with character count\n                        // Chinese mode contains a sub set indicator right after mode indicator\n                        var subset = bits.readBits(4);\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n                        }\n                        break;\n                    default:\n                        // \"Normal\" QR code modes:\n                        // How many characters will follow, encoded in this mode?\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\n                        switch (mode) {\n                            case Mode_1.default.NUMERIC:\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                                break;\n                            case Mode_1.default.ALPHANUMERIC:\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                break;\n                            case Mode_1.default.BYTE:\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                break;\n                            case Mode_1.default.KANJI:\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                                break;\n                            default:\n                                throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            } while (mode !== Mode_1.default.TERMINATOR);\n        }\n        catch (iae /*: IllegalArgumentException*/) {\n            // from readBits() calls\n            throw new FormatException_1.default();\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n    };\n    /**\n     * See specification GBT 18284-2000\n     */\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as GB2312 afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n            if (assembledTwoBytes < 0x003BF) {\n                // In the 0xA1A1 to 0xAAFE range\n                assembledTwoBytes += 0x0A1A1;\n            }\n            else {\n                // In the 0xB0A1 to 0xFAFE range\n                assembledTwoBytes += 0x0A6A1;\n            }\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n            offset += 2;\n            count--;\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as Shift_JIS afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n            if (assembledTwoBytes < 0x01F00) {\n                // In the 0x8140 to 0x9FFC range\n                assembledTwoBytes += 0x08140;\n            }\n            else {\n                // In the 0xE040 to 0xEBBF range\n                assembledTwoBytes += 0x0C140;\n            }\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n            offset += 2;\n            count--;\n        }\n        // Shift_JIS may not be supported in some environments:\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n        // Don't crash trying to read more bits than we have available.\n        if (8 * count > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        var readBytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            readBytes[i] = /*(byte) */ bits.readBits(8);\n        }\n        var encoding;\n        if (currentCharacterSetECI === null) {\n            // The spec isn't clear on this mode; see\n            // section 6.4.5: t does not say which encoding to assuming\n            // upon decoding. I have seen ISO-8859-1 used as well as\n            // Shift_JIS -- without anything like an ECI designator to\n            // give a hint.\n            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n        }\n        else {\n            encoding = currentCharacterSetECI.getName();\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(readBytes, encoding));\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n        byteSegments.push(readBytes);\n    };\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n            throw new FormatException_1.default();\n        }\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n    };\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n        // Read two characters at a time\n        var start = result.length();\n        while (count > 1) {\n            if (bits.available() < 11) {\n                throw new FormatException_1.default();\n            }\n            var nextTwoCharsBits = bits.readBits(11);\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n            count -= 2;\n        }\n        if (count === 1) {\n            // special case: one character left\n            if (bits.available() < 6) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n        }\n        // See section 6.4.8.1, 6.4.8.2\n        if (fc1InEffect) {\n            // We need to massage the result a bit if in an FNC1 mode:\n            for (var i = start; i < result.length(); i++) {\n                if (result.charAt(i) === '%') {\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                        // %% is rendered as %\n                        result.deleteCharAt(i + 1);\n                    }\n                    else {\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\n                        result.setCharAt(i, String.fromCharCode(0x1D));\n                    }\n                }\n            }\n        }\n    };\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n        // Read three digits at a time\n        while (count >= 3) {\n            // Each 10 bits encodes three digits\n            if (bits.available() < 10) {\n                throw new FormatException_1.default();\n            }\n            var threeDigitsBits = bits.readBits(10);\n            if (threeDigitsBits >= 1000) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n            count -= 3;\n        }\n        if (count === 2) {\n            // Two digits left over to read, encoded in 7 bits\n            if (bits.available() < 7) {\n                throw new FormatException_1.default();\n            }\n            var twoDigitsBits = bits.readBits(7);\n            if (twoDigitsBits >= 100) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n        }\n        else if (count === 1) {\n            // One digit left over to read\n            if (bits.available() < 4) {\n                throw new FormatException_1.default();\n            }\n            var digitBits = bits.readBits(4);\n            if (digitBits >= 10) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n        }\n    };\n    DecodedBitStreamParser.parseECIValue = function (bits) {\n        var firstByte = bits.readBits(8);\n        if ((firstByte & 0x80) === 0) {\n            // just one byte\n            return firstByte & 0x7F;\n        }\n        if ((firstByte & 0xC0) === 0x80) {\n            // two bytes\n            var secondByte = bits.readBits(8);\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n        }\n        if ((firstByte & 0xE0) === 0xC0) {\n            // three bytes\n            var secondThirdBytes = bits.readBits(16);\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\n    return DecodedBitStreamParser;\n}());\nexports[\"default\"] = DecodedBitStreamParser;\n// function Uint8ArrayToString(a: Uint8Array): string {\n//     const CHUNK_SZ = 0x8000;\n//     const c = new StringBuilder();\n//     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n//         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n//     }\n//     return c.toString();\n// }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9EZWNvZGVkQml0U3RyZWFtUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxxSkFBd0I7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMsaUtBQThCO0FBQzlELHNCQUFzQixtQkFBTyxDQUFDLDZKQUE0QjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDdEQsd0JBQXdCLG1CQUFPLENBQUMsbUpBQXVCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLHlKQUEwQjtBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQywySkFBMkI7QUFDMUQsYUFBYSxtQkFBTyxDQUFDLHdJQUFRO0FBQzdCLDhDQUE4QztBQUM5Qyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2RlY29kZXIvRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki9cbnZhciBCaXRTb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0U291cmNlXCIpO1xudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0lcIik7XG52YXIgRGVjb2RlclJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9EZWNvZGVyUmVzdWx0XCIpO1xudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xudmFyIFN0cmluZ0VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcbnZhciBNb2RlXzEgPSByZXF1aXJlKFwiLi9Nb2RlXCIpO1xuLyppbXBvcnQgamF2YS5pby5VbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uOyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbi8qKlxuICogPHA+UVIgQ29kZXMgY2FuIGVuY29kZSB0ZXh0IGFzIGJpdHMgaW4gb25lIG9mIHNldmVyYWwgbW9kZXMsIGFuZCBjYW4gdXNlIG11bHRpcGxlIG1vZGVzXG4gKiBpbiBvbmUgUVIgQ29kZS4gVGhpcyBjbGFzcyBkZWNvZGVzIHRoZSBiaXRzIGJhY2sgaW50byB0ZXh0LjwvcD5cbiAqXG4gKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4zIC0gNi40Ljc8L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcbiAgICB9XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIHZlcnNpb24sIGVjTGV2ZWwsIGhpbnRzKSB7XG4gICAgICAgIHZhciBiaXRzID0gbmV3IEJpdFNvdXJjZV8xLmRlZmF1bHQoYnl0ZXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHZhciBieXRlU2VnbWVudHMgPSBuZXcgQXJyYXkoKTsgLy8gMVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogSSBkbyBub3QgdXNlIGNvbnN0cnVjdG9yIHdpdGggc2l6ZSAxIGFzIGluIG9yaWdpbmFsIEphdmEgbWVhbnMgY2FwYWNpdHkgYW5kIHRoZSBhcnJheSBsZW5ndGggaXMgY2hlY2tlZCBiZWxvd1xuICAgICAgICB2YXIgc3ltYm9sU2VxdWVuY2UgPSAtMTtcbiAgICAgICAgdmFyIHBhcml0eURhdGEgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBmYzFJbkVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgc3RpbGwgYW5vdGhlciBzZWdtZW50IHRvIHJlYWQuLi5cbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT0ssIGFzc3VtZSB3ZSdyZSBkb25lLiBSZWFsbHksIGEgVEVSTUlOQVRPUiBtb2RlIHNob3VsZCBoYXZlIGJlZW4gcmVjb3JkZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZV8xLmRlZmF1bHQuVEVSTUlOQVRPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlQml0cyA9IGJpdHMucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlXzEuZGVmYXVsdC5mb3JCaXRzKG1vZGVCaXRzKTsgLy8gbW9kZSBpcyBlbmNvZGVkIGJ5IDQgYml0c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuRk5DMV9GSVJTVF9QT1NJVElPTjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5GTkMxX1NFQ09ORF9QT1NJVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIGxpdHRsZSB3aXRoIEZOQzEgZXhjZXB0IGFsdGVyIHRoZSBwYXJzZWQgcmVzdWx0IGEgYml0IGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMxSW5FZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuU1RSVUNUVVJFRF9BUFBFTkQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcXVlbmNlIG51bWJlciBhbmQgcGFyaXR5IGlzIGFkZGVkIGxhdGVyIHRvIHRoZSByZXN1bHQgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgbmV4dCA4IGJpdHMgKHN5bWJvbCBzZXF1ZW5jZSAjKSBhbmQgOCBiaXRzIChkYXRhOiBwYXJpdHkpLCB0aGVuIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xTZXF1ZW5jZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJpdHlEYXRhID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkVDSTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGRvZXNuJ3QgYXBwbHkgdG8gRUNJXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnBhcnNlRUNJVmFsdWUoYml0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkhBTlpJOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgaGFuZGxlIEhhbnppIG1vZGUgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBjaGFyYWN0ZXIgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoaW5lc2UgbW9kZSBjb250YWlucyBhIHN1YiBzZXQgaW5kaWNhdG9yIHJpZ2h0IGFmdGVyIG1vZGUgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2V0ID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudEhhbnppID0gYml0cy5yZWFkQml0cyhtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2V0ID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkdCMjMxMl9TVUJTRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUhhbnppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50SGFuemkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk5vcm1hbFwiIFFSIGNvZGUgbW9kZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgbWFueSBjaGFyYWN0ZXJzIHdpbGwgZm9sbG93LCBlbmNvZGVkIGluIHRoaXMgbW9kZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGJpdHMucmVhZEJpdHMobW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5OVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZU51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkFMUEhBTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQsIGZjMUluRWZmZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5CWVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUJ5dGVTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQsIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0ksIGJ5dGVTZWdtZW50cywgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LktBTkpJOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUthbmppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGVfMS5kZWZhdWx0LlRFUk1JTkFUT1IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpYWUgLyo6IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAvLyBmcm9tIHJlYWRCaXRzKCkgY2FsbHNcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyUmVzdWx0XzEuZGVmYXVsdChieXRlcywgcmVzdWx0LnRvU3RyaW5nKCksIGJ5dGVTZWdtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogYnl0ZVNlZ21lbnRzLCBlY0xldmVsID09PSBudWxsID8gbnVsbCA6IGVjTGV2ZWwudG9TdHJpbmcoKSwgc3ltYm9sU2VxdWVuY2UsIHBhcml0eURhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIHNwZWNpZmljYXRpb24gR0JUIDE4Mjg0LTIwMDBcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUhhbnppU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcbiAgICAgICAgLy8gYW5kIGRlY29kZSBhcyBHQjIzMTIgYWZ0ZXJ3YXJkc1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIGNvdW50KTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgICAgICAgdmFyIHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICAgICAgICB2YXIgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKCh0d29CeXRlcyAvIDB4MDYwKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgKHR3b0J5dGVzICUgMHgwNjApO1xuICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMDNCRikge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEExQTEgdG8gMHhBQUZFIHJhbmdlXG4gICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTFBMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEIwQTEgdG8gMHhGQUZFIHJhbmdlXG4gICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTZBMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KSAmIDB4RkYpO1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gLyooYnl0ZSkgKi8gKGFzc2VtYmxlZFR3b0J5dGVzICYgMHhGRik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5HQjIzMTIpKTtcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgR0IyMzEyIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoaWdub3JlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlS2FuamlTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xuICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlyc1xuICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIFNoaWZ0X0pJUyBhZnRlcndhcmRzXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSgyICogY291bnQpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gRWFjaCAxMyBiaXRzIGVuY29kZXMgYSAyLWJ5dGUgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YXIgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTtcbiAgICAgICAgICAgIHZhciBhc3NlbWJsZWRUd29CeXRlcyA9ICgoKHR3b0J5dGVzIC8gMHgwQzApIDw8IDgpICYgMHhGRkZGRkZGRikgfCAodHdvQnl0ZXMgJSAweDBDMCk7XG4gICAgICAgICAgICBpZiAoYXNzZW1ibGVkVHdvQnl0ZXMgPCAweDAxRjAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4ODE0MCB0byAweDlGRkMgcmFuZ2VcbiAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDA4MTQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4RTA0MCB0byAweEVCQkYgcmFuZ2VcbiAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBDMTQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAvKihieXRlKSAqLyAoYXNzZW1ibGVkVHdvQnl0ZXMgPj4gOCk7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAvKihieXRlKSAqLyBhc3NlbWJsZWRUd29CeXRlcztcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGlmdF9KSVMgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgaW4gc29tZSBlbnZpcm9ubWVudHM6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdC5kZWNvZGUoYnVmZmVyLCBTdHJpbmdVdGlsc18xLmRlZmF1bHQuU0hJRlRfSklTKSk7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogVE9ETzogaW1wbGVtZW50IFNISUZUX0pJUyBkZWNvZGUuIFN0cmluZ1ZpZXcgZnJvbSBNRE4gY291bGQgYmUgYSBzdGFydGluZyBwb2ludFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KGlnbm9yZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUJ5dGVTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLywgY3VycmVudENoYXJhY3RlclNldEVDSSwgYnl0ZVNlZ21lbnRzLCBoaW50cykge1xuICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKDggKiBjb3VudCA+IGJpdHMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZWFkQnl0ZXNbaV0gPSAvKihieXRlKSAqLyBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGluZztcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzcGVjIGlzbid0IGNsZWFyIG9uIHRoaXMgbW9kZTsgc2VlXG4gICAgICAgICAgICAvLyBzZWN0aW9uIDYuNC41OiB0IGRvZXMgbm90IHNheSB3aGljaCBlbmNvZGluZyB0byBhc3N1bWluZ1xuICAgICAgICAgICAgLy8gdXBvbiBkZWNvZGluZy4gSSBoYXZlIHNlZW4gSVNPLTg4NTktMSB1c2VkIGFzIHdlbGwgYXNcbiAgICAgICAgICAgIC8vIFNoaWZ0X0pJUyAtLSB3aXRob3V0IGFueXRoaW5nIGxpa2UgYW4gRUNJIGRlc2lnbmF0b3IgdG9cbiAgICAgICAgICAgIC8vIGdpdmUgYSBoaW50LlxuICAgICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ3Vlc3NFbmNvZGluZyhyZWFkQnl0ZXMsIGhpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gY3VycmVudENoYXJhY3RlclNldEVDSS5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShyZWFkQnl0ZXMsIGVuY29kaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoaWdub3JlZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVNlZ21lbnRzLnB1c2gocmVhZEJ5dGVzKTtcbiAgICB9O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHZhbHVlID49IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQUxQSEFOVU1FUklDX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BTFBIQU5VTUVSSUNfQ0hBUlNbdmFsdWVdO1xuICAgIH07XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLywgZmMxSW5FZmZlY3QpIHtcbiAgICAgICAgLy8gUmVhZCB0d28gY2hhcmFjdGVycyBhdCBhIHRpbWVcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVzdWx0Lmxlbmd0aCgpO1xuICAgICAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDExKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0VHdvQ2hhcnNCaXRzID0gYml0cy5yZWFkQml0cygxMSk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IobmV4dFR3b0NoYXJzQml0cyAvIDQ1KSkpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcihuZXh0VHdvQ2hhcnNCaXRzICUgNDUpKTtcbiAgICAgICAgICAgIGNvdW50IC09IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9uZSBjaGFyYWN0ZXIgbGVmdFxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoYml0cy5yZWFkQml0cyg2KSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBzZWN0aW9uIDYuNC44LjEsIDYuNC44LjJcbiAgICAgICAgaWYgKGZjMUluRWZmZWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1hc3NhZ2UgdGhlIHJlc3VsdCBhIGJpdCBpZiBpbiBhbiBGTkMxIG1vZGU6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCByZXN1bHQubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY2hhckF0KGkpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCByZXN1bHQubGVuZ3RoKCkgLSAxICYmIHJlc3VsdC5jaGFyQXQoaSArIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICUlIGlzIHJlbmRlcmVkIGFzICVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZWxldGVDaGFyQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gYWxwaGEgbW9kZSwgJSBzaG91bGQgYmUgY29udmVydGVkIHRvIEZOQzEgc2VwYXJhdG9yIDB4MURcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRDaGFyQXQoaSwgU3RyaW5nLmZyb21DaGFyQ29kZSgweDFEKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlTnVtZXJpY1NlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XG4gICAgICAgIC8vIFJlYWQgdGhyZWUgZGlnaXRzIGF0IGEgdGltZVxuICAgICAgICB3aGlsZSAoY291bnQgPj0gMykge1xuICAgICAgICAgICAgLy8gRWFjaCAxMCBiaXRzIGVuY29kZXMgdGhyZWUgZGlnaXRzXG4gICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aHJlZURpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDEwKTtcbiAgICAgICAgICAgIGlmICh0aHJlZURpZ2l0c0JpdHMgPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTAwKSkpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKHRocmVlRGlnaXRzQml0cyAvIDEwKSAlIDEwKSk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKHRocmVlRGlnaXRzQml0cyAlIDEwKSk7XG4gICAgICAgICAgICBjb3VudCAtPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgICAgLy8gVHdvIGRpZ2l0cyBsZWZ0IG92ZXIgdG8gcmVhZCwgZW5jb2RlZCBpbiA3IGJpdHNcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHdvRGlnaXRzQml0cyA9IGJpdHMucmVhZEJpdHMoNyk7XG4gICAgICAgICAgICBpZiAodHdvRGlnaXRzQml0cyA+PSAxMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKHR3b0RpZ2l0c0JpdHMgLyAxMCkpKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIodHdvRGlnaXRzQml0cyAlIDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIE9uZSBkaWdpdCBsZWZ0IG92ZXIgdG8gcmVhZFxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaWdpdEJpdHMgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgaWYgKGRpZ2l0Qml0cyA+PSAxMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKGRpZ2l0Qml0cykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnBhcnNlRUNJVmFsdWUgPSBmdW5jdGlvbiAoYml0cykge1xuICAgICAgICB2YXIgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8ganVzdCBvbmUgYnl0ZVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAmIDB4N0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgLy8gdHdvIGJ5dGVzXG4gICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICByZXR1cm4gKCgoZmlyc3RCeXRlICYgMHgzRikgPDwgOCkgJiAweEZGRkZGRkZGKSB8IHNlY29uZEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweEUwKSA9PT0gMHhDMCkge1xuICAgICAgICAgICAgLy8gdGhyZWUgYnl0ZXNcbiAgICAgICAgICAgIHZhciBzZWNvbmRUaGlyZEJ5dGVzID0gYml0cy5yZWFkQml0cygxNik7XG4gICAgICAgICAgICByZXR1cm4gKCgoZmlyc3RCeXRlICYgMHgxRikgPDwgMTYpICYgMHhGRkZGRkZGRikgfCBzZWNvbmRUaGlyZEJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC40IFRhYmxlIDVcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFMUEhBTlVNRVJJQ19DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzonO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuR0IyMzEyX1NVQlNFVCA9IDE7XG4gICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcbi8vIGZ1bmN0aW9uIFVpbnQ4QXJyYXlUb1N0cmluZyhhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbi8vICAgICBjb25zdCBDSFVOS19TWiA9IDB4ODAwMDtcbi8vICAgICBjb25zdCBjID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbi8vICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gQ0hVTktfU1opIHtcbi8vICAgICAgICAgYy5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhLnN1YmFycmF5KGksIGkgKyBDSFVOS19TWikpKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbi8vIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nvar BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\");\nvar BitMatrixParser_1 = __webpack_require__(/*! ./BitMatrixParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js\");\nvar DataBlock_1 = __webpack_require__(/*! ./DataBlock */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js\");\nvar DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js\");\nvar QRCodeDecoderMetaData_1 = __webpack_require__(/*! ./QRCodeDecoderMetaData */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js\");\n/*import java.util.Map;*/\n/**\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n * the QR Code from an image.</p>\n *\n * @author Sean Owen\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n    }\n    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(image, null)\n    // }\n    /**\n     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n     * \"true\" is taken to mean a black module.</p>\n     *\n     * @param image booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBooleanArray = function (image, hints) {\n        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n    };\n    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(bits, null)\n    // }\n    /**\n     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n     *\n     * @param bits booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n        // Construct a parser and read version, error-correction level\n        var parser = new BitMatrixParser_1.default(bits);\n        var ex = null;\n        try {\n            return this.decodeBitMatrixParser(parser, hints);\n        }\n        catch (e /*: FormatException, ChecksumException*/) {\n            ex = e;\n        }\n        try {\n            // Revert the bit matrix\n            parser.remask();\n            // Will be attempting a mirrored reading of the version and format info.\n            parser.setMirror(true);\n            // Preemptively read the version.\n            parser.readVersion();\n            // Preemptively read the format information.\n            parser.readFormatInformation();\n            /*\n             * Since we're here, this means we have successfully detected some kind\n             * of version and format information when mirrored. This is a good sign,\n             * that the QR code may be mirrored, and we should try once more with a\n             * mirrored content.\n             */\n            // Prepare for a mirrored reading.\n            parser.mirror();\n            var result = this.decodeBitMatrixParser(parser, hints);\n            // Success! Notify the caller that the code was mirrored.\n            result.setOther(new QRCodeDecoderMetaData_1.default(true));\n            return result;\n        }\n        catch (e /*FormatException | ChecksumException*/) {\n            // Throw the exception from the original reading\n            if (ex !== null) {\n                throw ex;\n            }\n            throw e;\n        }\n    };\n    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n        var e_1, _a, e_2, _b;\n        var version = parser.readVersion();\n        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n        // Read codewords\n        var codewords = parser.readCodewords();\n        // Separate into data blocks\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);\n        // Count total number of data bytes\n        var totalBytes = 0;\n        try {\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n                var dataBlock = dataBlocks_1_1.value;\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var resultBytes = new Uint8Array(totalBytes);\n        var resultOffset = 0;\n        try {\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n                var dataBlock = dataBlocks_2_1.value;\n                var codewordBytes = dataBlock.getCodewords();\n                var numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (var i = 0; i < numDataCodewords; i++) {\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // Decode the contents of that stream of bytes\n        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place using Reed-Solomon error correction.</p>\n     *\n     * @param codewordBytes data and error correction codewords\n     * @param numDataCodewords number of codewords that are data bytes\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\n        // const numCodewords = codewordBytes.length;\n        // First read into an array of ints\n        var codewordsInts = new Int32Array(codewordBytes);\n        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n        // const codewordsInts = new Int32Array(numCodewords)\n        // for (let i = 0; i < numCodewords; i++) {\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF\n        // }\n        try {\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n        }\n        catch (ignored /*: ReedSolomonException*/) {\n            throw new ChecksumException_1.default();\n        }\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\n        // We don't care about errors in the error-correction codewords\n        for (var i = 0; i < numDataCodewords; i++) {\n            codewordBytes[i] = /*(byte) */ codewordsInts[i];\n        }\n    };\n    return Decoder;\n}());\nexports[\"default\"] = Decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9EZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx1SkFBeUI7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMscUpBQXdCO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLDZLQUFvQztBQUM5RCwyQkFBMkIsbUJBQU8sQ0FBQywrTEFBNkM7QUFDaEYsd0JBQXdCLG1CQUFPLENBQUMsOEpBQW1CO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLGtKQUFhO0FBQ3ZDLCtCQUErQixtQkFBTyxDQUFDLDRLQUEwQjtBQUNqRSw4QkFBOEIsbUJBQU8sQ0FBQywwS0FBeUI7QUFDL0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csc0JBQXNCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxzQkFBc0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2RlY29kZXIvRGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki9cbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL0dlbmVyaWNHRlwiKTtcbnZhciBSZWVkU29sb21vbkRlY29kZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyXCIpO1xudmFyIEJpdE1hdHJpeFBhcnNlcl8xID0gcmVxdWlyZShcIi4vQml0TWF0cml4UGFyc2VyXCIpO1xudmFyIERhdGFCbG9ja18xID0gcmVxdWlyZShcIi4vRGF0YUJsb2NrXCIpO1xudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRCaXRTdHJlYW1QYXJzZXJcIik7XG52YXIgUVJDb2RlRGVjb2Rlck1ldGFEYXRhXzEgPSByZXF1aXJlKFwiLi9RUkNvZGVEZWNvZGVyTWV0YURhdGFcIik7XG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4vKipcbiAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgUVIgQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nXG4gKiB0aGUgUVIgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvZGVyKCkge1xuICAgICAgICB0aGlzLnJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXJfMS5kZWZhdWx0KEdlbmVyaWNHRl8xLmRlZmF1bHQuUVJfQ09ERV9GSUVMRF8yNTYpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBib29sZWFuW11bXSk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHtcbiAgICAvLyAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpXG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIDxwPkNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNhbiBkZWNvZGUgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEgMkQgYXJyYXkgb2YgYm9vbGVhbnMuXG4gICAgICogXCJ0cnVlXCIgaXMgdGFrZW4gdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2UgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIFFSIENvZGUgbW9kdWxlc1xuICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGluZyBoaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGluZmx1ZW5jZSBkZWNvZGluZ1xuICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIERlY29kZXIucHJvdG90eXBlLmRlY29kZUJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0TWF0cml4KEJpdE1hdHJpeF8xLmRlZmF1bHQucGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSwgaGludHMpO1xuICAgIH07XG4gICAgLy8gcHVibGljIGRlY29kZUJpdE1hdHJpeChiaXRzOiBCaXRNYXRyaXgpOiBEZWNvZGVyUmVzdWx0IC8qdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7XG4gICAgLy8gICByZXR1cm4gZGVjb2RlKGJpdHMsIG51bGwpXG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiaXRzIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXNcbiAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmdcbiAgICAgKiBAcmV0dXJuIHRleHQgYW5kIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgKi9cbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXRNYXRyaXggPSBmdW5jdGlvbiAoYml0cywgaGludHMpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgcGFyc2VyIGFuZCByZWFkIHZlcnNpb24sIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBCaXRNYXRyaXhQYXJzZXJfMS5kZWZhdWx0KGJpdHMpO1xuICAgICAgICB2YXIgZXggPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0TWF0cml4UGFyc2VyKHBhcnNlciwgaGludHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlIC8qOiBGb3JtYXRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIGV4ID0gZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBiaXQgbWF0cml4XG4gICAgICAgICAgICBwYXJzZXIucmVtYXNrKCk7XG4gICAgICAgICAgICAvLyBXaWxsIGJlIGF0dGVtcHRpbmcgYSBtaXJyb3JlZCByZWFkaW5nIG9mIHRoZSB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mby5cbiAgICAgICAgICAgIHBhcnNlci5zZXRNaXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAvLyBQcmVlbXB0aXZlbHkgcmVhZCB0aGUgdmVyc2lvbi5cbiAgICAgICAgICAgIHBhcnNlci5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gUHJlZW1wdGl2ZWx5IHJlYWQgdGhlIGZvcm1hdCBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgIHBhcnNlci5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTaW5jZSB3ZSdyZSBoZXJlLCB0aGlzIG1lYW5zIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGRldGVjdGVkIHNvbWUga2luZFxuICAgICAgICAgICAgICogb2YgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIHdoZW4gbWlycm9yZWQuIFRoaXMgaXMgYSBnb29kIHNpZ24sXG4gICAgICAgICAgICAgKiB0aGF0IHRoZSBRUiBjb2RlIG1heSBiZSBtaXJyb3JlZCwgYW5kIHdlIHNob3VsZCB0cnkgb25jZSBtb3JlIHdpdGggYVxuICAgICAgICAgICAgICogbWlycm9yZWQgY29udGVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBmb3IgYSBtaXJyb3JlZCByZWFkaW5nLlxuICAgICAgICAgICAgcGFyc2VyLm1pcnJvcigpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGVjb2RlQml0TWF0cml4UGFyc2VyKHBhcnNlciwgaGludHMpO1xuICAgICAgICAgICAgLy8gU3VjY2VzcyEgTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCB0aGUgY29kZSB3YXMgbWlycm9yZWQuXG4gICAgICAgICAgICByZXN1bHQuc2V0T3RoZXIobmV3IFFSQ29kZURlY29kZXJNZXRhRGF0YV8xLmRlZmF1bHQodHJ1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSAvKkZvcm1hdEV4Y2VwdGlvbiB8IENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIC8vIFRocm93IHRoZSBleGNlcHRpb24gZnJvbSB0aGUgb3JpZ2luYWwgcmVhZGluZ1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXRNYXRyaXhQYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyLCBoaW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBwYXJzZXIucmVhZFZlcnNpb24oKTtcbiAgICAgICAgdmFyIGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTtcbiAgICAgICAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG4gICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcbiAgICAgICAgdmFyIGRhdGFCbG9ja3MgPSBEYXRhQmxvY2tfMS5kZWZhdWx0LmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKTtcbiAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZGF0YUJsb2Nrc18xID0gX192YWx1ZXMoZGF0YUJsb2NrcyksIGRhdGFCbG9ja3NfMV8xID0gZGF0YUJsb2Nrc18xLm5leHQoKTsgIWRhdGFCbG9ja3NfMV8xLmRvbmU7IGRhdGFCbG9ja3NfMV8xID0gZGF0YUJsb2Nrc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzICs9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhQmxvY2tzXzFfMSAmJiAhZGF0YUJsb2Nrc18xXzEuZG9uZSAmJiAoX2EgPSBkYXRhQmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChkYXRhQmxvY2tzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICB2YXIgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgZm9yICh2YXIgZGF0YUJsb2Nrc18yID0gX192YWx1ZXMoZGF0YUJsb2NrcyksIGRhdGFCbG9ja3NfMl8xID0gZGF0YUJsb2Nrc18yLm5leHQoKTsgIWRhdGFCbG9ja3NfMl8xLmRvbmU7IGRhdGFCbG9ja3NfMl8xID0gZGF0YUJsb2Nrc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmRCeXRlcyA9IGRhdGFCbG9jay5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW3Jlc3VsdE9mZnNldCsrXSA9IGNvZGV3b3JkQnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUJsb2Nrc18yXzEgJiYgIWRhdGFCbG9ja3NfMl8xLmRvbmUgJiYgKF9iID0gZGF0YUJsb2Nrc18yLnJldHVybikpIF9iLmNhbGwoZGF0YUJsb2Nrc18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGUgdGhlIGNvbnRlbnRzIG9mIHRoYXQgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEuZGVmYXVsdC5kZWNvZGUocmVzdWx0Qnl0ZXMsIHZlcnNpb24sIGVjTGV2ZWwsIGhpbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZSB1c2luZyBSZWVkLVNvbG9tb24gZXJyb3IgY29ycmVjdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAqIEBwYXJhbSBudW1EYXRhQ29kZXdvcmRzIG51bWJlciBvZiBjb2Rld29yZHMgdGhhdCBhcmUgZGF0YSBieXRlc1xuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAqL1xuICAgIERlY29kZXIucHJvdG90eXBlLmNvcnJlY3RFcnJvcnMgPSBmdW5jdGlvbiAoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3JkcyAvKmludCovKSB7XG4gICAgICAgIC8vIGNvbnN0IG51bUNvZGV3b3JkcyA9IGNvZGV3b3JkQnl0ZXMubGVuZ3RoO1xuICAgICAgICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgICAgICB2YXIgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogbm90IHJlYWx5IG5lY2Vzc2FyeSB0byB0cmFuc2Zvcm0gdG8gaW50cz8gY291bGQgcmVkZXNpZ24gZXZlcnl0aGluZyB0byB3b3JrIHdpdGggdW5zaWduZWQgYnl0ZXM/XG4gICAgICAgIC8vIGNvbnN0IGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShudW1Db2Rld29yZHMpXG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgLy8gICBjb2Rld29yZHNJbnRzW2ldID0gY29kZXdvcmRCeXRlc1tpXSAmIDB4RkZcbiAgICAgICAgLy8gfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFJlZWRTb2xvbW9uRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXG4gICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgY29kZXdvcmRCeXRlc1tpXSA9IC8qKGJ5dGUpICovIGNvZGV3b3Jkc0ludHNbaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n * This includes the number of data codewords, and the number of times a block with these\n * parameters is used consecutively in the QR code version's format.</p>\n */\nvar ECB = /** @class */ (function () {\n    function ECB(count /*int*/, dataCodewords /*int*/) {\n        this.count = count;\n        this.dataCodewords = dataCodewords;\n    }\n    ECB.prototype.getCount = function () {\n        return this.count;\n    };\n    ECB.prototype.getDataCodewords = function () {\n        return this.dataCodewords;\n    };\n    return ECB;\n}());\nexports[\"default\"] = ECB;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9FQ0IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9FQ0IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3Igb25lIGVycm9yLWNvcnJlY3Rpb24gYmxvY2sgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLlxuICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcbiAqIHBhcmFtZXRlcnMgaXMgdXNlZCBjb25zZWN1dGl2ZWx5IGluIHRoZSBRUiBjb2RlIHZlcnNpb24ncyBmb3JtYXQuPC9wPlxuICovXG52YXIgRUNCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVDQihjb3VudCAvKmludCovLCBkYXRhQ29kZXdvcmRzIC8qaW50Ki8pIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLmRhdGFDb2Rld29yZHMgPSBkYXRhQ29kZXdvcmRzO1xuICAgIH1cbiAgICBFQ0IucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICB9O1xuICAgIEVDQi5wcm90b3R5cGUuZ2V0RGF0YUNvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcbiAgICB9O1xuICAgIHJldHVybiBFQ0I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRUNCO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n * each set of blocks. It also holds the number of error-correction codewords per block since it\n * will be the same across all blocks within one version.</p>\n */\nvar ECBlocks = /** @class */ (function () {\n    function ECBlocks(ecCodewordsPerBlock /*int*/) {\n        var ecBlocks = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            ecBlocks[_i - 1] = arguments[_i];\n        }\n        this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n        this.ecBlocks = ecBlocks;\n    }\n    ECBlocks.prototype.getECCodewordsPerBlock = function () {\n        return this.ecCodewordsPerBlock;\n    };\n    ECBlocks.prototype.getNumBlocks = function () {\n        var e_1, _a;\n        var total = 0;\n        var ecBlocks = this.ecBlocks;\n        try {\n            for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {\n                var ecBlock = ecBlocks_1_1.value;\n                total += ecBlock.getCount();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return total;\n    };\n    ECBlocks.prototype.getTotalECCodewords = function () {\n        return this.ecCodewordsPerBlock * this.getNumBlocks();\n    };\n    ECBlocks.prototype.getECBlocks = function () {\n        return this.ecBlocks;\n    };\n    return ECBlocks;\n}());\nexports[\"default\"] = ECBlocks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9FQ0Jsb2Nrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG9CQUFvQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL0VDQmxvY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBzZXQgb2YgZXJyb3ItY29ycmVjdGlvbiBibG9ja3MgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLiBNb3N0IHZlcnNpb25zIHdpbGxcbiAqIHVzZSBibG9ja3Mgb2YgZGlmZmVyaW5nIHNpemVzIHdpdGhpbiBvbmUgdmVyc2lvbiwgc28sIHRoaXMgZW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvclxuICogZWFjaCBzZXQgb2YgYmxvY2tzLiBJdCBhbHNvIGhvbGRzIHRoZSBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcGVyIGJsb2NrIHNpbmNlIGl0XG4gKiB3aWxsIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYmxvY2tzIHdpdGhpbiBvbmUgdmVyc2lvbi48L3A+XG4gKi9cbnZhciBFQ0Jsb2NrcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFQ0Jsb2NrcyhlY0NvZGV3b3Jkc1BlckJsb2NrIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBlY0Jsb2Nrc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2sgPSBlY0NvZGV3b3Jkc1BlckJsb2NrO1xuICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgfVxuICAgIEVDQmxvY2tzLnByb3RvdHlwZS5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrO1xuICAgIH07XG4gICAgRUNCbG9ja3MucHJvdG90eXBlLmdldE51bUJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIHZhciBlY0Jsb2NrcyA9IHRoaXMuZWNCbG9ja3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2Nrc18xID0gX192YWx1ZXMoZWNCbG9ja3MpLCBlY0Jsb2Nrc18xXzEgPSBlY0Jsb2Nrc18xLm5leHQoKTsgIWVjQmxvY2tzXzFfMS5kb25lOyBlY0Jsb2Nrc18xXzEgPSBlY0Jsb2Nrc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVjQmxvY2tzXzFfMSAmJiAhZWNCbG9ja3NfMV8xLmRvbmUgJiYgKF9hID0gZWNCbG9ja3NfMS5yZXR1cm4pKSBfYS5jYWxsKGVjQmxvY2tzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9O1xuICAgIEVDQmxvY2tzLnByb3RvdHlwZS5nZXRUb3RhbEVDQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrICogdGhpcy5nZXROdW1CbG9ja3MoKTtcbiAgICB9O1xuICAgIEVDQmxvY2tzLnByb3RvdHlwZS5nZXRFQ0Jsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XG4gICAgfTtcbiAgICByZXR1cm4gRUNCbG9ja3M7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRUNCbG9ja3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorCorrectionLevelValues = void 0;\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar ArgumentException_1 = __webpack_require__(/*! ../../ArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ErrorCorrectionLevelValues;\n(function (ErrorCorrectionLevelValues) {\n    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"L\"] = 0] = \"L\";\n    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"M\"] = 1] = \"M\";\n    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"Q\"] = 2] = \"Q\";\n    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"H\"] = 3] = \"H\";\n})(ErrorCorrectionLevelValues = exports.ErrorCorrectionLevelValues || (exports.ErrorCorrectionLevelValues = {}));\n/**\n * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels\n * defined by the QR code standard.</p>\n *\n * @author Sean Owen\n */\nvar ErrorCorrectionLevel = /** @class */ (function () {\n    function ErrorCorrectionLevel(value, stringValue, bits /*int*/) {\n        this.value = value;\n        this.stringValue = stringValue;\n        this.bits = bits;\n        ErrorCorrectionLevel.FOR_BITS.set(bits, this);\n        ErrorCorrectionLevel.FOR_VALUE.set(value, this);\n    }\n    ErrorCorrectionLevel.prototype.getValue = function () {\n        return this.value;\n    };\n    ErrorCorrectionLevel.prototype.getBits = function () {\n        return this.bits;\n    };\n    ErrorCorrectionLevel.fromString = function (s) {\n        switch (s) {\n            case 'L': return ErrorCorrectionLevel.L;\n            case 'M': return ErrorCorrectionLevel.M;\n            case 'Q': return ErrorCorrectionLevel.Q;\n            case 'H': return ErrorCorrectionLevel.H;\n            default: throw new ArgumentException_1.default(s + 'not available');\n        }\n    };\n    ErrorCorrectionLevel.prototype.toString = function () {\n        return this.stringValue;\n    };\n    ErrorCorrectionLevel.prototype.equals = function (o) {\n        if (!(o instanceof ErrorCorrectionLevel)) {\n            return false;\n        }\n        var other = o;\n        return this.value === other.value;\n    };\n    /**\n     * @param bits int containing the two bits encoding a QR Code's error correction level\n     * @return ErrorCorrectionLevel representing the encoded error correction level\n     */\n    ErrorCorrectionLevel.forBits = function (bits /*int*/) {\n        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return ErrorCorrectionLevel.FOR_BITS.get(bits);\n    };\n    ErrorCorrectionLevel.FOR_BITS = new Map();\n    ErrorCorrectionLevel.FOR_VALUE = new Map();\n    /** L = ~7% correction */\n    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);\n    /** M = ~15% correction */\n    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);\n    /** Q = ~25% correction */\n    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);\n    /** H = ~30% correction */\n    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);\n    return ErrorCorrectionLevel;\n}());\nexports[\"default\"] = ErrorCorrectionLevel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9FcnJvckNvcnJlY3Rpb25MZXZlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0M7QUFDbEMsNkNBQTZDO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRCxpQ0FBaUMsbUJBQU8sQ0FBQyxxS0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0Usa0NBQWtDLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL0Vycm9yQ29ycmVjdGlvbkxldmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzID0gdm9pZCAwO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki9cbnZhciBBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0FyZ3VtZW50RXhjZXB0aW9uXCIpO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbnZhciBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcztcbihmdW5jdGlvbiAoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMpIHtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkxcIl0gPSAwXSA9IFwiTFwiO1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiTVwiXSA9IDFdID0gXCJNXCI7XG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJRXCJdID0gMl0gPSBcIlFcIjtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkhcIl0gPSAzXSA9IFwiSFwiO1xufSkoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgPSBleHBvcnRzLkVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzIHx8IChleHBvcnRzLkVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzID0ge30pKTtcbi8qKlxuICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjUuMS4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgZm91ciBlcnJvciBjb3JyZWN0aW9uIGxldmVsc1xuICogZGVmaW5lZCBieSB0aGUgUVIgY29kZSBzdGFuZGFyZC48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbkxldmVsKHZhbHVlLCBzdHJpbmdWYWx1ZSwgYml0cyAvKmludCovKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5zZXQoYml0cywgdGhpcyk7XG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRS5zZXQodmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgfTtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICBjYXNlICdMJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBjYXNlICdNJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLk07XG4gICAgICAgICAgICBjYXNlICdRJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLlE7XG4gICAgICAgICAgICBjYXNlICdIJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkg7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KHMgKyAnbm90IGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZ1ZhbHVlO1xuICAgIH07XG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBFcnJvckNvcnJlY3Rpb25MZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYml0cyBpbnQgY29udGFpbmluZyB0aGUgdHdvIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlJ3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAqIEByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgKi9cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JCaXRzID0gZnVuY3Rpb24gKGJpdHMgLyppbnQqLykge1xuICAgICAgICBpZiAoYml0cyA8IDAgfHwgYml0cyA+PSBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5nZXQoYml0cyk7XG4gICAgfTtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUyA9IG5ldyBNYXAoKTtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7XG4gICAgLyoqIEwgPSB+NyUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkwgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuTCwgJ0wnLCAweDAxKTtcbiAgICAvKiogTSA9IH4xNSUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLk0gPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuTSwgJ00nLCAweDAwKTtcbiAgICAvKiogUSA9IH4yNSUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLlEgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuUSwgJ1EnLCAweDAzKTtcbiAgICAvKiogSCA9IH4zMCUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkggPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuSCwgJ0gnLCAweDAyKTtcbiAgICByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js":
/*!****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js ***!
  \****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar ErrorCorrectionLevel_1 = __webpack_require__(/*! ./ErrorCorrectionLevel */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\n/**\n * <p>Encapsulates a QR Code's format information, including the data mask used and\n * error correction level.</p>\n *\n * @author Sean Owen\n * @see DataMask\n * @see ErrorCorrectionLevel\n */\nvar FormatInformation = /** @class */ (function () {\n    function FormatInformation(formatInfo /*int*/) {\n        // Bits 3,4\n        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);\n        // Bottom 3 bits\n        this.dataMask = /*(byte) */ (formatInfo & 0x07);\n    }\n    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {\n        return Integer_1.default.bitCount(a ^ b);\n    };\n    /**\n     * @param maskedFormatInfo1 format info indicator, with mask still applied\n     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\n     *  to establish best match\n     * @return information about the format it specifies, or {@code null}\n     *  if doesn't seem to match any known pattern\n     */\n    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n        if (formatInfo !== null) {\n            return formatInfo;\n        }\n        // Should return null, but, some QR codes apparently\n        // do not mask this info. Try again by actually masking the pattern\n        // first\n        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n    };\n    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n        var e_1, _a;\n        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n        var bestDifference = Number.MAX_SAFE_INTEGER;\n        var bestFormatInfo = 0;\n        try {\n            for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var decodeInfo = _c.value;\n                var targetInfo = decodeInfo[0];\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n                    // Found an exact match\n                    return new FormatInformation(decodeInfo[1]);\n                }\n                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n                if (bitsDifference < bestDifference) {\n                    bestFormatInfo = decodeInfo[1];\n                    bestDifference = bitsDifference;\n                }\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\n                    // also try the other option\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n                    if (bitsDifference < bestDifference) {\n                        bestFormatInfo = decodeInfo[1];\n                        bestDifference = bitsDifference;\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n        // differing means we found a match\n        if (bestDifference <= 3) {\n            return new FormatInformation(bestFormatInfo);\n        }\n        return null;\n    };\n    FormatInformation.prototype.getErrorCorrectionLevel = function () {\n        return this.errorCorrectionLevel;\n    };\n    FormatInformation.prototype.getDataMask = function () {\n        return this.dataMask;\n    };\n    /*@Override*/\n    FormatInformation.prototype.hashCode = function () {\n        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;\n    };\n    /*@Override*/\n    FormatInformation.prototype.equals = function (o) {\n        if (!(o instanceof FormatInformation)) {\n            return false;\n        }\n        var other = o;\n        return this.errorCorrectionLevel === other.errorCorrectionLevel &&\n            this.dataMask === other.dataMask;\n    };\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n    /**\n     * See ISO 18004:2006, Annex C, Table C.1\n     */\n    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\n        Int32Array.from([0x5412, 0x00]),\n        Int32Array.from([0x5125, 0x01]),\n        Int32Array.from([0x5E7C, 0x02]),\n        Int32Array.from([0x5B4B, 0x03]),\n        Int32Array.from([0x45F9, 0x04]),\n        Int32Array.from([0x40CE, 0x05]),\n        Int32Array.from([0x4F97, 0x06]),\n        Int32Array.from([0x4AA0, 0x07]),\n        Int32Array.from([0x77C4, 0x08]),\n        Int32Array.from([0x72F3, 0x09]),\n        Int32Array.from([0x7DAA, 0x0A]),\n        Int32Array.from([0x789D, 0x0B]),\n        Int32Array.from([0x662F, 0x0C]),\n        Int32Array.from([0x6318, 0x0D]),\n        Int32Array.from([0x6C41, 0x0E]),\n        Int32Array.from([0x6976, 0x0F]),\n        Int32Array.from([0x1689, 0x10]),\n        Int32Array.from([0x13BE, 0x11]),\n        Int32Array.from([0x1CE7, 0x12]),\n        Int32Array.from([0x19D0, 0x13]),\n        Int32Array.from([0x0762, 0x14]),\n        Int32Array.from([0x0255, 0x15]),\n        Int32Array.from([0x0D0C, 0x16]),\n        Int32Array.from([0x083B, 0x17]),\n        Int32Array.from([0x355F, 0x18]),\n        Int32Array.from([0x3068, 0x19]),\n        Int32Array.from([0x3F31, 0x1A]),\n        Int32Array.from([0x3A06, 0x1B]),\n        Int32Array.from([0x24B4, 0x1C]),\n        Int32Array.from([0x2183, 0x1D]),\n        Int32Array.from([0x2EDA, 0x1E]),\n        Int32Array.from([0x2BED, 0x1F]),\n    ];\n    return FormatInformation;\n}());\nexports[\"default\"] = FormatInformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9Gb3JtYXRJbmZvcm1hdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2Q0FBNkM7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsd0tBQXdCO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDZJQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxVQUFVO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9Gb3JtYXRJbmZvcm1hdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki9cbnZhciBFcnJvckNvcnJlY3Rpb25MZXZlbF8xID0gcmVxdWlyZShcIi4vRXJyb3JDb3JyZWN0aW9uTGV2ZWxcIik7XG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGEgUVIgQ29kZSdzIGZvcm1hdCBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIHRoZSBkYXRhIG1hc2sgdXNlZCBhbmRcbiAqIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAc2VlIERhdGFNYXNrXG4gKiBAc2VlIEVycm9yQ29ycmVjdGlvbkxldmVsXG4gKi9cbnZhciBGb3JtYXRJbmZvcm1hdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gQml0cyAzLDRcbiAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsXzEuZGVmYXVsdC5mb3JCaXRzKChmb3JtYXRJbmZvID4+IDMpICYgMHgwMyk7XG4gICAgICAgIC8vIEJvdHRvbSAzIGJpdHNcbiAgICAgICAgdGhpcy5kYXRhTWFzayA9IC8qKGJ5dGUpICovIChmb3JtYXRJbmZvICYgMHgwNyk7XG4gICAgfVxuICAgIEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXJfMS5kZWZhdWx0LmJpdENvdW50KGEgXiBiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMSBmb3JtYXQgaW5mbyBpbmRpY2F0b3IsIHdpdGggbWFzayBzdGlsbCBhcHBsaWVkXG4gICAgICogQHBhcmFtIG1hc2tlZEZvcm1hdEluZm8yIHNlY29uZCBjb3B5IG9mIHNhbWUgaW5mbzsgYm90aCBhcmUgY2hlY2tlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICogIHRvIGVzdGFibGlzaCBiZXN0IG1hdGNoXG4gICAgICogQHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9ybWF0IGl0IHNwZWNpZmllcywgb3Ige0Bjb2RlIG51bGx9XG4gICAgICogIGlmIGRvZXNuJ3Qgc2VlbSB0byBtYXRjaCBhbnkga25vd24gcGF0dGVyblxuICAgICAqL1xuICAgIEZvcm1hdEluZm9ybWF0aW9uLmRlY29kZUZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKG1hc2tlZEZvcm1hdEluZm8xIC8qaW50Ki8sIG1hc2tlZEZvcm1hdEluZm8yIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8xLCBtYXNrZWRGb3JtYXRJbmZvMik7XG4gICAgICAgIGlmIChmb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SW5mbztcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIG51bGwsIGJ1dCwgc29tZSBRUiBjb2RlcyBhcHBhcmVudGx5XG4gICAgICAgIC8vIGRvIG5vdCBtYXNrIHRoaXMgaW5mby4gVHJ5IGFnYWluIGJ5IGFjdHVhbGx5IG1hc2tpbmcgdGhlIHBhdHRlcm5cbiAgICAgICAgLy8gZmlyc3RcbiAgICAgICAgcmV0dXJuIEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgXiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSLCBtYXNrZWRGb3JtYXRJbmZvMiBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIpO1xuICAgIH07XG4gICAgRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uIChtYXNrZWRGb3JtYXRJbmZvMSAvKmludCovLCBtYXNrZWRGb3JtYXRJbmZvMiAvKmludCovKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnQgaW4gRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCB3aXRoIGZld2VzdCBiaXRzIGRpZmZlcmluZ1xuICAgICAgICB2YXIgYmVzdERpZmZlcmVuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgdmFyIGJlc3RGb3JtYXRJbmZvID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlSW5mbyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJbmZvID0gZGVjb2RlSW5mb1swXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SW5mbyA9PT0gbWFza2VkRm9ybWF0SW5mbzEgfHwgdGFyZ2V0SW5mbyA9PT0gbWFza2VkRm9ybWF0SW5mbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gZXhhY3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRJbmZvcm1hdGlvbihkZWNvZGVJbmZvWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMSwgdGFyZ2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdEluZm8gPSBkZWNvZGVJbmZvWzFdO1xuICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza2VkRm9ybWF0SW5mbzEgIT09IG1hc2tlZEZvcm1hdEluZm8yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gdHJ5IHRoZSBvdGhlciBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nKG1hc2tlZEZvcm1hdEluZm8yLCB0YXJnZXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW1taW5nIGRpc3RhbmNlIG9mIHRoZSAzMiBtYXNrZWQgY29kZXMgaXMgNywgYnkgY29uc3RydWN0aW9uLCBzbyA8PSAzIGJpdHNcbiAgICAgICAgLy8gZGlmZmVyaW5nIG1lYW5zIHdlIGZvdW5kIGEgbWF0Y2hcbiAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oYmVzdEZvcm1hdEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlLmdldEVycm9yQ29ycmVjdGlvbkxldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICB9O1xuICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5nZXREYXRhTWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1hc2s7XG4gICAgfTtcbiAgICAvKkBPdmVycmlkZSovXG4gICAgRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgdGhpcy5kYXRhTWFzaztcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEZvcm1hdEluZm9ybWF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlciA9IG87XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID09PSBvdGhlci5lcnJvckNvcnJlY3Rpb25MZXZlbCAmJlxuICAgICAgICAgICAgdGhpcy5kYXRhTWFzayA9PT0gb3RoZXIuZGF0YU1hc2s7XG4gICAgfTtcbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSID0gMHg1NDEyO1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiwgQW5uZXggQywgVGFibGUgQy4xXG4gICAgICovXG4gICAgRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDU0MTIsIDB4MDBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDUxMjUsIDB4MDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDVFN0MsIDB4MDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDVCNEIsIDB4MDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDQ1RjksIDB4MDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDQwQ0UsIDB4MDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDRGOTcsIDB4MDZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDRBQTAsIDB4MDddKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDc3QzQsIDB4MDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDcyRjMsIDB4MDldKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDdEQUEsIDB4MEFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDc4OUQsIDB4MEJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDY2MkYsIDB4MENdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDYzMTgsIDB4MERdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDZDNDEsIDB4MEVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDY5NzYsIDB4MEZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE2ODksIDB4MTBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDEzQkUsIDB4MTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDFDRTcsIDB4MTJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE5RDAsIDB4MTNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDA3NjIsIDB4MTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDAyNTUsIDB4MTVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDBEMEMsIDB4MTZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDA4M0IsIDB4MTddKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDM1NUYsIDB4MThdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDMwNjgsIDB4MTldKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDNGMzEsIDB4MUFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDNBMDYsIDB4MUJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDI0QjQsIDB4MUNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDIxODMsIDB4MURdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDJFREEsIDB4MUVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDJCRUQsIDB4MUZdKSxcbiAgICBdO1xuICAgIHJldHVybiBGb3JtYXRJbmZvcm1hdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGb3JtYXRJbmZvcm1hdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModeValues = void 0;\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ModeValues;\n(function (ModeValues) {\n    ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n    ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n    ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n    ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n    ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n    ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n    ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n    ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n    ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));\n/**\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n * data can be encoded to bits in the QR code standard.</p>\n *\n * @author Sean Owen\n */\nvar Mode = /** @class */ (function () {\n    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n        this.value = value;\n        this.stringValue = stringValue;\n        this.characterCountBitsForVersions = characterCountBitsForVersions;\n        this.bits = bits;\n        Mode.FOR_BITS.set(bits, this);\n        Mode.FOR_VALUE.set(value, this);\n    }\n    /**\n     * @param bits four bits encoding a QR Code data mode\n     * @return Mode encoded by these bits\n     * @throws IllegalArgumentException if bits do not correspond to a known mode\n     */\n    Mode.forBits = function (bits /*int*/) {\n        var mode = Mode.FOR_BITS.get(bits);\n        if (undefined === mode) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return mode;\n    };\n    /**\n     * @param version version in question\n     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n     *         count of characters that will follow encoded in this Mode\n     */\n    Mode.prototype.getCharacterCountBits = function (version) {\n        var versionNumber = version.getVersionNumber();\n        var offset;\n        if (versionNumber <= 9) {\n            offset = 0;\n        }\n        else if (versionNumber <= 26) {\n            offset = 1;\n        }\n        else {\n            offset = 2;\n        }\n        return this.characterCountBitsForVersions[offset];\n    };\n    Mode.prototype.getValue = function () {\n        return this.value;\n    };\n    Mode.prototype.getBits = function () {\n        return this.bits;\n    };\n    Mode.prototype.equals = function (o) {\n        if (!(o instanceof Mode)) {\n            return false;\n        }\n        var other = o;\n        return this.value === other.value;\n    };\n    Mode.prototype.toString = function () {\n        return this.stringValue;\n    };\n    Mode.FOR_BITS = new Map();\n    Mode.FOR_VALUE = new Map();\n    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n    return Mode;\n}());\nexports[\"default\"] = Mode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9Nb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixpQ0FBaUMsbUJBQU8sQ0FBQyxxS0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL01vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9kZVZhbHVlcyA9IHZvaWQgMDtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgTW9kZVZhbHVlcztcbihmdW5jdGlvbiAoTW9kZVZhbHVlcykge1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIlRFUk1JTkFUT1JcIl0gPSAwXSA9IFwiVEVSTUlOQVRPUlwiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIk5VTUVSSUNcIl0gPSAxXSA9IFwiTlVNRVJJQ1wiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkFMUEhBTlVNRVJJQ1wiXSA9IDJdID0gXCJBTFBIQU5VTUVSSUNcIjtcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJTVFJVQ1RVUkVEX0FQUEVORFwiXSA9IDNdID0gXCJTVFJVQ1RVUkVEX0FQUEVORFwiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkJZVEVcIl0gPSA0XSA9IFwiQllURVwiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkVDSVwiXSA9IDVdID0gXCJFQ0lcIjtcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJLQU5KSVwiXSA9IDZdID0gXCJLQU5KSVwiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkZOQzFfRklSU1RfUE9TSVRJT05cIl0gPSA3XSA9IFwiRk5DMV9GSVJTVF9QT1NJVElPTlwiO1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCJdID0gOF0gPSBcIkZOQzFfU0VDT05EX1BPU0lUSU9OXCI7XG4gICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkhBTlpJXCJdID0gOV0gPSBcIkhBTlpJXCI7XG59KShNb2RlVmFsdWVzID0gZXhwb3J0cy5Nb2RlVmFsdWVzIHx8IChleHBvcnRzLk1vZGVWYWx1ZXMgPSB7fSkpO1xuLyoqXG4gKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4xLCBUYWJsZXMgMiBhbmQgMy4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBtb2RlcyBpbiB3aGljaFxuICogZGF0YSBjYW4gYmUgZW5jb2RlZCB0byBiaXRzIGluIHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgTW9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlKHZhbHVlLCBzdHJpbmdWYWx1ZSwgY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMsIGJpdHMgLyppbnQqLykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucyA9IGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zO1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICBNb2RlLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcbiAgICAgICAgTW9kZS5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJpdHMgZm91ciBiaXRzIGVuY29kaW5nIGEgUVIgQ29kZSBkYXRhIG1vZGVcbiAgICAgKiBAcmV0dXJuIE1vZGUgZW5jb2RlZCBieSB0aGVzZSBiaXRzXG4gICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYml0cyBkbyBub3QgY29ycmVzcG9uZCB0byBhIGtub3duIG1vZGVcbiAgICAgKi9cbiAgICBNb2RlLmZvckJpdHMgPSBmdW5jdGlvbiAoYml0cyAvKmludCovKSB7XG4gICAgICAgIHZhciBtb2RlID0gTW9kZS5GT1JfQklUUy5nZXQoYml0cyk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIGluIHF1ZXN0aW9uXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB1c2VkLCBpbiB0aGlzIFFSIENvZGUgc3ltYm9sIHtAbGluayBWZXJzaW9ufSwgdG8gZW5jb2RlIHRoZVxuICAgICAqICAgICAgICAgY291bnQgb2YgY2hhcmFjdGVycyB0aGF0IHdpbGwgZm9sbG93IGVuY29kZWQgaW4gdGhpcyBNb2RlXG4gICAgICovXG4gICAgTW9kZS5wcm90b3R5cGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgdmFyIHZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKTtcbiAgICAgICAgdmFyIG9mZnNldDtcbiAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPD0gOSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZXJzaW9uTnVtYmVyIDw9IDI2KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9uc1tvZmZzZXRdO1xuICAgIH07XG4gICAgTW9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgTW9kZS5wcm90b3R5cGUuZ2V0Qml0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICB9O1xuICAgIE1vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBNb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlciA9IG87XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbiAgICB9O1xuICAgIE1vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcbiAgICB9O1xuICAgIE1vZGUuRk9SX0JJVFMgPSBuZXcgTWFwKCk7XG4gICAgTW9kZS5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7XG4gICAgTW9kZS5URVJNSU5BVE9SID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5URVJNSU5BVE9SLCAnVEVSTUlOQVRPUicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDAwKTsgLy8gTm90IHJlYWxseSBhIG1vZGUuLi5cbiAgICBNb2RlLk5VTUVSSUMgPSBuZXcgTW9kZShNb2RlVmFsdWVzLk5VTUVSSUMsICdOVU1FUklDJywgSW50MzJBcnJheS5mcm9tKFsxMCwgMTIsIDE0XSksIDB4MDEpO1xuICAgIE1vZGUuQUxQSEFOVU1FUklDID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5BTFBIQU5VTUVSSUMsICdBTFBIQU5VTUVSSUMnLCBJbnQzMkFycmF5LmZyb20oWzksIDExLCAxM10pLCAweDAyKTtcbiAgICBNb2RlLlNUUlVDVFVSRURfQVBQRU5EID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5TVFJVQ1RVUkVEX0FQUEVORCwgJ1NUUlVDVFVSRURfQVBQRU5EJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDMpOyAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgTW9kZS5CWVRFID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5CWVRFLCAnQllURScsIEludDMyQXJyYXkuZnJvbShbOCwgMTYsIDE2XSksIDB4MDQpO1xuICAgIE1vZGUuRUNJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5FQ0ksICdFQ0knLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNyk7IC8vIGNoYXJhY3RlciBjb3VudHMgZG9uJ3QgYXBwbHlcbiAgICBNb2RlLktBTkpJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5LQU5KSSwgJ0tBTkpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwOCk7XG4gICAgTW9kZS5GTkMxX0ZJUlNUX1BPU0lUSU9OID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5GTkMxX0ZJUlNUX1BPU0lUSU9OLCAnRk5DMV9GSVJTVF9QT1NJVElPTicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA1KTtcbiAgICBNb2RlLkZOQzFfU0VDT05EX1BPU0lUSU9OID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5GTkMxX1NFQ09ORF9QT1NJVElPTiwgJ0ZOQzFfU0VDT05EX1BPU0lUSU9OJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDkpO1xuICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7IFwiSGFuemlcIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi9cbiAgICBNb2RlLkhBTlpJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5IQU5aSSwgJ0hBTlpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwRCk7XG4gICAgcmV0dXJuIE1vZGU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js":
/*!********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the\n * decoding caller. Callers are expected to process this.\n *\n * @see com.google.zxing.common.DecoderResult#getOther()\n */\nvar QRCodeDecoderMetaData = /** @class */ (function () {\n    function QRCodeDecoderMetaData(mirrored) {\n        this.mirrored = mirrored;\n    }\n    /**\n     * @return true if the QR Code was mirrored.\n     */\n    QRCodeDecoderMetaData.prototype.isMirrored = function () {\n        return this.mirrored;\n    };\n    /**\n     * Apply the result points' order correction due to mirroring.\n     *\n     * @param points Array of points to apply mirror correction to.\n     */\n    QRCodeDecoderMetaData.prototype.applyMirroredCorrection = function (points) {\n        if (!this.mirrored || points === null || points.length < 3) {\n            return;\n        }\n        var bottomLeft = points[0];\n        points[0] = points[2];\n        points[2] = bottomLeft;\n        // No need to 'fix' top-left and alignment pattern.\n    };\n    return QRCodeDecoderMetaData;\n}());\nexports[\"default\"] = QRCodeDecoderMetaData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9RUkNvZGVEZWNvZGVyTWV0YURhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2RlY29kZXIvUVJDb2RlRGVjb2Rlck1ldGFEYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1ldGEtZGF0YSBjb250YWluZXIgZm9yIFFSIENvZGUgZGVjb2RpbmcuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIG1heSBiZSB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvbiBiYWNrIHRvIHRoZVxuICogZGVjb2RpbmcgY2FsbGVyLiBDYWxsZXJzIGFyZSBleHBlY3RlZCB0byBwcm9jZXNzIHRoaXMuXG4gKlxuICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5EZWNvZGVyUmVzdWx0I2dldE90aGVyKClcbiAqL1xudmFyIFFSQ29kZURlY29kZXJNZXRhRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRUkNvZGVEZWNvZGVyTWV0YURhdGEobWlycm9yZWQpIHtcbiAgICAgICAgdGhpcy5taXJyb3JlZCA9IG1pcnJvcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIFFSIENvZGUgd2FzIG1pcnJvcmVkLlxuICAgICAqL1xuICAgIFFSQ29kZURlY29kZXJNZXRhRGF0YS5wcm90b3R5cGUuaXNNaXJyb3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcmVzdWx0IHBvaW50cycgb3JkZXIgY29ycmVjdGlvbiBkdWUgdG8gbWlycm9yaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50cyBBcnJheSBvZiBwb2ludHMgdG8gYXBwbHkgbWlycm9yIGNvcnJlY3Rpb24gdG8uXG4gICAgICovXG4gICAgUVJDb2RlRGVjb2Rlck1ldGFEYXRhLnByb3RvdHlwZS5hcHBseU1pcnJvcmVkQ29ycmVjdGlvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcmVkIHx8IHBvaW50cyA9PT0gbnVsbCB8fCBwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gcG9pbnRzWzBdO1xuICAgICAgICBwb2ludHNbMF0gPSBwb2ludHNbMl07XG4gICAgICAgIHBvaW50c1syXSA9IGJvdHRvbUxlZnQ7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gJ2ZpeCcgdG9wLWxlZnQgYW5kIGFsaWdubWVudCBwYXR0ZXJuLlxuICAgIH07XG4gICAgcmV0dXJuIFFSQ29kZURlY29kZXJNZXRhRGF0YTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBRUkNvZGVEZWNvZGVyTWV0YURhdGE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nvar FormatInformation_1 = __webpack_require__(/*! ./FormatInformation */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js\");\nvar ECBlocks_1 = __webpack_require__(/*! ./ECBlocks */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js\");\nvar ECB_1 = __webpack_require__(/*! ./ECB */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js\");\nvar FormatException_1 = __webpack_require__(/*! ../../FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * See ISO 18004:2006 Annex D\n *\n * @author Sean Owen\n */\nvar Version = /** @class */ (function () {\n    function Version(versionNumber /*int*/, alignmentPatternCenters) {\n        var e_1, _a;\n        var ecBlocks = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            ecBlocks[_i - 2] = arguments[_i];\n        }\n        this.versionNumber = versionNumber;\n        this.alignmentPatternCenters = alignmentPatternCenters;\n        this.ecBlocks = ecBlocks;\n        var total = 0;\n        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();\n        var ecbArray = ecBlocks[0].getECBlocks();\n        try {\n            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {\n                var ecBlock = ecbArray_1_1.value;\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        this.totalCodewords = total;\n    }\n    Version.prototype.getVersionNumber = function () {\n        return this.versionNumber;\n    };\n    Version.prototype.getAlignmentPatternCenters = function () {\n        return this.alignmentPatternCenters;\n    };\n    Version.prototype.getTotalCodewords = function () {\n        return this.totalCodewords;\n    };\n    Version.prototype.getDimensionForVersion = function () {\n        return 17 + 4 * this.versionNumber;\n    };\n    Version.prototype.getECBlocksForLevel = function (ecLevel) {\n        return this.ecBlocks[ecLevel.getValue()];\n        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)\n        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number\n    };\n    /**\n     * <p>Deduces version information purely from QR Code dimensions.</p>\n     *\n     * @param dimension dimension in modules\n     * @return Version for a QR Code of that dimension\n     * @throws FormatException if dimension is not 1 mod 4\n     */\n    Version.getProvisionalVersionForDimension = function (dimension /*int*/) {\n        if (dimension % 4 !== 1) {\n            throw new FormatException_1.default();\n        }\n        try {\n            return this.getVersionForNumber((dimension - 17) / 4);\n        }\n        catch (ignored /*: IllegalArgumentException*/) {\n            throw new FormatException_1.default();\n        }\n    };\n    Version.getVersionForNumber = function (versionNumber /*int*/) {\n        if (versionNumber < 1 || versionNumber > 40) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return Version.VERSIONS[versionNumber - 1];\n    };\n    Version.decodeVersionInformation = function (versionBits /*int*/) {\n        var bestDifference = Number.MAX_SAFE_INTEGER;\n        var bestVersion = 0;\n        for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {\n            var targetVersion = Version.VERSION_DECODE_INFO[i];\n            // Do the version info bits match exactly? done.\n            if (targetVersion === versionBits) {\n                return Version.getVersionForNumber(i + 7);\n            }\n            // Otherwise see if this is the closest to a real version info bit string\n            // we have seen so far\n            var bitsDifference = FormatInformation_1.default.numBitsDiffering(versionBits, targetVersion);\n            if (bitsDifference < bestDifference) {\n                bestVersion = i + 7;\n                bestDifference = bitsDifference;\n            }\n        }\n        // We can tolerate up to 3 bits of error since no two version info codewords will\n        // differ in less than 8 bits.\n        if (bestDifference <= 3) {\n            return Version.getVersionForNumber(bestVersion);\n        }\n        // If we didn't find a close enough match, fail\n        return null;\n    };\n    /**\n     * See ISO 18004:2006 Annex E\n     */\n    Version.prototype.buildFunctionPattern = function () {\n        var dimension = this.getDimensionForVersion();\n        var bitMatrix = new BitMatrix_1.default(dimension);\n        // Top left finder pattern + separator + format\n        bitMatrix.setRegion(0, 0, 9, 9);\n        // Top right finder pattern + separator + format\n        bitMatrix.setRegion(dimension - 8, 0, 8, 9);\n        // Bottom left finder pattern + separator + format\n        bitMatrix.setRegion(0, dimension - 8, 9, 8);\n        // Alignment patterns\n        var max = this.alignmentPatternCenters.length;\n        for (var x = 0; x < max; x++) {\n            var i = this.alignmentPatternCenters[x] - 2;\n            for (var y = 0; y < max; y++) {\n                if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {\n                    // No alignment patterns near the three finder patterns\n                    continue;\n                }\n                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);\n            }\n        }\n        // Vertical timing pattern\n        bitMatrix.setRegion(6, 9, 1, dimension - 17);\n        // Horizontal timing pattern\n        bitMatrix.setRegion(9, 6, dimension - 17, 1);\n        if (this.versionNumber > 6) {\n            // Version info, top right\n            bitMatrix.setRegion(dimension - 11, 0, 3, 6);\n            // Version info, bottom left\n            bitMatrix.setRegion(0, dimension - 11, 6, 3);\n        }\n        return bitMatrix;\n    };\n    /*@Override*/\n    Version.prototype.toString = function () {\n        return '' + this.versionNumber;\n    };\n    /**\n       * See ISO 18004:2006 Annex D.\n       * Element i represents the raw version bits that specify version i + 7\n       */\n    Version.VERSION_DECODE_INFO = Int32Array.from([\n        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,\n        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,\n        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,\n        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,\n        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,\n        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,\n        0x2542E, 0x26A64, 0x27541, 0x28C69\n    ]);\n    /**\n       * See ISO 18004:2006 6.5.1 Table 9\n       */\n    Version.VERSIONS = [\n        new Version(1, new Int32Array(0), new ECBlocks_1.default(7, new ECB_1.default(1, 19)), new ECBlocks_1.default(10, new ECB_1.default(1, 16)), new ECBlocks_1.default(13, new ECB_1.default(1, 13)), new ECBlocks_1.default(17, new ECB_1.default(1, 9))),\n        new Version(2, Int32Array.from([6, 18]), new ECBlocks_1.default(10, new ECB_1.default(1, 34)), new ECBlocks_1.default(16, new ECB_1.default(1, 28)), new ECBlocks_1.default(22, new ECB_1.default(1, 22)), new ECBlocks_1.default(28, new ECB_1.default(1, 16))),\n        new Version(3, Int32Array.from([6, 22]), new ECBlocks_1.default(15, new ECB_1.default(1, 55)), new ECBlocks_1.default(26, new ECB_1.default(1, 44)), new ECBlocks_1.default(18, new ECB_1.default(2, 17)), new ECBlocks_1.default(22, new ECB_1.default(2, 13))),\n        new Version(4, Int32Array.from([6, 26]), new ECBlocks_1.default(20, new ECB_1.default(1, 80)), new ECBlocks_1.default(18, new ECB_1.default(2, 32)), new ECBlocks_1.default(26, new ECB_1.default(2, 24)), new ECBlocks_1.default(16, new ECB_1.default(4, 9))),\n        new Version(5, Int32Array.from([6, 30]), new ECBlocks_1.default(26, new ECB_1.default(1, 108)), new ECBlocks_1.default(24, new ECB_1.default(2, 43)), new ECBlocks_1.default(18, new ECB_1.default(2, 15), new ECB_1.default(2, 16)), new ECBlocks_1.default(22, new ECB_1.default(2, 11), new ECB_1.default(2, 12))),\n        new Version(6, Int32Array.from([6, 34]), new ECBlocks_1.default(18, new ECB_1.default(2, 68)), new ECBlocks_1.default(16, new ECB_1.default(4, 27)), new ECBlocks_1.default(24, new ECB_1.default(4, 19)), new ECBlocks_1.default(28, new ECB_1.default(4, 15))),\n        new Version(7, Int32Array.from([6, 22, 38]), new ECBlocks_1.default(20, new ECB_1.default(2, 78)), new ECBlocks_1.default(18, new ECB_1.default(4, 31)), new ECBlocks_1.default(18, new ECB_1.default(2, 14), new ECB_1.default(4, 15)), new ECBlocks_1.default(26, new ECB_1.default(4, 13), new ECB_1.default(1, 14))),\n        new Version(8, Int32Array.from([6, 24, 42]), new ECBlocks_1.default(24, new ECB_1.default(2, 97)), new ECBlocks_1.default(22, new ECB_1.default(2, 38), new ECB_1.default(2, 39)), new ECBlocks_1.default(22, new ECB_1.default(4, 18), new ECB_1.default(2, 19)), new ECBlocks_1.default(26, new ECB_1.default(4, 14), new ECB_1.default(2, 15))),\n        new Version(9, Int32Array.from([6, 26, 46]), new ECBlocks_1.default(30, new ECB_1.default(2, 116)), new ECBlocks_1.default(22, new ECB_1.default(3, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(20, new ECB_1.default(4, 16), new ECB_1.default(4, 17)), new ECBlocks_1.default(24, new ECB_1.default(4, 12), new ECB_1.default(4, 13))),\n        new Version(10, Int32Array.from([6, 28, 50]), new ECBlocks_1.default(18, new ECB_1.default(2, 68), new ECB_1.default(2, 69)), new ECBlocks_1.default(26, new ECB_1.default(4, 43), new ECB_1.default(1, 44)), new ECBlocks_1.default(24, new ECB_1.default(6, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(28, new ECB_1.default(6, 15), new ECB_1.default(2, 16))),\n        new Version(11, Int32Array.from([6, 30, 54]), new ECBlocks_1.default(20, new ECB_1.default(4, 81)), new ECBlocks_1.default(30, new ECB_1.default(1, 50), new ECB_1.default(4, 51)), new ECBlocks_1.default(28, new ECB_1.default(4, 22), new ECB_1.default(4, 23)), new ECBlocks_1.default(24, new ECB_1.default(3, 12), new ECB_1.default(8, 13))),\n        new Version(12, Int32Array.from([6, 32, 58]), new ECBlocks_1.default(24, new ECB_1.default(2, 92), new ECB_1.default(2, 93)), new ECBlocks_1.default(22, new ECB_1.default(6, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(26, new ECB_1.default(4, 20), new ECB_1.default(6, 21)), new ECBlocks_1.default(28, new ECB_1.default(7, 14), new ECB_1.default(4, 15))),\n        new Version(13, Int32Array.from([6, 34, 62]), new ECBlocks_1.default(26, new ECB_1.default(4, 107)), new ECBlocks_1.default(22, new ECB_1.default(8, 37), new ECB_1.default(1, 38)), new ECBlocks_1.default(24, new ECB_1.default(8, 20), new ECB_1.default(4, 21)), new ECBlocks_1.default(22, new ECB_1.default(12, 11), new ECB_1.default(4, 12))),\n        new Version(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_1.default(30, new ECB_1.default(3, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(24, new ECB_1.default(4, 40), new ECB_1.default(5, 41)), new ECBlocks_1.default(20, new ECB_1.default(11, 16), new ECB_1.default(5, 17)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(5, 13))),\n        new Version(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_1.default(22, new ECB_1.default(5, 87), new ECB_1.default(1, 88)), new ECBlocks_1.default(24, new ECB_1.default(5, 41), new ECB_1.default(5, 42)), new ECBlocks_1.default(30, new ECB_1.default(5, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(7, 13))),\n        new Version(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_1.default(24, new ECB_1.default(5, 98), new ECB_1.default(1, 99)), new ECBlocks_1.default(28, new ECB_1.default(7, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(24, new ECB_1.default(15, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(30, new ECB_1.default(3, 15), new ECB_1.default(13, 16))),\n        new Version(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_1.default(28, new ECB_1.default(1, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(1, 47)), new ECBlocks_1.default(28, new ECB_1.default(1, 22), new ECB_1.default(15, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(17, 15))),\n        new Version(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_1.default(30, new ECB_1.default(5, 120), new ECB_1.default(1, 121)), new ECBlocks_1.default(26, new ECB_1.default(9, 43), new ECB_1.default(4, 44)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(1, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(19, 15))),\n        new Version(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_1.default(28, new ECB_1.default(3, 113), new ECB_1.default(4, 114)), new ECBlocks_1.default(26, new ECB_1.default(3, 44), new ECB_1.default(11, 45)), new ECBlocks_1.default(26, new ECB_1.default(17, 21), new ECB_1.default(4, 22)), new ECBlocks_1.default(26, new ECB_1.default(9, 13), new ECB_1.default(16, 14))),\n        new Version(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_1.default(28, new ECB_1.default(3, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(26, new ECB_1.default(3, 41), new ECB_1.default(13, 42)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(5, 25)), new ECBlocks_1.default(28, new ECB_1.default(15, 15), new ECB_1.default(10, 16))),\n        new Version(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_1.default(28, new ECB_1.default(4, 116), new ECB_1.default(4, 117)), new ECBlocks_1.default(26, new ECB_1.default(17, 42)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(19, 16), new ECB_1.default(6, 17))),\n        new Version(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_1.default(28, new ECB_1.default(2, 111), new ECB_1.default(7, 112)), new ECBlocks_1.default(28, new ECB_1.default(17, 46)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(24, new ECB_1.default(34, 13))),\n        new Version(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_1.default(30, new ECB_1.default(4, 121), new ECB_1.default(5, 122)), new ECBlocks_1.default(28, new ECB_1.default(4, 47), new ECB_1.default(14, 48)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(16, 15), new ECB_1.default(14, 16))),\n        new Version(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_1.default(30, new ECB_1.default(6, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(6, 45), new ECB_1.default(14, 46)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(30, new ECB_1.default(30, 16), new ECB_1.default(2, 17))),\n        new Version(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_1.default(26, new ECB_1.default(8, 106), new ECB_1.default(4, 107)), new ECBlocks_1.default(28, new ECB_1.default(8, 47), new ECB_1.default(13, 48)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(13, 16))),\n        new Version(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_1.default(28, new ECB_1.default(10, 114), new ECB_1.default(2, 115)), new ECBlocks_1.default(28, new ECB_1.default(19, 46), new ECB_1.default(4, 47)), new ECBlocks_1.default(28, new ECB_1.default(28, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(33, 16), new ECB_1.default(4, 17))),\n        new Version(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_1.default(30, new ECB_1.default(8, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(22, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(30, new ECB_1.default(8, 23), new ECB_1.default(26, 24)), new ECBlocks_1.default(30, new ECB_1.default(12, 15), new ECB_1.default(28, 16))),\n        new Version(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_1.default(30, new ECB_1.default(3, 117), new ECB_1.default(10, 118)), new ECBlocks_1.default(28, new ECB_1.default(3, 45), new ECB_1.default(23, 46)), new ECBlocks_1.default(30, new ECB_1.default(4, 24), new ECB_1.default(31, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(31, 16))),\n        new Version(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_1.default(30, new ECB_1.default(7, 116), new ECB_1.default(7, 117)), new ECBlocks_1.default(28, new ECB_1.default(21, 45), new ECB_1.default(7, 46)), new ECBlocks_1.default(30, new ECB_1.default(1, 23), new ECB_1.default(37, 24)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(26, 16))),\n        new Version(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_1.default(30, new ECB_1.default(5, 115), new ECB_1.default(10, 116)), new ECBlocks_1.default(28, new ECB_1.default(19, 47), new ECB_1.default(10, 48)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(25, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(25, 16))),\n        new Version(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(3, 116)), new ECBlocks_1.default(28, new ECB_1.default(2, 46), new ECB_1.default(29, 47)), new ECBlocks_1.default(30, new ECB_1.default(42, 24), new ECB_1.default(1, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(28, 16))),\n        new Version(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_1.default(30, new ECB_1.default(17, 115)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(10, 24), new ECB_1.default(35, 25)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(35, 16))),\n        new Version(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_1.default(30, new ECB_1.default(17, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(21, 47)), new ECBlocks_1.default(30, new ECB_1.default(29, 24), new ECB_1.default(19, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(46, 16))),\n        new Version(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(6, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(44, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(30, new ECB_1.default(59, 16), new ECB_1.default(1, 17))),\n        new Version(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_1.default(30, new ECB_1.default(12, 121), new ECB_1.default(7, 122)), new ECBlocks_1.default(28, new ECB_1.default(12, 47), new ECB_1.default(26, 48)), new ECBlocks_1.default(30, new ECB_1.default(39, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(41, 16))),\n        new Version(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_1.default(30, new ECB_1.default(6, 121), new ECB_1.default(14, 122)), new ECBlocks_1.default(28, new ECB_1.default(6, 47), new ECB_1.default(34, 48)), new ECBlocks_1.default(30, new ECB_1.default(46, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(2, 15), new ECB_1.default(64, 16))),\n        new Version(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_1.default(30, new ECB_1.default(17, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(29, 46), new ECB_1.default(14, 47)), new ECBlocks_1.default(30, new ECB_1.default(49, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(24, 15), new ECB_1.default(46, 16))),\n        new Version(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_1.default(30, new ECB_1.default(4, 122), new ECB_1.default(18, 123)), new ECBlocks_1.default(28, new ECB_1.default(13, 46), new ECB_1.default(32, 47)), new ECBlocks_1.default(30, new ECB_1.default(48, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(42, 15), new ECB_1.default(32, 16))),\n        new Version(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_1.default(30, new ECB_1.default(20, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(40, 47), new ECB_1.default(7, 48)), new ECBlocks_1.default(30, new ECB_1.default(43, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(10, 15), new ECB_1.default(67, 16))),\n        new Version(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_1.default(30, new ECB_1.default(19, 118), new ECB_1.default(6, 119)), new ECBlocks_1.default(28, new ECB_1.default(18, 47), new ECB_1.default(31, 48)), new ECBlocks_1.default(30, new ECB_1.default(34, 24), new ECB_1.default(34, 25)), new ECBlocks_1.default(30, new ECB_1.default(20, 15), new ECB_1.default(61, 16)))\n    ];\n    return Version;\n}());\nexports[\"default\"] = Version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGVjb2Rlci9WZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxxSkFBd0I7QUFDbEQsMEJBQTBCLG1CQUFPLENBQUMsa0tBQXFCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGdKQUFZO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxzSUFBTztBQUMzQix3QkFBd0IsbUJBQU8sQ0FBQyxtSkFBdUI7QUFDdkQsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG9CQUFvQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZWNvZGVyL1ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmRlY29kZXIgeyovXG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcbnZhciBGb3JtYXRJbmZvcm1hdGlvbl8xID0gcmVxdWlyZShcIi4vRm9ybWF0SW5mb3JtYXRpb25cIik7XG52YXIgRUNCbG9ja3NfMSA9IHJlcXVpcmUoXCIuL0VDQmxvY2tzXCIpO1xudmFyIEVDQl8xID0gcmVxdWlyZShcIi4vRUNCXCIpO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG4vKipcbiAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBEXG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIFZlcnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyIC8qaW50Ki8sIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgZWNCbG9ja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGVjQmxvY2tzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgIHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMgPSBhbGlnbm1lbnRQYXR0ZXJuQ2VudGVycztcbiAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICB2YXIgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrc1swXS5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7XG4gICAgICAgIHZhciBlY2JBcnJheSA9IGVjQmxvY2tzWzBdLmdldEVDQmxvY2tzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlY2JBcnJheV8xID0gX192YWx1ZXMoZWNiQXJyYXkpLCBlY2JBcnJheV8xXzEgPSBlY2JBcnJheV8xLm5leHQoKTsgIWVjYkFycmF5XzFfMS5kb25lOyBlY2JBcnJheV8xXzEgPSBlY2JBcnJheV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNiQXJyYXlfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKSAqIChlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKSArIGVjQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVjYkFycmF5XzFfMSAmJiAhZWNiQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gZWNiQXJyYXlfMS5yZXR1cm4pKSBfYS5jYWxsKGVjYkFycmF5XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxDb2Rld29yZHMgPSB0b3RhbDtcbiAgICB9XG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0VmVyc2lvbk51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICB9O1xuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldEFsaWdubWVudFBhdHRlcm5DZW50ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycztcbiAgICB9O1xuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldFRvdGFsQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvZGV3b3JkcztcbiAgICB9O1xuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldERpbWVuc2lvbkZvclZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxNyArIDQgKiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgfTtcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRFQ0Jsb2Nrc0ZvckxldmVsID0gZnVuY3Rpb24gKGVjTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3NbZWNMZXZlbC5nZXRWYWx1ZSgpXTtcbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG9yaWdpbmFsIHdhcyB1c2luZyBvcmRpbmFsLCBhbmQgdXNpbmcgdGhlIG9yZGVyIG9mIGxldmVscyBhcyBkZWZpbmVkIGluIEVycm9yQ29ycmVjdGlvbkxldmVsIGVudW0gKExNUUgpXG4gICAgICAgIC8vIEkgd2lsbCB1c2UgdGhlIGRpcmVjdCB2YWx1ZSBmcm9tIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzIGVudW0gd2hpY2ggaW4gdHlwZXNjcmlwdCBnb2VzIHRvIGEgbnVtYmVyXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gcHVyZWx5IGZyb20gUVIgQ29kZSBkaW1lbnNpb25zLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIGluIG1vZHVsZXNcbiAgICAgKiBAcmV0dXJuIFZlcnNpb24gZm9yIGEgUVIgQ29kZSBvZiB0aGF0IGRpbWVuc2lvblxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyBub3QgMSBtb2QgNFxuICAgICAqL1xuICAgIFZlcnNpb24uZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24gJSA0ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWZXJzaW9uRm9yTnVtYmVyKChkaW1lbnNpb24gLSAxNykgLyA0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlciA9IGZ1bmN0aW9uICh2ZXJzaW9uTnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPCAxIHx8IHZlcnNpb25OdW1iZXIgPiA0MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmVyc2lvbi5WRVJTSU9OU1t2ZXJzaW9uTnVtYmVyIC0gMV07XG4gICAgfTtcbiAgICBWZXJzaW9uLmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICh2ZXJzaW9uQml0cyAvKmludCovKSB7XG4gICAgICAgIHZhciBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB2YXIgYmVzdFZlcnNpb24gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFZlcnNpb24uVkVSU0lPTl9ERUNPREVfSU5GTy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk9baV07XG4gICAgICAgICAgICAvLyBEbyB0aGUgdmVyc2lvbiBpbmZvIGJpdHMgbWF0Y2ggZXhhY3RseT8gZG9uZS5cbiAgICAgICAgICAgIGlmICh0YXJnZXRWZXJzaW9uID09PSB2ZXJzaW9uQml0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIoaSArIDcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlZSBpZiB0aGlzIGlzIHRoZSBjbG9zZXN0IHRvIGEgcmVhbCB2ZXJzaW9uIGluZm8gYml0IHN0cmluZ1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBzZWVuIHNvIGZhclxuICAgICAgICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb25fMS5kZWZhdWx0Lm51bUJpdHNEaWZmZXJpbmcodmVyc2lvbkJpdHMsIHRhcmdldFZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBiZXN0VmVyc2lvbiA9IGkgKyA3O1xuICAgICAgICAgICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY2FuIHRvbGVyYXRlIHVwIHRvIDMgYml0cyBvZiBlcnJvciBzaW5jZSBubyB0d28gdmVyc2lvbiBpbmZvIGNvZGV3b3JkcyB3aWxsXG4gICAgICAgIC8vIGRpZmZlciBpbiBsZXNzIHRoYW4gOCBiaXRzLlxuICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlcihiZXN0VmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjbG9zZSBlbm91Z2ggbWF0Y2gsIGZhaWxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRVxuICAgICAqL1xuICAgIFZlcnNpb24ucHJvdG90eXBlLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCk7XG4gICAgICAgIHZhciBiaXRNYXRyaXggPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChkaW1lbnNpb24pO1xuICAgICAgICAvLyBUb3AgbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIDAsIDksIDkpO1xuICAgICAgICAvLyBUb3AgcmlnaHQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbihkaW1lbnNpb24gLSA4LCAwLCA4LCA5KTtcbiAgICAgICAgLy8gQm90dG9tIGxlZnQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSA4LCA5LCA4KTtcbiAgICAgICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zXG4gICAgICAgIHZhciBtYXggPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXg7IHgrKykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF4OyB5KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHggPT09IDAgJiYgKHkgPT09IDAgfHwgeSA9PT0gbWF4IC0gMSkpIHx8ICh4ID09PSBtYXggLSAxICYmIHkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oNiwgOSwgMSwgZGltZW5zaW9uIC0gMTcpO1xuICAgICAgICAvLyBIb3Jpem9udGFsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTnVtYmVyID4gNikge1xuICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCB0b3AgcmlnaHRcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpO1xuICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCBib3R0b20gbGVmdFxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSAxMSwgNiwgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdE1hdHJpeDtcbiAgICB9O1xuICAgIC8qQE92ZXJyaWRlKi9cbiAgICBWZXJzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRC5cbiAgICAgICAqIEVsZW1lbnQgaSByZXByZXNlbnRzIHRoZSByYXcgdmVyc2lvbiBiaXRzIHRoYXQgc3BlY2lmeSB2ZXJzaW9uIGkgKyA3XG4gICAgICAgKi9cbiAgICBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk8gPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAweDA3Qzk0LCAweDA4NUJDLCAweDA5QTk5LCAweDBBNEQzLCAweDBCQkY2LFxuICAgICAgICAweDBDNzYyLCAweDBEODQ3LCAweDBFNjBELCAweDBGOTI4LCAweDEwQjc4LFxuICAgICAgICAweDExNDVELCAweDEyQTE3LCAweDEzNTMyLCAweDE0OUE2LCAweDE1NjgzLFxuICAgICAgICAweDE2OEM5LCAweDE3N0VDLCAweDE4RUM0LCAweDE5MUUxLCAweDFBRkFCLFxuICAgICAgICAweDFCMDhFLCAweDFDQzFBLCAweDFEMzNGLCAweDFFRDc1LCAweDFGMjUwLFxuICAgICAgICAweDIwOUQ1LCAweDIxNkYwLCAweDIyOEJBLCAweDIzNzlGLCAweDI0QjBCLFxuICAgICAgICAweDI1NDJFLCAweDI2QTY0LCAweDI3NTQxLCAweDI4QzY5XG4gICAgXSk7XG4gICAgLyoqXG4gICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgNi41LjEgVGFibGUgOVxuICAgICAgICovXG4gICAgVmVyc2lvbi5WRVJTSU9OUyA9IFtcbiAgICAgICAgbmV3IFZlcnNpb24oMSwgbmV3IEludDMyQXJyYXkoMCksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMiwgSW50MzJBcnJheS5mcm9tKFs2LCAxOF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDEwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAzNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE2LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMywgSW50MzJBcnJheS5mcm9tKFs2LCAyMl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE1LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA1NSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA4MCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA5KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDEwOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCA0MykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExKSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTIpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDYsIEludDMyQXJyYXkuZnJvbShbNiwgMzRdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgNjgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDcsIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDc4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDMxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxNCkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNCwgNDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgOTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMzgpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzOSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxOCksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE5KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDksIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAzNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDM3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTAsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDY4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgNjkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxOSksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDIwKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDExLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA4MSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA1MCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDUxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTIpLCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTIsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDkyKSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgOTMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMzYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDEzLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2Ml0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMzcpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAzOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDEyLCAxMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDYsIDY2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA0MCksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDQxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDE3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxNSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDgsIDcwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDg3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgODgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgNDEpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCA0MikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxNiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDk4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCA0NikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMTkpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyMCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTcsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxMDcpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAxMDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDE4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTIwKSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDksIDQzKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxOSwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDE5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTE0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDQ0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDQ1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAyMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDksIDEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTYsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyMCwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDEwNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEwOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgzLCA0MSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCA0MikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDIxLCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgNDIpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDIyLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDExMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMzQsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyMywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIxKSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNiwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDI0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1NCwgODAsIDEwNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMTcpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTYsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMwLCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMTA2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTA3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMjYsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjgsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMzMsIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDI3LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAxMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDQ1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMjMpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNiwgMjQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTIsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjgsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDExNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxMTYpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjEsIDQ1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjMpLCBuZXcgRUNCXzEuZGVmYXVsdCgzNywgMjQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzMCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAxMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCA0NyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjMsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjUsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzMSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMywgMTE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjksIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQyLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDI4LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzIsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDExNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzUsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDM1LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzMsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMSwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjksIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQ2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzQsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNDQsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNTksIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDM1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTIsIDEyMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDEyMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMiwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNiwgNDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMzksIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzYsIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMjEpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgMTIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzQsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQ2LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDY0LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzcsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDI5LCA0NiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0OSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjQsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNDYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzOCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE4LCAxMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzIsIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQ4LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0MiwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDM5LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjAsIDExNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCg0MCwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0MywgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMiwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNjcsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig0MCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxMTgpLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyMCwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCg2MSwgMTYpKSlcbiAgICBdO1xuICAgIHJldHVybiBWZXJzaW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFZlcnNpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js":
/*!****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js ***!
  \****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.detector {*/\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in\n * all but the simplest QR Codes.</p>\n *\n * @author Sean Owen\n */\nvar AlignmentPattern = /** @class */ (function (_super) {\n    __extends(AlignmentPattern, _super);\n    function AlignmentPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {\n        var _this = _super.call(this, posX, posY) || this;\n        _this.estimatedModuleSize = estimatedModuleSize;\n        return _this;\n    }\n    /**\n     * <p>Determines if this alignment pattern \"about equals\" an alignment pattern at the stated\n     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n     */\n    AlignmentPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {\n        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n        }\n        return false;\n    };\n    /**\n     * Combines this object's current estimate of a finder pattern position and module size\n     * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.\n     */\n    AlignmentPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {\n        var combinedX = (this.getX() + j) / 2.0;\n        var combinedY = (this.getY() + i) / 2.0;\n        var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;\n        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);\n    };\n    return AlignmentPattern;\n}(ResultPoint_1.default));\nexports[\"default\"] = AlignmentPattern;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvQWxpZ25tZW50UGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhDQUE4QztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQywySUFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvQWxpZ25tZW50UGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYW4gYWxpZ25tZW50IHBhdHRlcm4sIHdoaWNoIGFyZSB0aGUgc21hbGxlciBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cbiAqIGFsbCBidXQgdGhlIHNpbXBsZXN0IFFSIENvZGVzLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG52YXIgQWxpZ25tZW50UGF0dGVybiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxpZ25tZW50UGF0dGVybiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbGlnbm1lbnRQYXR0ZXJuKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9zWCwgcG9zWSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+RGV0ZXJtaW5lcyBpZiB0aGlzIGFsaWdubWVudCBwYXR0ZXJuIFwiYWJvdXQgZXF1YWxzXCIgYW4gYWxpZ25tZW50IHBhdHRlcm4gYXQgdGhlIHN0YXRlZFxuICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XG4gICAgICovXG4gICAgQWxpZ25tZW50UGF0dGVybi5wcm90b3R5cGUuYWJvdXRFcXVhbHMgPSBmdW5jdGlvbiAobW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8IG1vZHVsZVNpemVEaWZmIDw9IHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvbiBhbmQgbW9kdWxlIHNpemVcbiAgICAgKiB3aXRoIGEgbmV3IGVzdGltYXRlLiBJdCByZXR1cm5zIGEgbmV3IHtAY29kZSBGaW5kZXJQYXR0ZXJufSBjb250YWluaW5nIGFuIGF2ZXJhZ2Ugb2YgdGhlIHR3by5cbiAgICAgKi9cbiAgICBBbGlnbm1lbnRQYXR0ZXJuLnByb3RvdHlwZS5jb21iaW5lRXN0aW1hdGUgPSBmdW5jdGlvbiAoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykge1xuICAgICAgICB2YXIgY29tYmluZWRYID0gKHRoaXMuZ2V0WCgpICsgaikgLyAyLjA7XG4gICAgICAgIHZhciBjb21iaW5lZFkgPSAodGhpcy5nZXRZKCkgKyBpKSAvIDIuMDtcbiAgICAgICAgdmFyIGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgKyBuZXdNb2R1bGVTaXplKSAvIDIuMDtcbiAgICAgICAgcmV0dXJuIG5ldyBBbGlnbm1lbnRQYXR0ZXJuKGNvbWJpbmVkWCwgY29tYmluZWRZLCBjb21iaW5lZE1vZHVsZVNpemUpO1xuICAgIH07XG4gICAgcmV0dXJuIEFsaWdubWVudFBhdHRlcm47XG59KFJlc3VsdFBvaW50XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWxpZ25tZW50UGF0dGVybjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AlignmentPattern_1 = __webpack_require__(/*! ./AlignmentPattern */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/*import java.util.ArrayList;*/\n/*import java.util.List;*/\n/**\n * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n * patterns but are smaller and appear at regular intervals throughout the image.</p>\n *\n * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n *\n * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n * pasted and stripped down here for maximum performance but does unfortunately duplicate\n * some code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n *\n * @author Sean Owen\n */\nvar AlignmentPatternFinder = /** @class */ (function () {\n    /**\n     * <p>Creates a finder that will look in a portion of the whole image.</p>\n     *\n     * @param image image to search\n     * @param startX left column from which to start searching\n     * @param startY top row from which to start searching\n     * @param width width of region to search\n     * @param height height of region to search\n     * @param moduleSize estimated module size so far\n     */\n    function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {\n        this.image = image;\n        this.startX = startX;\n        this.startY = startY;\n        this.width = width;\n        this.height = height;\n        this.moduleSize = moduleSize;\n        this.resultPointCallback = resultPointCallback;\n        this.possibleCenters = []; // new Array<any>(5))\n        // TYPESCRIPTPORT: array initialization without size as the length is checked below\n        this.crossCheckStateCount = new Int32Array(3);\n    }\n    /**\n     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n     * it's pretty performance-critical and so is written to be fast foremost.</p>\n     *\n     * @return {@link AlignmentPattern} if found\n     * @throws NotFoundException if not found\n     */\n    AlignmentPatternFinder.prototype.find = function () {\n        var startX = this.startX;\n        var height = this.height;\n        var width = this.width;\n        var maxJ = startX + width;\n        var middleI = this.startY + (height / 2);\n        // We are looking for black/white/black modules in 1:1:1 ratio\n        // this tracks the number of black/white/black modules seen so far\n        var stateCount = new Int32Array(3);\n        var image = this.image;\n        for (var iGen = 0; iGen < height; iGen++) {\n            // Search from middle outwards\n            var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            var j = startX;\n            // Burn off leading white pixels before anything else; if we start in the middle of\n            // a white run, it doesn't make sense to count its length, since we don't know if the\n            // white run continued to the left of the start point\n            while (j < maxJ && !image.get(j, i)) {\n                j++;\n            }\n            var currentState = 0;\n            while (j < maxJ) {\n                if (image.get(j, i)) {\n                    // Black pixel\n                    if (currentState === 1) { // Counting black pixels\n                        stateCount[1]++;\n                    }\n                    else { // Counting white pixels\n                        if (currentState === 2) { // A winner?\n                            if (this.foundPatternCross(stateCount)) { // Yes\n                                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n                                if (confirmed !== null) {\n                                    return confirmed;\n                                }\n                            }\n                            stateCount[0] = stateCount[2];\n                            stateCount[1] = 1;\n                            stateCount[2] = 0;\n                            currentState = 1;\n                        }\n                        else {\n                            stateCount[++currentState]++;\n                        }\n                    }\n                }\n                else { // White pixel\n                    if (currentState === 1) { // Counting black pixels\n                        currentState++;\n                    }\n                    stateCount[currentState]++;\n                }\n                j++;\n            }\n            if (this.foundPatternCross(stateCount)) {\n                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n                if (confirmed !== null) {\n                    return confirmed;\n                }\n            }\n        }\n        // Hmm, nothing we saw was observed and confirmed twice. If we had\n        // any guess at all, return it.\n        if (this.possibleCenters.length !== 0) {\n            return this.possibleCenters[0];\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Given a count of black/white/black pixels just seen and an end position,\n     * figures the location of the center of this black/white/black run.\n     */\n    AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\n        return (end - stateCount[2]) - stateCount[1] / 2.0;\n    };\n    /**\n     * @param stateCount count of black/white/black pixels just read\n     * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n     *         used by alignment patterns to be considered a match\n     */\n    AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {\n        var moduleSize = this.moduleSize;\n        var maxVariance = moduleSize / 2.0;\n        for (var i = 0; i < 3; i++) {\n            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * <p>After a horizontal scan finds a potential alignment pattern, this method\n     * \"cross-checks\" by scanning down vertically through the center of the possible\n     * alignment pattern to see if the same proportion is detected.</p>\n     *\n     * @param startI row where an alignment pattern was detected\n     * @param centerJ center of the section that appears to cross an alignment pattern\n     * @param maxCount maximum reasonable number of modules that should be\n     * observed in any reading state, based on the results of the horizontal scan\n     * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n     */\n    AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var image = this.image;\n        var maxI = image.getHeight();\n        var stateCount = this.crossCheckStateCount;\n        stateCount[0] = 0;\n        stateCount[1] = 0;\n        stateCount[2] = 0;\n        // Start counting up from center\n        var i = startI;\n        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i--;\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (i < 0 || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            i--;\n        }\n        if (stateCount[0] > maxCount) {\n            return NaN;\n        }\n        // Now also count down from center\n        i = startI + 1;\n        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i++;\n        }\n        if (i === maxI || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n            stateCount[2]++;\n            i++;\n        }\n        if (stateCount[2] > maxCount) {\n            return NaN;\n        }\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n            return NaN;\n        }\n        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n    };\n    /**\n     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n     * cross check with a vertical scan, and if successful, will see if this pattern had been\n     * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n     * found the alignment pattern.</p>\n     *\n     * @param stateCount reading state module counts from horizontal scan\n     * @param i row where alignment pattern may be found\n     * @param j end of possible alignment pattern in row\n     * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n     */\n    AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {\n        var e_1, _a;\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n        var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n        var centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);\n        if (!isNaN(centerI)) {\n            var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n            try {\n                for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var center = _c.value;\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // Hadn't found this before; save it\n            var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);\n            this.possibleCenters.push(point);\n            if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                this.resultPointCallback.foundPossibleResultPoint(point);\n            }\n        }\n        return null;\n    };\n    return AlignmentPatternFinder;\n}());\nexports[\"default\"] = AlignmentPatternFinder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvQWxpZ25tZW50UGF0dGVybkZpbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsbUJBQU8sQ0FBQyxpS0FBb0I7QUFDckQsMEJBQTBCLG1CQUFPLENBQUMsdUpBQXlCO0FBQzNELDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0RBQWtEO0FBQ2xELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZXRlY3Rvci9BbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQWxpZ25tZW50UGF0dGVybl8xID0gcmVxdWlyZShcIi4vQWxpZ25tZW50UGF0dGVyblwiKTtcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbi8qKlxuICogPHA+VGhpcyBjbGFzcyBhdHRlbXB0cyB0byBmaW5kIGFsaWdubWVudCBwYXR0ZXJucyBpbiBhIFFSIENvZGUuIEFsaWdubWVudCBwYXR0ZXJucyBsb29rIGxpa2UgZmluZGVyXG4gKiBwYXR0ZXJucyBidXQgYXJlIHNtYWxsZXIgYW5kIGFwcGVhciBhdCByZWd1bGFyIGludGVydmFscyB0aHJvdWdob3V0IHRoZSBpbWFnZS48L3A+XG4gKlxuICogPHA+QXQgdGhlIG1vbWVudCB0aGlzIG9ubHkgbG9va3MgZm9yIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICpcbiAqIDxwPlRoaXMgaXMgbW9zdGx5IGEgc2ltcGxpZmllZCBjb3B5IG9mIHtAbGluayBGaW5kZXJQYXR0ZXJuRmluZGVyfS4gSXQgaXMgY29waWVkLFxuICogcGFzdGVkIGFuZCBzdHJpcHBlZCBkb3duIGhlcmUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UgYnV0IGRvZXMgdW5mb3J0dW5hdGVseSBkdXBsaWNhdGVcbiAqIHNvbWUgY29kZS48L3A+XG4gKlxuICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudC4gRWFjaCB0aHJlYWQgbXVzdCBhbGxvY2F0ZSBpdHMgb3duIG9iamVjdC48L3A+XG4gKlxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIEFsaWdubWVudFBhdHRlcm5GaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogPHA+Q3JlYXRlcyBhIGZpbmRlciB0aGF0IHdpbGwgbG9vayBpbiBhIHBvcnRpb24gb2YgdGhlIHdob2xlIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0gc3RhcnRYIGxlZnQgY29sdW1uIGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICogQHBhcmFtIHN0YXJ0WSB0b3Agcm93IGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHJlZ2lvbiB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGhlaWdodCBvZiByZWdpb24gdG8gc2VhcmNoXG4gICAgICogQHBhcmFtIG1vZHVsZVNpemUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIHNvIGZhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFsaWdubWVudFBhdHRlcm5GaW5kZXIoaW1hZ2UsIHN0YXJ0WCAvKmludCovLCBzdGFydFkgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIG1vZHVsZVNpemUgLypmbG9hdCovLCByZXN1bHRQb2ludENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zdGFydFggPSBzdGFydFg7XG4gICAgICAgIHRoaXMuc3RhcnRZID0gc3RhcnRZO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLm1vZHVsZVNpemUgPSBtb2R1bGVTaXplO1xuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdOyAvLyBuZXcgQXJyYXk8YW55Pig1KSlcbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGFycmF5IGluaXRpYWxpemF0aW9uIHdpdGhvdXQgc2l6ZSBhcyB0aGUgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3dcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBmaW5kIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4gaW4gdGhlIGltYWdlLiBJdCBpcyBhIGJpdCBtZXNzeSBzaW5jZVxuICAgICAqIGl0J3MgcHJldHR5IHBlcmZvcm1hbmNlLWNyaXRpY2FsIGFuZCBzbyBpcyB3cml0dGVuIHRvIGJlIGZhc3QgZm9yZW1vc3QuPC9wPlxuICAgICAqXG4gICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmRcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIEFsaWdubWVudFBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydFggPSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB2YXIgbWF4SiA9IHN0YXJ0WCArIHdpZHRoO1xuICAgICAgICB2YXIgbWlkZGxlSSA9IHRoaXMuc3RhcnRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgICAvLyBXZSBhcmUgbG9va2luZyBmb3IgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBpbiAxOjE6MSByYXRpb1xuICAgICAgICAvLyB0aGlzIHRyYWNrcyB0aGUgbnVtYmVyIG9mIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgc2VlbiBzbyBmYXJcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSgzKTtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgZm9yICh2YXIgaUdlbiA9IDA7IGlHZW4gPCBoZWlnaHQ7IGlHZW4rKykge1xuICAgICAgICAgICAgLy8gU2VhcmNoIGZyb20gbWlkZGxlIG91dHdhcmRzXG4gICAgICAgICAgICB2YXIgaSA9IG1pZGRsZUkgKyAoKGlHZW4gJiAweDAxKSA9PT0gMCA/IE1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpIDogLU1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpKTtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgIHZhciBqID0gc3RhcnRYO1xuICAgICAgICAgICAgLy8gQnVybiBvZmYgbGVhZGluZyB3aGl0ZSBwaXhlbHMgYmVmb3JlIGFueXRoaW5nIGVsc2U7IGlmIHdlIHN0YXJ0IGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgIC8vIGEgd2hpdGUgcnVuLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY291bnQgaXRzIGxlbmd0aCwgc2luY2Ugd2UgZG9uJ3Qga25vdyBpZiB0aGVcbiAgICAgICAgICAgIC8vIHdoaXRlIHJ1biBjb250aW51ZWQgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCbGFjayBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAxKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDIpIHsgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBXaGl0ZSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAxKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIbW0sIG5vdGhpbmcgd2Ugc2F3IHdhcyBvYnNlcnZlZCBhbmQgY29uZmlybWVkIHR3aWNlLiBJZiB3ZSBoYWRcbiAgICAgICAgLy8gYW55IGd1ZXNzIGF0IGFsbCwgcmV0dXJuIGl0LlxuICAgICAgICBpZiAodGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sXG4gICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIGJsYWNrL3doaXRlL2JsYWNrIHJ1bi5cbiAgICAgKi9cbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzJdKSAtIHN0YXRlQ291bnRbMV0gLyAyLjA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkXG4gICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8xIHJhdGlvc1xuICAgICAqICAgICAgICAgdXNlZCBieSBhbGlnbm1lbnQgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoXG4gICAgICovXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuZm91bmRQYXR0ZXJuQ3Jvc3MgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCkge1xuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZTtcbiAgICAgICAgdmFyIG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFtpXSkgPj0gbWF4VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBhbGlnbm1lbnQgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgKiBcImNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gdmVydGljYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICogYWxpZ25tZW50IHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYW4gYWxpZ25tZW50IHBhdHRlcm4gd2FzIGRldGVjdGVkXG4gICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxuICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGFsaWdubWVudCBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrVmVydGljYWwgPSBmdW5jdGlvbiAoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQ7XG4gICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgIHZhciBpID0gc3RhcnRJO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA+PSAwICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlclxuICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1heEkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMl0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVDb3VudFsyXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxuICAgICAqIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCwgd2lsbCBzZWUgaWYgdGhpcyBwYXR0ZXJuIGhhZCBiZWVuXG4gICAgICogZm91bmQgb24gYSBwcmV2aW91cyBob3Jpem9udGFsIHNjYW4uIElmIHNvLCB3ZSBjb25zaWRlciBpdCBjb25maXJtZWQgYW5kIGNvbmNsdWRlIHdlIGhhdmVcbiAgICAgKiBmb3VuZCB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb20gaG9yaXpvbnRhbCBzY2FuXG4gICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGFsaWdubWVudCBwYXR0ZXJuIG1heSBiZSBmb3VuZFxuICAgICAqIEBwYXJhbSBqIGVuZCBvZiBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybiBpbiByb3dcbiAgICAgKiBAcmV0dXJuIHtAbGluayBBbGlnbm1lbnRQYXR0ZXJufSBpZiB3ZSBoYXZlIGZvdW5kIHRoZSBzYW1lIHBhdHRlcm4gdHdpY2UsIG9yIG51bGwgaWYgbm90XG4gICAgICovXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuaGFuZGxlUG9zc2libGVDZW50ZXIgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgIHZhciBjZW50ZXJKID0gQWxpZ25tZW50UGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgICAgICB2YXIgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIC8qKGludCkgKi8gY2VudGVySiwgMiAqIHN0YXRlQ291bnRbMV0sIHN0YXRlQ291bnRUb3RhbCk7XG4gICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgICAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gKHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSkgLyAzLjA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYWRuJ3QgZm91bmQgdGhpcyBiZWZvcmU7IHNhdmUgaXRcbiAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBBbGlnbm1lbnRQYXR0ZXJuXzEuZGVmYXVsdChjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFsaWdubWVudFBhdHRlcm5GaW5kZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWxpZ25tZW50UGF0dGVybkZpbmRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nvar DetectorResult_1 = __webpack_require__(/*! ../../common/DetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js\");\n// import GridSampler from '../../common/GridSampler';\nvar GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js\");\nvar PerspectiveTransform_1 = __webpack_require__(/*! ../../common/PerspectiveTransform */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js\");\nvar DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar Version_1 = __webpack_require__(/*! ../decoder/Version */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js\");\nvar AlignmentPatternFinder_1 = __webpack_require__(/*! ./AlignmentPatternFinder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js\");\nvar FinderPatternFinder_1 = __webpack_require__(/*! ./FinderPatternFinder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js\");\n/*import java.util.Map;*/\n/**\n * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n    }\n    Detector.prototype.getImage = function () {\n        return this.image;\n    };\n    Detector.prototype.getResultPointCallback = function () {\n        return this.resultPointCallback;\n    };\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n    //   return detect(null)\n    // }\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @param hints optional hints to detector\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    Detector.prototype.detect = function (hints) {\n        this.resultPointCallback = (hints === null || hints === undefined) ? null :\n            /*(ResultPointCallback) */ hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);\n        var info = finder.find(hints);\n        return this.processFinderPatternInfo(info);\n    };\n    Detector.prototype.processFinderPatternInfo = function (info) {\n        var topLeft = info.getTopLeft();\n        var topRight = info.getTopRight();\n        var bottomLeft = info.getBottomLeft();\n        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n        if (moduleSize < 1.0) {\n            throw new NotFoundException_1.default('No pattern found in proccess finder.');\n        }\n        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);\n        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n        var alignmentPattern = null;\n        // Anything above version 1 has an alignment pattern\n        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n            // Guess where a \"bottom right\" finder pattern would have been\n            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n            // Estimate that alignment pattern is closer by 3 modules\n            // from \"bottom right\" to known top left location\n            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n            // Kind of arbitrary -- expand search radius before giving up\n            for (var i = 4; i <= 16; i <<= 1) {\n                try {\n                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                    break;\n                }\n                catch (re /*NotFoundException*/) {\n                    if (!(re instanceof NotFoundException_1.default)) {\n                        throw re;\n                    }\n                    // try next round\n                }\n            }\n            // If we didn't find alignment pattern... well try anyway without it\n        }\n        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n        var bits = Detector.sampleGrid(this.image, transform, dimension);\n        var points;\n        if (alignmentPattern === null) {\n            points = [bottomLeft, topLeft, topRight];\n        }\n        else {\n            points = [bottomLeft, topLeft, topRight, alignmentPattern];\n        }\n        return new DetectorResult_1.default(bits, points);\n    };\n    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {\n        var dimMinusThree = dimension - 3.5;\n        var bottomRightX; /*float*/\n        var bottomRightY; /*float*/\n        var sourceBottomRightX; /*float*/\n        var sourceBottomRightY; /*float*/\n        if (alignmentPattern !== null) {\n            bottomRightX = alignmentPattern.getX();\n            bottomRightY = alignmentPattern.getY();\n            sourceBottomRightX = dimMinusThree - 3.0;\n            sourceBottomRightY = sourceBottomRightX;\n        }\n        else {\n            // Don't have an alignment pattern, just make up the bottom-right point\n            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();\n            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();\n            sourceBottomRightX = dimMinusThree;\n            sourceBottomRightY = dimMinusThree;\n        }\n        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n    };\n    Detector.sampleGrid = function (image, transform, dimension /*int*/) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n    };\n    /**\n     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n     * of the finder patterns and estimated module size.</p>\n     */\n    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {\n        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);\n        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);\n        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n        switch (dimension & 0x03) { // mod 4\n            case 0:\n                dimension++;\n                break;\n            // 1? do nothing\n            case 2:\n                dimension--;\n                break;\n            case 3:\n                throw new NotFoundException_1.default('Dimensions could be not found.');\n        }\n        return dimension;\n    };\n    /**\n     * <p>Computes an average estimated module size based on estimated derived from the positions\n     * of the three finder patterns.</p>\n     *\n     * @param topLeft detected top-left finder pattern center\n     * @param topRight detected top-right finder pattern center\n     * @param bottomLeft detected bottom-left finder pattern center\n     * @return estimated module size\n     */\n    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n        // Take the average\n        return (this.calculateModuleSizeOneWay(topLeft, topRight) +\n            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n    };\n    /**\n     * <p>Estimates module size based on two finder patterns -- it uses\n     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n     * width of each, measuring along the axis between their centers.</p>\n     */\n    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()), \n        /*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()));\n        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()), \n        /*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()));\n        if (isNaN(moduleSizeEst1)) {\n            return moduleSizeEst2 / 7.0;\n        }\n        if (isNaN(moduleSizeEst2)) {\n            return moduleSizeEst1 / 7.0;\n        }\n        // Average them, and divide by 7 since we've counted the width of 3 black modules,\n        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n    };\n    /**\n     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n     * a finder pattern by looking for a black-white-black run from the center in the direction\n     * of another point (another finder pattern center), and in the opposite direction too.\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n        // Now count other way -- don't run off image though of course\n        var scale = 1.0;\n        var otherToX = fromX - (toX - fromX);\n        if (otherToX < 0) {\n            scale = fromX / /*(float) */ (fromX - otherToX);\n            otherToX = 0;\n        }\n        else if (otherToX >= this.image.getWidth()) {\n            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n            otherToX = this.image.getWidth() - 1;\n        }\n        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n        scale = 1.0;\n        if (otherToY < 0) {\n            scale = fromY / /*(float) */ (fromY - otherToY);\n            otherToY = 0;\n        }\n        else if (otherToY >= this.image.getHeight()) {\n            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n            otherToY = this.image.getHeight() - 1;\n        }\n        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n        // Middle pixel is double-counted this way; subtract 1\n        return result - 1.0;\n    };\n    /**\n     * <p>This method traces a line from a point in the image, in the direction towards another point.\n     * It begins in a black region, and keeps going until it finds white, then black, then white again.\n     * It reports the distance from the start to this point.</p>\n     *\n     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n     * may be skewed or rotated.</p>\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        // Mild variant of Bresenham's algorithm\n        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var xstep = fromX < toX ? 1 : -1;\n        var ystep = fromY < toY ? 1 : -1;\n        // In black pixels, looking for white, first or second time.\n        var state = 0;\n        // Loop up until x == toX, but not beyond\n        var xLimit = toX + xstep;\n        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {\n            var realX = steep ? y : x;\n            var realY = steep ? x : y;\n            // Does current pixel mean we have moved white to black or vice versa?\n            // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n            // color, advance to next state or end if we are in state 2 already\n            if ((state === 1) === this.image.get(realX, realY)) {\n                if (state === 2) {\n                    return MathUtils_1.default.distance(x, y, fromX, fromY);\n                }\n                state++;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n        // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n        if (state === 2) {\n            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);\n        }\n        // else we didn't find even black-white-black; no estimate is really possible\n        return NaN;\n    };\n    /**\n     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n     *\n     * @param overallEstModuleSize estimated module size so far\n     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n     * @param estAlignmentY y coordinate of above\n     * @param allowanceFactor number of pixels in all directions to search from the center\n     * @return {@link AlignmentPattern} if found, or null otherwise\n     * @throws NotFoundException if an unexpected error occurs during detection\n     */\n    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {\n        // Look for an alignment pattern (3 modules in size) around where it\n        // should be\n        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');\n        }\n        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');\n        }\n        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n        return alignmentFinder.find();\n    };\n    return Detector;\n}());\nexports[\"default\"] = Detector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvRGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsdUtBQWlDO0FBQzNELHVCQUF1QixtQkFBTyxDQUFDLCtKQUE2QjtBQUM1RDtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLHlLQUFrQztBQUN0RSw2QkFBNkIsbUJBQU8sQ0FBQywyS0FBbUM7QUFDeEUsdUJBQXVCLG1CQUFPLENBQUMsaUpBQXNCO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQywySUFBbUI7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsdUpBQW9CO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLDZLQUEwQjtBQUNqRSw0QkFBNEIsbUJBQU8sQ0FBQyx1S0FBdUI7QUFDM0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUE2RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQXNEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2RldGVjdG9yL0RldGVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcbnZhciBEZXRlY3RvclJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9EZXRlY3RvclJlc3VsdFwiKTtcbi8vIGltcG9ydCBHcmlkU2FtcGxlciBmcm9tICcuLi8uLi9jb21tb24vR3JpZFNhbXBsZXInO1xudmFyIEdyaWRTYW1wbGVySW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZVwiKTtcbnZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9QZXJzcGVjdGl2ZVRyYW5zZm9ybVwiKTtcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRQb2ludFwiKTtcbnZhciBWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vZGVjb2Rlci9WZXJzaW9uXCIpO1xudmFyIEFsaWdubWVudFBhdHRlcm5GaW5kZXJfMSA9IHJlcXVpcmUoXCIuL0FsaWdubWVudFBhdHRlcm5GaW5kZXJcIik7XG52YXIgRmluZGVyUGF0dGVybkZpbmRlcl8xID0gcmVxdWlyZShcIi4vRmluZGVyUGF0dGVybkZpbmRlclwiKTtcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbi8qKlxuICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIFFSIENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlIFFSIENvZGVcbiAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXRlY3RvcihpbWFnZSkge1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XG4gICAgfTtcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0UmVzdWx0UG9pbnRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgUVIgQ29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgZGV0ZWN0KCk6IERldGVjdG9yUmVzdWx0IC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7XG4gICAgLy8gICByZXR1cm4gZGV0ZWN0KG51bGwpXG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoaW50cyBvcHRpb25hbCBoaW50cyB0byBkZXRlY3RvclxuICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgUVIgQ29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24gKGhpbnRzKSB7XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IChoaW50cyA9PT0gbnVsbCB8fCBoaW50cyA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOlxuICAgICAgICAgICAgLyooUmVzdWx0UG9pbnRDYWxsYmFjaykgKi8gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgIHZhciBmaW5kZXIgPSBuZXcgRmluZGVyUGF0dGVybkZpbmRlcl8xLmRlZmF1bHQodGhpcy5pbWFnZSwgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrKTtcbiAgICAgICAgdmFyIGluZm8gPSBmaW5kZXIuZmluZChoaW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKTtcbiAgICB9O1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5wcm9jZXNzRmluZGVyUGF0dGVybkluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICB2YXIgdG9wTGVmdCA9IGluZm8uZ2V0VG9wTGVmdCgpO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSBpbmZvLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gaW5mby5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIHZhciBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcbiAgICAgICAgaWYgKG1vZHVsZVNpemUgPCAxLjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05vIHBhdHRlcm4gZm91bmQgaW4gcHJvY2Nlc3MgZmluZGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBEZXRlY3Rvci5jb21wdXRlRGltZW5zaW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplKTtcbiAgICAgICAgdmFyIHByb3Zpc2lvbmFsVmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihkaW1lbnNpb24pO1xuICAgICAgICB2YXIgbW9kdWxlc0JldHdlZW5GUENlbnRlcnMgPSBwcm92aXNpb25hbFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpIC0gNztcbiAgICAgICAgdmFyIGFsaWdubWVudFBhdHRlcm4gPSBudWxsO1xuICAgICAgICAvLyBBbnl0aGluZyBhYm92ZSB2ZXJzaW9uIDEgaGFzIGFuIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24uZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBHdWVzcyB3aGVyZSBhIFwiYm90dG9tIHJpZ2h0XCIgZmluZGVyIHBhdHRlcm4gd291bGQgaGF2ZSBiZWVuXG4gICAgICAgICAgICB2YXIgYm90dG9tUmlnaHRYID0gdG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkgKyBib3R0b21MZWZ0LmdldFgoKTtcbiAgICAgICAgICAgIHZhciBib3R0b21SaWdodFkgPSB0b3BSaWdodC5nZXRZKCkgLSB0b3BMZWZ0LmdldFkoKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xuICAgICAgICAgICAgLy8gRXN0aW1hdGUgdGhhdCBhbGlnbm1lbnQgcGF0dGVybiBpcyBjbG9zZXIgYnkgMyBtb2R1bGVzXG4gICAgICAgICAgICAvLyBmcm9tIFwiYm90dG9tIHJpZ2h0XCIgdG8ga25vd24gdG9wIGxlZnQgbG9jYXRpb25cbiAgICAgICAgICAgIHZhciBjb3JyZWN0aW9uVG9Ub3BMZWZ0ID0gMS4wIC0gMy4wIC8gbW9kdWxlc0JldHdlZW5GUENlbnRlcnM7XG4gICAgICAgICAgICB2YXIgZXN0QWxpZ25tZW50WCA9IC8qKGludCkgKi8gTWF0aC5mbG9vcih0b3BMZWZ0LmdldFgoKSArIGNvcnJlY3Rpb25Ub1RvcExlZnQgKiAoYm90dG9tUmlnaHRYIC0gdG9wTGVmdC5nZXRYKCkpKTtcbiAgICAgICAgICAgIHZhciBlc3RBbGlnbm1lbnRZID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WSgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFkgLSB0b3BMZWZ0LmdldFkoKSkpO1xuICAgICAgICAgICAgLy8gS2luZCBvZiBhcmJpdHJhcnkgLS0gZXhwYW5kIHNlYXJjaCByYWRpdXMgYmVmb3JlIGdpdmluZyB1cFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDQ7IGkgPD0gMTY7IGkgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRQYXR0ZXJuID0gdGhpcy5maW5kQWxpZ25tZW50SW5SZWdpb24obW9kdWxlU2l6ZSwgZXN0QWxpZ25tZW50WCwgZXN0QWxpZ25tZW50WSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocmUgLypOb3RGb3VuZEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IG5leHQgcm91bmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbGlnbm1lbnQgcGF0dGVybi4uLiB3ZWxsIHRyeSBhbnl3YXkgd2l0aG91dCBpdFxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBEZXRlY3Rvci5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbik7XG4gICAgICAgIHZhciBiaXRzID0gRGV0ZWN0b3Iuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbik7XG4gICAgICAgIHZhciBwb2ludHM7XG4gICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gW2JvdHRvbUxlZnQsIHRvcExlZnQsIHRvcFJpZ2h0LCBhbGlnbm1lbnRQYXR0ZXJuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0XzEuZGVmYXVsdChiaXRzLCBwb2ludHMpO1xuICAgIH07XG4gICAgRGV0ZWN0b3IuY3JlYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBhbGlnbm1lbnRQYXR0ZXJuLCBkaW1lbnNpb24gLyppbnQqLykge1xuICAgICAgICB2YXIgZGltTWludXNUaHJlZSA9IGRpbWVuc2lvbiAtIDMuNTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0WDsgLypmbG9hdCovXG4gICAgICAgIHZhciBib3R0b21SaWdodFk7IC8qZmxvYXQqL1xuICAgICAgICB2YXIgc291cmNlQm90dG9tUmlnaHRYOyAvKmZsb2F0Ki9cbiAgICAgICAgdmFyIHNvdXJjZUJvdHRvbVJpZ2h0WTsgLypmbG9hdCovXG4gICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib3R0b21SaWdodFggPSBhbGlnbm1lbnRQYXR0ZXJuLmdldFgoKTtcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0WSA9IGFsaWdubWVudFBhdHRlcm4uZ2V0WSgpO1xuICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gZGltTWludXNUaHJlZSAtIDMuMDtcbiAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WSA9IHNvdXJjZUJvdHRvbVJpZ2h0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvbid0IGhhdmUgYW4gYWxpZ25tZW50IHBhdHRlcm4sIGp1c3QgbWFrZSB1cCB0aGUgYm90dG9tLXJpZ2h0IHBvaW50XG4gICAgICAgICAgICBib3R0b21SaWdodFggPSAodG9wUmlnaHQuZ2V0WCgpIC0gdG9wTGVmdC5nZXRYKCkpICsgYm90dG9tTGVmdC5nZXRYKCk7XG4gICAgICAgICAgICBib3R0b21SaWdodFkgPSAodG9wUmlnaHQuZ2V0WSgpIC0gdG9wTGVmdC5nZXRZKCkpICsgYm90dG9tTGVmdC5nZXRZKCk7XG4gICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFggPSBkaW1NaW51c1RocmVlO1xuICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRZID0gZGltTWludXNUaHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm1fMS5kZWZhdWx0LnF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoMy41LCAzLjUsIGRpbU1pbnVzVGhyZWUsIDMuNSwgc291cmNlQm90dG9tUmlnaHRYLCBzb3VyY2VCb3R0b21SaWdodFksIDMuNSwgZGltTWludXNUaHJlZSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHRYLCBib3R0b21SaWdodFksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgfTtcbiAgICBEZXRlY3Rvci5zYW1wbGVHcmlkID0gZnVuY3Rpb24gKGltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgIHZhciBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZV8xLmRlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZXIuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0oaW1hZ2UsIGRpbWVuc2lvbiwgZGltZW5zaW9uLCB0cmFuc2Zvcm0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+Q29tcHV0ZXMgdGhlIGRpbWVuc2lvbiAobnVtYmVyIG9mIG1vZHVsZXMgb24gYSBzaXplKSBvZiB0aGUgUVIgQ29kZSBiYXNlZCBvbiB0aGUgcG9zaXRpb25cbiAgICAgKiBvZiB0aGUgZmluZGVyIHBhdHRlcm5zIGFuZCBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuPC9wPlxuICAgICAqL1xuICAgIERldGVjdG9yLmNvbXB1dGVEaW1lbnNpb24gPSBmdW5jdGlvbiAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIG1vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgIHZhciB0bHRyQ2VudGVyc0RpbWVuc2lvbiA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoUmVzdWx0UG9pbnRfMS5kZWZhdWx0LmRpc3RhbmNlKHRvcExlZnQsIHRvcFJpZ2h0KSAvIG1vZHVsZVNpemUpO1xuICAgICAgICB2YXIgdGxibENlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKFJlc3VsdFBvaW50XzEuZGVmYXVsdC5kaXN0YW5jZSh0b3BMZWZ0LCBib3R0b21MZWZ0KSAvIG1vZHVsZVNpemUpO1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gTWF0aC5mbG9vcigodGx0ckNlbnRlcnNEaW1lbnNpb24gKyB0bGJsQ2VudGVyc0RpbWVuc2lvbikgLyAyKSArIDc7XG4gICAgICAgIHN3aXRjaCAoZGltZW5zaW9uICYgMHgwMykgeyAvLyBtb2QgNFxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gMT8gZG8gbm90aGluZ1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbi0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RpbWVuc2lvbnMgY291bGQgYmUgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1lbnNpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA8cD5Db21wdXRlcyBhbiBhdmVyYWdlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBiYXNlZCBvbiBlc3RpbWF0ZWQgZGVyaXZlZCBmcm9tIHRoZSBwb3NpdGlvbnNcbiAgICAgKiBvZiB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3BMZWZ0IGRldGVjdGVkIHRvcC1sZWZ0IGZpbmRlciBwYXR0ZXJuIGNlbnRlclxuICAgICAqIEBwYXJhbSB0b3BSaWdodCBkZXRlY3RlZCB0b3AtcmlnaHQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICogQHBhcmFtIGJvdHRvbUxlZnQgZGV0ZWN0ZWQgYm90dG9tLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICogQHJldHVybiBlc3RpbWF0ZWQgbW9kdWxlIHNpemVcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuY2FsY3VsYXRlTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCkge1xuICAgICAgICAvLyBUYWtlIHRoZSBhdmVyYWdlXG4gICAgICAgIHJldHVybiAodGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHRvcExlZnQsIHRvcFJpZ2h0KSArXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+RXN0aW1hdGVzIG1vZHVsZSBzaXplIGJhc2VkIG9uIHR3byBmaW5kZXIgcGF0dGVybnMgLS0gaXQgdXNlc1xuICAgICAqIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoaW50LCBpbnQsIGludCwgaW50KX0gdG8gZmlndXJlIHRoZVxuICAgICAqIHdpZHRoIG9mIGVhY2gsIG1lYXN1cmluZyBhbG9uZyB0aGUgYXhpcyBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuPC9wPlxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5ID0gZnVuY3Rpb24gKHBhdHRlcm4sIG90aGVyUGF0dGVybikge1xuICAgICAgICB2YXIgbW9kdWxlU2l6ZUVzdDEgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRZKCkpLCBcbiAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRZKCkpKTtcbiAgICAgICAgdmFyIG1vZHVsZVNpemVFc3QyID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFkoKSksIFxuICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcbiAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WSgpKSk7XG4gICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MiAvIDcuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4obW9kdWxlU2l6ZUVzdDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDEgLyA3LjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXZlcmFnZSB0aGVtLCBhbmQgZGl2aWRlIGJ5IDcgc2luY2Ugd2UndmUgY291bnRlZCB0aGUgd2lkdGggb2YgMyBibGFjayBtb2R1bGVzLFxuICAgICAgICAvLyBhbmQgMSB3aGl0ZSBhbmQgMSBibGFjayBtb2R1bGUgb24gZWl0aGVyIHNpZGUuIEVyZ28sIGRpdmlkZSBzdW0gYnkgMTQuXG4gICAgICAgIHJldHVybiAobW9kdWxlU2l6ZUVzdDEgKyBtb2R1bGVTaXplRXN0MikgLyAxNC4wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlcyB0aGUgdG90YWwgd2lkdGggb2ZcbiAgICAgKiBhIGZpbmRlciBwYXR0ZXJuIGJ5IGxvb2tpbmcgZm9yIGEgYmxhY2std2hpdGUtYmxhY2sgcnVuIGZyb20gdGhlIGNlbnRlciBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICogb2YgYW5vdGhlciBwb2ludCAoYW5vdGhlciBmaW5kZXIgcGF0dGVybiBjZW50ZXIpLCBhbmQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0b28uXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzID0gZnVuY3Rpb24gKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG4gICAgICAgIC8vIE5vdyBjb3VudCBvdGhlciB3YXkgLS0gZG9uJ3QgcnVuIG9mZiBpbWFnZSB0aG91Z2ggb2YgY291cnNlXG4gICAgICAgIHZhciBzY2FsZSA9IDEuMDtcbiAgICAgICAgdmFyIG90aGVyVG9YID0gZnJvbVggLSAodG9YIC0gZnJvbVgpO1xuICAgICAgICBpZiAob3RoZXJUb1ggPCAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGZyb21YIC8gLyooZmxvYXQpICovIChmcm9tWCAtIG90aGVyVG9YKTtcbiAgICAgICAgICAgIG90aGVyVG9YID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlclRvWCA+PSB0aGlzLmltYWdlLmdldFdpZHRoKCkpIHtcbiAgICAgICAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDEgLSBmcm9tWCkgLyAvKihmbG9hdCkgKi8gKG90aGVyVG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlclRvWSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihmcm9tWSAtICh0b1kgLSBmcm9tWSkgKiBzY2FsZSk7XG4gICAgICAgIHNjYWxlID0gMS4wO1xuICAgICAgICBpZiAob3RoZXJUb1kgPCAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGZyb21ZIC8gLyooZmxvYXQpICovIChmcm9tWSAtIG90aGVyVG9ZKTtcbiAgICAgICAgICAgIG90aGVyVG9ZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlclRvWSA+PSB0aGlzLmltYWdlLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSAtIGZyb21ZKSAvIC8qKGZsb2F0KSAqLyAob3RoZXJUb1kgLSBmcm9tWSk7XG4gICAgICAgICAgICBvdGhlclRvWSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyVG9YID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGZyb21YICsgKG90aGVyVG9YIC0gZnJvbVgpICogc2NhbGUpO1xuICAgICAgICByZXN1bHQgKz0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCBvdGhlclRvWCwgb3RoZXJUb1kpO1xuICAgICAgICAvLyBNaWRkbGUgcGl4ZWwgaXMgZG91YmxlLWNvdW50ZWQgdGhpcyB3YXk7IHN1YnRyYWN0IDFcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAtIDEuMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgbWV0aG9kIHRyYWNlcyBhIGxpbmUgZnJvbSBhIHBvaW50IGluIHRoZSBpbWFnZSwgaW4gdGhlIGRpcmVjdGlvbiB0b3dhcmRzIGFub3RoZXIgcG9pbnQuXG4gICAgICogSXQgYmVnaW5zIGluIGEgYmxhY2sgcmVnaW9uLCBhbmQga2VlcHMgZ29pbmcgdW50aWwgaXQgZmluZHMgd2hpdGUsIHRoZW4gYmxhY2ssIHRoZW4gd2hpdGUgYWdhaW4uXG4gICAgICogSXQgcmVwb3J0cyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgdG8gdGhpcyBwb2ludC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGlzIHVzZWQgd2hlbiBmaWd1cmluZyBvdXQgaG93IHdpZGUgYSBmaW5kZXIgcGF0dGVybiBpcywgd2hlbiB0aGUgZmluZGVyIHBhdHRlcm5cbiAgICAgKiBtYXkgYmUgc2tld2VkIG9yIHJvdGF0ZWQuPC9wPlxuICAgICAqL1xuICAgIERldGVjdG9yLnByb3RvdHlwZS5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4gPSBmdW5jdGlvbiAoZnJvbVggLyppbnQqLywgZnJvbVkgLyppbnQqLywgdG9YIC8qaW50Ki8sIHRvWSAvKmludCovKSB7XG4gICAgICAgIC8vIE1pbGQgdmFyaWFudCBvZiBCcmVzZW5oYW0ncyBhbGdvcml0aG1cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG1cbiAgICAgICAgdmFyIHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZnJvbVg7XG4gICAgICAgICAgICBmcm9tWCA9IGZyb21ZO1xuICAgICAgICAgICAgZnJvbVkgPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IHRvWDtcbiAgICAgICAgICAgIHRvWCA9IHRvWTtcbiAgICAgICAgICAgIHRvWSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7XG4gICAgICAgIHZhciBlcnJvciA9IC1keCAvIDI7XG4gICAgICAgIHZhciB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xuICAgICAgICB2YXIgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgLy8gSW4gYmxhY2sgcGl4ZWxzLCBsb29raW5nIGZvciB3aGl0ZSwgZmlyc3Qgb3Igc2Vjb25kIHRpbWUuXG4gICAgICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgICAgIC8vIExvb3AgdXAgdW50aWwgeCA9PSB0b1gsIGJ1dCBub3QgYmV5b25kXG4gICAgICAgIHZhciB4TGltaXQgPSB0b1ggKyB4c3RlcDtcbiAgICAgICAgZm9yICh2YXIgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHhMaW1pdDsgeCArPSB4c3RlcCkge1xuICAgICAgICAgICAgdmFyIHJlYWxYID0gc3RlZXAgPyB5IDogeDtcbiAgICAgICAgICAgIHZhciByZWFsWSA9IHN0ZWVwID8geCA6IHk7XG4gICAgICAgICAgICAvLyBEb2VzIGN1cnJlbnQgcGl4ZWwgbWVhbiB3ZSBoYXZlIG1vdmVkIHdoaXRlIHRvIGJsYWNrIG9yIHZpY2UgdmVyc2E/XG4gICAgICAgICAgICAvLyBTY2FubmluZyBibGFjayBpbiBzdGF0ZSAwLDIgYW5kIHdoaXRlIGluIHN0YXRlIDEsIHNvIGlmIHdlIGZpbmQgdGhlIHdyb25nXG4gICAgICAgICAgICAvLyBjb2xvciwgYWR2YW5jZSB0byBuZXh0IHN0YXRlIG9yIGVuZCBpZiB3ZSBhcmUgaW4gc3RhdGUgMiBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoKHN0YXRlID09PSAxKSA9PT0gdGhpcy5pbWFnZS5nZXQocmVhbFgsIHJlYWxZKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzXzEuZGVmYXVsdC5kaXN0YW5jZSh4LCB5LCBmcm9tWCwgZnJvbVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gZHk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgICAgICAgICBlcnJvciAtPSBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VuZCBibGFjay13aGl0ZS1ibGFjazsgZ2l2ZSB0aGUgYmVuZWZpdCBvZiB0aGUgZG91YnQgdGhhdCB0aGUgbmV4dCBwaXhlbCBvdXRzaWRlIHRoZSBpbWFnZVxuICAgICAgICAvLyBpcyBcIndoaXRlXCIgc28gdGhpcyBsYXN0IHBvaW50IGF0ICh0b1greFN0ZXAsdG9ZKSBpcyB0aGUgcmlnaHQgZW5kaW5nLiBUaGlzIGlzIHJlYWxseSBhXG4gICAgICAgIC8vIHNtYWxsIGFwcHJveGltYXRpb247ICh0b1greFN0ZXAsdG9ZK3lTdGVwKSBtaWdodCBiZSByZWFsbHkgY29ycmVjdC4gSWdub3JlIHRoaXMuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UodG9YICsgeHN0ZXAsIHRvWSwgZnJvbVgsIGZyb21ZKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIHdlIGRpZG4ndCBmaW5kIGV2ZW4gYmxhY2std2hpdGUtYmxhY2s7IG5vIGVzdGltYXRlIGlzIHJlYWxseSBwb3NzaWJsZVxuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+QXR0ZW1wdHMgdG8gbG9jYXRlIGFuIGFsaWdubWVudCBwYXR0ZXJuIGluIGEgbGltaXRlZCByZWdpb24gb2YgdGhlIGltYWdlLCB3aGljaCBpc1xuICAgICAqIGd1ZXNzZWQgdG8gY29udGFpbiBpdC4gVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIG92ZXJhbGxFc3RNb2R1bGVTaXplIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBzbyBmYXJcbiAgICAgKiBAcGFyYW0gZXN0QWxpZ25tZW50WCB4IGNvb3JkaW5hdGUgb2YgY2VudGVyIG9mIGFyZWEgcHJvYmFibHkgY29udGFpbmluZyBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAqIEBwYXJhbSBlc3RBbGlnbm1lbnRZIHkgY29vcmRpbmF0ZSBvZiBhYm92ZVxuICAgICAqIEBwYXJhbSBhbGxvd2FuY2VGYWN0b3IgbnVtYmVyIG9mIHBpeGVscyBpbiBhbGwgZGlyZWN0aW9ucyB0byBzZWFyY2ggZnJvbSB0aGUgY2VudGVyXG4gICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmQsIG9yIG51bGwgb3RoZXJ3aXNlXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycyBkdXJpbmcgZGV0ZWN0aW9uXG4gICAgICovXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmZpbmRBbGlnbm1lbnRJblJlZ2lvbiA9IGZ1bmN0aW9uIChvdmVyYWxsRXN0TW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGVzdEFsaWdubWVudFggLyppbnQqLywgZXN0QWxpZ25tZW50WSAvKmludCovLCBhbGxvd2FuY2VGYWN0b3IgLypmbG9hdCovKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGFsaWdubWVudCBwYXR0ZXJuICgzIG1vZHVsZXMgaW4gc2l6ZSkgYXJvdW5kIHdoZXJlIGl0XG4gICAgICAgIC8vIHNob3VsZCBiZVxuICAgICAgICB2YXIgYWxsb3dhbmNlID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGFsbG93YW5jZUZhY3RvciAqIG92ZXJhbGxFc3RNb2R1bGVTaXplKTtcbiAgICAgICAgdmFyIGFsaWdubWVudEFyZWFMZWZ0WCA9IE1hdGgubWF4KDAsIGVzdEFsaWdubWVudFggLSBhbGxvd2FuY2UpO1xuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYVJpZ2h0WCA9IE1hdGgubWluKHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDEsIGVzdEFsaWdubWVudFggKyBhbGxvd2FuY2UpO1xuICAgICAgICBpZiAoYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgnQWxpZ25tZW50IHRvcCBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYVRvcFkgPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRZIC0gYWxsb3dhbmNlKTtcbiAgICAgICAgdmFyIGFsaWdubWVudEFyZWFCb3R0b21ZID0gTWF0aC5taW4odGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDEsIGVzdEFsaWdubWVudFkgKyBhbGxvd2FuY2UpO1xuICAgICAgICBpZiAoYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgnQWxpZ25tZW50IGJvdHRvbSBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxpZ25tZW50RmluZGVyID0gbmV3IEFsaWdubWVudFBhdHRlcm5GaW5kZXJfMS5kZWZhdWx0KHRoaXMuaW1hZ2UsIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYVRvcFksIGFsaWdubWVudEFyZWFSaWdodFggLSBhbGlnbm1lbnRBcmVhTGVmdFgsIGFsaWdubWVudEFyZWFCb3R0b21ZIC0gYWxpZ25tZW50QXJlYVRvcFksIG92ZXJhbGxFc3RNb2R1bGVTaXplLCB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gYWxpZ25tZW50RmluZGVyLmZpbmQoKTtcbiAgICB9O1xuICAgIHJldHVybiBEZXRlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZXRlY3RvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.detector {*/\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\n/**\n * <p>Encapsulates a finder pattern, which are the three square patterns found in\n * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\n * as a convenience to the finder's bookkeeping.</p>\n *\n * @author Sean Owen\n */\nvar FinderPattern = /** @class */ (function (_super) {\n    __extends(FinderPattern, _super);\n    // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\n    //   this(posX, posY, estimatedModuleSize, 1)\n    // }\n    function FinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {\n        var _this = _super.call(this, posX, posY) || this;\n        _this.estimatedModuleSize = estimatedModuleSize;\n        _this.count = count;\n        if (undefined === count) {\n            _this.count = 1;\n        }\n        return _this;\n    }\n    FinderPattern.prototype.getEstimatedModuleSize = function () {\n        return this.estimatedModuleSize;\n    };\n    FinderPattern.prototype.getCount = function () {\n        return this.count;\n    };\n    /*\n    void incrementCount() {\n      this.count++\n    }\n     */\n    /**\n     * <p>Determines if this finder pattern \"about equals\" a finder pattern at the stated\n     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n     */\n    FinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {\n        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n        }\n        return false;\n    };\n    /**\n     * Combines this object's current estimate of a finder pattern position and module size\n     * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average\n     * based on count.\n     */\n    FinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {\n        var combinedCount = this.count + 1;\n        var combinedX = (this.count * this.getX() + j) / combinedCount;\n        var combinedY = (this.count * this.getY() + i) / combinedCount;\n        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\n        return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);\n    };\n    return FinderPattern;\n}(ResultPoint_1.default));\nexports[\"default\"] = FinderPattern;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvRmluZGVyUGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhDQUE4QztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQywySUFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvRmluZGVyUGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xuLyoqXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBmaW5kZXIgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSB0aHJlZSBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cbiAqIHRoZSBjb3JuZXJzIG9mIFFSIENvZGVzLiBJdCBhbHNvIGVuY2Fwc3VsYXRlcyBhIGNvdW50IG9mIHNpbWlsYXIgZmluZGVyIHBhdHRlcm5zLFxuICogYXMgYSBjb252ZW5pZW5jZSB0byB0aGUgZmluZGVyJ3MgYm9va2tlZXBpbmcuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBGaW5kZXJQYXR0ZXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaW5kZXJQYXR0ZXJuLCBfc3VwZXIpO1xuICAgIC8vIEZpbmRlclBhdHRlcm4ocG9zWDogbnVtYmVyLypmbG9hdCovLCBwb3NZOiBudW1iZXIvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemU6IG51bWJlci8qZmxvYXQqLykge1xuICAgIC8vICAgdGhpcyhwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplLCAxKVxuICAgIC8vIH1cbiAgICBmdW5jdGlvbiBGaW5kZXJQYXR0ZXJuKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9zWCwgcG9zWSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgIF90aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICBfdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgIH07XG4gICAgRmluZGVyUGF0dGVybi5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgIH07XG4gICAgLypcbiAgICB2b2lkIGluY3JlbWVudENvdW50KCkge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkRldGVybWluZXMgaWYgdGhpcyBmaW5kZXIgcGF0dGVybiBcImFib3V0IGVxdWFsc1wiIGEgZmluZGVyIHBhdHRlcm4gYXQgdGhlIHN0YXRlZFxuICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XG4gICAgICovXG4gICAgRmluZGVyUGF0dGVybi5wcm90b3R5cGUuYWJvdXRFcXVhbHMgPSBmdW5jdGlvbiAobW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8IG1vZHVsZVNpemVEaWZmIDw9IHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvbiBhbmQgbW9kdWxlIHNpemVcbiAgICAgKiB3aXRoIGEgbmV3IGVzdGltYXRlLiBJdCByZXR1cm5zIGEgbmV3IHtAY29kZSBGaW5kZXJQYXR0ZXJufSBjb250YWluaW5nIGEgd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAqIGJhc2VkIG9uIGNvdW50LlxuICAgICAqL1xuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmNvbWJpbmVFc3RpbWF0ZSA9IGZ1bmN0aW9uIChpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8sIG5ld01vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgIHZhciBjb21iaW5lZENvdW50ID0gdGhpcy5jb3VudCArIDE7XG4gICAgICAgIHZhciBjb21iaW5lZFggPSAodGhpcy5jb3VudCAqIHRoaXMuZ2V0WCgpICsgaikgLyBjb21iaW5lZENvdW50O1xuICAgICAgICB2YXIgY29tYmluZWRZID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFkoKSArIGkpIC8gY29tYmluZWRDb3VudDtcbiAgICAgICAgdmFyIGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmNvdW50ICogdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xuICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4oY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSwgY29tYmluZWRDb3VudCk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluZGVyUGF0dGVybjtcbn0oUmVzdWx0UG9pbnRfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js ***!
  \*******************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.detector {*/\nvar DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nvar FinderPattern_1 = __webpack_require__(/*! ./FinderPattern */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js\");\nvar FinderPatternInfo_1 = __webpack_require__(/*! ./FinderPatternInfo */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js\");\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\n/*import java.io.Serializable;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collections;*/\n/*import java.util.Comparator;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\n * markers at three corners of a QR Code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\n *\n * @author Sean Owen\n */\nvar FinderPatternFinder = /** @class */ (function () {\n    /**\n     * <p>Creates a finder that will search the image for three finder patterns.</p>\n     *\n     * @param image image to search\n     */\n    // public constructor(image: BitMatrix) {\n    //   this(image, null)\n    // }\n    function FinderPatternFinder(image, resultPointCallback) {\n        this.image = image;\n        this.resultPointCallback = resultPointCallback;\n        this.possibleCenters = [];\n        this.crossCheckStateCount = new Int32Array(5);\n        this.resultPointCallback = resultPointCallback;\n    }\n    FinderPatternFinder.prototype.getImage = function () {\n        return this.image;\n    };\n    FinderPatternFinder.prototype.getPossibleCenters = function () {\n        return this.possibleCenters;\n    };\n    FinderPatternFinder.prototype.find = function (hints) {\n        var tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);\n        var pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE);\n        var image = this.image;\n        var maxI = image.getHeight();\n        var maxJ = image.getWidth();\n        // We are looking for black/white/black/white/black modules in\n        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\n        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\n        // image, and then account for the center being 3 modules in size. This gives the smallest\n        // number of pixels the center could be, so skip this often. When trying harder, look for all\n        // QR versions regardless of how dense they are.\n        var iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));\n        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {\n            iSkip = FinderPatternFinder.MIN_SKIP;\n        }\n        var done = false;\n        var stateCount = new Int32Array(5);\n        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {\n            // Get a row of black/white values\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            stateCount[3] = 0;\n            stateCount[4] = 0;\n            var currentState = 0;\n            for (var j = 0; j < maxJ; j++) {\n                if (image.get(j, i)) {\n                    // Black pixel\n                    if ((currentState & 1) === 1) { // Counting white pixels\n                        currentState++;\n                    }\n                    stateCount[currentState]++;\n                }\n                else { // White pixel\n                    if ((currentState & 1) === 0) { // Counting black pixels\n                        if (currentState === 4) { // A winner?\n                            if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes\n                                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);\n                                if (confirmed === true) {\n                                    // Start examining every other line. Checking each line turned out to be too\n                                    // expensive and didn't improve performance.\n                                    iSkip = 2;\n                                    if (this.hasSkipped === true) {\n                                        done = this.haveMultiplyConfirmedCenters();\n                                    }\n                                    else {\n                                        var rowSkip = this.findRowSkip();\n                                        if (rowSkip > stateCount[2]) {\n                                            // Skip rows between row of lower confirmed center\n                                            // and top of presumed third confirmed center\n                                            // but back up a bit to get a full chance of detecting\n                                            // it, entire width of center of finder pattern\n                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                                            // of pattern we saw) to be conservative, and also back off by iSkip which\n                                            // is about to be re-added\n                                            i += rowSkip - stateCount[2] - iSkip;\n                                            j = maxJ - 1;\n                                        }\n                                    }\n                                }\n                                else {\n                                    stateCount[0] = stateCount[2];\n                                    stateCount[1] = stateCount[3];\n                                    stateCount[2] = stateCount[4];\n                                    stateCount[3] = 1;\n                                    stateCount[4] = 0;\n                                    currentState = 3;\n                                    continue;\n                                }\n                                // Clear state to start looking again\n                                currentState = 0;\n                                stateCount[0] = 0;\n                                stateCount[1] = 0;\n                                stateCount[2] = 0;\n                                stateCount[3] = 0;\n                                stateCount[4] = 0;\n                            }\n                            else { // No, shift counts back by two\n                                stateCount[0] = stateCount[2];\n                                stateCount[1] = stateCount[3];\n                                stateCount[2] = stateCount[4];\n                                stateCount[3] = 1;\n                                stateCount[4] = 0;\n                                currentState = 3;\n                            }\n                        }\n                        else {\n                            stateCount[++currentState]++;\n                        }\n                    }\n                    else { // Counting white pixels\n                        stateCount[currentState]++;\n                    }\n                }\n            }\n            if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);\n                if (confirmed === true) {\n                    iSkip = stateCount[0];\n                    if (this.hasSkipped) {\n                        // Found a third one\n                        done = this.haveMultiplyConfirmedCenters();\n                    }\n                }\n            }\n        }\n        var patternInfo = this.selectBestPatterns();\n        ResultPoint_1.default.orderBestPatterns(patternInfo);\n        return new FinderPatternInfo_1.default(patternInfo);\n    };\n    /**\n     * Given a count of black/white/black/white/black pixels just seen and an end position,\n     * figures the location of the center of this run.\n     */\n    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\n        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\n    };\n    /**\n     * @param stateCount count of black/white/black/white/black pixels just read\n     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\n     *         used by finder patterns to be considered a match\n     */\n    FinderPatternFinder.foundPatternCross = function (stateCount) {\n        var totalModuleSize = 0;\n        for (var i = 0; i < 5; i++) {\n            var count = stateCount[i];\n            if (count === 0) {\n                return false;\n            }\n            totalModuleSize += count;\n        }\n        if (totalModuleSize < 7) {\n            return false;\n        }\n        var moduleSize = totalModuleSize / 7.0;\n        var maxVariance = moduleSize / 2.0;\n        // Allow less than 50% variance from 1-1-3-1-1 proportions\n        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&\n            Math.abs(moduleSize - stateCount[1]) < maxVariance &&\n            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&\n            Math.abs(moduleSize - stateCount[3]) < maxVariance &&\n            Math.abs(moduleSize - stateCount[4]) < maxVariance;\n    };\n    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {\n        var crossCheckStateCount = this.crossCheckStateCount;\n        crossCheckStateCount[0] = 0;\n        crossCheckStateCount[1] = 0;\n        crossCheckStateCount[2] = 0;\n        crossCheckStateCount[3] = 0;\n        crossCheckStateCount[4] = 0;\n        return crossCheckStateCount;\n    };\n    /**\n     * After a vertical and horizontal scan finds a potential finder pattern, this method\n     * \"cross-cross-cross-checks\" by scanning down diagonally through the center of the possible\n     * finder pattern to see if the same proportion is detected.\n     *\n     * @param startI row where a finder pattern was detected\n     * @param centerJ center of the section that appears to cross a finder pattern\n     * @param maxCount maximum reasonable number of modules that should be\n     *  observed in any reading state, based on the results of the horizontal scan\n     * @param originalStateCountTotal The original state count total.\n     * @return true if proportions are withing expected limits\n     */\n    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var stateCount = this.getCrossCheckStateCount();\n        // Start counting up, left from center finding black center mass\n        var i = 0;\n        var image = this.image;\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {\n            stateCount[2]++;\n            i++;\n        }\n        if (startI < i || centerJ < i) {\n            return false;\n        }\n        // Continue up, left finding white space\n        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&\n            stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i++;\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (startI < i || centerJ < i || stateCount[1] > maxCount) {\n            return false;\n        }\n        // Continue up, left finding black border\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&\n            stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            i++;\n        }\n        if (stateCount[0] > maxCount) {\n            return false;\n        }\n        var maxI = image.getHeight();\n        var maxJ = image.getWidth();\n        // Now also count down, right from center\n        i = 1;\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {\n            stateCount[2]++;\n            i++;\n        }\n        // Ran off the edge?\n        if (startI + i >= maxI || centerJ + i >= maxJ) {\n            return false;\n        }\n        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&\n            stateCount[3] < maxCount) {\n            stateCount[3]++;\n            i++;\n        }\n        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\n            return false;\n        }\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&\n            stateCount[4] < maxCount) {\n            stateCount[4]++;\n            i++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return false;\n        }\n        // If we found a finder-pattern-like section, but its size is more than 100% different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&\n            FinderPatternFinder.foundPatternCross(stateCount);\n    };\n    /**\n     * <p>After a horizontal scan finds a potential finder pattern, this method\n     * \"cross-checks\" by scanning down vertically through the center of the possible\n     * finder pattern to see if the same proportion is detected.</p>\n     *\n     * @param startI row where a finder pattern was detected\n     * @param centerJ center of the section that appears to cross a finder pattern\n     * @param maxCount maximum reasonable number of modules that should be\n     * observed in any reading state, based on the results of the horizontal scan\n     * @return vertical center of finder pattern, or {@link Float#NaN} if not found\n     */\n    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var image = this.image;\n        var maxI = image.getHeight();\n        var stateCount = this.getCrossCheckStateCount();\n        // Start counting up from center\n        var i = startI;\n        while (i >= 0 && image.get(centerJ, i)) {\n            stateCount[2]++;\n            i--;\n        }\n        if (i < 0) {\n            return NaN;\n        }\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i--;\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (i < 0 || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            i--;\n        }\n        if (stateCount[0] > maxCount) {\n            return NaN;\n        }\n        // Now also count down from center\n        i = startI + 1;\n        while (i < maxI && image.get(centerJ, i)) {\n            stateCount[2]++;\n            i++;\n        }\n        if (i === maxI) {\n            return NaN;\n        }\n        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {\n            stateCount[3]++;\n            i++;\n        }\n        if (i === maxI || stateCount[3] >= maxCount) {\n            return NaN;\n        }\n        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {\n            stateCount[4]++;\n            i++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return NaN;\n        }\n        // If we found a finder-pattern-like section, but its size is more than 40% different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n            return NaN;\n        }\n        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\n    };\n    /**\n     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\n     * except it reads horizontally instead of vertically. This is used to cross-cross\n     * check a vertical cross check and locate the real center of the alignment pattern.</p>\n     */\n    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var image = this.image;\n        var maxJ = image.getWidth();\n        var stateCount = this.getCrossCheckStateCount();\n        var j = startJ;\n        while (j >= 0 && image.get(j, centerI)) {\n            stateCount[2]++;\n            j--;\n        }\n        if (j < 0) {\n            return NaN;\n        }\n        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            j--;\n        }\n        if (j < 0 || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            j--;\n        }\n        if (stateCount[0] > maxCount) {\n            return NaN;\n        }\n        j = startJ + 1;\n        while (j < maxJ && image.get(j, centerI)) {\n            stateCount[2]++;\n            j++;\n        }\n        if (j === maxJ) {\n            return NaN;\n        }\n        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {\n            stateCount[3]++;\n            j++;\n        }\n        if (j === maxJ || stateCount[3] >= maxCount) {\n            return NaN;\n        }\n        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {\n            stateCount[4]++;\n            j++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return NaN;\n        }\n        // If we found a finder-pattern-like section, but its size is significantly different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n            return NaN;\n        }\n        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\n    };\n    /**\n     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\n     * with another horizontal scan. This is needed primarily to locate the real horizontal\n     * center of the pattern in cases of extreme skew.\n     * And then we cross-cross-cross check with another diagonal scan.</p>\n     *\n     * <p>If that succeeds the finder pattern location is added to a list that tracks\n     * the number of times each location has been nearly-matched as a finder pattern.\n     * Each additional find is more evidence that the location is in fact a finder\n     * pattern center\n     *\n     * @param stateCount reading state module counts from horizontal scan\n     * @param i row where finder pattern may be found\n     * @param j end of possible finder pattern in row\n     * @param pureBarcode true if in \"pure barcode\" mode\n     * @return true if a finder pattern candidate was found this time\n     */\n    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        var centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);\n        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\n        if (!isNaN(centerI)) {\n            // Re-cross check\n            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\n            if (!isNaN(centerJ) &&\n                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\n                var estimatedModuleSize = stateCountTotal / 7.0;\n                var found = false;\n                var possibleCenters = this.possibleCenters;\n                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {\n                    var center = possibleCenters[index];\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    var point = new FinderPattern_1.default(centerJ, centerI, estimatedModuleSize);\n                    possibleCenters.push(point);\n                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                        this.resultPointCallback.foundPossibleResultPoint(point);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return number of rows we could safely skip during scanning, based on the first\n     *         two finder patterns that have been located. In some cases their position will\n     *         allow us to infer that the third pattern must lie below a certain point farther\n     *         down in the image.\n     */\n    FinderPatternFinder.prototype.findRowSkip = function () {\n        var e_1, _a;\n        var max = this.possibleCenters.length;\n        if (max <= 1) {\n            return 0;\n        }\n        var firstConfirmedCenter = null;\n        try {\n            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var center = _c.value;\n                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    if (firstConfirmedCenter == null) {\n                        firstConfirmedCenter = center;\n                    }\n                    else {\n                        // We have two confirmed centers\n                        // How far down can we skip before resuming looking for the next\n                        // pattern? In the worst case, only the difference between the\n                        // difference in the x / y coordinates of the two centers.\n                        // This is the case where you find top left last.\n                        this.hasSkipped = true;\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -\n                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return 0;\n    };\n    /**\n     * @return true iff we have found at least 3 finder patterns that have been detected\n     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\n     *         candidates is \"pretty similar\"\n     */\n    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {\n        var e_2, _a, e_3, _b;\n        var confirmedCount = 0;\n        var totalModuleSize = 0.0;\n        var max = this.possibleCenters.length;\n        try {\n            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var pattern = _d.value;\n                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    confirmedCount++;\n                    totalModuleSize += pattern.getEstimatedModuleSize();\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        if (confirmedCount < 3) {\n            return false;\n        }\n        // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n        // and that we need to keep looking. We detect this by asking if the estimated module sizes\n        // vary too much. We arbitrarily say that when the total deviation from average exceeds\n        // 5% of the total module size estimates, it's too much.\n        var average = totalModuleSize / max;\n        var totalDeviation = 0.0;\n        try {\n            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var pattern = _f.value;\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return totalDeviation <= 0.05 * totalModuleSize;\n    };\n    /**\n     * @return the 3 best {@link FinderPattern}s from our list of candidates. The \"best\" are\n     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\n     *         size differs from the average among those patterns the least\n     * @throws NotFoundException if 3 such finder patterns do not exist\n     */\n    FinderPatternFinder.prototype.selectBestPatterns = function () {\n        var e_4, _a, e_5, _b;\n        var startSize = this.possibleCenters.length;\n        if (startSize < 3) {\n            // Couldn't find enough finder patterns\n            throw new NotFoundException_1.default();\n        }\n        var possibleCenters = this.possibleCenters;\n        var average;\n        // Filter outlier possibilities whose module size is too different\n        if (startSize > 3) {\n            // But we can only afford to do so if we have at least 4 possibilities to choose from\n            var totalModuleSize = 0.0;\n            var square = 0.0;\n            try {\n                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var center = _d.value;\n                    var size = center.getEstimatedModuleSize();\n                    totalModuleSize += size;\n                    square += size * size;\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            average = totalModuleSize / startSize;\n            var stdDev = Math.sqrt(square / startSize - average * average);\n            possibleCenters.sort(\n            /**\n             * <p>Orders by furthest from average</p>\n             */\n            // FurthestFromAverageComparator implements Comparator<FinderPattern>\n            function (center1, center2) {\n                var dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                var dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                return dA < dB ? -1 : dA > dB ? 1 : 0;\n            });\n            var limit = Math.max(0.2 * average, stdDev);\n            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {\n                var pattern = possibleCenters[i];\n                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\n                    possibleCenters.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (possibleCenters.length > 3) {\n            // Throw away all but those first size candidate points we found.\n            var totalModuleSize = 0.0;\n            try {\n                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {\n                    var possibleCenter = possibleCenters_1_1.value;\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            average = totalModuleSize / possibleCenters.length;\n            possibleCenters.sort(\n            /**\n             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\n             */\n            // CenterComparator implements Comparator<FinderPattern>\n            function (center1, center2) {\n                if (center2.getCount() === center1.getCount()) {\n                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                    return dA < dB ? 1 : dA > dB ? -1 : 0;\n                }\n                else {\n                    return center2.getCount() - center1.getCount();\n                }\n            });\n            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\n        }\n        return [\n            possibleCenters[0],\n            possibleCenters[1],\n            possibleCenters[2]\n        ];\n    };\n    FinderPatternFinder.CENTER_QUORUM = 2;\n    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\n    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\n    return FinderPatternFinder;\n}());\nexports[\"default\"] = FinderPatternFinder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvRmluZGVyUGF0dGVybkZpbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4Q0FBOEM7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsaUpBQXNCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDJJQUFtQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQywySkFBaUI7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsbUtBQXFCO0FBQ3ZELDBCQUEwQixtQkFBTyxDQUFDLHVKQUF5QjtBQUMzRCw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9EQUFvRDtBQUNwRCxrREFBa0Q7QUFDbEQscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUE4QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxrQkFBa0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEIsMERBQTBEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsMkJBQTJCO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9kZXRlY3Rvci9GaW5kZXJQYXR0ZXJuRmluZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL0RlY29kZUhpbnRUeXBlXCIpO1xudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XG52YXIgRmluZGVyUGF0dGVybl8xID0gcmVxdWlyZShcIi4vRmluZGVyUGF0dGVyblwiKTtcbnZhciBGaW5kZXJQYXR0ZXJuSW5mb18xID0gcmVxdWlyZShcIi4vRmluZGVyUGF0dGVybkluZm9cIik7XG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcbi8qaW1wb3J0IGphdmEuaW8uU2VyaWFsaXphYmxlOyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4vKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7Ki9cbi8qaW1wb3J0IGphdmEudXRpbC5Db21wYXJhdG9yOyovXG4vKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuLyoqXG4gKiA8cD5UaGlzIGNsYXNzIGF0dGVtcHRzIHRvIGZpbmQgZmluZGVyIHBhdHRlcm5zIGluIGEgUVIgQ29kZS4gRmluZGVyIHBhdHRlcm5zIGFyZSB0aGUgc3F1YXJlXG4gKiBtYXJrZXJzIGF0IHRocmVlIGNvcm5lcnMgb2YgYSBRUiBDb2RlLjwvcD5cbiAqXG4gKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50LiBFYWNoIHRocmVhZCBtdXN0IGFsbG9jYXRlIGl0cyBvd24gb2JqZWN0LlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBGaW5kZXJQYXR0ZXJuRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIHNlYXJjaCB0aGUgaW1hZ2UgZm9yIHRocmVlIGZpbmRlciBwYXR0ZXJucy48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gc2VhcmNoXG4gICAgICovXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGltYWdlOiBCaXRNYXRyaXgpIHtcbiAgICAvLyAgIHRoaXMoaW1hZ2UsIG51bGwpXG4gICAgLy8gfVxuICAgIGZ1bmN0aW9uIEZpbmRlclBhdHRlcm5GaW5kZXIoaW1hZ2UsIHJlc3VsdFBvaW50Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdO1xuICAgICAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7XG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgfVxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICB9O1xuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmdldFBvc3NpYmxlQ2VudGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgIH07XG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChoaW50cykge1xuICAgICAgICB2YXIgdHJ5SGFyZGVyID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5UUllfSEFSREVSKTtcbiAgICAgICAgdmFyIHB1cmVCYXJjb2RlID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QVVJFX0JBUkNPREUpO1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluXG4gICAgICAgIC8vIDE6MTozOjE6MSByYXRpbzsgdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBzdWNoIG1vZHVsZXMgc2VlbiBzbyBmYXJcbiAgICAgICAgLy8gTGV0J3MgYXNzdW1lIHRoYXQgdGhlIG1heGltdW0gdmVyc2lvbiBRUiBDb2RlIHdlIHN1cHBvcnQgdGFrZXMgdXAgMS80IHRoZSBoZWlnaHQgb2YgdGhlXG4gICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiBhY2NvdW50IGZvciB0aGUgY2VudGVyIGJlaW5nIDMgbW9kdWxlcyBpbiBzaXplLiBUaGlzIGdpdmVzIHRoZSBzbWFsbGVzdFxuICAgICAgICAvLyBudW1iZXIgb2YgcGl4ZWxzIHRoZSBjZW50ZXIgY291bGQgYmUsIHNvIHNraXAgdGhpcyBvZnRlbi4gV2hlbiB0cnlpbmcgaGFyZGVyLCBsb29rIGZvciBhbGxcbiAgICAgICAgLy8gUVIgdmVyc2lvbnMgcmVnYXJkbGVzcyBvZiBob3cgZGVuc2UgdGhleSBhcmUuXG4gICAgICAgIHZhciBpU2tpcCA9IE1hdGguZmxvb3IoKDMgKiBtYXhJKSAvICg0ICogRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUykpO1xuICAgICAgICBpZiAoaVNraXAgPCBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQIHx8IHRyeUhhcmRlcikge1xuICAgICAgICAgICAgaVNraXAgPSBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7XG4gICAgICAgIGZvciAodmFyIGkgPSBpU2tpcCAtIDE7IGkgPCBtYXhJICYmICFkb25lOyBpICs9IGlTa2lwKSB7XG4gICAgICAgICAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heEo7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMSkgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMCkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHsgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGosIHB1cmVCYXJjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZXhhbWluaW5nIGV2ZXJ5IG90aGVyIGxpbmUuIENoZWNraW5nIGVhY2ggbGluZSB0dXJuZWQgb3V0IHRvIGJlIHRvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlTa2lwID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93U2tpcCA+IHN0YXRlQ291bnRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJldHdlZW4gcm93IG9mIGxvd2VyIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvcCBvZiBwcmVzdW1lZCB0aGlyZCBjb25maXJtZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBiYWNrIHVwIGEgYml0IHRvIGdldCBhIGZ1bGwgY2hhbmNlIG9mIGRldGVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCwgZW50aXJlIHdpZHRoIG9mIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcm93U2tpcCAtIHN0YXRlQ291bnRbMl0gLSBpU2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IG1heEogLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgc3RhdGUgdG8gc3RhcnQgbG9va2luZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBObywgc2hpZnQgY291bnRzIGJhY2sgYnkgdHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKLCBwdXJlQmFyY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IHN0YXRlQ291bnRbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgdGhpcmQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnMoKTtcbiAgICAgICAgUmVzdWx0UG9pbnRfMS5kZWZhdWx0Lm9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5JbmZvKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuSW5mb18xLmRlZmF1bHQocGF0dGVybkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sXG4gICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIHJ1bi5cbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzRdIC0gc3RhdGVDb3VudFszXSkgLSBzdGF0ZUNvdW50WzJdIC8gMi4wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHN0YXRlQ291bnQgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3QgcmVhZFxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhlIHByb3BvcnRpb25zIG9mIHRoZSBjb3VudHMgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSAxLzEvMy8xLzEgcmF0aW9zXG4gICAgICogICAgICAgICB1c2VkIGJ5IGZpbmRlciBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzID0gZnVuY3Rpb24gKHN0YXRlQ291bnQpIHtcbiAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBzdGF0ZUNvdW50W2ldO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RhbE1vZHVsZVNpemUgPCA3KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0b3RhbE1vZHVsZVNpemUgLyA3LjA7XG4gICAgICAgIHZhciBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XG4gICAgICAgIC8vIEFsbG93IGxlc3MgdGhhbiA1MCUgdmFyaWFuY2UgZnJvbSAxLTEtMy0xLTEgcHJvcG9ydGlvbnNcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzBdKSA8IG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFsxXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoMy4wICogbW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMl0pIDwgMyAqIG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFszXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbNF0pIDwgbWF4VmFyaWFuY2U7XG4gICAgfTtcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbM10gPSAwO1xuICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgIHJldHVybiBjcm9zc0NoZWNrU3RhdGVDb3VudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIGEgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgKiBcImNyb3NzLWNyb3NzLWNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gZGlhZ29uYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxuICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiAgb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgVGhlIG9yaWdpbmFsIHN0YXRlIGNvdW50IHRvdGFsLlxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9wb3J0aW9ucyBhcmUgd2l0aGluZyBleHBlY3RlZCBsaW1pdHNcbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrRGlhZ29uYWwgPSBmdW5jdGlvbiAoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAsIGxlZnQgZnJvbSBjZW50ZXIgZmluZGluZyBibGFjayBjZW50ZXIgbWFzc1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmICFpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyBibGFjayBib3JkZXJcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biwgcmlnaHQgZnJvbSBjZW50ZXJcbiAgICAgICAgaSA9IDE7XG4gICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGVkZ2U/XG4gICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4Sikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgIWltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkgJiZcbiAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDEwMCUgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA8IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAmJlxuICAgICAgICAgICAgRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDxwPkFmdGVyIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxuICAgICAqIFwiY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biB2ZXJ0aWNhbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcbiAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxuICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxuICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrVmVydGljYWwgPSBmdW5jdGlvbiAoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcbiAgICAgICAgdmFyIGkgPSBzdGFydEk7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpKSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgIGkgPSBzdGFydEkgKyAxO1xuICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpKSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1heEkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzNdKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1heEkgfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbNF0gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDQwJSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgdmFyIHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xuICAgICAgICAgICAgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+TGlrZSB7QGxpbmsgI2Nyb3NzQ2hlY2tWZXJ0aWNhbChpbnQsIGludCwgaW50LCBpbnQpfSwgYW5kIGluIGZhY3QgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCxcbiAgICAgKiBleGNlcHQgaXQgcmVhZHMgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2YgdmVydGljYWxseS4gVGhpcyBpcyB1c2VkIHRvIGNyb3NzLWNyb3NzXG4gICAgICogY2hlY2sgYSB2ZXJ0aWNhbCBjcm9zcyBjaGVjayBhbmQgbG9jYXRlIHRoZSByZWFsIGNlbnRlciBvZiB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAqL1xuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmNyb3NzQ2hlY2tIb3Jpem9udGFsID0gZnVuY3Rpb24gKHN0YXJ0SiAvKmludCovLCBjZW50ZXJJIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgdmFyIG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgdmFyIGogPSBzdGFydEo7XG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGogPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBqID0gc3RhcnRKICsgMTtcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqID09PSBtYXhKKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqID09PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIHNpZ25pZmljYW50bHkgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopIDogTmFOO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBpcyBjYWxsZWQgd2hlbiBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuLiBJdCB3aWxsXG4gICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsLCBhaCwgY3Jvc3MtY3Jvc3MtY2hlY2tcbiAgICAgKiB3aXRoIGFub3RoZXIgaG9yaXpvbnRhbCBzY2FuLiBUaGlzIGlzIG5lZWRlZCBwcmltYXJpbHkgdG8gbG9jYXRlIHRoZSByZWFsIGhvcml6b250YWxcbiAgICAgKiBjZW50ZXIgb2YgdGhlIHBhdHRlcm4gaW4gY2FzZXMgb2YgZXh0cmVtZSBza2V3LlxuICAgICAqIEFuZCB0aGVuIHdlIGNyb3NzLWNyb3NzLWNyb3NzIGNoZWNrIHdpdGggYW5vdGhlciBkaWFnb25hbCBzY2FuLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPklmIHRoYXQgc3VjY2VlZHMgdGhlIGZpbmRlciBwYXR0ZXJuIGxvY2F0aW9uIGlzIGFkZGVkIHRvIGEgbGlzdCB0aGF0IHRyYWNrc1xuICAgICAqIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBsb2NhdGlvbiBoYXMgYmVlbiBuZWFybHktbWF0Y2hlZCBhcyBhIGZpbmRlciBwYXR0ZXJuLlxuICAgICAqIEVhY2ggYWRkaXRpb25hbCBmaW5kIGlzIG1vcmUgZXZpZGVuY2UgdGhhdCB0aGUgbG9jYXRpb24gaXMgaW4gZmFjdCBhIGZpbmRlclxuICAgICAqIHBhdHRlcm4gY2VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCByZWFkaW5nIHN0YXRlIG1vZHVsZSBjb3VudHMgZnJvbSBob3Jpem9udGFsIHNjYW5cbiAgICAgKiBAcGFyYW0gaSByb3cgd2hlcmUgZmluZGVyIHBhdHRlcm4gbWF5IGJlIGZvdW5kXG4gICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGZpbmRlciBwYXR0ZXJuIGluIHJvd1xuICAgICAqIEBwYXJhbSBwdXJlQmFyY29kZSB0cnVlIGlmIGluIFwicHVyZSBiYXJjb2RlXCIgbW9kZVxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGZpbmRlciBwYXR0ZXJuIGNhbmRpZGF0ZSB3YXMgZm91bmQgdGhpcyB0aW1lXG4gICAgICovXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuaGFuZGxlUG9zc2libGVDZW50ZXIgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgaSAvKmludCovLCBqIC8qaW50Ki8sIHB1cmVCYXJjb2RlKSB7XG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgIHZhciBjZW50ZXJKID0gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgICAgICB2YXIgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgaWYgKCFpc05hTihjZW50ZXJJKSkge1xuICAgICAgICAgICAgLy8gUmUtY3Jvc3MgY2hlY2tcbiAgICAgICAgICAgIGNlbnRlckogPSB0aGlzLmNyb3NzQ2hlY2tIb3Jpem9udGFsKC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSAmJlxuICAgICAgICAgICAgICAgICghcHVyZUJhcmNvZGUgfHwgdGhpcy5jcm9zc0NoZWNrRGlhZ29uYWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVzdGltYXRlZE1vZHVsZVNpemUgPSBzdGF0ZUNvdW50VG90YWwgLyA3LjA7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoXzEgPSBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aF8xOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VudGVyLmFib3V0RXF1YWxzKGVzdGltYXRlZE1vZHVsZVNpemUsIGNlbnRlckksIGNlbnRlckopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdID0gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IEZpbmRlclBhdHRlcm5fMS5kZWZhdWx0KGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IG51bGwgJiYgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJvd3Mgd2UgY291bGQgc2FmZWx5IHNraXAgZHVyaW5nIHNjYW5uaW5nLCBiYXNlZCBvbiB0aGUgZmlyc3RcbiAgICAgKiAgICAgICAgIHR3byBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gbG9jYXRlZC4gSW4gc29tZSBjYXNlcyB0aGVpciBwb3NpdGlvbiB3aWxsXG4gICAgICogICAgICAgICBhbGxvdyB1cyB0byBpbmZlciB0aGF0IHRoZSB0aGlyZCBwYXR0ZXJuIG11c3QgbGllIGJlbG93IGEgY2VydGFpbiBwb2ludCBmYXJ0aGVyXG4gICAgICogICAgICAgICBkb3duIGluIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5maW5kUm93U2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChtYXggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0Q29uZmlybWVkQ2VudGVyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuZ2V0Q291bnQoKSA+PSBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29uZmlybWVkQ2VudGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q29uZmlybWVkQ2VudGVyID0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0d28gY29uZmlybWVkIGNlbnRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBmYXIgZG93biBjYW4gd2Ugc2tpcCBiZWZvcmUgcmVzdW1pbmcgbG9va2luZyBmb3IgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm4/IEluIHRoZSB3b3JzdCBjYXNlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSB4IC8geSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNlbnRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHlvdSBmaW5kIHRvcCBsZWZ0IGxhc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1NraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qKGludCkgKi8gTWF0aC5mbG9vcigoTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WCgpIC0gY2VudGVyLmdldFgoKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFkoKSAtIGNlbnRlci5nZXRZKCkpKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHdlIGhhdmUgZm91bmQgYXQgbGVhc3QgMyBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWRcbiAgICAgKiAgICAgICAgIGF0IGxlYXN0IHtAbGluayAjQ0VOVEVSX1FVT1JVTX0gdGltZXMgZWFjaCwgYW5kLCB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIG9mIHRoZVxuICAgICAqICAgICAgICAgY2FuZGlkYXRlcyBpcyBcInByZXR0eSBzaW1pbGFyXCJcbiAgICAgKi9cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYjtcbiAgICAgICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDtcbiAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpcm1lZENvdW50IDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9LLCB3ZSBoYXZlIGF0IGxlYXN0IDMgY29uZmlybWVkIGNlbnRlcnMsIGJ1dCwgaXQncyBwb3NzaWJsZSB0aGF0IG9uZSBpcyBhIFwiZmFsc2UgcG9zaXRpdmVcIlxuICAgICAgICAvLyBhbmQgdGhhdCB3ZSBuZWVkIHRvIGtlZXAgbG9va2luZy4gV2UgZGV0ZWN0IHRoaXMgYnkgYXNraW5nIGlmIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemVzXG4gICAgICAgIC8vIHZhcnkgdG9vIG11Y2guIFdlIGFyYml0cmFyaWx5IHNheSB0aGF0IHdoZW4gdGhlIHRvdGFsIGRldmlhdGlvbiBmcm9tIGF2ZXJhZ2UgZXhjZWVkc1xuICAgICAgICAvLyA1JSBvZiB0aGUgdG90YWwgbW9kdWxlIHNpemUgZXN0aW1hdGVzLCBpdCdzIHRvbyBtdWNoLlxuICAgICAgICB2YXIgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIG1heDtcbiAgICAgICAgdmFyIHRvdGFsRGV2aWF0aW9uID0gMC4wO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRvdGFsRGV2aWF0aW9uICs9IE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxEZXZpYXRpb24gPD0gMC4wNSAqIHRvdGFsTW9kdWxlU2l6ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIDMgYmVzdCB7QGxpbmsgRmluZGVyUGF0dGVybn1zIGZyb20gb3VyIGxpc3Qgb2YgY2FuZGlkYXRlcy4gVGhlIFwiYmVzdFwiIGFyZVxuICAgICAqICAgICAgICAgdGhvc2UgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcywgYW5kIHdob3NlIG1vZHVsZVxuICAgICAqICAgICAgICAgc2l6ZSBkaWZmZXJzIGZyb20gdGhlIGF2ZXJhZ2UgYW1vbmcgdGhvc2UgcGF0dGVybnMgdGhlIGxlYXN0XG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiAzIHN1Y2ggZmluZGVyIHBhdHRlcm5zIGRvIG5vdCBleGlzdFxuICAgICAqL1xuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLnNlbGVjdEJlc3RQYXR0ZXJucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfNCwgX2EsIGVfNSwgX2I7XG4gICAgICAgIHZhciBzdGFydFNpemUgPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydFNpemUgPCAzKSB7XG4gICAgICAgICAgICAvLyBDb3VsZG4ndCBmaW5kIGVub3VnaCBmaW5kZXIgcGF0dGVybnNcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgIHZhciBhdmVyYWdlO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0bGllciBwb3NzaWJpbGl0aWVzIHdob3NlIG1vZHVsZSBzaXplIGlzIHRvbyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHN0YXJ0U2l6ZSA+IDMpIHtcbiAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gb25seSBhZmZvcmQgdG8gZG8gc28gaWYgd2UgaGF2ZSBhdCBsZWFzdCA0IHBvc3NpYmlsaXRpZXMgdG8gY2hvb3NlIGZyb21cbiAgICAgICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICB2YXIgc3F1YXJlID0gMC4wO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMucG9zc2libGVDZW50ZXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gY2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSArPSBzaXplICogc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gc3RhcnRTaXplO1xuICAgICAgICAgICAgdmFyIHN0ZERldiA9IE1hdGguc3FydChzcXVhcmUgLyBzdGFydFNpemUgLSBhdmVyYWdlICogYXZlcmFnZSk7XG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc29ydChcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IGZ1cnRoZXN0IGZyb20gYXZlcmFnZTwvcD5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gRnVydGhlc3RGcm9tQXZlcmFnZUNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XG4gICAgICAgICAgICBmdW5jdGlvbiAoY2VudGVyMSwgY2VudGVyMikge1xuICAgICAgICAgICAgICAgIHZhciBkQSA9IE1hdGguYWJzKGNlbnRlcjIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZEEgPCBkQiA/IC0xIDogZEEgPiBkQiA/IDEgOiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBNYXRoLm1heCgwLjIgKiBhdmVyYWdlLCBzdGREZXYpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoICYmIHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHBvc3NpYmxlQ2VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKSA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhvc2UgZmlyc3Qgc2l6ZSBjYW5kaWRhdGUgcG9pbnRzIHdlIGZvdW5kLlxuICAgICAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcG9zc2libGVDZW50ZXJzXzEgPSBfX3ZhbHVlcyhwb3NzaWJsZUNlbnRlcnMpLCBwb3NzaWJsZUNlbnRlcnNfMV8xID0gcG9zc2libGVDZW50ZXJzXzEubmV4dCgpOyAhcG9zc2libGVDZW50ZXJzXzFfMS5kb25lOyBwb3NzaWJsZUNlbnRlcnNfMV8xID0gcG9zc2libGVDZW50ZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUNlbnRlciA9IHBvc3NpYmxlQ2VudGVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBwb3NzaWJsZUNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUNlbnRlcnNfMV8xICYmICFwb3NzaWJsZUNlbnRlcnNfMV8xLmRvbmUgJiYgKF9iID0gcG9zc2libGVDZW50ZXJzXzEucmV0dXJuKSkgX2IuY2FsbChwb3NzaWJsZUNlbnRlcnNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSB7QGxpbmsgRmluZGVyUGF0dGVybiNnZXRDb3VudCgpfSwgZGVzY2VuZGluZy48L3A+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIENlbnRlckNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XG4gICAgICAgICAgICBmdW5jdGlvbiAoY2VudGVyMSwgY2VudGVyMikge1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIyLmdldENvdW50KCkgPT09IGNlbnRlcjEuZ2V0Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZEEgPCBkQiA/IDEgOiBkQSA+IGRCID8gLTEgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjIuZ2V0Q291bnQoKSAtIGNlbnRlcjEuZ2V0Q291bnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoMyk7IC8vIHRoaXMgaXMgbm90IHJlYWx5IG5lY2Vzc2FyeSBhcyB3ZSBvbmx5IHJldHVybiBmaXJzdCAzIGFueXdheVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMF0sXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMV0sXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMl1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSA9IDI7XG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUCA9IDM7IC8vIDEgcGl4ZWwvbW9kdWxlIHRpbWVzIDMgbW9kdWxlcy9jZW50ZXJcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTID0gNTc7IC8vIHN1cHBvcnQgdXAgdG8gdmVyc2lvbiAxMCBmb3IgbW9iaWxlIGNsaWVudHNcbiAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuRmluZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js":
/*!*****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * <p>Encapsulates information about finder patterns in an image, including the location of\n * the three finder patterns, and their estimated module size.</p>\n *\n * @author Sean Owen\n */\nvar FinderPatternInfo = /** @class */ (function () {\n    function FinderPatternInfo(patternCenters) {\n        this.bottomLeft = patternCenters[0];\n        this.topLeft = patternCenters[1];\n        this.topRight = patternCenters[2];\n    }\n    FinderPatternInfo.prototype.getBottomLeft = function () {\n        return this.bottomLeft;\n    };\n    FinderPatternInfo.prototype.getTopLeft = function () {\n        return this.topLeft;\n    };\n    FinderPatternInfo.prototype.getTopRight = function () {\n        return this.topRight;\n    };\n    return FinderPatternInfo;\n}());\nexports[\"default\"] = FinderPatternInfo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvRmluZGVyUGF0dGVybkluZm8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2RldGVjdG9yL0ZpbmRlclBhdHRlcm5JbmZvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIDxwPkVuY2Fwc3VsYXRlcyBpbmZvcm1hdGlvbiBhYm91dCBmaW5kZXIgcGF0dGVybnMgaW4gYW4gaW1hZ2UsIGluY2x1ZGluZyB0aGUgbG9jYXRpb24gb2ZcbiAqIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnMsIGFuZCB0aGVpciBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuPC9wPlxuICpcbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKi9cbnZhciBGaW5kZXJQYXR0ZXJuSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5kZXJQYXR0ZXJuSW5mbyhwYXR0ZXJuQ2VudGVycykge1xuICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBwYXR0ZXJuQ2VudGVyc1swXTtcbiAgICAgICAgdGhpcy50b3BMZWZ0ID0gcGF0dGVybkNlbnRlcnNbMV07XG4gICAgICAgIHRoaXMudG9wUmlnaHQgPSBwYXR0ZXJuQ2VudGVyc1syXTtcbiAgICB9XG4gICAgRmluZGVyUGF0dGVybkluZm8ucHJvdG90eXBlLmdldEJvdHRvbUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgfTtcbiAgICBGaW5kZXJQYXR0ZXJuSW5mby5wcm90b3R5cGUuZ2V0VG9wTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdDtcbiAgICB9O1xuICAgIEZpbmRlclBhdHRlcm5JbmZvLnByb3RvdHlwZS5nZXRUb3BSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wUmlnaHQ7XG4gICAgfTtcbiAgICByZXR1cm4gRmluZGVyUGF0dGVybkluZm87XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmluZGVyUGF0dGVybkluZm87XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar BlockPair = /** @class */ (function () {\n    function BlockPair(dataBytes, errorCorrectionBytes) {\n        this.dataBytes = dataBytes;\n        this.errorCorrectionBytes = errorCorrectionBytes;\n    }\n    BlockPair.prototype.getDataBytes = function () {\n        return this.dataBytes;\n    };\n    BlockPair.prototype.getErrorCorrectionBytes = function () {\n        return this.errorCorrectionBytes;\n    };\n    return BlockPair;\n}());\nexports[\"default\"] = BlockPair;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9CbG9ja1BhaXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9CbG9ja1BhaXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmVuY29kZXIgeyovXG52YXIgQmxvY2tQYWlyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJsb2NrUGFpcihkYXRhQnl0ZXMsIGVycm9yQ29ycmVjdGlvbkJ5dGVzKSB7XG4gICAgICAgIHRoaXMuZGF0YUJ5dGVzID0gZGF0YUJ5dGVzO1xuICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkJ5dGVzID0gZXJyb3JDb3JyZWN0aW9uQnl0ZXM7XG4gICAgfVxuICAgIEJsb2NrUGFpci5wcm90b3R5cGUuZ2V0RGF0YUJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQnl0ZXM7XG4gICAgfTtcbiAgICBCbG9ja1BhaXIucHJvdG90eXBlLmdldEVycm9yQ29ycmVjdGlvbkJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1BhaXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tQYWlyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.encoder {*/\n/*import java.util.Arrays;*/\nvar Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\n/**\n * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned\n * -1, 0, and 1, I'm going to use less memory and go with bytes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar ByteMatrix = /** @class */ (function () {\n    function ByteMatrix(width /*int*/, height /*int*/) {\n        this.width = width;\n        this.height = height;\n        var bytes = new Array(height); // [height][width]\n        for (var i = 0; i !== height; i++) {\n            bytes[i] = new Uint8Array(width);\n        }\n        this.bytes = bytes;\n    }\n    ByteMatrix.prototype.getHeight = function () {\n        return this.height;\n    };\n    ByteMatrix.prototype.getWidth = function () {\n        return this.width;\n    };\n    ByteMatrix.prototype.get = function (x /*int*/, y /*int*/) {\n        return this.bytes[y][x];\n    };\n    /**\n     * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)\n     */\n    ByteMatrix.prototype.getArray = function () {\n        return this.bytes;\n    };\n    // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside\n    ByteMatrix.prototype.setNumber = function (x /*int*/, y /*int*/, value /*byte|int*/) {\n        this.bytes[y][x] = value;\n    };\n    // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {\n    //   bytes[y][x] = (byte) value\n    // }\n    ByteMatrix.prototype.setBoolean = function (x /*int*/, y /*int*/, value) {\n        this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);\n    };\n    ByteMatrix.prototype.clear = function (value /*byte*/) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var aByte = _c.value;\n                Arrays_1.default.fill(aByte, value);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    ByteMatrix.prototype.equals = function (o) {\n        if (!(o instanceof ByteMatrix)) {\n            return false;\n        }\n        var other = o;\n        if (this.width !== other.width) {\n            return false;\n        }\n        if (this.height !== other.height) {\n            return false;\n        }\n        for (var y = 0, height = this.height; y < height; ++y) {\n            var bytesY = this.bytes[y];\n            var otherBytesY = other.bytes[y];\n            for (var x = 0, width = this.width; x < width; ++x) {\n                if (bytesY[x] !== otherBytesY[x]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    /*@Override*/\n    ByteMatrix.prototype.toString = function () {\n        var result = new StringBuilder_1.default(); // (2 * width * height + 2)\n        for (var y = 0, height = this.height; y < height; ++y) {\n            var bytesY = this.bytes[y];\n            for (var x = 0, width = this.width; x < width; ++x) {\n                switch (bytesY[x]) {\n                    case 0:\n                        result.append(' 0');\n                        break;\n                    case 1:\n                        result.append(' 1');\n                        break;\n                    default:\n                        result.append('  ');\n                        break;\n                }\n            }\n            result.append('\\n');\n        }\n        return result.toString();\n    };\n    return ByteMatrix;\n}());\nexports[\"default\"] = ByteMatrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9CeXRlTWF0cml4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3QywwQkFBMEI7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLDJJQUFtQjtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQyx5SkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9CeXRlTWF0cml4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5lbmNvZGVyIHsqL1xuLyppbXBvcnQgamF2YS51dGlsLkFycmF5czsqL1xudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvQXJyYXlzXCIpO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG4vKipcbiAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyIGdldHMgYXNzaWduZWRcbiAqIC0xLCAwLCBhbmQgMSwgSSdtIGdvaW5nIHRvIHVzZSBsZXNzIG1lbW9yeSBhbmQgZ28gd2l0aCBieXRlcy5cbiAqXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICovXG52YXIgQnl0ZU1hdHJpeCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCeXRlTWF0cml4KHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShoZWlnaHQpOyAvLyBbaGVpZ2h0XVt3aWR0aF1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGhlaWdodDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tpXSA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgfVxuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH07XG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH07XG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3ldW3hdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBhbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBhcyBieXRlcywgaW4gcm93LW1ham9yIG9yZGVyLiBhcnJheVt5XVt4XSByZXByZXNlbnRzIHBvaW50ICh4LHkpXG4gICAgICovXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICAgIH07XG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IHByZWZmZXIgdG8gbGV0IHR3byBtZXRob2RzIGluc3RlYWQgb2Ygb3ZlcnJpZGUgdG8gYXZvaWQgdHlwZSBjb21wYXJpc29uIGluc2lkZVxuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLnNldE51bWJlciA9IGZ1bmN0aW9uICh4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUgLypieXRlfGludCovKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNbeV1beF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8vIHB1YmxpYyBzZXQoeDogbnVtYmVyIC8qaW50Ki8sIHk6IG51bWJlciAvKmludCovLCB2YWx1ZTogbnVtYmVyIC8qaW50Ki8pOiB2b2lkIHtcbiAgICAvLyAgIGJ5dGVzW3ldW3hdID0gKGJ5dGUpIHZhbHVlXG4gICAgLy8gfVxuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLnNldEJvb2xlYW4gPSBmdW5jdGlvbiAoeCAvKmludCovLCB5IC8qaW50Ki8sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNbeV1beF0gPSAvKihieXRlKSAqLyAodmFsdWUgPyAxIDogMCk7XG4gICAgfTtcbiAgICBCeXRlTWF0cml4LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICh2YWx1ZSAvKmJ5dGUqLykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5ieXRlcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYUJ5dGUgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBBcnJheXNfMS5kZWZhdWx0LmZpbGwoYUJ5dGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCeXRlTWF0cml4LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQnl0ZU1hdHJpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xuICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gb3RoZXIud2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IG90aGVyLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcbiAgICAgICAgICAgIHZhciBvdGhlckJ5dGVzWSA9IG90aGVyLmJ5dGVzW3ldO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNZW3hdICE9PSBvdGhlckJ5dGVzWVt4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7IC8vICgyICogd2lkdGggKiBoZWlnaHQgKyAyKVxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzWSA9IHRoaXMuYnl0ZXNbeV07XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnl0ZXNZW3hdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIDEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBCeXRlTWF0cml4O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJ5dGVNYXRyaXg7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar EncodeHintType_1 = __webpack_require__(/*! ../../EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\nvar BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\nvar GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nvar ReedSolomonEncoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js\");\nvar Mode_1 = __webpack_require__(/*! ../decoder/Mode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js\");\nvar Version_1 = __webpack_require__(/*! ../decoder/Version */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js\");\nvar MaskUtil_1 = __webpack_require__(/*! ./MaskUtil */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js\");\nvar ByteMatrix_1 = __webpack_require__(/*! ./ByteMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js\");\nvar QRCode_1 = __webpack_require__(/*! ./QRCode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js\");\nvar MatrixUtil_1 = __webpack_require__(/*! ./MatrixUtil */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js\");\nvar StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\nvar BlockPair_1 = __webpack_require__(/*! ./BlockPair */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js\");\nvar WriterException_1 = __webpack_require__(/*! ../../WriterException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.Map;*/\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar Encoder = /** @class */ (function () {\n    // TYPESCRIPTPORT: changed to UTF8, the default for js\n    function Encoder() {\n    }\n    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n    // Basically it applies four rules and summate all penalties.\n    Encoder.calculateMaskPenalty = function (matrix) {\n        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\n    };\n    /**\n     * @param content text to encode\n     * @param ecLevel error correction level to use\n     * @return {@link QRCode} representing the encoded QR code\n     * @throws WriterException if encoding can't succeed, because of for example invalid content\n     *   or configuration\n     */\n    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n    //   return encode(content, ecLevel, null)\n    // }\n    Encoder.encode = function (content, ecLevel, hints) {\n        if (hints === void 0) { hints = null; }\n        // Determine what character encoding has been specified by the caller, if any\n        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\n        if (hasEncodingHint) {\n            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\n        }\n        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n        // multiple modes / segments even if that were more efficient. Twould be nice.\n        var mode = this.chooseMode(content, encoding);\n        // This will store the header information, like mode and\n        // length, as well as \"header\" segments like an ECI segment.\n        var headerBits = new BitArray_1.default();\n        // Append ECI segment if applicable\n        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n            if (eci !== undefined) {\n                this.appendECI(eci, headerBits);\n            }\n        }\n        // (With ECI in place,) Write the mode marker\n        this.appendModeInfo(mode, headerBits);\n        // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n        // main payload yet.\n        var dataBits = new BitArray_1.default();\n        this.appendBytes(content, mode, dataBits, encoding);\n        var version;\n        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\n            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\n            version = Version_1.default.getVersionForNumber(versionNumber);\n            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n            if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                throw new WriterException_1.default('Data too big for requested version');\n            }\n        }\n        else {\n            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n        }\n        var headerAndDataBits = new BitArray_1.default();\n        headerAndDataBits.appendBitArray(headerBits);\n        // Find \"length\" of main segment and write it\n        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\n        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n        // Put data together into the overall payload\n        headerAndDataBits.appendBitArray(dataBits);\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n        // Terminate the bits properly.\n        this.terminateBits(numDataBytes, headerAndDataBits);\n        // Interleave data bits with error correction code.\n        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n        var qrCode = new QRCode_1.default();\n        qrCode.setECLevel(ecLevel);\n        qrCode.setMode(mode);\n        qrCode.setVersion(version);\n        //  Choose the mask pattern and set to \"qrCode\".\n        var dimension = version.getDimensionForVersion();\n        var matrix = new ByteMatrix_1.default(dimension, dimension);\n        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n        qrCode.setMaskPattern(maskPattern);\n        // Build the matrix and set it to \"qrCode\".\n        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n        qrCode.setMatrix(matrix);\n        return qrCode;\n    };\n    /**\n     * Decides the smallest version of QR code that will contain all of the provided data.\n     *\n     * @throws WriterException if the data cannot fit in any version\n     */\n    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n        // Hard part: need to know version to know how many bits length takes. But need to know how many\n        // bits it takes to know version. First we take a guess at version by assuming version will be\n        // the minimum, 1:\n        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\n        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n        return this.chooseVersion(bitsNeeded, ecLevel);\n    };\n    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n    };\n    /**\n     * @return the code point of the table used in alphanumeric mode or\n     *  -1 if there is no corresponding code in the table.\n     */\n    Encoder.getAlphanumericCode = function (code /*int*/) {\n        if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n            return Encoder.ALPHANUMERIC_TABLE[code];\n        }\n        return -1;\n    };\n    // public static chooseMode(content: string): Mode {\n    //   return chooseMode(content, null);\n    // }\n    /**\n     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n     */\n    Encoder.chooseMode = function (content, encoding) {\n        if (encoding === void 0) { encoding = null; }\n        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n            // Choose Kanji mode if all input are double-byte characters\n            return Mode_1.default.KANJI;\n        }\n        var hasNumeric = false;\n        var hasAlphanumeric = false;\n        for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n            var c = content.charAt(i);\n            if (Encoder.isDigit(c)) {\n                hasNumeric = true;\n            }\n            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                hasAlphanumeric = true;\n            }\n            else {\n                return Mode_1.default.BYTE;\n            }\n        }\n        if (hasAlphanumeric) {\n            return Mode_1.default.ALPHANUMERIC;\n        }\n        if (hasNumeric) {\n            return Mode_1.default.NUMERIC;\n        }\n        return Mode_1.default.BYTE;\n    };\n    Encoder.isOnlyDoubleByteKanji = function (content) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            return false;\n        }\n        var length = bytes.length;\n        if (length % 2 !== 0) {\n            return false;\n        }\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n        var bestMaskPattern = -1;\n        // We try all mask patterns to choose the best one.\n        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\n            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n            var penalty = this.calculateMaskPenalty(matrix);\n            if (penalty < minPenalty) {\n                minPenalty = penalty;\n                bestMaskPattern = maskPattern;\n            }\n        }\n        return bestMaskPattern;\n    };\n    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {\n        for (var versionNum = 1; versionNum <= 40; versionNum++) {\n            var version = Version_1.default.getVersionForNumber(versionNum);\n            if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                return version;\n            }\n        }\n        throw new WriterException_1.default('Data too big');\n    };\n    /**\n     * @return true if the number of input bits will fit in a code with the specified version and\n     * error correction level.\n     */\n    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {\n        // In the following comments, we use numbers of Version 7-H.\n        // numBytes = 196\n        var numBytes = version.getTotalCodewords();\n        // getNumECBytes = 130\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numEcBytes = ecBlocks.getTotalECCodewords();\n        // getNumDataBytes = 196 - 130 = 66\n        var numDataBytes = numBytes - numEcBytes;\n        var totalInputBytes = (numInputBits + 7) / 8;\n        return numDataBytes >= totalInputBytes;\n    };\n    /**\n     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n     */\n    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {\n        var capacity = numDataBytes * 8;\n        if (bits.getSize() > capacity) {\n            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\n                capacity);\n        }\n        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n            bits.appendBit(false);\n        }\n        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n        // If the last byte isn't 8-bit aligned, we'll add padding bits.\n        var numBitsInLastByte = bits.getSize() & 0x07;\n        if (numBitsInLastByte > 0) {\n            for (var i = numBitsInLastByte; i < 8; i++) {\n                bits.appendBit(false);\n            }\n        }\n        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n        for (var i = 0; i < numPaddingBytes; ++i) {\n            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n        }\n        if (bits.getSize() !== capacity) {\n            throw new WriterException_1.default('Bits size does not equal capacity');\n        }\n    };\n    /**\n     * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n     * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n     * JISX0510:2004 (p.30)\n     */\n    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n        if (blockID >= numRSBlocks) {\n            throw new WriterException_1.default('Block ID too large');\n        }\n        // numRsBlocksInGroup2 = 196 % 5 = 1\n        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n        // numRsBlocksInGroup1 = 5 - 1 = 4\n        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n        // numTotalBytesInGroup1 = 196 / 5 = 39\n        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n        // numTotalBytesInGroup2 = 39 + 1 = 40\n        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n        // numDataBytesInGroup1 = 66 / 5 = 13\n        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n        // numDataBytesInGroup2 = 13 + 1 = 14\n        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n        // numEcBytesInGroup1 = 39 - 13 = 26\n        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n        // numEcBytesInGroup2 = 40 - 14 = 26\n        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n        // Sanity checks.\n        // 26 = 26\n        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n            throw new WriterException_1.default('EC bytes mismatch');\n        }\n        // 5 = 4 + 1.\n        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n            throw new WriterException_1.default('RS blocks mismatch');\n        }\n        // 196 = (13 + 26) * 4 + (14 + 26) * 1\n        if (numTotalBytes !==\n            ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                numRsBlocksInGroup1) +\n                ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                    numRsBlocksInGroup2)) {\n            throw new WriterException_1.default('Total bytes mismatch');\n        }\n        if (blockID < numRsBlocksInGroup1) {\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\n            numECBytesInBlock[0] = numEcBytesInGroup1;\n        }\n        else {\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\n            numECBytesInBlock[0] = numEcBytesInGroup2;\n        }\n    };\n    /**\n     * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n     * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n     */\n    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n        var e_1, _a, e_2, _b;\n        // \"bits\" must have \"getNumDataBytes\" bytes of data.\n        if (bits.getSizeInBytes() !== numDataBytes) {\n            throw new WriterException_1.default('Number of bits and data bytes does not match');\n        }\n        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n        // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n        var dataBytesOffset = 0;\n        var maxNumDataBytes = 0;\n        var maxNumEcBytes = 0;\n        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n        for (var i = 0; i < numRSBlocks; ++i) {\n            var numDataBytesInBlock = new Int32Array(1);\n            var numEcBytesInBlock = new Int32Array(1);\n            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n            var size = numDataBytesInBlock[0];\n            var dataBytes = new Uint8Array(size);\n            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\n            maxNumDataBytes = Math.max(maxNumDataBytes, size);\n            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n            dataBytesOffset += numDataBytesInBlock[0];\n        }\n        if (numDataBytes !== dataBytesOffset) {\n            throw new WriterException_1.default('Data bytes does not match offset');\n        }\n        var result = new BitArray_1.default();\n        // First, place data blocks.\n        for (var i = 0; i < maxNumDataBytes; ++i) {\n            try {\n                for (var blocks_1 = (e_1 = void 0, __values(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n                    var block = blocks_1_1.value;\n                    var dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        // Then, place error correction blocks.\n        for (var i = 0; i < maxNumEcBytes; ++i) {\n            try {\n                for (var blocks_2 = (e_2 = void 0, __values(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n                    var block = blocks_2_1.value;\n                    var ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\n            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +\n                result.getSizeInBytes() + ' differ.');\n        }\n        return result;\n    };\n    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {\n        var numDataBytes = dataBytes.length;\n        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n        for (var i = 0; i < numDataBytes; i++) {\n            toEncode[i] = dataBytes[i] & 0xFF;\n        }\n        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n        var ecBytes = new Uint8Array(numEcBytesInBlock);\n        for (var i = 0; i < numEcBytesInBlock; i++) {\n            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n        }\n        return ecBytes;\n    };\n    /**\n     * Append mode info. On success, store the result in \"bits\".\n     */\n    Encoder.appendModeInfo = function (mode, bits) {\n        bits.appendBits(mode.getBits(), 4);\n    };\n    /**\n     * Append length info. On success, store the result in \"bits\".\n     */\n    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {\n        var numBits = mode.getCharacterCountBits(version);\n        if (numLetters >= (1 << numBits)) {\n            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n        }\n        bits.appendBits(numLetters, numBits);\n    };\n    /**\n     * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n     */\n    Encoder.appendBytes = function (content, mode, bits, encoding) {\n        switch (mode) {\n            case Mode_1.default.NUMERIC:\n                Encoder.appendNumericBytes(content, bits);\n                break;\n            case Mode_1.default.ALPHANUMERIC:\n                Encoder.appendAlphanumericBytes(content, bits);\n                break;\n            case Mode_1.default.BYTE:\n                Encoder.append8BitBytes(content, bits, encoding);\n                break;\n            case Mode_1.default.KANJI:\n                Encoder.appendKanjiBytes(content, bits);\n                break;\n            default:\n                throw new WriterException_1.default('Invalid mode: ' + mode);\n        }\n    };\n    Encoder.getDigit = function (singleCharacter) {\n        return singleCharacter.charCodeAt(0) - 48;\n    };\n    Encoder.isDigit = function (singleCharacter) {\n        var cn = Encoder.getDigit(singleCharacter);\n        return cn >= 0 && cn <= 9;\n    };\n    Encoder.appendNumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var num1 = Encoder.getDigit(content.charAt(i));\n            if (i + 2 < length) {\n                // Encode three numeric letters in ten bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                var num3 = Encoder.getDigit(content.charAt(i + 2));\n                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                i += 3;\n            }\n            else if (i + 1 < length) {\n                // Encode two numeric letters in seven bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                bits.appendBits(num1 * 10 + num2, 7);\n                i += 2;\n            }\n            else {\n                // Encode one numeric letter in four bits.\n                bits.appendBits(num1, 4);\n                i++;\n            }\n        }\n    };\n    Encoder.appendAlphanumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n            if (code1 === -1) {\n                throw new WriterException_1.default();\n            }\n            if (i + 1 < length) {\n                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                if (code2 === -1) {\n                    throw new WriterException_1.default();\n                }\n                // Encode two alphanumeric letters in 11 bits.\n                bits.appendBits(code1 * 45 + code2, 11);\n                i += 2;\n            }\n            else {\n                // Encode one alphanumeric letter in six bits.\n                bits.appendBits(code1, 6);\n                i++;\n            }\n        }\n    };\n    Encoder.append8BitBytes = function (content, bits, encoding) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, encoding);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n            var b = bytes[i];\n            bits.appendBits(b, 8);\n        }\n    };\n    /**\n     * @throws WriterException\n     */\n    Encoder.appendKanjiBytes = function (content, bits) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        var length = bytes.length;\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            var byte2 = bytes[i + 1] & 0xFF;\n            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\n            var subtracted = -1;\n            if (code >= 0x8140 && code <= 0x9ffc) {\n                subtracted = code - 0x8140;\n            }\n            else if (code >= 0xe040 && code <= 0xebbf) {\n                subtracted = code - 0xc140;\n            }\n            if (subtracted === -1) {\n                throw new WriterException_1.default('Invalid byte sequence');\n            }\n            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\n            bits.appendBits(encoded, 13);\n        }\n    };\n    Encoder.appendECI = function (eci, bits) {\n        bits.appendBits(Mode_1.default.ECI.getBits(), 4);\n        // This is correct for values up to 127, which is all we need now.\n        bits.appendBits(eci.getValue(), 8);\n    };\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\n    return Encoder;\n}());\nexports[\"default\"] = Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9FbmNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3Qyx1QkFBdUIsbUJBQU8sQ0FBQyxpSkFBc0I7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsbUpBQXVCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLGlLQUE4QjtBQUM5RCxrQkFBa0IsbUJBQU8sQ0FBQyw2S0FBb0M7QUFDOUQsMkJBQTJCLG1CQUFPLENBQUMsK0xBQTZDO0FBQ2hGLGFBQWEsbUJBQU8sQ0FBQyxpSkFBaUI7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsdUpBQW9CO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLGdKQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLG9KQUFjO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw0SUFBVTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxvSkFBYztBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywySkFBMkI7QUFDMUQsa0JBQWtCLG1CQUFPLENBQUMsa0pBQWE7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsbUpBQXVCO0FBQ3ZELDhDQUE4QztBQUM5Qyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlCQUFpQjtBQUNyRztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxrQ0FBa0Msa0RBQWtEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0Esb0dBQW9HLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSxvR0FBb0csa0JBQWtCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvcXJjb2RlL2VuY29kZXIvRW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZW5jb2RlciB7Ki9cbnZhciBFbmNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL0VuY29kZUhpbnRUeXBlXCIpO1xudmFyIEJpdEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0JpdEFycmF5XCIpO1xudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0lcIik7XG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL0dlbmVyaWNHRlwiKTtcbnZhciBSZWVkU29sb21vbkVuY29kZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyXCIpO1xudmFyIE1vZGVfMSA9IHJlcXVpcmUoXCIuLi9kZWNvZGVyL01vZGVcIik7XG52YXIgVmVyc2lvbl8xID0gcmVxdWlyZShcIi4uL2RlY29kZXIvVmVyc2lvblwiKTtcbnZhciBNYXNrVXRpbF8xID0gcmVxdWlyZShcIi4vTWFza1V0aWxcIik7XG52YXIgQnl0ZU1hdHJpeF8xID0gcmVxdWlyZShcIi4vQnl0ZU1hdHJpeFwiKTtcbnZhciBRUkNvZGVfMSA9IHJlcXVpcmUoXCIuL1FSQ29kZVwiKTtcbnZhciBNYXRyaXhVdGlsXzEgPSByZXF1aXJlKFwiLi9NYXRyaXhVdGlsXCIpO1xudmFyIFN0cmluZ0VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcbnZhciBCbG9ja1BhaXJfMSA9IHJlcXVpcmUoXCIuL0Jsb2NrUGFpclwiKTtcbnZhciBXcml0ZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Xcml0ZXJFeGNlcHRpb25cIik7XG4vKmltcG9ydCBqYXZhLmlvLlVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb247Ki9cbi8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbi8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uOyovXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4vKipcbiAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcbiAqL1xudmFyIEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdG8gVVRGOCwgdGhlIGRlZmF1bHQgZm9yIGpzXG4gICAgZnVuY3Rpb24gRW5jb2RlcigpIHtcbiAgICB9XG4gICAgLy8gVGhlIG1hc2sgcGVuYWx0eSBjYWxjdWxhdGlvbiBpcyBjb21wbGljYXRlZC4gIFNlZSBUYWJsZSAyMSBvZiBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICAvLyBCYXNpY2FsbHkgaXQgYXBwbGllcyBmb3VyIHJ1bGVzIGFuZCBzdW1tYXRlIGFsbCBwZW5hbHRpZXMuXG4gICAgRW5jb2Rlci5jYWxjdWxhdGVNYXNrUGVuYWx0eSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIE1hc2tVdGlsXzEuZGVmYXVsdC5hcHBseU1hc2tQZW5hbHR5UnVsZTEobWF0cml4KVxuICAgICAgICAgICAgKyBNYXNrVXRpbF8xLmRlZmF1bHQuYXBwbHlNYXNrUGVuYWx0eVJ1bGUyKG1hdHJpeClcbiAgICAgICAgICAgICsgTWFza1V0aWxfMS5kZWZhdWx0LmFwcGx5TWFza1BlbmFsdHlSdWxlMyhtYXRyaXgpXG4gICAgICAgICAgICArIE1hc2tVdGlsXzEuZGVmYXVsdC5hcHBseU1hc2tQZW5hbHR5UnVsZTQobWF0cml4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250ZW50IHRleHQgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIGVjTGV2ZWwgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHtAbGluayBRUkNvZGV9IHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBRUiBjb2RlXG4gICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb24gaWYgZW5jb2RpbmcgY2FuJ3Qgc3VjY2VlZCwgYmVjYXVzZSBvZiBmb3IgZXhhbXBsZSBpbnZhbGlkIGNvbnRlbnRcbiAgICAgKiAgIG9yIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgc3RhdGljIGVuY29kZShjb250ZW50OiBzdHJpbmcsIGVjTGV2ZWw6IEVycm9yQ29ycmVjdGlvbkxldmVsKTogUVJDb2RlIC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiovIHtcbiAgICAvLyAgIHJldHVybiBlbmNvZGUoY29udGVudCwgZWNMZXZlbCwgbnVsbClcbiAgICAvLyB9XG4gICAgRW5jb2Rlci5lbmNvZGUgPSBmdW5jdGlvbiAoY29udGVudCwgZWNMZXZlbCwgaGludHMpIHtcbiAgICAgICAgaWYgKGhpbnRzID09PSB2b2lkIDApIHsgaGludHMgPSBudWxsOyB9XG4gICAgICAgIC8vIERldGVybWluZSB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIGNhbGxlciwgaWYgYW55XG4gICAgICAgIHZhciBlbmNvZGluZyA9IEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkc7XG4gICAgICAgIHZhciBoYXNFbmNvZGluZ0hpbnQgPSBoaW50cyAhPT0gbnVsbCAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuQ0hBUkFDVEVSX1NFVCk7XG4gICAgICAgIGlmIChoYXNFbmNvZGluZ0hpbnQpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBpY2sgYW4gZW5jb2RpbmcgbW9kZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gdXNlXG4gICAgICAgIC8vIG11bHRpcGxlIG1vZGVzIC8gc2VnbWVudHMgZXZlbiBpZiB0aGF0IHdlcmUgbW9yZSBlZmZpY2llbnQuIFR3b3VsZCBiZSBuaWNlLlxuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuY2hvb3NlTW9kZShjb250ZW50LCBlbmNvZGluZyk7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBzdG9yZSB0aGUgaGVhZGVyIGluZm9ybWF0aW9uLCBsaWtlIG1vZGUgYW5kXG4gICAgICAgIC8vIGxlbmd0aCwgYXMgd2VsbCBhcyBcImhlYWRlclwiIHNlZ21lbnRzIGxpa2UgYW4gRUNJIHNlZ21lbnQuXG4gICAgICAgIHZhciBoZWFkZXJCaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyBBcHBlbmQgRUNJIHNlZ21lbnQgaWYgYXBwbGljYWJsZVxuICAgICAgICBpZiAobW9kZSA9PT0gTW9kZV8xLmRlZmF1bHQuQllURSAmJiAoaGFzRW5jb2RpbmdIaW50IHx8IEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgIT09IGVuY29kaW5nKSkge1xuICAgICAgICAgICAgdmFyIGVjaSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChlY2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRUNJKGVjaSwgaGVhZGVyQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gKFdpdGggRUNJIGluIHBsYWNlLCkgV3JpdGUgdGhlIG1vZGUgbWFya2VyXG4gICAgICAgIHRoaXMuYXBwZW5kTW9kZUluZm8obW9kZSwgaGVhZGVyQml0cyk7XG4gICAgICAgIC8vIENvbGxlY3QgZGF0YSB3aXRoaW4gdGhlIG1haW4gc2VnbWVudCwgc2VwYXJhdGVseSwgdG8gY291bnQgaXRzIHNpemUgaWYgbmVlZGVkLiBEb24ndCBhZGQgaXQgdG9cbiAgICAgICAgLy8gbWFpbiBwYXlsb2FkIHlldC5cbiAgICAgICAgdmFyIGRhdGFCaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmFwcGVuZEJ5dGVzKGNvbnRlbnQsIG1vZGUsIGRhdGFCaXRzLCBlbmNvZGluZyk7XG4gICAgICAgIHZhciB2ZXJzaW9uO1xuICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LlFSX1ZFUlNJT04pKSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbk51bWJlciA9IE51bWJlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LlFSX1ZFUlNJT04pLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgIHZlcnNpb24gPSBWZXJzaW9uXzEuZGVmYXVsdC5nZXRWZXJzaW9uRm9yTnVtYmVyKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgICAgdmFyIGJpdHNOZWVkZWQgPSB0aGlzLmNhbGN1bGF0ZUJpdHNOZWVkZWQobW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMsIHZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpbGxGaXQoYml0c05lZWRlZCwgdmVyc2lvbiwgZWNMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnRGF0YSB0b28gYmlnIGZvciByZXF1ZXN0ZWQgdmVyc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMucmVjb21tZW5kVmVyc2lvbihlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlckFuZERhdGFCaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xuICAgICAgICBoZWFkZXJBbmREYXRhQml0cy5hcHBlbmRCaXRBcnJheShoZWFkZXJCaXRzKTtcbiAgICAgICAgLy8gRmluZCBcImxlbmd0aFwiIG9mIG1haW4gc2VnbWVudCBhbmQgd3JpdGUgaXRcbiAgICAgICAgdmFyIG51bUxldHRlcnMgPSBtb2RlID09PSBNb2RlXzEuZGVmYXVsdC5CWVRFID8gZGF0YUJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSA6IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFwcGVuZExlbmd0aEluZm8obnVtTGV0dGVycywgdmVyc2lvbiwgbW9kZSwgaGVhZGVyQW5kRGF0YUJpdHMpO1xuICAgICAgICAvLyBQdXQgZGF0YSB0b2dldGhlciBpbnRvIHRoZSBvdmVyYWxsIHBheWxvYWRcbiAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoZGF0YUJpdHMpO1xuICAgICAgICB2YXIgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgIHZhciBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAgIC8vIFRlcm1pbmF0ZSB0aGUgYml0cyBwcm9wZXJseS5cbiAgICAgICAgdGhpcy50ZXJtaW5hdGVCaXRzKG51bURhdGFCeXRlcywgaGVhZGVyQW5kRGF0YUJpdHMpO1xuICAgICAgICAvLyBJbnRlcmxlYXZlIGRhdGEgYml0cyB3aXRoIGVycm9yIGNvcnJlY3Rpb24gY29kZS5cbiAgICAgICAgdmFyIGZpbmFsQml0cyA9IHRoaXMuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGhlYWRlckFuZERhdGFCaXRzLCB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCksIG51bURhdGFCeXRlcywgZWNCbG9ja3MuZ2V0TnVtQmxvY2tzKCkpO1xuICAgICAgICB2YXIgcXJDb2RlID0gbmV3IFFSQ29kZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgcXJDb2RlLnNldEVDTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgIHFyQ29kZS5zZXRNb2RlKG1vZGUpO1xuICAgICAgICBxckNvZGUuc2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgICAgLy8gIENob29zZSB0aGUgbWFzayBwYXR0ZXJuIGFuZCBzZXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEJ5dGVNYXRyaXhfMS5kZWZhdWx0KGRpbWVuc2lvbiwgZGltZW5zaW9uKTtcbiAgICAgICAgdmFyIG1hc2tQYXR0ZXJuID0gdGhpcy5jaG9vc2VNYXNrUGF0dGVybihmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgIHFyQ29kZS5zZXRNYXNrUGF0dGVybihtYXNrUGF0dGVybik7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBtYXRyaXggYW5kIHNldCBpdCB0byBcInFyQ29kZVwiLlxuICAgICAgICBNYXRyaXhVdGlsXzEuZGVmYXVsdC5idWlsZE1hdHJpeChmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xuICAgICAgICBxckNvZGUuc2V0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBxckNvZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHRoZSBzbWFsbGVzdCB2ZXJzaW9uIG9mIFFSIGNvZGUgdGhhdCB3aWxsIGNvbnRhaW4gYWxsIG9mIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb24gaWYgdGhlIGRhdGEgY2Fubm90IGZpdCBpbiBhbnkgdmVyc2lvblxuICAgICAqL1xuICAgIEVuY29kZXIucmVjb21tZW5kVmVyc2lvbiA9IGZ1bmN0aW9uIChlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cykge1xuICAgICAgICAvLyBIYXJkIHBhcnQ6IG5lZWQgdG8ga25vdyB2ZXJzaW9uIHRvIGtub3cgaG93IG1hbnkgYml0cyBsZW5ndGggdGFrZXMuIEJ1dCBuZWVkIHRvIGtub3cgaG93IG1hbnlcbiAgICAgICAgLy8gYml0cyBpdCB0YWtlcyB0byBrbm93IHZlcnNpb24uIEZpcnN0IHdlIHRha2UgYSBndWVzcyBhdCB2ZXJzaW9uIGJ5IGFzc3VtaW5nIHZlcnNpb24gd2lsbCBiZVxuICAgICAgICAvLyB0aGUgbWluaW11bSwgMTpcbiAgICAgICAgdmFyIHByb3Zpc2lvbmFsQml0c05lZWRlZCA9IHRoaXMuY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgVmVyc2lvbl8xLmRlZmF1bHQuZ2V0VmVyc2lvbkZvck51bWJlcigxKSk7XG4gICAgICAgIHZhciBwcm92aXNpb25hbFZlcnNpb24gPSB0aGlzLmNob29zZVZlcnNpb24ocHJvdmlzaW9uYWxCaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgLy8gVXNlIHRoYXQgZ3Vlc3MgdG8gY2FsY3VsYXRlIHRoZSByaWdodCB2ZXJzaW9uLiBJIGFtIHN0aWxsIG5vdCBzdXJlIHRoaXMgd29ya3MgaW4gMTAwJSBvZiBjYXNlcy5cbiAgICAgICAgdmFyIGJpdHNOZWVkZWQgPSB0aGlzLmNhbGN1bGF0ZUJpdHNOZWVkZWQobW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMsIHByb3Zpc2lvbmFsVmVyc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNob29zZVZlcnNpb24oYml0c05lZWRlZCwgZWNMZXZlbCk7XG4gICAgfTtcbiAgICBFbmNvZGVyLmNhbGN1bGF0ZUJpdHNOZWVkZWQgPSBmdW5jdGlvbiAobW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckJpdHMuZ2V0U2l6ZSgpICsgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikgKyBkYXRhQml0cy5nZXRTaXplKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRoZSBjb2RlIHBvaW50IG9mIHRoZSB0YWJsZSB1c2VkIGluIGFscGhhbnVtZXJpYyBtb2RlIG9yXG4gICAgICogIC0xIGlmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY29kZSBpbiB0aGUgdGFibGUuXG4gICAgICovXG4gICAgRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlID0gZnVuY3Rpb24gKGNvZGUgLyppbnQqLykge1xuICAgICAgICBpZiAoY29kZSA8IEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFW2NvZGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIHB1YmxpYyBzdGF0aWMgY2hvb3NlTW9kZShjb250ZW50OiBzdHJpbmcpOiBNb2RlIHtcbiAgICAvLyAgIHJldHVybiBjaG9vc2VNb2RlKGNvbnRlbnQsIG51bGwpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDaG9vc2UgdGhlIGJlc3QgbW9kZSBieSBleGFtaW5pbmcgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCAnZW5jb2RpbmcnIGlzIHVzZWQgYXMgYSBoaW50O1xuICAgICAqIGlmIGl0IGlzIFNoaWZ0X0pJUywgYW5kIHRoZSBpbnB1dCBpcyBvbmx5IGRvdWJsZS1ieXRlIEthbmppLCB0aGVuIHdlIHJldHVybiB7QGxpbmsgTW9kZSNLQU5KSX0uXG4gICAgICovXG4gICAgRW5jb2Rlci5jaG9vc2VNb2RlID0gZnVuY3Rpb24gKGNvbnRlbnQsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gbnVsbDsgfVxuICAgICAgICBpZiAoQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5TSklTLmdldE5hbWUoKSA9PT0gZW5jb2RpbmcgJiYgdGhpcy5pc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkpIHtcbiAgICAgICAgICAgIC8vIENob29zZSBLYW5qaSBtb2RlIGlmIGFsbCBpbnB1dCBhcmUgZG91YmxlLWJ5dGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgcmV0dXJuIE1vZGVfMS5kZWZhdWx0LktBTkpJO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNOdW1lcmljID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYW51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gY29udGVudC5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKEVuY29kZXIuaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgICAgIGhhc051bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nZXRBbHBoYW51bWVyaWNDb2RlKGMuY2hhckNvZGVBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaGFzQWxwaGFudW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5CWVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNBbHBoYW51bWVyaWMpIHtcbiAgICAgICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5BTFBIQU5VTUVSSUM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc051bWVyaWMpIHtcbiAgICAgICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5OVU1FUklDO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5CWVRFO1xuICAgIH07XG4gICAgRW5jb2Rlci5pc09ubHlEb3VibGVCeXRlS2FuamkgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB2YXIgYnl0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBieXRlcyA9IFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdC5lbmNvZGUoY29udGVudCwgQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5TSklTKTsgLy8gY29udGVudC5nZXRCeXRlcyhcIlNoaWZ0X0pJU1wiKSlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZTEgPSBieXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICBpZiAoKGJ5dGUxIDwgMHg4MSB8fCBieXRlMSA+IDB4OUYpICYmIChieXRlMSA8IDB4RTAgfHwgYnl0ZTEgPiAweEVCKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEVuY29kZXIuY2hvb3NlTWFza1BhdHRlcm4gPSBmdW5jdGlvbiAoYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgIHZhciBtaW5QZW5hbHR5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIExvd2VyIHBlbmFsdHkgaXMgYmV0dGVyLlxuICAgICAgICB2YXIgYmVzdE1hc2tQYXR0ZXJuID0gLTE7XG4gICAgICAgIC8vIFdlIHRyeSBhbGwgbWFzayBwYXR0ZXJucyB0byBjaG9vc2UgdGhlIGJlc3Qgb25lLlxuICAgICAgICBmb3IgKHZhciBtYXNrUGF0dGVybiA9IDA7IG1hc2tQYXR0ZXJuIDwgUVJDb2RlXzEuZGVmYXVsdC5OVU1fTUFTS19QQVRURVJOUzsgbWFza1BhdHRlcm4rKykge1xuICAgICAgICAgICAgTWF0cml4VXRpbF8xLmRlZmF1bHQuYnVpbGRNYXRyaXgoYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICB2YXIgcGVuYWx0eSA9IHRoaXMuY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcbiAgICAgICAgICAgIGlmIChwZW5hbHR5IDwgbWluUGVuYWx0eSkge1xuICAgICAgICAgICAgICAgIG1pblBlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICAgICAgICAgIGJlc3RNYXNrUGF0dGVybiA9IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XG4gICAgfTtcbiAgICBFbmNvZGVyLmNob29zZVZlcnNpb24gPSBmdW5jdGlvbiAobnVtSW5wdXRCaXRzIC8qaW50Ki8sIGVjTGV2ZWwpIHtcbiAgICAgICAgZm9yICh2YXIgdmVyc2lvbk51bSA9IDE7IHZlcnNpb25OdW0gPD0gNDA7IHZlcnNpb25OdW0rKykge1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBWZXJzaW9uXzEuZGVmYXVsdC5nZXRWZXJzaW9uRm9yTnVtYmVyKHZlcnNpb25OdW0pO1xuICAgICAgICAgICAgaWYgKEVuY29kZXIud2lsbEZpdChudW1JbnB1dEJpdHMsIHZlcnNpb24sIGVjTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RhdGEgdG9vIGJpZycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBudW1iZXIgb2YgaW5wdXQgYml0cyB3aWxsIGZpdCBpbiBhIGNvZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHZlcnNpb24gYW5kXG4gICAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICAgKi9cbiAgICBFbmNvZGVyLndpbGxGaXQgPSBmdW5jdGlvbiAobnVtSW5wdXRCaXRzIC8qaW50Ki8sIHZlcnNpb24sIGVjTGV2ZWwpIHtcbiAgICAgICAgLy8gSW4gdGhlIGZvbGxvd2luZyBjb21tZW50cywgd2UgdXNlIG51bWJlcnMgb2YgVmVyc2lvbiA3LUguXG4gICAgICAgIC8vIG51bUJ5dGVzID0gMTk2XG4gICAgICAgIHZhciBudW1CeXRlcyA9IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKTtcbiAgICAgICAgLy8gZ2V0TnVtRUNCeXRlcyA9IDEzMFxuICAgICAgICB2YXIgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgIHZhciBudW1FY0J5dGVzID0gZWNCbG9ja3MuZ2V0VG90YWxFQ0NvZGV3b3JkcygpO1xuICAgICAgICAvLyBnZXROdW1EYXRhQnl0ZXMgPSAxOTYgLSAxMzAgPSA2NlxuICAgICAgICB2YXIgbnVtRGF0YUJ5dGVzID0gbnVtQnl0ZXMgLSBudW1FY0J5dGVzO1xuICAgICAgICB2YXIgdG90YWxJbnB1dEJ5dGVzID0gKG51bUlucHV0Qml0cyArIDcpIC8gODtcbiAgICAgICAgcmV0dXJuIG51bURhdGFCeXRlcyA+PSB0b3RhbElucHV0Qnl0ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgYml0cyBhcyBkZXNjcmliZWQgaW4gOC40LjggYW5kIDguNC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuMjQpLlxuICAgICAqL1xuICAgIEVuY29kZXIudGVybWluYXRlQml0cyA9IGZ1bmN0aW9uIChudW1EYXRhQnl0ZXMgLyppbnQqLywgYml0cykge1xuICAgICAgICB2YXIgY2FwYWNpdHkgPSBudW1EYXRhQnl0ZXMgKiA4O1xuICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2RhdGEgYml0cyBjYW5ub3QgZml0IGluIHRoZSBRUiBDb2RlJyArIGJpdHMuZ2V0U2l6ZSgpICsgJyA+ICcgK1xuICAgICAgICAgICAgICAgIGNhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgYml0cy5nZXRTaXplKCkgPCBjYXBhY2l0eTsgKytpKSB7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRlcm1pbmF0aW9uIGJpdHMuIFNlZSA4LjQuOCBvZiBKSVNYMDUxMDoyMDA0IChwLjI0KSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYnl0ZSBpc24ndCA4LWJpdCBhbGlnbmVkLCB3ZSdsbCBhZGQgcGFkZGluZyBiaXRzLlxuICAgICAgICB2YXIgbnVtQml0c0luTGFzdEJ5dGUgPSBiaXRzLmdldFNpemUoKSAmIDB4MDc7XG4gICAgICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBudW1CaXRzSW5MYXN0Qnl0ZTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgc3BhY2UsIHdlJ2xsIGZpbGwgdGhlIHNwYWNlIHdpdGggcGFkZGluZyBwYXR0ZXJucyBkZWZpbmVkIGluIDguNC45IChwLjI0KS5cbiAgICAgICAgdmFyIG51bVBhZGRpbmdCeXRlcyA9IG51bURhdGFCeXRlcyAtIGJpdHMuZ2V0U2l6ZUluQnl0ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QYWRkaW5nQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKChpICYgMHgwMSkgPT09IDAgPyAweEVDIDogMHgxMSwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0JpdHMgc2l6ZSBkb2VzIG5vdCBlcXVhbCBjYXBhY2l0eScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbnVtYmVyIG9mIGRhdGEgYnl0ZXMgYW5kIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciBibG9jayBpZCBcImJsb2NrSURcIi4gU3RvcmVcbiAgICAgKiB0aGUgcmVzdWx0IGluIFwibnVtRGF0YUJ5dGVzSW5CbG9ja1wiLCBhbmQgXCJudW1FQ0J5dGVzSW5CbG9ja1wiLiBTZWUgdGFibGUgMTIgaW4gOC41LjEgb2ZcbiAgICAgKiBKSVNYMDUxMDoyMDA0IChwLjMwKVxuICAgICAqL1xuICAgIEVuY29kZXIuZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQgPSBmdW5jdGlvbiAobnVtVG90YWxCeXRlcyAvKmludCovLCBudW1EYXRhQnl0ZXMgLyppbnQqLywgbnVtUlNCbG9ja3MgLyppbnQqLywgYmxvY2tJRCAvKmludCovLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FQ0J5dGVzSW5CbG9jaykge1xuICAgICAgICBpZiAoYmxvY2tJRCA+PSBudW1SU0Jsb2Nrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0Jsb2NrIElEIHRvbyBsYXJnZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDIgPSAxOTYgJSA1ID0gMVxuICAgICAgICB2YXIgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcbiAgICAgICAgLy8gbnVtUnNCbG9ja3NJbkdyb3VwMSA9IDUgLSAxID0gNFxuICAgICAgICB2YXIgbnVtUnNCbG9ja3NJbkdyb3VwMSA9IG51bVJTQmxvY2tzIC0gbnVtUnNCbG9ja3NJbkdyb3VwMjtcbiAgICAgICAgLy8gbnVtVG90YWxCeXRlc0luR3JvdXAxID0gMTk2IC8gNSA9IDM5XG4gICAgICAgIHZhciBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bVRvdGFsQnl0ZXMgLyBudW1SU0Jsb2Nrcyk7XG4gICAgICAgIC8vIG51bVRvdGFsQnl0ZXNJbkdyb3VwMiA9IDM5ICsgMSA9IDQwXG4gICAgICAgIHZhciBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAvLyBudW1EYXRhQnl0ZXNJbkdyb3VwMSA9IDY2IC8gNSA9IDEzXG4gICAgICAgIHZhciBudW1EYXRhQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtRGF0YUJ5dGVzIC8gbnVtUlNCbG9ja3MpO1xuICAgICAgICAvLyBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IDEzICsgMSA9IDE0XG4gICAgICAgIHZhciBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IG51bURhdGFCeXRlc0luR3JvdXAxICsgMTtcbiAgICAgICAgLy8gbnVtRWNCeXRlc0luR3JvdXAxID0gMzkgLSAxMyA9IDI2XG4gICAgICAgIHZhciBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgLy8gbnVtRWNCeXRlc0luR3JvdXAyID0gNDAgLSAxNCA9IDI2XG4gICAgICAgIHZhciBudW1FY0J5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMjtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrcy5cbiAgICAgICAgLy8gMjYgPSAyNlxuICAgICAgICBpZiAobnVtRWNCeXRlc0luR3JvdXAxICE9PSBudW1FY0J5dGVzSW5Hcm91cDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdFQyBieXRlcyBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUgPSA0ICsgMS5cbiAgICAgICAgaWYgKG51bVJTQmxvY2tzICE9PSBudW1Sc0Jsb2Nrc0luR3JvdXAxICsgbnVtUnNCbG9ja3NJbkdyb3VwMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1JTIGJsb2NrcyBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDE5NiA9ICgxMyArIDI2KSAqIDQgKyAoMTQgKyAyNikgKiAxXG4gICAgICAgIGlmIChudW1Ub3RhbEJ5dGVzICE9PVxuICAgICAgICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMSArIG51bUVjQnl0ZXNJbkdyb3VwMSkgKlxuICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDEpICtcbiAgICAgICAgICAgICAgICAoKG51bURhdGFCeXRlc0luR3JvdXAyICsgbnVtRWNCeXRlc0luR3JvdXAyKSAqXG4gICAgICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnVG90YWwgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tJRCA8IG51bVJzQmxvY2tzSW5Hcm91cDEpIHtcbiAgICAgICAgICAgIG51bURhdGFCeXRlc0luQmxvY2tbMF0gPSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgbnVtRUNCeXRlc0luQmxvY2tbMF0gPSBudW1FY0J5dGVzSW5Hcm91cDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybGVhdmUgXCJiaXRzXCIgd2l0aCBjb3JyZXNwb25kaW5nIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMuIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAgICAgKiBcInJlc3VsdFwiLiBUaGUgaW50ZXJsZWF2ZSBydWxlIGlzIGNvbXBsaWNhdGVkLiBTZWUgOC42IG9mIEpJU1gwNTEwOjIwMDQgKHAuMzcpIGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIEVuY29kZXIuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzID0gZnVuY3Rpb24gKGJpdHMsIG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8pIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIC8vIFwiYml0c1wiIG11c3QgaGF2ZSBcImdldE51bURhdGFCeXRlc1wiIGJ5dGVzIG9mIGRhdGEuXG4gICAgICAgIGlmIChiaXRzLmdldFNpemVJbkJ5dGVzKCkgIT09IG51bURhdGFCeXRlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ051bWJlciBvZiBiaXRzIGFuZCBkYXRhIGJ5dGVzIGRvZXMgbm90IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAxLiAgRGl2aWRlIGRhdGEgYnl0ZXMgaW50byBibG9ja3MgYW5kIGdlbmVyYXRlIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgZm9yIHRoZW0uIFdlJ2xsXG4gICAgICAgIC8vIHN0b3JlIHRoZSBkaXZpZGVkIGRhdGEgYnl0ZXMgYmxvY2tzIGFuZCBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGJsb2NrcyBpbnRvIFwiYmxvY2tzXCIuXG4gICAgICAgIHZhciBkYXRhQnl0ZXNPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4TnVtRGF0YUJ5dGVzID0gMDtcbiAgICAgICAgdmFyIG1heE51bUVjQnl0ZXMgPSAwO1xuICAgICAgICAvLyBTaW5jZSwgd2Uga25vdyB0aGUgbnVtYmVyIG9mIHJlZWRzb2xtb24gYmxvY2tzLCB3ZSBjYW4gaW5pdGlhbGl6ZSB0aGUgdmVjdG9yIHdpdGggdGhlIG51bWJlci5cbiAgICAgICAgdmFyIGJsb2NrcyA9IG5ldyBBcnJheSgpOyAvLyBuZXcgQXJyYXk8QmxvY2tQYWlyPihudW1SU0Jsb2NrcylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1SU0Jsb2NrczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbnVtRGF0YUJ5dGVzSW5CbG9jayA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgdmFyIG51bUVjQnl0ZXNJbkJsb2NrID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICBFbmNvZGVyLmdldE51bURhdGFCeXRlc0FuZE51bUVDQnl0ZXNGb3JCbG9ja0lEKG51bVRvdGFsQnl0ZXMsIG51bURhdGFCeXRlcywgbnVtUlNCbG9ja3MsIGksIG51bURhdGFCeXRlc0luQmxvY2ssIG51bUVjQnl0ZXNJbkJsb2NrKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gbnVtRGF0YUJ5dGVzSW5CbG9ja1swXTtcbiAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgICAgIGJpdHMudG9CeXRlcyg4ICogZGF0YUJ5dGVzT2Zmc2V0LCBkYXRhQnl0ZXMsIDAsIHNpemUpO1xuICAgICAgICAgICAgdmFyIGVjQnl0ZXMgPSBFbmNvZGVyLmdlbmVyYXRlRUNCeXRlcyhkYXRhQnl0ZXMsIG51bUVjQnl0ZXNJbkJsb2NrWzBdKTtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBCbG9ja1BhaXJfMS5kZWZhdWx0KGRhdGFCeXRlcywgZWNCeXRlcykpO1xuICAgICAgICAgICAgbWF4TnVtRGF0YUJ5dGVzID0gTWF0aC5tYXgobWF4TnVtRGF0YUJ5dGVzLCBzaXplKTtcbiAgICAgICAgICAgIG1heE51bUVjQnl0ZXMgPSBNYXRoLm1heChtYXhOdW1FY0J5dGVzLCBlY0J5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhQnl0ZXNPZmZzZXQgKz0gbnVtRGF0YUJ5dGVzSW5CbG9ja1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtRGF0YUJ5dGVzICE9PSBkYXRhQnl0ZXNPZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdEYXRhIGJ5dGVzIGRvZXMgbm90IG1hdGNoIG9mZnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8vIEZpcnN0LCBwbGFjZSBkYXRhIGJsb2Nrcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOdW1EYXRhQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBibG9ja3NfMSA9IChlXzEgPSB2b2lkIDAsIF9fdmFsdWVzKGJsb2NrcykpLCBibG9ja3NfMV8xID0gYmxvY2tzXzEubmV4dCgpOyAhYmxvY2tzXzFfMS5kb25lOyBibG9ja3NfMV8xID0gYmxvY2tzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMgPSBibG9jay5nZXREYXRhQnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBkYXRhQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQml0cyhkYXRhQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NfMV8xICYmICFibG9ja3NfMV8xLmRvbmUgJiYgKF9hID0gYmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChibG9ja3NfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVuLCBwbGFjZSBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOdW1FY0J5dGVzOyArK2kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tzXzIgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyhibG9ja3MpKSwgYmxvY2tzXzJfMSA9IGJsb2Nrc18yLm5leHQoKTsgIWJsb2Nrc18yXzEuZG9uZTsgYmxvY2tzXzJfMSA9IGJsb2Nrc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWNCeXRlcyA9IGJsb2NrLmdldEVycm9yQ29ycmVjdGlvbkJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgZWNCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGVjQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NfMl8xICYmICFibG9ja3NfMl8xLmRvbmUgJiYgKF9iID0gYmxvY2tzXzIucmV0dXJuKSkgX2IuY2FsbChibG9ja3NfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtVG90YWxCeXRlcyAhPT0gcmVzdWx0LmdldFNpemVJbkJ5dGVzKCkpIHsgLy8gU2hvdWxkIGJlIHNhbWUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnSW50ZXJsZWF2aW5nIGVycm9yOiAnICsgbnVtVG90YWxCeXRlcyArICcgYW5kICcgK1xuICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRTaXplSW5CeXRlcygpICsgJyBkaWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEVuY29kZXIuZ2VuZXJhdGVFQ0J5dGVzID0gZnVuY3Rpb24gKGRhdGFCeXRlcywgbnVtRWNCeXRlc0luQmxvY2sgLyppbnQqLykge1xuICAgICAgICB2YXIgbnVtRGF0YUJ5dGVzID0gZGF0YUJ5dGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvRW5jb2RlID0gbmV3IEludDMyQXJyYXkobnVtRGF0YUJ5dGVzICsgbnVtRWNCeXRlc0luQmxvY2spOyAvLyBpbnRbbnVtRGF0YUJ5dGVzICsgbnVtRWNCeXRlc0luQmxvY2tdXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgIHRvRW5jb2RlW2ldID0gZGF0YUJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBuZXcgUmVlZFNvbG9tb25FbmNvZGVyXzEuZGVmYXVsdChHZW5lcmljR0ZfMS5kZWZhdWx0LlFSX0NPREVfRklFTERfMjU2KS5lbmNvZGUodG9FbmNvZGUsIG51bUVjQnl0ZXNJbkJsb2NrKTtcbiAgICAgICAgdmFyIGVjQnl0ZXMgPSBuZXcgVWludDhBcnJheShudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWNCeXRlc0luQmxvY2s7IGkrKykge1xuICAgICAgICAgICAgZWNCeXRlc1tpXSA9IC8qKGJ5dGUpICovIHRvRW5jb2RlW251bURhdGFCeXRlcyArIGldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlY0J5dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kIG1vZGUgaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgKi9cbiAgICBFbmNvZGVyLmFwcGVuZE1vZGVJbmZvID0gZnVuY3Rpb24gKG1vZGUsIGJpdHMpIHtcbiAgICAgICAgYml0cy5hcHBlbmRCaXRzKG1vZGUuZ2V0Qml0cygpLCA0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGVuZCBsZW5ndGggaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgKi9cbiAgICBFbmNvZGVyLmFwcGVuZExlbmd0aEluZm8gPSBmdW5jdGlvbiAobnVtTGV0dGVycyAvKmludCovLCB2ZXJzaW9uLCBtb2RlLCBiaXRzKSB7XG4gICAgICAgIHZhciBudW1CaXRzID0gbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbik7XG4gICAgICAgIGlmIChudW1MZXR0ZXJzID49ICgxIDw8IG51bUJpdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdChudW1MZXR0ZXJzICsgJyBpcyBiaWdnZXIgdGhhbiAnICsgKCgxIDw8IG51bUJpdHMpIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW1MZXR0ZXJzLCBudW1CaXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGVuZCBcImJ5dGVzXCIgaW4gXCJtb2RlXCIgbW9kZSAoZW5jb2RpbmcpIGludG8gXCJiaXRzXCIuIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIuXG4gICAgICovXG4gICAgRW5jb2Rlci5hcHBlbmRCeXRlcyA9IGZ1bmN0aW9uIChjb250ZW50LCBtb2RlLCBiaXRzLCBlbmNvZGluZykge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZE51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgIEVuY29kZXIuYXBwZW5kQWxwaGFudW1lcmljQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkJZVEU6XG4gICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmQ4Qml0Qnl0ZXMoY29udGVudCwgYml0cywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5LQU5KSTpcbiAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEthbmppQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdJbnZhbGlkIG1vZGU6ICcgKyBtb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5nZXREaWdpdCA9IGZ1bmN0aW9uIChzaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZUNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIC0gNDg7XG4gICAgfTtcbiAgICBFbmNvZGVyLmlzRGlnaXQgPSBmdW5jdGlvbiAoc2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgICAgIHZhciBjbiA9IEVuY29kZXIuZ2V0RGlnaXQoc2luZ2xlQ2hhcmFjdGVyKTtcbiAgICAgICAgcmV0dXJuIGNuID49IDAgJiYgY24gPD0gOTtcbiAgICB9O1xuICAgIEVuY29kZXIuYXBwZW5kTnVtZXJpY0J5dGVzID0gZnVuY3Rpb24gKGNvbnRlbnQsIGJpdHMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbnVtMSA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgaWYgKGkgKyAyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5jb2RlIHRocmVlIG51bWVyaWMgbGV0dGVycyBpbiB0ZW4gYml0cy5cbiAgICAgICAgICAgICAgICB2YXIgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtMyA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDIpKTtcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMobnVtMSAqIDEwMCArIG51bTIgKiAxMCArIG51bTMsIDEwKTtcbiAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEVuY29kZSB0d28gbnVtZXJpYyBsZXR0ZXJzIGluIHNldmVuIGJpdHMuXG4gICAgICAgICAgICAgICAgdmFyIG51bTIgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMCArIG51bTIsIDcpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVuY29kZSBvbmUgbnVtZXJpYyBsZXR0ZXIgaW4gZm91ciBiaXRzLlxuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xLCA0KTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIuYXBwZW5kQWxwaGFudW1lcmljQnl0ZXMgPSBmdW5jdGlvbiAoY29udGVudCwgYml0cykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlMSA9IEVuY29kZXIuZ2V0QWxwaGFudW1lcmljQ29kZShjb250ZW50LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKGNvZGUxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTIgPSBFbmNvZGVyLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUyID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgdHdvIGFscGhhbnVtZXJpYyBsZXR0ZXJzIGluIDExIGJpdHMuXG4gICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxICogNDUgKyBjb2RlMiwgMTEpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVuY29kZSBvbmUgYWxwaGFudW1lcmljIGxldHRlciBpbiBzaXggYml0cy5cbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEsIDYpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5hcHBlbmQ4Qml0Qnl0ZXMgPSBmdW5jdGlvbiAoY29udGVudCwgYml0cywgZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIGJ5dGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnl0ZXMgPSBTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZW5jb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodWVlIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KHVlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8yID0gYnl0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGhfMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGIsIDgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIFdyaXRlckV4Y2VwdGlvblxuICAgICAqL1xuICAgIEVuY29kZXIuYXBwZW5kS2FuamlCeXRlcyA9IGZ1bmN0aW9uIChjb250ZW50LCBiaXRzKSB7XG4gICAgICAgIHZhciBieXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlNKSVMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQodWVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZTEgPSBieXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBieXRlc1tpICsgMV0gJiAweEZGO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSAoKGJ5dGUxIDw8IDgpICYgMHhGRkZGRkZGRikgfCBieXRlMjtcbiAgICAgICAgICAgIHZhciBzdWJ0cmFjdGVkID0gLTE7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSAweDgxNDAgJiYgY29kZSA8PSAweDlmZmMpIHtcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdGVkID0gY29kZSAtIDB4ODE0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gMHhlMDQwICYmIGNvZGUgPD0gMHhlYmJmKSB7XG4gICAgICAgICAgICAgICAgc3VidHJhY3RlZCA9IGNvZGUgLSAweGMxNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VidHJhY3RlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5jb2RlZCA9ICgoc3VidHJhY3RlZCA+PiA4KSAqIDB4YzApICsgKHN1YnRyYWN0ZWQgJiAweGZmKTtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhlbmNvZGVkLCAxMyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIuYXBwZW5kRUNJID0gZnVuY3Rpb24gKGVjaSwgYml0cykge1xuICAgICAgICBiaXRzLmFwcGVuZEJpdHMoTW9kZV8xLmRlZmF1bHQuRUNJLmdldEJpdHMoKSwgNCk7XG4gICAgICAgIC8vIFRoaXMgaXMgY29ycmVjdCBmb3IgdmFsdWVzIHVwIHRvIDEyNywgd2hpY2ggaXMgYWxsIHdlIG5lZWQgbm93LlxuICAgICAgICBiaXRzLmFwcGVuZEJpdHMoZWNpLmdldFZhbHVlKCksIDgpO1xuICAgIH07XG4gICAgLy8gVGhlIG9yaWdpbmFsIHRhYmxlIGlzIGRlZmluZWQgaW4gdGhlIHRhYmxlIDUgb2YgSklTWDA1MTA6MjAwNCAocC4xOSkuXG4gICAgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIDM2LCAtMSwgLTEsIC0xLCAzNywgMzgsIC0xLCAtMSwgLTEsIC0xLCAzOSwgNDAsIC0xLCA0MSwgNDIsIDQzLFxuICAgICAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCA0NCwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCxcbiAgICAgICAgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgXSk7XG4gICAgRW5jb2Rlci5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORyA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuVVRGOC5nZXROYW1lKCk7IC8vIFwiSVNPLTg4NTktMVwiXG4gICAgcmV0dXJuIEVuY29kZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW5jb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * @author Satoru Takabayashi\n * @author Daniel Switkin\n * @author Sean Owen\n */\nvar MaskUtil = /** @class */ (function () {\n    function MaskUtil() {\n        // do nothing\n    }\n    /**\n     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n     * give penalty to them. Example: 00000 or 11111.\n     */\n    MaskUtil.applyMaskPenaltyRule1 = function (matrix) {\n        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n    };\n    /**\n     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n     */\n    MaskUtil.applyMaskPenaltyRule2 = function (matrix) {\n        var penalty = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height - 1; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width - 1; x++) {\n                var value = arrayY[x];\n                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                    penalty++;\n                }\n            }\n        }\n        return MaskUtil.N2 * penalty;\n    };\n    /**\n     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n     * find patterns like 000010111010000, we give penalty once.\n     */\n    MaskUtil.applyMaskPenaltyRule3 = function (matrix) {\n        var numPenalties = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n                var arrayY = array[y]; // We can at least optimize this access\n                if (x + 6 < width &&\n                    arrayY[x] === 1 &&\n                    arrayY[x + 1] === 0 &&\n                    arrayY[x + 2] === 1 &&\n                    arrayY[x + 3] === 1 &&\n                    arrayY[x + 4] === 1 &&\n                    arrayY[x + 5] === 0 &&\n                    arrayY[x + 6] === 1 &&\n                    (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                    numPenalties++;\n                }\n                if (y + 6 < height &&\n                    array[y][x] === 1 &&\n                    array[y + 1][x] === 0 &&\n                    array[y + 2][x] === 1 &&\n                    array[y + 3][x] === 1 &&\n                    array[y + 4][x] === 1 &&\n                    array[y + 5][x] === 0 &&\n                    array[y + 6][x] === 1 &&\n                    (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                    numPenalties++;\n                }\n            }\n        }\n        return numPenalties * MaskUtil.N3;\n    };\n    MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, rowArray.length);\n        for (var i = from; i < to; i++) {\n            if (rowArray[i] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, array.length);\n        for (var i = from; i < to; i++) {\n            if (array[i][col] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n     */\n    MaskUtil.applyMaskPenaltyRule4 = function (matrix) {\n        var numDarkCells = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width; x++) {\n                if (arrayY[x] === 1) {\n                    numDarkCells++;\n                }\n            }\n        }\n        var numTotalCells = matrix.getHeight() * matrix.getWidth();\n        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n        return fivePercentVariances * MaskUtil.N4;\n    };\n    /**\n     * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n     * pattern conditions.\n     */\n    MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {\n        var intermediate; /*int*/\n        var temp; /*int*/\n        switch (maskPattern) {\n            case 0:\n                intermediate = (y + x) & 0x1;\n                break;\n            case 1:\n                intermediate = y & 0x1;\n                break;\n            case 2:\n                intermediate = x % 3;\n                break;\n            case 3:\n                intermediate = (y + x) % 3;\n                break;\n            case 4:\n                intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;\n                break;\n            case 5:\n                temp = y * x;\n                intermediate = (temp & 0x1) + (temp % 3);\n                break;\n            case 6:\n                temp = y * x;\n                intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;\n                break;\n            case 7:\n                temp = y * x;\n                intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;\n                break;\n            default:\n                throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);\n        }\n        return intermediate === 0;\n    };\n    /**\n     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n     * vertical and horizontal orders respectively.\n     */\n    MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {\n        var penalty = 0;\n        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n        var array = matrix.getArray();\n        for (var i = 0; i < iLimit; i++) {\n            var numSameBitCells = 0;\n            var prevBit = -1;\n            for (var j = 0; j < jLimit; j++) {\n                var bit = isHorizontal ? array[i][j] : array[j][i];\n                if (bit === prevBit) {\n                    numSameBitCells++;\n                }\n                else {\n                    if (numSameBitCells >= 5) {\n                        penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                    }\n                    numSameBitCells = 1; // Include the cell itself.\n                    prevBit = bit;\n                }\n            }\n            if (numSameBitCells >= 5) {\n                penalty += MaskUtil.N1 + (numSameBitCells - 5);\n            }\n        }\n        return penalty;\n    };\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n    return MaskUtil;\n}());\nexports[\"default\"] = MaskUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9NYXNrVXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyxxS0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsV0FBVztBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9lbmNvZGVyL01hc2tVdGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBAYXV0aG9yIFNhdG9ydSBUYWthYmF5YXNoaVxuICogQGF1dGhvciBEYW5pZWwgU3dpdGtpblxuICogQGF1dGhvciBTZWFuIE93ZW5cbiAqL1xudmFyIE1hc2tVdGlsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hc2tVdGlsKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDEgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gRmluZCByZXBldGl0aXZlIGNlbGxzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kXG4gICAgICogZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uIEV4YW1wbGU6IDAwMDAwIG9yIDExMTExLlxuICAgICAqL1xuICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgdHJ1ZSkgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDIgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gRmluZCAyeDIgYmxvY2tzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kIGdpdmVcbiAgICAgKiBwZW5hbHR5IHRvIHRoZW0uIFRoaXMgaXMgYWN0dWFsbHkgZXF1aXZhbGVudCB0byB0aGUgc3BlYydzIHJ1bGUsIHdoaWNoIGlzIHRvIGZpbmQgTXhOIGJsb2NrcyBhbmQgZ2l2ZSBhXG4gICAgICogcGVuYWx0eSBwcm9wb3J0aW9uYWwgdG8gKE0tMSl4KE4tMSksIGJlY2F1c2UgdGhpcyBpcyB0aGUgbnVtYmVyIG9mIDJ4MiBibG9ja3MgaW5zaWRlIHN1Y2ggYSBibG9jay5cbiAgICAgKi9cbiAgICBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTIgPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHZhciBwZW5hbHR5ID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgdmFyIGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aCAtIDE7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5WVt4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGFycmF5WVt4ICsgMV0gJiYgdmFsdWUgPT09IGFycmF5W3kgKyAxXVt4XSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3ggKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5hbHR5Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXNrVXRpbC5OMiAqIHBlbmFsdHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmUgcnVucyBvZiAxOjE6MzoxOjE6NFxuICAgICAqIHN0YXJ0aW5nIHdpdGggYmxhY2ssIG9yIDQ6MToxOjM6MToxIHN0YXJ0aW5nIHdpdGggd2hpdGUsIGFuZCBnaXZlIHBlbmFsdHkgdG8gdGhlbS4gIElmIHdlXG4gICAgICogZmluZCBwYXR0ZXJucyBsaWtlIDAwMDAxMDExMTAxMDAwMCwgd2UgZ2l2ZSBwZW5hbHR5IG9uY2UuXG4gICAgICovXG4gICAgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUzID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICB2YXIgbnVtUGVuYWx0aWVzID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlZID0gYXJyYXlbeV07IC8vIFdlIGNhbiBhdCBsZWFzdCBvcHRpbWl6ZSB0aGlzIGFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmICh4ICsgNiA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3ggKyAzXSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDRdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3ggKyA2XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAoTWFza1V0aWwuaXNXaGl0ZUhvcml6b250YWwoYXJyYXlZLCB4IC0gNCwgeCkgfHwgTWFza1V0aWwuaXNXaGl0ZUhvcml6b250YWwoYXJyYXlZLCB4ICsgNywgeCArIDExKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ICsgNiA8IGhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheVt5XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgMV1beF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDJdW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAzXVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgNF1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDVdW3hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA2XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAoTWFza1V0aWwuaXNXaGl0ZVZlcnRpY2FsKGFycmF5LCB4LCB5IC0gNCwgeSkgfHwgTWFza1V0aWwuaXNXaGl0ZVZlcnRpY2FsKGFycmF5LCB4LCB5ICsgNywgeSArIDExKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1QZW5hbHRpZXMgKiBNYXNrVXRpbC5OMztcbiAgICB9O1xuICAgIE1hc2tVdGlsLmlzV2hpdGVIb3Jpem9udGFsID0gZnVuY3Rpb24gKHJvd0FycmF5LCBmcm9tIC8qaW50Ki8sIHRvIC8qaW50Ki8pIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCByb3dBcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyb3dBcnJheVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbCA9IGZ1bmN0aW9uIChhcnJheSwgY29sIC8qaW50Ki8sIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoZnJvbSwgMCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odG8sIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldW2NvbF0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSA0IGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgZGFyayBjZWxscyBhbmQgZ2l2ZVxuICAgICAqIHBlbmFsdHkgaWYgdGhlIHJhdGlvIGlzIGZhciBmcm9tIDUwJS4gSXQgZ2l2ZXMgMTAgcGVuYWx0eSBmb3IgNSUgZGlzdGFuY2UuXG4gICAgICovXG4gICAgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGU0ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICB2YXIgbnVtRGFya0NlbGxzID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlZID0gYXJyYXlbeV07XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlZW3hdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bURhcmtDZWxscysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtVG90YWxDZWxscyA9IG1hdHJpeC5nZXRIZWlnaHQoKSAqIG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgZml2ZVBlcmNlbnRWYXJpYW5jZXMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG51bURhcmtDZWxscyAqIDIgLSBudW1Ub3RhbENlbGxzKSAqIDEwIC8gbnVtVG90YWxDZWxscyk7XG4gICAgICAgIHJldHVybiBmaXZlUGVyY2VudFZhcmlhbmNlcyAqIE1hc2tVdGlsLk40O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtYXNrIGJpdCBmb3IgXCJnZXRNYXNrUGF0dGVyblwiIGF0IFwieFwiIGFuZCBcInlcIi4gU2VlIDguOCBvZiBKSVNYMDUxMDoyMDA0IGZvciBtYXNrXG4gICAgICogcGF0dGVybiBjb25kaXRpb25zLlxuICAgICAqL1xuICAgIE1hc2tVdGlsLmdldERhdGFNYXNrQml0ID0gZnVuY3Rpb24gKG1hc2tQYXR0ZXJuIC8qaW50Ki8sIHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgIHZhciBpbnRlcm1lZGlhdGU7IC8qaW50Ki9cbiAgICAgICAgdmFyIHRlbXA7IC8qaW50Ki9cbiAgICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICh5ICsgeCkgJiAweDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0geSAmIDB4MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSB4ICUgMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoeSArIHgpICUgMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoTWF0aC5mbG9vcih5IC8gMikgKyBNYXRoLmZsb29yKHggLyAzKSkgJiAweDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGVtcCA9IHkgKiB4O1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICh0ZW1wICYgMHgxKSArICh0ZW1wICUgMyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGVtcCA9IHkgKiB4O1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKCh0ZW1wICUgMykgKyAoKHkgKyB4KSAmIDB4MSkpICYgMHgxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnSW52YWxpZCBtYXNrIHBhdHRlcm46ICcgKyBtYXNrUGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVybWVkaWF0ZSA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxLiBXZSBuZWVkIHRoaXMgZm9yIGRvaW5nIHRoaXMgY2FsY3VsYXRpb24gaW4gYm90aFxuICAgICAqIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIG9yZGVycyByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxSW50ZXJuYWwgPSBmdW5jdGlvbiAobWF0cml4LCBpc0hvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHBlbmFsdHkgPSAwO1xuICAgICAgICB2YXIgaUxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldEhlaWdodCgpIDogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBqTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0V2lkdGgoKSA6IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBudW1TYW1lQml0Q2VsbHMgPSAwO1xuICAgICAgICAgICAgdmFyIHByZXZCaXQgPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgakxpbWl0OyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0ID0gaXNIb3Jpem9udGFsID8gYXJyYXlbaV1bal0gOiBhcnJheVtqXVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoYml0ID09PSBwcmV2Qml0KSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5ICs9IE1hc2tVdGlsLk4xICsgKG51bVNhbWVCaXRDZWxscyAtIDUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscyA9IDE7IC8vIEluY2x1ZGUgdGhlIGNlbGwgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICBwcmV2Qml0ID0gYml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1TYW1lQml0Q2VsbHMgPj0gNSkge1xuICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gTWFza1V0aWwuTjEgKyAobnVtU2FtZUJpdENlbGxzIC0gNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlbmFsdHk7XG4gICAgfTtcbiAgICAvLyBQZW5hbHR5IHdlaWdodHMgZnJvbSBzZWN0aW9uIDYuOC4yLjFcbiAgICBNYXNrVXRpbC5OMSA9IDM7XG4gICAgTWFza1V0aWwuTjIgPSAzO1xuICAgIE1hc2tVdGlsLk4zID0gNDA7XG4gICAgTWFza1V0aWwuTjQgPSAxMDtcbiAgICByZXR1cm4gTWFza1V0aWw7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWFza1V0aWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nvar Integer_1 = __webpack_require__(/*! ../../util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar QRCode_1 = __webpack_require__(/*! ./QRCode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js\");\nvar MaskUtil_1 = __webpack_require__(/*! ./MaskUtil */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js\");\nvar WriterException_1 = __webpack_require__(/*! ../../WriterException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar MatrixUtil = /** @class */ (function () {\n    function MatrixUtil() {\n        // do nothing\n    }\n    // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).\n    //\n    // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding\n    // with the ByteMatrix initialized all to zero.\n    MatrixUtil.clearMatrix = function (matrix) {\n        // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255\n        matrix.clear(/*(byte) */ /*-1*/ 255);\n    };\n    // Build 2D matrix of QR Code from \"dataBits\" with \"ecLevel\", \"version\" and \"getMaskPattern\". On\n    // success, store the result in \"matrix\" and return true.\n    MatrixUtil.buildMatrix = function (dataBits, ecLevel, version, maskPattern /*int*/, matrix) {\n        MatrixUtil.clearMatrix(matrix);\n        MatrixUtil.embedBasicPatterns(version, matrix);\n        // Type information appear with any version.\n        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);\n        // Version info appear if version >= 7.\n        MatrixUtil.maybeEmbedVersionInfo(version, matrix);\n        // Data should be embedded at end.\n        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);\n    };\n    // Embed basic patterns. On success, modify the matrix and return true.\n    // The basic patterns are:\n    // - Position detection patterns\n    // - Timing patterns\n    // - Dark dot at the left bottom corner\n    // - Position adjustment patterns, if need be\n    MatrixUtil.embedBasicPatterns = function (version, matrix) {\n        // Let's get started with embedding big squares at corners.\n        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);\n        // Then, embed the dark dot at the left bottom corner.\n        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);\n        // Position adjustment patterns appear if version >= 2.\n        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);\n        // Timing patterns should be embedded after position adj. patterns.\n        MatrixUtil.embedTimingPatterns(matrix);\n    };\n    // Embed type information. On success, modify the matrix.\n    MatrixUtil.embedTypeInfo = function (ecLevel, maskPattern /*int*/, matrix) {\n        var typeInfoBits = new BitArray_1.default();\n        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);\n        for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {\n            // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in\n            // \"typeInfoBits\".\n            var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);\n            // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).\n            var coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];\n            var x1 = coordinates[0];\n            var y1 = coordinates[1];\n            matrix.setBoolean(x1, y1, bit);\n            if (i < 8) {\n                // Right top corner.\n                var x2 = matrix.getWidth() - i - 1;\n                var y2 = 8;\n                matrix.setBoolean(x2, y2, bit);\n            }\n            else {\n                // Left bottom corner.\n                var x2 = 8;\n                var y2 = matrix.getHeight() - 7 + (i - 8);\n                matrix.setBoolean(x2, y2, bit);\n            }\n        }\n    };\n    // Embed version information if need be. On success, modify the matrix and return true.\n    // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.\n    MatrixUtil.maybeEmbedVersionInfo = function (version, matrix) {\n        if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.\n            return; // Don't need version info.\n        }\n        var versionInfoBits = new BitArray_1.default();\n        MatrixUtil.makeVersionInfoBits(version, versionInfoBits);\n        var bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.\n        for (var i = 0; i < 6; ++i) {\n            for (var j = 0; j < 3; ++j) {\n                // Place bits in LSB (least significant bit) to MSB order.\n                var bit = versionInfoBits.get(bitIndex);\n                bitIndex--;\n                // Left bottom corner.\n                matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);\n                // Right bottom corner.\n                matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);\n            }\n        }\n    };\n    // Embed \"dataBits\" using \"getMaskPattern\". On success, modify the matrix and return true.\n    // For debugging purposes, it skips masking process if \"getMaskPattern\" is -1(TYPESCRIPTPORT: 255).\n    // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.\n    MatrixUtil.embedDataBits = function (dataBits, maskPattern /*int*/, matrix) {\n        var bitIndex = 0;\n        var direction = -1;\n        // Start from the right bottom cell.\n        var x = matrix.getWidth() - 1;\n        var y = matrix.getHeight() - 1;\n        while (x > 0) {\n            // Skip the vertical timing pattern.\n            if (x === 6) {\n                x -= 1;\n            }\n            while (y >= 0 && y < matrix.getHeight()) {\n                for (var i = 0; i < 2; ++i) {\n                    var xx = x - i;\n                    // Skip the cell if it's not empty.\n                    if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {\n                        continue;\n                    }\n                    var bit = void 0;\n                    if (bitIndex < dataBits.getSize()) {\n                        bit = dataBits.get(bitIndex);\n                        ++bitIndex;\n                    }\n                    else {\n                        // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described\n                        // in 8.4.9 of JISX0510:2004 (p. 24).\n                        bit = false;\n                    }\n                    // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).\n                    if (maskPattern !== 255 && MaskUtil_1.default.getDataMaskBit(maskPattern, xx, y)) {\n                        bit = !bit;\n                    }\n                    matrix.setBoolean(xx, y, bit);\n                }\n                y += direction;\n            }\n            direction = -direction; // Reverse the direction.\n            y += direction;\n            x -= 2; // Move to the left.\n        }\n        // All bits should be consumed.\n        if (bitIndex !== dataBits.getSize()) {\n            throw new WriterException_1.default('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());\n        }\n    };\n    // Return the position of the most significant bit set (one: to) in the \"value\". The most\n    // significant bit is position 32. If there is no bit set, return 0. Examples:\n    // - findMSBSet(0) => 0\n    // - findMSBSet(1) => 1\n    // - findMSBSet(255) => 8\n    MatrixUtil.findMSBSet = function (value /*int*/) {\n        return 32 - Integer_1.default.numberOfLeadingZeros(value);\n    };\n    // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for \"value\" using polynomial \"poly\". The BCH\n    // code is used for encoding type information and version information.\n    // Example: Calculation of version information of 7.\n    // f(x) is created from 7.\n    //   - 7 = 000111 in 6 bits\n    //   - f(x) = x^2 + x^1 + x^0\n    // g(x) is given by the standard (p. 67)\n    //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1\n    // Multiply f(x) by x^(18 - 6)\n    //   - f'(x) = f(x) * x^(18 - 6)\n    //   - f'(x) = x^14 + x^13 + x^12\n    // Calculate the remainder of f'(x) / g(x)\n    //         x^2\n    //         __________________________________________________\n    //   g(x) )x^14 + x^13 + x^12\n    //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2\n    //         --------------------------------------------------\n    //                              x^11 + x^10 + x^7 + x^4 + x^2\n    //\n    // The remainder is x^11 + x^10 + x^7 + x^4 + x^2\n    // Encode it in binary: 110010010100\n    // The return value is 0xc94 (1100 1001 0100)\n    //\n    // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit\n    // operations. We don't care if coefficients are positive or negative.\n    MatrixUtil.calculateBCHCode = function (value /*int*/, poly /*int*/) {\n        if (poly === 0) {\n            throw new IllegalArgumentException_1.default('0 polynomial');\n        }\n        // If poly is \"1 1111 0010 0101\" (version info poly), msbSetInPoly is 13. We'll subtract 1\n        // from 13 to make it 12.\n        var msbSetInPoly = MatrixUtil.findMSBSet(poly);\n        value <<= msbSetInPoly - 1;\n        // Do the division business using exclusive-or operations.\n        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {\n            value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);\n        }\n        // Now the \"value\" is the remainder (i.e. the BCH code)\n        return value;\n    };\n    // Make bit vector of type information. On success, store the result in \"bits\" and return true.\n    // Encode error correction level and mask pattern. See 8.9 of\n    // JISX0510:2004 (p.45) for details.\n    MatrixUtil.makeTypeInfoBits = function (ecLevel, maskPattern /*int*/, bits) {\n        if (!QRCode_1.default.isValidMaskPattern(maskPattern)) {\n            throw new WriterException_1.default('Invalid mask pattern');\n        }\n        var typeInfo = (ecLevel.getBits() << 3) | maskPattern;\n        bits.appendBits(typeInfo, 5);\n        var bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);\n        bits.appendBits(bchCode, 10);\n        var maskBits = new BitArray_1.default();\n        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);\n        bits.xor(maskBits);\n        if (bits.getSize() !== 15) { // Just in case.\n            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());\n        }\n    };\n    // Make bit vector of version information. On success, store the result in \"bits\" and return true.\n    // See 8.10 of JISX0510:2004 (p.45) for details.\n    MatrixUtil.makeVersionInfoBits = function (version, bits) {\n        bits.appendBits(version.getVersionNumber(), 6);\n        var bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);\n        bits.appendBits(bchCode, 12);\n        if (bits.getSize() !== 18) { // Just in case.\n            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());\n        }\n    };\n    // Check if \"value\" is empty.\n    MatrixUtil.isEmpty = function (value /*int*/) {\n        return value === 255; // -1\n    };\n    MatrixUtil.embedTimingPatterns = function (matrix) {\n        // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical\n        // separation patterns (1: size). Thus, 8 = 7 + 1.\n        for (var i = 8; i < matrix.getWidth() - 8; ++i) {\n            var bit = (i + 1) % 2;\n            // Horizontal line.\n            if (MatrixUtil.isEmpty(matrix.get(i, 6))) {\n                matrix.setNumber(i, 6, bit);\n            }\n            // Vertical line.\n            if (MatrixUtil.isEmpty(matrix.get(6, i))) {\n                matrix.setNumber(6, i, bit);\n            }\n        }\n    };\n    // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)\n    MatrixUtil.embedDarkDotAtLeftBottomCorner = function (matrix) {\n        if (matrix.get(8, matrix.getHeight() - 8) === 0) {\n            throw new WriterException_1.default();\n        }\n        matrix.setNumber(8, matrix.getHeight() - 8, 1);\n    };\n    MatrixUtil.embedHorizontalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {\n        for (var x = 0; x < 8; ++x) {\n            if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {\n                throw new WriterException_1.default();\n            }\n            matrix.setNumber(xStart + x, yStart, 0);\n        }\n    };\n    MatrixUtil.embedVerticalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {\n        for (var y = 0; y < 7; ++y) {\n            if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {\n                throw new WriterException_1.default();\n            }\n            matrix.setNumber(xStart, yStart + y, 0);\n        }\n    };\n    MatrixUtil.embedPositionAdjustmentPattern = function (xStart /*int*/, yStart /*int*/, matrix) {\n        for (var y = 0; y < 5; ++y) {\n            var patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];\n            for (var x = 0; x < 5; ++x) {\n                matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n            }\n        }\n    };\n    MatrixUtil.embedPositionDetectionPattern = function (xStart /*int*/, yStart /*int*/, matrix) {\n        for (var y = 0; y < 7; ++y) {\n            var patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];\n            for (var x = 0; x < 7; ++x) {\n                matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n            }\n        }\n    };\n    // Embed position detection patterns and surrounding vertical/horizontal separators.\n    MatrixUtil.embedPositionDetectionPatternsAndSeparators = function (matrix) {\n        // Embed three big squares at corners.\n        var pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;\n        // Left top corner.\n        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);\n        // Right top corner.\n        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);\n        // Left bottom corner.\n        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);\n        // Embed horizontal separation patterns around the squares.\n        var hspWidth = 8;\n        // Left top corner.\n        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);\n        // Right top corner.\n        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);\n        // Left bottom corner.\n        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);\n        // Embed vertical separation patterns around the squares.\n        var vspSize = 7;\n        // Left top corner.\n        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);\n        // Right top corner.\n        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);\n        // Left bottom corner.\n        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);\n    };\n    // Embed position adjustment patterns if need be.\n    MatrixUtil.maybeEmbedPositionAdjustmentPatterns = function (version, matrix) {\n        if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2\n            return;\n        }\n        var index = version.getVersionNumber() - 1;\n        var coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];\n        for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {\n            var y = coordinates[i];\n            if (y >= 0) {\n                for (var j = 0; j !== length_1; j++) {\n                    var x = coordinates[j];\n                    if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {\n                        // If the cell is unset, we embed the position adjustment pattern here.\n                        // -2 is necessary since the x/y coordinates point to the center of the pattern, not the\n                        // left top corner.\n                        MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);\n                    }\n                }\n            }\n        }\n    };\n    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n    ]);\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1]),\n    ]);\n    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([\n        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),\n        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),\n        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),\n        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),\n        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),\n        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),\n        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),\n        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),\n        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),\n        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),\n        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),\n        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),\n        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),\n        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),\n    ]);\n    // Type info cells at the left top corner.\n    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([\n        Int32Array.from([8, 0]),\n        Int32Array.from([8, 1]),\n        Int32Array.from([8, 2]),\n        Int32Array.from([8, 3]),\n        Int32Array.from([8, 4]),\n        Int32Array.from([8, 5]),\n        Int32Array.from([8, 7]),\n        Int32Array.from([8, 8]),\n        Int32Array.from([7, 8]),\n        Int32Array.from([5, 8]),\n        Int32Array.from([4, 8]),\n        Int32Array.from([3, 8]),\n        Int32Array.from([2, 8]),\n        Int32Array.from([1, 8]),\n        Int32Array.from([0, 8]),\n    ]);\n    // From Appendix D in JISX0510:2004 (p. 67)\n    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101\n    // From Appendix C in JISX0510:2004 (p.65).\n    MatrixUtil.TYPE_INFO_POLY = 0x537;\n    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;\n    return MatrixUtil;\n}());\nexports[\"default\"] = MatrixUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9NYXRyaXhVdGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QztBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSkFBdUI7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsNklBQW9CO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyw0SUFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxnSkFBWTtBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQyxtSkFBdUI7QUFDdkQsaUNBQWlDLG1CQUFPLENBQUMscUtBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsd0JBQXdCLE9BQU87QUFDL0IsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9lbmNvZGVyL01hdHJpeFV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmVuY29kZXIgeyovXG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0QXJyYXlcIik7XG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcbnZhciBRUkNvZGVfMSA9IHJlcXVpcmUoXCIuL1FSQ29kZVwiKTtcbnZhciBNYXNrVXRpbF8xID0gcmVxdWlyZShcIi4vTWFza1V0aWxcIik7XG52YXIgV3JpdGVyRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vV3JpdGVyRXhjZXB0aW9uXCIpO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbi8qKlxuICogQGF1dGhvciBzYXRvcnV4QGdvb2dsZS5jb20gKFNhdG9ydSBUYWthYmF5YXNoaSkgLSBjcmVhdG9yXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICovXG52YXIgTWF0cml4VXRpbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRyaXhVdGlsKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIC8vIFNldCBhbGwgY2VsbHMgdG8gLTEgKFRZUEVTQ1JJUFRQT1JUOiAyNTUpLiAgLTEgKFRZUEVTQ1JJUFRQT1JUOiAyNTUpIG1lYW5zIHRoYXQgdGhlIGNlbGwgaXMgZW1wdHkgKG5vdCBzZXQgeWV0KS5cbiAgICAvL1xuICAgIC8vIEpBVkFQT1JUOiBXZSBzaG91bGRuJ3QgbmVlZCB0byBkbyB0aGlzIGF0IGFsbC4gVGhlIGNvZGUgc2hvdWxkIGJlIHJld3JpdHRlbiB0byBiZWdpbiBlbmNvZGluZ1xuICAgIC8vIHdpdGggdGhlIEJ5dGVNYXRyaXggaW5pdGlhbGl6ZWQgYWxsIHRvIHplcm8uXG4gICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IHdlIHVzZSBVaW50QXJyYXkgc2UgY2hhbmdlZCBoZXJlIGZyb20gLTEgdG8gMjU1XG4gICAgICAgIG1hdHJpeC5jbGVhcigvKihieXRlKSAqLyAvKi0xKi8gMjU1KTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkIDJEIG1hdHJpeCBvZiBRUiBDb2RlIGZyb20gXCJkYXRhQml0c1wiIHdpdGggXCJlY0xldmVsXCIsIFwidmVyc2lvblwiIGFuZCBcImdldE1hc2tQYXR0ZXJuXCIuIE9uXG4gICAgLy8gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcIm1hdHJpeFwiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBNYXRyaXhVdGlsLmJ1aWxkTWF0cml4ID0gZnVuY3Rpb24gKGRhdGFCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeChtYXRyaXgpO1xuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkQmFzaWNQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpO1xuICAgICAgICAvLyBUeXBlIGluZm9ybWF0aW9uIGFwcGVhciB3aXRoIGFueSB2ZXJzaW9uLlxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgIC8vIFZlcnNpb24gaW5mbyBhcHBlYXIgaWYgdmVyc2lvbiA+PSA3LlxuICAgICAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpO1xuICAgICAgICAvLyBEYXRhIHNob3VsZCBiZSBlbWJlZGRlZCBhdCBlbmQuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWREYXRhQml0cyhkYXRhQml0cywgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgfTtcbiAgICAvLyBFbWJlZCBiYXNpYyBwYXR0ZXJucy4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXggYW5kIHJldHVybiB0cnVlLlxuICAgIC8vIFRoZSBiYXNpYyBwYXR0ZXJucyBhcmU6XG4gICAgLy8gLSBQb3NpdGlvbiBkZXRlY3Rpb24gcGF0dGVybnNcbiAgICAvLyAtIFRpbWluZyBwYXR0ZXJuc1xuICAgIC8vIC0gRGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lclxuICAgIC8vIC0gUG9zaXRpb24gYWRqdXN0bWVudCBwYXR0ZXJucywgaWYgbmVlZCBiZVxuICAgIE1hdHJpeFV0aWwuZW1iZWRCYXNpY1BhdHRlcm5zID0gZnVuY3Rpb24gKHZlcnNpb24sIG1hdHJpeCkge1xuICAgICAgICAvLyBMZXQncyBnZXQgc3RhcnRlZCB3aXRoIGVtYmVkZGluZyBiaWcgc3F1YXJlcyBhdCBjb3JuZXJzLlxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMobWF0cml4KTtcbiAgICAgICAgLy8gVGhlbiwgZW1iZWQgdGhlIGRhcmsgZG90IGF0IHRoZSBsZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWREYXJrRG90QXRMZWZ0Qm90dG9tQ29ybmVyKG1hdHJpeCk7XG4gICAgICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cbiAgICAgICAgTWF0cml4VXRpbC5tYXliZUVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybnModmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgLy8gVGltaW5nIHBhdHRlcm5zIHNob3VsZCBiZSBlbWJlZGRlZCBhZnRlciBwb3NpdGlvbiBhZGouIHBhdHRlcm5zLlxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcbiAgICB9O1xuICAgIC8vIEVtYmVkIHR5cGUgaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIG1vZGlmeSB0aGUgbWF0cml4LlxuICAgIE1hdHJpeFV0aWwuZW1iZWRUeXBlSW5mbyA9IGZ1bmN0aW9uIChlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIHR5cGVJbmZvQml0cyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcbiAgICAgICAgTWF0cml4VXRpbC5tYWtlVHlwZUluZm9CaXRzKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuLCB0eXBlSW5mb0JpdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgc2l6ZSA9IHR5cGVJbmZvQml0cy5nZXRTaXplKCk7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIHRvIE1TQiBvcmRlci4gIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyB0aGUgbGFzdCB2YWx1ZSBpblxuICAgICAgICAgICAgLy8gXCJ0eXBlSW5mb0JpdHNcIi5cbiAgICAgICAgICAgIHZhciBiaXQgPSB0eXBlSW5mb0JpdHMuZ2V0KHR5cGVJbmZvQml0cy5nZXRTaXplKCkgLSAxIC0gaSk7XG4gICAgICAgICAgICAvLyBUeXBlIGluZm8gYml0cyBhdCB0aGUgbGVmdCB0b3AgY29ybmVyLiBTZWUgOC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuNDYpLlxuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVNbaV07XG4gICAgICAgICAgICB2YXIgeDEgPSBjb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgIHZhciB5MSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDEsIHkxLCBiaXQpO1xuICAgICAgICAgICAgaWYgKGkgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgICAgICB2YXIgeDIgPSBtYXRyaXguZ2V0V2lkdGgoKSAtIGkgLSAxO1xuICAgICAgICAgICAgICAgIHZhciB5MiA9IDg7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDIsIHkyLCBiaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgIHZhciB4MiA9IDg7XG4gICAgICAgICAgICAgICAgdmFyIHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDIsIHkyLCBiaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBFbWJlZCB2ZXJzaW9uIGluZm9ybWF0aW9uIGlmIG5lZWQgYmUuIE9uIHN1Y2Nlc3MsIG1vZGlmeSB0aGUgbWF0cml4IGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgOC4xMCBvZiBKSVNYMDUxMDoyMDA0IChwLjQ3KSBmb3IgaG93IHRvIGVtYmVkIHZlcnNpb24gaW5mb3JtYXRpb24uXG4gICAgTWF0cml4VXRpbC5tYXliZUVtYmVkVmVyc2lvbkluZm8gPSBmdW5jdGlvbiAodmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDcpIHsgLy8gVmVyc2lvbiBpbmZvIGlzIG5lY2Vzc2FyeSBpZiB2ZXJzaW9uID49IDcuXG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IG5lZWQgdmVyc2lvbiBpbmZvLlxuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uSW5mb0JpdHMgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KCk7XG4gICAgICAgIE1hdHJpeFV0aWwubWFrZVZlcnNpb25JbmZvQml0cyh2ZXJzaW9uLCB2ZXJzaW9uSW5mb0JpdHMpO1xuICAgICAgICB2YXIgYml0SW5kZXggPSA2ICogMyAtIDE7IC8vIEl0IHdpbGwgZGVjcmVhc2UgZnJvbSAxNyB0byAwLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBQbGFjZSBiaXRzIGluIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSB0byBNU0Igb3JkZXIuXG4gICAgICAgICAgICAgICAgdmFyIGJpdCA9IHZlcnNpb25JbmZvQml0cy5nZXQoYml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGJpdEluZGV4LS07XG4gICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKGksIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgYml0KTtcbiAgICAgICAgICAgICAgICAvLyBSaWdodCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgaSwgYml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRW1iZWQgXCJkYXRhQml0c1wiIHVzaW5nIFwiZ2V0TWFza1BhdHRlcm5cIi4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXggYW5kIHJldHVybiB0cnVlLlxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgLy8gU2VlIDguNyBvZiBKSVNYMDUxMDoyMDA0IChwLjM4KSBmb3IgaG93IHRvIGVtYmVkIGRhdGEgYml0cy5cbiAgICBNYXRyaXhVdGlsLmVtYmVkRGF0YUJpdHMgPSBmdW5jdGlvbiAoZGF0YUJpdHMsIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICB2YXIgYml0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIHJpZ2h0IGJvdHRvbSBjZWxsLlxuICAgICAgICB2YXIgeCA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gMTtcbiAgICAgICAgdmFyIHkgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICB3aGlsZSAoeCA+IDApIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuLlxuICAgICAgICAgICAgaWYgKHggPT09IDYpIHtcbiAgICAgICAgICAgICAgICB4IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoeSA+PSAwICYmIHkgPCBtYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeHggPSB4IC0gaTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgY2VsbCBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4eCwgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPCBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGRhdGFCaXRzLmdldChiaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2JpdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkZGluZyBiaXQuIElmIHRoZXJlIGlzIG5vIGJpdCBsZWZ0LCB3ZSdsbCBmaWxsIHRoZSBsZWZ0IGNlbGxzIHdpdGggMCwgYXMgZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiA4LjQuOSBvZiBKSVNYMDUxMDoyMDA0IChwLiAyNCkuXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIG1hc2tpbmcgaWYgbWFza19wYXR0ZXJuIGlzIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQYXR0ZXJuICE9PSAyNTUgJiYgTWFza1V0aWxfMS5kZWZhdWx0LmdldERhdGFNYXNrQml0KG1hc2tQYXR0ZXJuLCB4eCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9ICFiaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeHgsIHksIGJpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aW9uID0gLWRpcmVjdGlvbjsgLy8gUmV2ZXJzZSB0aGUgZGlyZWN0aW9uLlxuICAgICAgICAgICAgeSArPSBkaXJlY3Rpb247XG4gICAgICAgICAgICB4IC09IDI7IC8vIE1vdmUgdG8gdGhlIGxlZnQuXG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxuICAgICAgICBpZiAoYml0SW5kZXggIT09IGRhdGFCaXRzLmdldFNpemUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05vdCBhbGwgYml0cyBjb25zdW1lZDogJyArIGJpdEluZGV4ICsgJy8nICsgZGF0YUJpdHMuZ2V0U2l6ZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0IChvbmU6IHRvKSBpbiB0aGUgXCJ2YWx1ZVwiLiBUaGUgbW9zdFxuICAgIC8vIHNpZ25pZmljYW50IGJpdCBpcyBwb3NpdGlvbiAzMi4gSWYgdGhlcmUgaXMgbm8gYml0IHNldCwgcmV0dXJuIDAuIEV4YW1wbGVzOlxuICAgIC8vIC0gZmluZE1TQlNldCgwKSA9PiAwXG4gICAgLy8gLSBmaW5kTVNCU2V0KDEpID0+IDFcbiAgICAvLyAtIGZpbmRNU0JTZXQoMjU1KSA9PiA4XG4gICAgTWF0cml4VXRpbC5maW5kTVNCU2V0ID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIDMyIC0gSW50ZWdlcl8xLmRlZmF1bHQubnVtYmVyT2ZMZWFkaW5nWmVyb3ModmFsdWUpO1xuICAgIH07XG4gICAgLy8gQ2FsY3VsYXRlIEJDSCAoQm9zZS1DaGF1ZGh1cmktSG9jcXVlbmdoZW0pIGNvZGUgZm9yIFwidmFsdWVcIiB1c2luZyBwb2x5bm9taWFsIFwicG9seVwiLiBUaGUgQkNIXG4gICAgLy8gY29kZSBpcyB1c2VkIGZvciBlbmNvZGluZyB0eXBlIGluZm9ybWF0aW9uIGFuZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgIC8vIEV4YW1wbGU6IENhbGN1bGF0aW9uIG9mIHZlcnNpb24gaW5mb3JtYXRpb24gb2YgNy5cbiAgICAvLyBmKHgpIGlzIGNyZWF0ZWQgZnJvbSA3LlxuICAgIC8vICAgLSA3ID0gMDAwMTExIGluIDYgYml0c1xuICAgIC8vICAgLSBmKHgpID0geF4yICsgeF4xICsgeF4wXG4gICAgLy8gZyh4KSBpcyBnaXZlbiBieSB0aGUgc3RhbmRhcmQgKHAuIDY3KVxuICAgIC8vICAgLSBnKHgpID0geF4xMiArIHheMTEgKyB4XjEwICsgeF45ICsgeF44ICsgeF41ICsgeF4yICsgMVxuICAgIC8vIE11bHRpcGx5IGYoeCkgYnkgeF4oMTggLSA2KVxuICAgIC8vICAgLSBmJyh4KSA9IGYoeCkgKiB4XigxOCAtIDYpXG4gICAgLy8gICAtIGYnKHgpID0geF4xNCArIHheMTMgKyB4XjEyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByZW1haW5kZXIgb2YgZicoeCkgLyBnKHgpXG4gICAgLy8gICAgICAgICB4XjJcbiAgICAvLyAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gICAgLy8gICBnKHgpICl4XjE0ICsgeF4xMyArIHheMTJcbiAgICAvLyAgICAgICAgIHheMTQgKyB4XjEzICsgeF4xMiArIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgLy8gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAvL1xuICAgIC8vIFRoZSByZW1haW5kZXIgaXMgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAvLyBFbmNvZGUgaXQgaW4gYmluYXJ5OiAxMTAwMTAwMTAxMDBcbiAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIDB4Yzk0ICgxMTAwIDEwMDEgMDEwMClcbiAgICAvL1xuICAgIC8vIFNpbmNlIGFsbCBjb2VmZmljaWVudHMgaW4gdGhlIHBvbHlub21pYWxzIGFyZSAxIG9yIDAsIHdlIGNhbiBkbyB0aGUgY2FsY3VsYXRpb24gYnkgYml0XG4gICAgLy8gb3BlcmF0aW9ucy4gV2UgZG9uJ3QgY2FyZSBpZiBjb2VmZmljaWVudHMgYXJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuICAgIE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSA9IGZ1bmN0aW9uICh2YWx1ZSAvKmludCovLCBwb2x5IC8qaW50Ki8pIHtcbiAgICAgICAgaWYgKHBvbHkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCcwIHBvbHlub21pYWwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBwb2x5IGlzIFwiMSAxMTExIDAwMTAgMDEwMVwiICh2ZXJzaW9uIGluZm8gcG9seSksIG1zYlNldEluUG9seSBpcyAxMy4gV2UnbGwgc3VidHJhY3QgMVxuICAgICAgICAvLyBmcm9tIDEzIHRvIG1ha2UgaXQgMTIuXG4gICAgICAgIHZhciBtc2JTZXRJblBvbHkgPSBNYXRyaXhVdGlsLmZpbmRNU0JTZXQocG9seSk7XG4gICAgICAgIHZhbHVlIDw8PSBtc2JTZXRJblBvbHkgLSAxO1xuICAgICAgICAvLyBEbyB0aGUgZGl2aXNpb24gYnVzaW5lc3MgdXNpbmcgZXhjbHVzaXZlLW9yIG9wZXJhdGlvbnMuXG4gICAgICAgIHdoaWxlIChNYXRyaXhVdGlsLmZpbmRNU0JTZXQodmFsdWUpID49IG1zYlNldEluUG9seSkge1xuICAgICAgICAgICAgdmFsdWUgXj0gcG9seSA8PCAoTWF0cml4VXRpbC5maW5kTVNCU2V0KHZhbHVlKSAtIG1zYlNldEluUG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHRoZSBcInZhbHVlXCIgaXMgdGhlIHJlbWFpbmRlciAoaS5lLiB0aGUgQkNIIGNvZGUpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8vIE1ha2UgYml0IHZlY3RvciBvZiB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBFbmNvZGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhbmQgbWFzayBwYXR0ZXJuLiBTZWUgOC45IG9mXG4gICAgLy8gSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgTWF0cml4VXRpbC5tYWtlVHlwZUluZm9CaXRzID0gZnVuY3Rpb24gKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgaWYgKCFRUkNvZGVfMS5kZWZhdWx0LmlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdJbnZhbGlkIG1hc2sgcGF0dGVybicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IChlY0xldmVsLmdldEJpdHMoKSA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xuICAgICAgICBiaXRzLmFwcGVuZEJpdHModHlwZUluZm8sIDUpO1xuICAgICAgICB2YXIgYmNoQ29kZSA9IE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSh0eXBlSW5mbywgTWF0cml4VXRpbC5UWVBFX0lORk9fUE9MWSk7XG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMCk7XG4gICAgICAgIHZhciBtYXNrQml0cyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcbiAgICAgICAgbWFza0JpdHMuYXBwZW5kQml0cyhNYXRyaXhVdGlsLlRZUEVfSU5GT19NQVNLX1BBVFRFUk4sIDE1KTtcbiAgICAgICAgYml0cy54b3IobWFza0JpdHMpO1xuICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE1KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNYWtlIGJpdCB2ZWN0b3Igb2YgdmVyc2lvbiBpbmZvcm1hdGlvbi4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIiBhbmQgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgTWF0cml4VXRpbC5tYWtlVmVyc2lvbkluZm9CaXRzID0gZnVuY3Rpb24gKHZlcnNpb24sIGJpdHMpIHtcbiAgICAgICAgYml0cy5hcHBlbmRCaXRzKHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpLCA2KTtcbiAgICAgICAgdmFyIGJjaENvZGUgPSBNYXRyaXhVdGlsLmNhbGN1bGF0ZUJDSENvZGUodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCksIE1hdHJpeFV0aWwuVkVSU0lPTl9JTkZPX1BPTFkpO1xuICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTIpO1xuICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE4KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDaGVjayBpZiBcInZhbHVlXCIgaXMgZW1wdHkuXG4gICAgTWF0cml4VXRpbC5pc0VtcHR5ID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAyNTU7IC8vIC0xXG4gICAgfTtcbiAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMgPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIC8vIC04IGlzIGZvciBza2lwcGluZyBwb3NpdGlvbiBkZXRlY3Rpb24gcGF0dGVybnMgKDc6IHNpemUpLCBhbmQgdHdvIGhvcml6b250YWwvdmVydGljYWxcbiAgICAgICAgLy8gc2VwYXJhdGlvbiBwYXR0ZXJucyAoMTogc2l6ZSkuIFRodXMsIDggPSA3ICsgMS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDg7IGkgPCBtYXRyaXguZ2V0V2lkdGgoKSAtIDg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJpdCA9IChpICsgMSkgJSAyO1xuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lLlxuICAgICAgICAgICAgaWYgKE1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KGksIDYpKSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoaSwgNiwgYml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUuXG4gICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoNiwgaSkpKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcig2LCBpLCBiaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBFbWJlZCB0aGUgbG9uZWx5IGRhcmsgZG90IGF0IGxlZnQgYm90dG9tIGNvcm5lci4gSklTWDA1MTA6MjAwNCAocC40NilcbiAgICBNYXRyaXhVdGlsLmVtYmVkRGFya0RvdEF0TGVmdEJvdHRvbUNvcm5lciA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgaWYgKG1hdHJpeC5nZXQoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LnNldE51bWJlcig4LCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSA4LCAxKTtcbiAgICB9O1xuICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4gPSBmdW5jdGlvbiAoeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA4OyArK3gpIHtcbiAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeFN0YXJ0ICsgeCwgeVN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQgKyB4LCB5U3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybiA9IGZ1bmN0aW9uICh4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDc7ICsreSkge1xuICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4U3RhcnQsIHlTdGFydCArIHkpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCwgeVN0YXJ0ICsgeSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJuID0gZnVuY3Rpb24gKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgKyt5KSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVyblkgPSBNYXRyaXhVdGlsLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTlt5XTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgKyt4KSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQgKyB4LCB5U3RhcnQgKyB5LCBwYXR0ZXJuWVt4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4gPSBmdW5jdGlvbiAoeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA3OyArK3kpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuWSA9IE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk5beV07XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDc7ICsreCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoeFN0YXJ0ICsgeCwgeVN0YXJ0ICsgeSwgcGF0dGVybllbeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBFbWJlZCBwb3NpdGlvbiBkZXRlY3Rpb24gcGF0dGVybnMgYW5kIHN1cnJvdW5kaW5nIHZlcnRpY2FsL2hvcml6b250YWwgc2VwYXJhdG9ycy5cbiAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMgPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIC8vIEVtYmVkIHRocmVlIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgICAgIHZhciBwZHBXaWR0aCA9IE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk5bMF0ubGVuZ3RoO1xuICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4oMCwgMCwgbWF0cml4KTtcbiAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybihtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCAwLCBtYXRyaXgpO1xuICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4oMCwgbWF0cml4LmdldFdpZHRoKCkgLSBwZHBXaWR0aCwgbWF0cml4KTtcbiAgICAgICAgLy8gRW1iZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICAgICAgdmFyIGhzcFdpZHRoID0gODtcbiAgICAgICAgLy8gTGVmdCB0b3AgY29ybmVyLlxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKDAsIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcbiAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybihtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBoc3BXaWR0aCAtIDEsIG1hdHJpeCk7XG4gICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAvLyBFbWJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICAgICAgdmFyIHZzcFNpemUgPSA3O1xuICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKHZzcFNpemUsIDAsIG1hdHJpeCk7XG4gICAgICAgIC8vIFJpZ2h0IHRvcCBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIHZzcFNpemUgLSAxLCAwLCBtYXRyaXgpO1xuICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKHZzcFNpemUsIG1hdHJpeC5nZXRIZWlnaHQoKSAtIHZzcFNpemUsIG1hdHJpeCk7XG4gICAgfTtcbiAgICAvLyBFbWJlZCBwb3NpdGlvbiBhZGp1c3RtZW50IHBhdHRlcm5zIGlmIG5lZWQgYmUuXG4gICAgTWF0cml4VXRpbC5tYXliZUVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybnMgPSBmdW5jdGlvbiAodmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHsgLy8gVGhlIHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSAtIDE7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IE1hdHJpeFV0aWwuUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOX0NPT1JESU5BVEVfVEFCTEVbaW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgIT09IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGxlbmd0aF8xOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiBNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4LCB5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjZWxsIGlzIHVuc2V0LCB3ZSBlbWJlZCB0aGUgcG9zaXRpb24gYWRqdXN0bWVudCBwYXR0ZXJuIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtMiBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHgveSBjb29yZGluYXRlcyBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSBwYXR0ZXJuLCBub3QgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybih4IC0gMiwgeSAtIDIsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDEsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMSwgMSwgMSwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgXSk7XG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMV0pLFxuICAgIF0pO1xuICAgIC8vIEZyb20gQXBwZW5kaXggRS4gVGFibGUgMSwgSklTMDUxMFg6MjAwNCAoNzE6IHApLiBUaGUgdGFibGUgd2FzIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRSA9IEFycmF5LmZyb20oW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMTgsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgMzgsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzAsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMTgsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzAsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzQsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksXG4gICAgXSk7XG4gICAgLy8gVHlwZSBpbmZvIGNlbGxzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVMgPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzcsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs1LCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzAsIDhdKSxcbiAgICBdKTtcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEQgaW4gSklTWDA1MTA6MjAwNCAocC4gNjcpXG4gICAgTWF0cml4VXRpbC5WRVJTSU9OX0lORk9fUE9MWSA9IDB4MWYyNTsgLy8gMSAxMTExIDAwMTAgMDEwMVxuICAgIC8vIEZyb20gQXBwZW5kaXggQyBpbiBKSVNYMDUxMDoyMDA0IChwLjY1KS5cbiAgICBNYXRyaXhVdGlsLlRZUEVfSU5GT19QT0xZID0gMHg1Mzc7XG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOID0gMHg1NDEyO1xuICAgIHJldHVybiBNYXRyaXhVdGlsO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdHJpeFV0aWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar QRCode = /** @class */ (function () {\n    function QRCode() {\n        this.maskPattern = -1;\n    }\n    QRCode.prototype.getMode = function () {\n        return this.mode;\n    };\n    QRCode.prototype.getECLevel = function () {\n        return this.ecLevel;\n    };\n    QRCode.prototype.getVersion = function () {\n        return this.version;\n    };\n    QRCode.prototype.getMaskPattern = function () {\n        return this.maskPattern;\n    };\n    QRCode.prototype.getMatrix = function () {\n        return this.matrix;\n    };\n    /*@Override*/\n    QRCode.prototype.toString = function () {\n        var result = new StringBuilder_1.default(); // (200)\n        result.append('<<\\n');\n        result.append(' mode: ');\n        result.append(this.mode ? this.mode.toString() : 'null');\n        result.append('\\n ecLevel: ');\n        result.append(this.ecLevel ? this.ecLevel.toString() : 'null');\n        result.append('\\n version: ');\n        result.append(this.version ? this.version.toString() : 'null');\n        result.append('\\n maskPattern: ');\n        result.append(this.maskPattern.toString());\n        if (this.matrix) {\n            result.append('\\n matrix:\\n');\n            result.append(this.matrix.toString());\n        }\n        else {\n            result.append('\\n matrix: null\\n');\n        }\n        result.append('>>\\n');\n        return result.toString();\n    };\n    QRCode.prototype.setMode = function (value) {\n        this.mode = value;\n    };\n    QRCode.prototype.setECLevel = function (value) {\n        this.ecLevel = value;\n    };\n    QRCode.prototype.setVersion = function (version) {\n        this.version = version;\n    };\n    QRCode.prototype.setMaskPattern = function (value /*int*/) {\n        this.maskPattern = value;\n    };\n    QRCode.prototype.setMatrix = function (value) {\n        this.matrix = value;\n    };\n    // Check if \"mask_pattern\" is valid.\n    QRCode.isValidMaskPattern = function (maskPattern /*int*/) {\n        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;\n    };\n    QRCode.NUM_MASK_PATTERNS = 8;\n    return QRCode;\n}());\nexports[\"default\"] = QRCode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS9xcmNvZGUvZW5jb2Rlci9RUkNvZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMseUpBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3FyY29kZS9lbmNvZGVyL1FSQ29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XG4vKipcbiAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcbiAqL1xudmFyIFFSQ29kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRUkNvZGUoKSB7XG4gICAgICAgIHRoaXMubWFza1BhdHRlcm4gPSAtMTtcbiAgICB9XG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRFQ0xldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lY0xldmVsO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRNYXNrUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFza1BhdHRlcm47XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICAgIH07XG4gICAgLypAT3ZlcnJpZGUqL1xuICAgIFFSQ29kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTsgLy8gKDIwMClcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnPDxcXG4nKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnIG1vZGU6ICcpO1xuICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMubW9kZSA/IHRoaXMubW9kZS50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIGVjTGV2ZWw6ICcpO1xuICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZWNMZXZlbCA/IHRoaXMuZWNMZXZlbC50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIHZlcnNpb246ICcpO1xuICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMudmVyc2lvbiA/IHRoaXMudmVyc2lvbi50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hc2tQYXR0ZXJuOiAnKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1hc2tQYXR0ZXJuLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6XFxuJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMubWF0cml4LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hdHJpeDogbnVsbFxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hcHBlbmQoJz4+XFxuJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1vZGUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuc2V0RUNMZXZlbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVjTGV2ZWwgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuc2V0VmVyc2lvbiA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnNldE1hc2tQYXR0ZXJuID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgdGhpcy5tYXNrUGF0dGVybiA9IHZhbHVlO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5zZXRNYXRyaXggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRyaXggPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8vIENoZWNrIGlmIFwibWFza19wYXR0ZXJuXCIgaXMgdmFsaWQuXG4gICAgUVJDb2RlLmlzVmFsaWRNYXNrUGF0dGVybiA9IGZ1bmN0aW9uIChtYXNrUGF0dGVybiAvKmludCovKSB7XG4gICAgICAgIHJldHVybiBtYXNrUGF0dGVybiA+PSAwICYmIG1hc2tQYXR0ZXJuIDwgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TO1xuICAgIH07XG4gICAgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TID0gODtcbiAgICByZXR1cm4gUVJDb2RlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFFSQ29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar System_1 = __webpack_require__(/*! ./System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar ArrayIndexOutOfBoundsException_1 = __webpack_require__(/*! ../ArrayIndexOutOfBoundsException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js\");\nvar Arrays = /** @class */ (function () {\n    function Arrays() {\n    }\n    /**\n     * Assigns the specified int value to each element of the specified array\n     * of ints.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     */\n    Arrays.fill = function (a, val) {\n        for (var i = 0, len = a.length; i < len; i++)\n            a[i] = val;\n    };\n    /**\n     * Assigns the specified int value to each element of the specified\n     * range of the specified array of ints.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     */\n    Arrays.fillWithin = function (a, fromIndex, toIndex, val) {\n        Arrays.rangeCheck(a.length, fromIndex, toIndex);\n        for (var i = fromIndex; i < toIndex; i++)\n            a[i] = val;\n    };\n    /**\n     * Checks that {@code fromIndex} and {@code toIndex} are in\n     * the range and throws an exception if they aren't.\n     */\n    Arrays.rangeCheck = function (arrayLength, fromIndex, toIndex) {\n        if (fromIndex > toIndex) {\n            throw new IllegalArgumentException_1.default('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');\n        }\n        if (fromIndex < 0) {\n            throw new ArrayIndexOutOfBoundsException_1.default(fromIndex);\n        }\n        if (toIndex > arrayLength) {\n            throw new ArrayIndexOutOfBoundsException_1.default(toIndex);\n        }\n    };\n    Arrays.asList = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return args;\n    };\n    Arrays.create = function (rows, cols, value) {\n        var arr = Array.from({ length: rows });\n        return arr.map(function (x) { return Array.from({ length: cols }).fill(value); });\n    };\n    Arrays.createInt32Array = function (rows, cols, value) {\n        var arr = Array.from({ length: rows });\n        return arr.map(function (x) { return Int32Array.from({ length: cols }).fill(value); });\n    };\n    Arrays.equals = function (first, second) {\n        if (!first) {\n            return false;\n        }\n        if (!second) {\n            return false;\n        }\n        if (!first.length) {\n            return false;\n        }\n        if (!second.length) {\n            return false;\n        }\n        if (first.length !== second.length) {\n            return false;\n        }\n        for (var i = 0, length_1 = first.length; i < length_1; i++) {\n            if (first[i] !== second[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Arrays.hashCode = function (a) {\n        var e_1, _a;\n        if (a === null) {\n            return 0;\n        }\n        var result = 1;\n        try {\n            for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n                var element = a_1_1.value;\n                result = 31 * result + element;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    Arrays.fillUint8Array = function (a, value) {\n        for (var i = 0; i !== a.length; i++) {\n            a[i] = value;\n        }\n    };\n    Arrays.copyOf = function (original, newLength) {\n        return original.slice(0, newLength);\n    };\n    Arrays.copyOfUint8Array = function (original, newLength) {\n        if (original.length <= newLength) {\n            var newArray = new Uint8Array(newLength);\n            newArray.set(original);\n            return newArray;\n        }\n        return original.slice(0, newLength);\n    };\n    Arrays.copyOfRange = function (original, from, to) {\n        var newLength = to - from;\n        var copy = new Int32Array(newLength);\n        System_1.default.arraycopy(original, from, copy, 0, newLength);\n        return copy;\n    };\n    /*\n    * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point\n    * for the new element.\n    * Parameters:\n    *     ar - A sorted array\n    *     el - An element to search for\n    *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:\n    *        a negative number  if a is less than b;\n    *        0 if a is equal to b;\n    *        a positive number of a is greater than b.\n    * The array may contain duplicate elements. If there are more than one equal elements in the array,\n    * the returned value can be the index of any one of the equal elements.\n    *\n    * http://jsfiddle.net/aryzhov/pkfst550/\n    */\n    Arrays.binarySearch = function (ar, el, comparator) {\n        if (undefined === comparator) {\n            comparator = Arrays.numberComparator;\n        }\n        var m = 0;\n        var n = ar.length - 1;\n        while (m <= n) {\n            var k = (n + m) >> 1;\n            var cmp = comparator(el, ar[k]);\n            if (cmp > 0) {\n                m = k + 1;\n            }\n            else if (cmp < 0) {\n                n = k - 1;\n            }\n            else {\n                return k;\n            }\n        }\n        return -m - 1;\n    };\n    Arrays.numberComparator = function (a, b) {\n        return a - b;\n    };\n    return Arrays;\n}());\nexports[\"default\"] = Arrays;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0FycmF5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsa0lBQVU7QUFDakMsaUNBQWlDLG1CQUFPLENBQUMsa0tBQTZCO0FBQ3RFLHVDQUF1QyxtQkFBTyxDQUFDLDhLQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0MsUUFBUSxjQUFjLG1CQUFtQix5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxrREFBa0QscUJBQXFCO0FBQ3ZFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLEtBQUssZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxzQ0FBc0Msb0JBQW9CLGNBQWMsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxzQ0FBc0MseUJBQXlCLGNBQWMsZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0FycmF5cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XG52YXIgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIpO1xudmFyIEFycmF5cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcnJheXMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXlcbiAgICAgKiBvZiBpbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgQXJyYXlzLmZpbGwgPSBmdW5jdGlvbiAoYSwgdmFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgYVtpXSA9IHZhbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgKiByYW5nZSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5IG9mIGludHMuICBUaGUgcmFuZ2UgdG8gYmUgZmlsbGVkXG4gICAgICogZXh0ZW5kcyBmcm9tIGluZGV4IHtAY29kZSBmcm9tSW5kZXh9LCBpbmNsdXNpdmUsIHRvIGluZGV4XG4gICAgICoge0Bjb2RlIHRvSW5kZXh9LCBleGNsdXNpdmUuICAoSWYge0Bjb2RlIGZyb21JbmRleD09dG9JbmRleH0sIHRoZVxuICAgICAqIHJhbmdlIHRvIGJlIGZpbGxlZCBpcyBlbXB0eS4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICogQHBhcmFtIGZyb21JbmRleCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgKGluY2x1c2l2ZSkgdG8gYmVcbiAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB0b0luZGV4IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IChleGNsdXNpdmUpIHRvIGJlXG4gICAgICogICAgICAgIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPiB0b0luZGV4fVxuICAgICAqIEB0aHJvd3MgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPCAwfSBvclxuICAgICAqICAgICAgICAge0Bjb2RlIHRvSW5kZXggPiBhLmxlbmd0aH1cbiAgICAgKi9cbiAgICBBcnJheXMuZmlsbFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBmcm9tSW5kZXgsIHRvSW5kZXgsIHZhbCkge1xuICAgICAgICBBcnJheXMucmFuZ2VDaGVjayhhLmxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKylcbiAgICAgICAgICAgIGFbaV0gPSB2YWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCB7QGNvZGUgZnJvbUluZGV4fSBhbmQge0Bjb2RlIHRvSW5kZXh9IGFyZSBpblxuICAgICAqIHRoZSByYW5nZSBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGV5IGFyZW4ndC5cbiAgICAgKi9cbiAgICBBcnJheXMucmFuZ2VDaGVjayA9IGZ1bmN0aW9uIChhcnJheUxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnZnJvbUluZGV4KCcgKyBmcm9tSW5kZXggKyAnKSA+IHRvSW5kZXgoJyArIHRvSW5kZXggKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEuZGVmYXVsdChmcm9tSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0luZGV4ID4gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMS5kZWZhdWx0KHRvSW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcnJheXMuYXNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgQXJyYXlzLmNyZWF0ZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXlzLmNyZWF0ZUludDMyQXJyYXkgPSBmdW5jdGlvbiAocm93cywgY29scywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGFyciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBJbnQzMkFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXlzLmVxdWFscyA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmlyc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGZpcnN0Lmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFtpXSAhPT0gc2Vjb25kW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQXJyYXlzLmhhc2hDb2RlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGFfMSA9IF9fdmFsdWVzKGEpLCBhXzFfMSA9IGFfMS5uZXh0KCk7ICFhXzFfMS5kb25lOyBhXzFfMSA9IGFfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGFfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDMxICogcmVzdWx0ICsgZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFfMV8xICYmICFhXzFfMS5kb25lICYmIChfYSA9IGFfMS5yZXR1cm4pKSBfYS5jYWxsKGFfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEFycmF5cy5maWxsVWludDhBcnJheSA9IGZ1bmN0aW9uIChhLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcnJheXMuY29weU9mID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnNsaWNlKDAsIG5ld0xlbmd0aCk7XG4gICAgfTtcbiAgICBBcnJheXMuY29weU9mVWludDhBcnJheSA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggPD0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgbmV3QXJyYXkuc2V0KG9yaWdpbmFsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWwuc2xpY2UoMCwgbmV3TGVuZ3RoKTtcbiAgICB9O1xuICAgIEFycmF5cy5jb3B5T2ZSYW5nZSA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIG5ld0xlbmd0aCA9IHRvIC0gZnJvbTtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgSW50MzJBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShvcmlnaW5hbCwgZnJvbSwgY29weSwgMCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcbiAgICAvKlxuICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygb2YgdGhlIGVsZW1lbnQgaW4gYSBzb3J0ZWQgYXJyYXkgb3IgKC1uLTEpIHdoZXJlIG4gaXMgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICogZm9yIHRoZSBuZXcgZWxlbWVudC5cbiAgICAqIFBhcmFtZXRlcnM6XG4gICAgKiAgICAgYXIgLSBBIHNvcnRlZCBhcnJheVxuICAgICogICAgIGVsIC0gQW4gZWxlbWVudCB0byBzZWFyY2ggZm9yXG4gICAgKiAgICAgY29tcGFyYXRvciAtIEEgY29tcGFyYXRvciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHRha2VzIHR3byBhcmd1bWVudHM6IChhLCBiKSBhbmQgcmV0dXJuczpcbiAgICAqICAgICAgICBhIG5lZ2F0aXZlIG51bWJlciAgaWYgYSBpcyBsZXNzIHRoYW4gYjtcbiAgICAqICAgICAgICAwIGlmIGEgaXMgZXF1YWwgdG8gYjtcbiAgICAqICAgICAgICBhIHBvc2l0aXZlIG51bWJlciBvZiBhIGlzIGdyZWF0ZXIgdGhhbiBiLlxuICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2F0ZSBlbGVtZW50cy4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgZXF1YWwgZWxlbWVudHMgaW4gdGhlIGFycmF5LFxuICAgICogdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSB0aGUgaW5kZXggb2YgYW55IG9uZSBvZiB0aGUgZXF1YWwgZWxlbWVudHMuXG4gICAgKlxuICAgICogaHR0cDovL2pzZmlkZGxlLm5ldC9hcnl6aG92L3BrZnN0NTUwL1xuICAgICovXG4gICAgQXJyYXlzLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIChhciwgZWwsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY29tcGFyYXRvcikge1xuICAgICAgICAgICAgY29tcGFyYXRvciA9IEFycmF5cy5udW1iZXJDb21wYXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gMDtcbiAgICAgICAgdmFyIG4gPSBhci5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobSA8PSBuKSB7XG4gICAgICAgICAgICB2YXIgayA9IChuICsgbSkgPj4gMTtcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGVsLCBhcltrXSk7XG4gICAgICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIG0gPSBrICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBuID0gayAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLW0gLSAxO1xuICAgIH07XG4gICAgQXJyYXlzLm51bWJlckNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlzO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFycmF5cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// package java.io;\n// import java.util.Arrays;\nvar Arrays_1 = __webpack_require__(/*! ./Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nvar OutputStream_1 = __webpack_require__(/*! ./OutputStream */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/OutputStream.js\");\nvar Integer_1 = __webpack_require__(/*! ./Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nvar IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nvar OutOfMemoryError_1 = __webpack_require__(/*! ../OutOfMemoryError */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js\");\nvar System_1 = __webpack_require__(/*! ./System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nvar IndexOutOfBoundsException_1 = __webpack_require__(/*! ../IndexOutOfBoundsException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js\");\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an <tt>IOException</tt>.\n *\n * @author  Arthur van Hoff\n * @since   JDK1.0\n */\nvar ByteArrayOutputStream = /** @class */ (function (_super) {\n    __extends(ByteArrayOutputStream, _super);\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 32 bytes, though its size increases if necessary.\n     */\n    // public constructor() {\n    //     this(32);\n    // }\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param   size   the initial size.\n     * @exception  IllegalArgumentException if size is negative.\n     */\n    function ByteArrayOutputStream(size) {\n        if (size === void 0) { size = 32; }\n        var _this = _super.call(this) || this;\n        /**\n         * The number of valid bytes in the buffer.\n         */\n        _this.count = 0;\n        if (size < 0) {\n            throw new IllegalArgumentException_1.default('Negative initial size: '\n                + size);\n        }\n        _this.buf = new Uint8Array(size);\n        return _this;\n    }\n    /**\n     * Increases the capacity if necessary to ensure that it can hold\n     * at least the number of elements specified by the minimum\n     * capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n     * interpreted as a request for the unsatisfiably large capacity\n     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n     */\n    ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {\n        // overflow-conscious code\n        if (minCapacity - this.buf.length > 0)\n            this.grow(minCapacity);\n    };\n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    ByteArrayOutputStream.prototype.grow = function (minCapacity) {\n        // overflow-conscious code\n        var oldCapacity = this.buf.length;\n        var newCapacity = oldCapacity << 1;\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity < 0) {\n            if (minCapacity < 0) // overflow\n                throw new OutOfMemoryError_1.default();\n            newCapacity = Integer_1.default.MAX_VALUE;\n        }\n        this.buf = Arrays_1.default.copyOfUint8Array(this.buf, newCapacity);\n    };\n    /**\n     * Writes the specified byte to this byte array output stream.\n     *\n     * @param   b   the byte to be written.\n     */\n    ByteArrayOutputStream.prototype.write = function (b) {\n        this.ensureCapacity(this.count + 1);\n        this.buf[this.count] = /*(byte)*/ b;\n        this.count += 1;\n    };\n    /**\n     * Writes <code>len</code> bytes from the specified byte array\n     * starting at offset <code>off</code> to this byte array output stream.\n     *\n     * @param   b     the data.\n     * @param   off   the start offset in the data.\n     * @param   len   the number of bytes to write.\n     */\n    ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {\n        if ((off < 0) || (off > b.length) || (len < 0) ||\n            ((off + len) - b.length > 0)) {\n            throw new IndexOutOfBoundsException_1.default();\n        }\n        this.ensureCapacity(this.count + len);\n        System_1.default.arraycopy(b, off, this.buf, this.count, len);\n        this.count += len;\n    };\n    /**\n     * Writes the complete contents of this byte array output stream to\n     * the specified output stream argument, as if by calling the output\n     * stream's write method using <code>out.write(buf, 0, count)</code>.\n     *\n     * @param      out   the output stream to which to write the data.\n     * @exception  IOException  if an I/O error occurs.\n     */\n    ByteArrayOutputStream.prototype.writeTo = function (out) {\n        out.writeBytesOffset(this.buf, 0, this.count);\n    };\n    /**\n     * Resets the <code>count</code> field of this byte array output\n     * stream to zero, so that all currently accumulated output in the\n     * output stream is discarded. The output stream can be used again,\n     * reusing the already allocated buffer space.\n     *\n     * @see     java.io.ByteArrayInputStream#count\n     */\n    ByteArrayOutputStream.prototype.reset = function () {\n        this.count = 0;\n    };\n    /**\n     * Creates a newly allocated byte array. Its size is the current\n     * size of this output stream and the valid contents of the buffer\n     * have been copied into it.\n     *\n     * @return  the current contents of this output stream, as a byte array.\n     * @see     java.io.ByteArrayOutputStream#size()\n     */\n    ByteArrayOutputStream.prototype.toByteArray = function () {\n        return Arrays_1.default.copyOfUint8Array(this.buf, this.count);\n    };\n    /**\n     * Returns the current size of the buffer.\n     *\n     * @return  the value of the <code>count</code> field, which is the number\n     *          of valid bytes in this output stream.\n     * @see     java.io.ByteArrayOutputStream#count\n     */\n    ByteArrayOutputStream.prototype.size = function () {\n        return this.count;\n    };\n    ByteArrayOutputStream.prototype.toString = function (param) {\n        if (!param) {\n            return this.toString_void();\n        }\n        if (typeof param === 'string') {\n            return this.toString_string(param);\n        }\n        return this.toString_number(param);\n    };\n    /**\n     * Converts the buffer's contents into a string decoding bytes using the\n     * platform's default character set. The length of the new <tt>String</tt>\n     * is a function of the character set, and hence may not be equal to the\n     * size of the buffer.\n     *\n     * <p> This method always replaces malformed-input and unmappable-character\n     * sequences with the default replacement string for the platform's\n     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n     * class should be used when more control over the decoding process is\n     * required.\n     *\n     * @return String decoded from the buffer's contents.\n     * @since  JDK1.1\n     */\n    ByteArrayOutputStream.prototype.toString_void = function () {\n        return new String(this.buf /*, 0, this.count*/).toString();\n    };\n    /**\n     * Converts the buffer's contents into a string by decoding the bytes using\n     * the specified {@link java.nio.charset.Charset charsetName}. The length of\n     * the new <tt>String</tt> is a function of the charset, and hence may not be\n     * equal to the length of the byte array.\n     *\n     * <p> This method always replaces malformed-input and unmappable-character\n     * sequences with this charset's default replacement string. The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  charsetName  the name of a supported\n     *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n     * @return String decoded from the buffer's contents.\n     * @exception  UnsupportedEncodingException\n     *             If the named charset is not supported\n     * @since   JDK1.1\n     */\n    ByteArrayOutputStream.prototype.toString_string = function (charsetName) {\n        return new String(this.buf /*, 0, this.count, charsetName*/).toString();\n    };\n    /**\n     * Creates a newly allocated string. Its size is the current size of\n     * the output stream and the valid contents of the buffer have been\n     * copied into it. Each character <i>c</i> in the resulting string is\n     * constructed from the corresponding element <i>b</i> in the byte\n     * array such that:\n     * <blockquote><pre>\n     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n     * </pre></blockquote>\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK&nbsp;1.1, the preferred way to do this is via the\n     * <code>toString(String enc)</code> method, which takes an encoding-name\n     * argument, or the <code>toString()</code> method, which uses the\n     * platform's default character encoding.\n     *\n     * @param      hibyte    the high byte of each resulting Unicode character.\n     * @return     the current contents of the output stream, as a string.\n     * @see        java.io.ByteArrayOutputStream#size()\n     * @see        java.io.ByteArrayOutputStream#toString(String)\n     * @see        java.io.ByteArrayOutputStream#toString()\n     */\n    // @Deprecated\n    ByteArrayOutputStream.prototype.toString_number = function (hibyte) {\n        return new String(this.buf /*, hibyte, 0, this.count*/).toString();\n    };\n    /**\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an <tt>IOException</tt>.\n     * <p>\n     *\n     * @throws IOException\n     */\n    ByteArrayOutputStream.prototype.close = function () {\n    };\n    return ByteArrayOutputStream;\n}(OutputStream_1.default));\nexports[\"default\"] = ByteArrayOutputStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0J5dGVBcnJheU91dHB1dFN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0lBQVU7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsOElBQWdCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLG9JQUFXO0FBQ25DLGlDQUFpQyxtQkFBTyxDQUFDLGtLQUE2QjtBQUN0RSx5QkFBeUIsbUJBQU8sQ0FBQyxrSkFBcUI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLGtJQUFVO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLG9LQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0EsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxLQUFLLGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvQnl0ZUFycmF5T3V0cHV0U3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAoYykgMTk5NCwgMjAxMCwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cbiAqXG4gKiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcbiAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpc1xuICogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlIFwiQ2xhc3NwYXRoXCIgZXhjZXB0aW9uIGFzIHByb3ZpZGVkXG4gKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cbiAqXG4gKiBUaGlzIGNvZGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiB2ZXJzaW9uIDIgZm9yIG1vcmUgZGV0YWlscyAoYSBjb3B5IGlzIGluY2x1ZGVkIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdFxuICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uXG4gKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXG4gKiBJbmMuLCA1MSBGcmFua2xpbiBTdCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0EuXG4gKlxuICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcbiAqIG9yIHZpc2l0IHd3dy5vcmFjbGUuY29tIGlmIHlvdSBuZWVkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgaGF2ZSBhbnlcbiAqIHF1ZXN0aW9ucy5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBwYWNrYWdlIGphdmEuaW87XG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuL0FycmF5c1wiKTtcbnZhciBPdXRwdXRTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL091dHB1dFN0cmVhbVwiKTtcbnZhciBJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9JbnRlZ2VyXCIpO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbnZhciBPdXRPZk1lbW9yeUVycm9yXzEgPSByZXF1aXJlKFwiLi4vT3V0T2ZNZW1vcnlFcnJvclwiKTtcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbnZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGFuIG91dHB1dCBzdHJlYW0gaW4gd2hpY2ggdGhlIGRhdGEgaXNcbiAqIHdyaXR0ZW4gaW50byBhIGJ5dGUgYXJyYXkuIFRoZSBidWZmZXIgYXV0b21hdGljYWxseSBncm93cyBhcyBkYXRhXG4gKiBpcyB3cml0dGVuIHRvIGl0LlxuICogVGhlIGRhdGEgY2FuIGJlIHJldHJpZXZlZCB1c2luZyA8Y29kZT50b0J5dGVBcnJheSgpPC9jb2RlPiBhbmRcbiAqIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+LlxuICogPHA+XG4gKiBDbG9zaW5nIGEgPHR0PkJ5dGVBcnJheU91dHB1dFN0cmVhbTwvdHQ+IGhhcyBubyBlZmZlY3QuIFRoZSBtZXRob2RzIGluXG4gKiB0aGlzIGNsYXNzIGNhbiBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHN0cmVhbSBoYXMgYmVlbiBjbG9zZWQgd2l0aG91dFxuICogZ2VuZXJhdGluZyBhbiA8dHQ+SU9FeGNlcHRpb248L3R0Pi5cbiAqXG4gKiBAYXV0aG9yICBBcnRodXIgdmFuIEhvZmZcbiAqIEBzaW5jZSAgIEpESzEuMFxuICovXG52YXIgQnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCeXRlQXJyYXlPdXRwdXRTdHJlYW0sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uIFRoZSBidWZmZXIgY2FwYWNpdHkgaXNcbiAgICAgKiBpbml0aWFsbHkgMzIgYnl0ZXMsIHRob3VnaCBpdHMgc2l6ZSBpbmNyZWFzZXMgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyAgICAgdGhpcygzMik7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLCB3aXRoIGEgYnVmZmVyIGNhcGFjaXR5IG9mXG4gICAgICogdGhlIHNwZWNpZmllZCBzaXplLCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHNpemUgICB0aGUgaW5pdGlhbCBzaXplLlxuICAgICAqIEBleGNlcHRpb24gIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBzaXplIGlzIG5lZ2F0aXZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJ5dGVBcnJheU91dHB1dFN0cmVhbShzaXplKSB7XG4gICAgICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IDMyOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGluIHRoZSBidWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05lZ2F0aXZlIGluaXRpYWwgc2l6ZTogJ1xuICAgICAgICAgICAgICAgICsgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYnVmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2VzIHRoZSBjYXBhY2l0eSBpZiBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgaXQgY2FuIGhvbGRcbiAgICAgKiBhdCBsZWFzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgbWluaW11bVxuICAgICAqIGNhcGFjaXR5IGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbkNhcGFjaXR5IHRoZSBkZXNpcmVkIG1pbmltdW0gY2FwYWNpdHlcbiAgICAgKiBAdGhyb3dzIE91dE9mTWVtb3J5RXJyb3IgaWYge0Bjb2RlIG1pbkNhcGFjaXR5IDwgMH0uICBUaGlzIGlzXG4gICAgICogaW50ZXJwcmV0ZWQgYXMgYSByZXF1ZXN0IGZvciB0aGUgdW5zYXRpc2ZpYWJseSBsYXJnZSBjYXBhY2l0eVxuICAgICAqIHtAY29kZSAobG9uZykgSW50ZWdlci5NQVhfVkFMVUUgKyAobWluQ2FwYWNpdHkgLSBJbnRlZ2VyLk1BWF9WQUxVRSl9LlxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHkgPSBmdW5jdGlvbiAobWluQ2FwYWNpdHkpIHtcbiAgICAgICAgLy8gb3ZlcmZsb3ctY29uc2Npb3VzIGNvZGVcbiAgICAgICAgaWYgKG1pbkNhcGFjaXR5IC0gdGhpcy5idWYubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRoaXMuZ3JvdyhtaW5DYXBhY2l0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZXMgdGhlIGNhcGFjaXR5IHRvIGVuc3VyZSB0aGF0IGl0IGNhbiBob2xkIGF0IGxlYXN0IHRoZVxuICAgICAqIG51bWJlciBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIG1pbmltdW0gY2FwYWNpdHkgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluQ2FwYWNpdHkgdGhlIGRlc2lyZWQgbWluaW11bSBjYXBhY2l0eVxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuZ3JvdyA9IGZ1bmN0aW9uIChtaW5DYXBhY2l0eSkge1xuICAgICAgICAvLyBvdmVyZmxvdy1jb25zY2lvdXMgY29kZVxuICAgICAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gICAgICAgIHZhciBuZXdDYXBhY2l0eSA9IG9sZENhcGFjaXR5IDw8IDE7XG4gICAgICAgIGlmIChuZXdDYXBhY2l0eSAtIG1pbkNhcGFjaXR5IDwgMClcbiAgICAgICAgICAgIG5ld0NhcGFjaXR5ID0gbWluQ2FwYWNpdHk7XG4gICAgICAgIGlmIChuZXdDYXBhY2l0eSA8IDApIHtcbiAgICAgICAgICAgIGlmIChtaW5DYXBhY2l0eSA8IDApIC8vIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mTWVtb3J5RXJyb3JfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICBuZXdDYXBhY2l0eSA9IEludGVnZXJfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZiA9IEFycmF5c18xLmRlZmF1bHQuY29weU9mVWludDhBcnJheSh0aGlzLmJ1ZiwgbmV3Q2FwYWNpdHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBzcGVjaWZpZWQgYnl0ZSB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIGIgICB0aGUgYnl0ZSB0byBiZSB3cml0dGVuLlxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuY291bnQgKyAxKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5jb3VudF0gPSAvKihieXRlKSovIGI7XG4gICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICogc3RhcnRpbmcgYXQgb2Zmc2V0IDxjb2RlPm9mZjwvY29kZT4gdG8gdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBiICAgICB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSAgIGxlbiAgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICovXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGVzT2Zmc2V0ID0gZnVuY3Rpb24gKGIsIG9mZiwgbGVuKSB7XG4gICAgICAgIGlmICgob2ZmIDwgMCkgfHwgKG9mZiA+IGIubGVuZ3RoKSB8fCAobGVuIDwgMCkgfHxcbiAgICAgICAgICAgICgob2ZmICsgbGVuKSAtIGIubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5jb3VudCArIGxlbik7XG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KGIsIG9mZiwgdGhpcy5idWYsIHRoaXMuY291bnQsIGxlbik7XG4gICAgICAgIHRoaXMuY291bnQgKz0gbGVuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBjb21wbGV0ZSBjb250ZW50cyBvZiB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbSB0b1xuICAgICAqIHRoZSBzcGVjaWZpZWQgb3V0cHV0IHN0cmVhbSBhcmd1bWVudCwgYXMgaWYgYnkgY2FsbGluZyB0aGUgb3V0cHV0XG4gICAgICogc3RyZWFtJ3Mgd3JpdGUgbWV0aG9kIHVzaW5nIDxjb2RlPm91dC53cml0ZShidWYsIDAsIGNvdW50KTwvY29kZT4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgICBvdXQgICB0aGUgb3V0cHV0IHN0cmVhbSB0byB3aGljaCB0byB3cml0ZSB0aGUgZGF0YS5cbiAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgKi9cbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLndyaXRlVG8gPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIG91dC53cml0ZUJ5dGVzT2Zmc2V0KHRoaXMuYnVmLCAwLCB0aGlzLmNvdW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkIG9mIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXRcbiAgICAgKiBzdHJlYW0gdG8gemVybywgc28gdGhhdCBhbGwgY3VycmVudGx5IGFjY3VtdWxhdGVkIG91dHB1dCBpbiB0aGVcbiAgICAgKiBvdXRwdXQgc3RyZWFtIGlzIGRpc2NhcmRlZC4gVGhlIG91dHB1dCBzdHJlYW0gY2FuIGJlIHVzZWQgYWdhaW4sXG4gICAgICogcmV1c2luZyB0aGUgYWxyZWFkeSBhbGxvY2F0ZWQgYnVmZmVyIHNwYWNlLlxuICAgICAqXG4gICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlJbnB1dFN0cmVhbSNjb3VudFxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ld2x5IGFsbG9jYXRlZCBieXRlIGFycmF5LiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudFxuICAgICAqIHNpemUgb2YgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgdmFsaWQgY29udGVudHMgb2YgdGhlIGJ1ZmZlclxuICAgICAqIGhhdmUgYmVlbiBjb3BpZWQgaW50byBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoaXMgb3V0cHV0IHN0cmVhbSwgYXMgYSBieXRlIGFycmF5LlxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3NpemUoKVxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBBcnJheXNfMS5kZWZhdWx0LmNvcHlPZlVpbnQ4QXJyYXkodGhpcy5idWYsIHRoaXMuY291bnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB0aGUgdmFsdWUgb2YgdGhlIDxjb2RlPmNvdW50PC9jb2RlPiBmaWVsZCwgd2hpY2ggaXMgdGhlIG51bWJlclxuICAgICAqICAgICAgICAgIG9mIHZhbGlkIGJ5dGVzIGluIHRoaXMgb3V0cHV0IHN0cmVhbS5cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNjb3VudFxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgfTtcbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX3ZvaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfc3RyaW5nKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ19udW1iZXIocGFyYW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgZGVjb2RpbmcgYnl0ZXMgdXNpbmcgdGhlXG4gICAgICogcGxhdGZvcm0ncyBkZWZhdWx0IGNoYXJhY3RlciBzZXQuIFRoZSBsZW5ndGggb2YgdGhlIG5ldyA8dHQ+U3RyaW5nPC90dD5cbiAgICAgKiBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgc2V0LCBhbmQgaGVuY2UgbWF5IG5vdCBiZSBlcXVhbCB0byB0aGVcbiAgICAgKiBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICpcbiAgICAgKiA8cD4gVGhpcyBtZXRob2QgYWx3YXlzIHJlcGxhY2VzIG1hbGZvcm1lZC1pbnB1dCBhbmQgdW5tYXBwYWJsZS1jaGFyYWN0ZXJcbiAgICAgKiBzZXF1ZW5jZXMgd2l0aCB0aGUgZGVmYXVsdCByZXBsYWNlbWVudCBzdHJpbmcgZm9yIHRoZSBwbGF0Zm9ybSdzXG4gICAgICogZGVmYXVsdCBjaGFyYWN0ZXIgc2V0LiBUaGUge0BsaW5rcGxhaW4gamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0RGVjb2Rlcn1cbiAgICAgKiBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbCBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzXG4gICAgICogcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFN0cmluZyBkZWNvZGVkIGZyb20gdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICAgICAqIEBzaW5jZSAgSkRLMS4xXG4gICAgICovXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZ192b2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgYnkgZGVjb2RpbmcgdGhlIGJ5dGVzIHVzaW5nXG4gICAgICogdGhlIHNwZWNpZmllZCB7QGxpbmsgamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0IGNoYXJzZXROYW1lfS4gVGhlIGxlbmd0aCBvZlxuICAgICAqIHRoZSBuZXcgPHR0PlN0cmluZzwvdHQ+IGlzIGEgZnVuY3Rpb24gb2YgdGhlIGNoYXJzZXQsIGFuZCBoZW5jZSBtYXkgbm90IGJlXG4gICAgICogZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIDxwPiBUaGlzIG1ldGhvZCBhbHdheXMgcmVwbGFjZXMgbWFsZm9ybWVkLWlucHV0IGFuZCB1bm1hcHBhYmxlLWNoYXJhY3RlclxuICAgICAqIHNlcXVlbmNlcyB3aXRoIHRoaXMgY2hhcnNldCdzIGRlZmF1bHQgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGUge0BsaW5rXG4gICAgICogamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0RGVjb2Rlcn0gY2xhc3Mgc2hvdWxkIGJlIHVzZWQgd2hlbiBtb3JlIGNvbnRyb2xcbiAgICAgKiBvdmVyIHRoZSBkZWNvZGluZyBwcm9jZXNzIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICBjaGFyc2V0TmFtZSAgdGhlIG5hbWUgb2YgYSBzdXBwb3J0ZWRcbiAgICAgKiAgICAgICAgICAgICAge0BsaW5rcGxhaW4gamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0IDwvY29kZT5jaGFyc2V0PGNvZGU+fVxuICAgICAqIEByZXR1cm4gU3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gICAgICogQGV4Y2VwdGlvbiAgVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvblxuICAgICAqICAgICAgICAgICAgIElmIHRoZSBuYW1lZCBjaGFyc2V0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBAc2luY2UgICBKREsxLjFcbiAgICAgKi9cbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLnRvU3RyaW5nX3N0cmluZyA9IGZ1bmN0aW9uIChjaGFyc2V0TmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCwgY2hhcnNldE5hbWUqLykudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nLiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudCBzaXplIG9mXG4gICAgICogdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSB2YWxpZCBjb250ZW50cyBvZiB0aGUgYnVmZmVyIGhhdmUgYmVlblxuICAgICAqIGNvcGllZCBpbnRvIGl0LiBFYWNoIGNoYXJhY3RlciA8aT5jPC9pPiBpbiB0aGUgcmVzdWx0aW5nIHN0cmluZyBpc1xuICAgICAqIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCA8aT5iPC9pPiBpbiB0aGUgYnl0ZVxuICAgICAqIGFycmF5IHN1Y2ggdGhhdDpcbiAgICAgKiA8YmxvY2txdW90ZT48cHJlPlxuICAgICAqICAgICBjID09IChjaGFyKSgoKGhpYnl0ZSAmYW1wOyAweGZmKSAmbHQ7Jmx0OyA4KSB8IChiICZhbXA7IDB4ZmYpKVxuICAgICAqIDwvcHJlPjwvYmxvY2txdW90ZT5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGRvZXMgbm90IHByb3Blcmx5IGNvbnZlcnQgYnl0ZXMgaW50byBjaGFyYWN0ZXJzLlxuICAgICAqIEFzIG9mIEpESyZuYnNwOzEuMSwgdGhlIHByZWZlcnJlZCB3YXkgdG8gZG8gdGhpcyBpcyB2aWEgdGhlXG4gICAgICogPGNvZGU+dG9TdHJpbmcoU3RyaW5nIGVuYyk8L2NvZGU+IG1ldGhvZCwgd2hpY2ggdGFrZXMgYW4gZW5jb2RpbmctbmFtZVxuICAgICAqIGFyZ3VtZW50LCBvciB0aGUgPGNvZGU+dG9TdHJpbmcoKTwvY29kZT4gbWV0aG9kLCB3aGljaCB1c2VzIHRoZVxuICAgICAqIHBsYXRmb3JtJ3MgZGVmYXVsdCBjaGFyYWN0ZXIgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgICBoaWJ5dGUgICAgdGhlIGhpZ2ggYnl0ZSBvZiBlYWNoIHJlc3VsdGluZyBVbmljb2RlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuICAgICB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgb3V0cHV0IHN0cmVhbSwgYXMgYSBzdHJpbmcuXG4gICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jc2l6ZSgpXG4gICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoU3RyaW5nKVxuICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3RvU3RyaW5nKClcbiAgICAgKi9cbiAgICAvLyBARGVwcmVjYXRlZFxuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmdfbnVtYmVyID0gZnVuY3Rpb24gKGhpYnl0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgaGlieXRlLCAwLCB0aGlzLmNvdW50Ki8pLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zaW5nIGEgPHR0PkJ5dGVBcnJheU91dHB1dFN0cmVhbTwvdHQ+IGhhcyBubyBlZmZlY3QuIFRoZSBtZXRob2RzIGluXG4gICAgICogdGhpcyBjbGFzcyBjYW4gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkIHdpdGhvdXRcbiAgICAgKiBnZW5lcmF0aW5nIGFuIDx0dD5JT0V4Y2VwdGlvbjwvdHQ+LlxuICAgICAqIDxwPlxuICAgICAqXG4gICAgICogQHRocm93cyBJT0V4Y2VwdGlvblxuICAgICAqL1xuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gQnl0ZUFycmF5T3V0cHV0U3RyZWFtO1xufShPdXRwdXRTdHJlYW1fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCeXRlQXJyYXlPdXRwdXRTdHJlYW07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar CharacterSetECI_1 = __webpack_require__(/*! ../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\n/**\n * Just to make a shortcut between Java code and TS code.\n */\nvar Charset = /** @class */ (function (_super) {\n    __extends(Charset, _super);\n    function Charset() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Charset.forName = function (name) {\n        return this.getCharacterSetECIByName(name);\n    };\n    return Charset;\n}(CharacterSetECI_1.default));\nexports[\"default\"] = Charset;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0NoYXJzZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyw4SkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvQ2hhcnNldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0lcIik7XG4vKipcbiAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICovXG52YXIgQ2hhcnNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhcnNldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFyc2V0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENoYXJzZXQuZm9yTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFyc2V0O1xufShDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFyc2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Collections.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Collections.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Collections = /** @class */ (function () {\n    function Collections() {\n    }\n    /**\n     * The singletonList(T) method is used to return an immutable list containing only the specified object.\n     */\n    Collections.singletonList = function (item) {\n        return [item];\n    };\n    /**\n     * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.\n     */\n    Collections.min = function (collection, comparator) {\n        return collection.sort(comparator)[0];\n    };\n    return Collections;\n}());\nexports[\"default\"] = Collections;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0NvbGxlY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvQ29sbGVjdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29sbGVjdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaW5nbGV0b25MaXN0KFQpIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiBhbiBpbW11dGFibGUgbGlzdCBjb250YWluaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAgICovXG4gICAgQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBbaXRlbV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluKENvbGxlY3Rpb248PyBleHRlbmRzIFQ+LCBDb21wYXJhdG9yPD8gc3VwZXIgVD4pIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IG9mIHRoZSBnaXZlbiBjb2xsZWN0aW9uLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBjb21wYXJhdG9yLlxuICAgICAqL1xuICAgIENvbGxlY3Rpb25zLm1pbiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNvcnQoY29tcGFyYXRvcilbMF07XG4gICAgfTtcbiAgICByZXR1cm4gQ29sbGVjdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGVjdGlvbnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Collections.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Float.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Float.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Ponyfill for Java's Float class.\n */\nvar Float = /** @class */ (function () {\n    function Float() {\n    }\n    /**\n     * SincTS has no difference between int and float, there's all numbers,\n     * this is used only to polyfill Java code.\n     */\n    Float.floatToIntBits = function (f) {\n        return f;\n    };\n    /**\n     * The float max value in JS is the number max value.\n     */\n    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n    return Float;\n}());\nexports[\"default\"] = Float;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0Zsb2F0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0Zsb2F0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQb255ZmlsbCBmb3IgSmF2YSdzIEZsb2F0IGNsYXNzLlxuICovXG52YXIgRmxvYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxvYXQoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbmNUUyBoYXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGludCBhbmQgZmxvYXQsIHRoZXJlJ3MgYWxsIG51bWJlcnMsXG4gICAgICogdGhpcyBpcyB1c2VkIG9ubHkgdG8gcG9seWZpbGwgSmF2YSBjb2RlLlxuICAgICAqL1xuICAgIEZsb2F0LmZsb2F0VG9JbnRCaXRzID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXQgbWF4IHZhbHVlIGluIEpTIGlzIHRoZSBudW1iZXIgbWF4IHZhbHVlLlxuICAgICAqL1xuICAgIEZsb2F0Lk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIHJldHVybiBGbG9hdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGbG9hdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Float.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Java Formatter class polyfill that works in the JS way.\n */\nvar Formatter = /** @class */ (function () {\n    function Formatter() {\n        this.buffer = '';\n    }\n    /**\n     *\n     * @see https://stackoverflow.com/a/13439711/4367683\n     *\n     * @param str\n     * @param arr\n     */\n    Formatter.form = function (str, arr) {\n        var i = -1;\n        function callback(exp, p0, p1, p2, p3, p4) {\n            if (exp === '%%')\n                return '%';\n            if (arr[++i] === undefined)\n                return undefined;\n            exp = p2 ? parseInt(p2.substr(1)) : undefined;\n            var base = p3 ? parseInt(p3.substr(1)) : undefined;\n            var val;\n            switch (p4) {\n                case 's':\n                    val = arr[i];\n                    break;\n                case 'c':\n                    val = arr[i][0];\n                    break;\n                case 'f':\n                    val = parseFloat(arr[i]).toFixed(exp);\n                    break;\n                case 'p':\n                    val = parseFloat(arr[i]).toPrecision(exp);\n                    break;\n                case 'e':\n                    val = parseFloat(arr[i]).toExponential(exp);\n                    break;\n                case 'x':\n                    val = parseInt(arr[i]).toString(base ? base : 16);\n                    break;\n                case 'd':\n                    val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                    break;\n            }\n            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n            var size = parseInt(p1); /* padding size */\n            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n            while (val.length < size)\n                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n            return val;\n        }\n        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n        return str.replace(regex, callback);\n    };\n    /**\n     *\n     * @param append The new string to append.\n     * @param args Argumets values to be formated.\n     */\n    Formatter.prototype.format = function (append) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this.buffer += Formatter.form(append, args);\n    };\n    /**\n     * Returns the Formatter string value.\n     */\n    Formatter.prototype.toString = function () {\n        return this.buffer;\n    };\n    return Formatter;\n}());\nexports[\"default\"] = Formatter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0Zvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsNkRBQTZEO0FBQzdEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0Zvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSmF2YSBGb3JtYXR0ZXIgY2xhc3MgcG9seWZpbGwgdGhhdCB3b3JrcyBpbiB0aGUgSlMgd2F5LlxuICovXG52YXIgRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvcm1hdHRlcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQzOTcxMS80MzY3NjgzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyXG4gICAgICogQHBhcmFtIGFyclxuICAgICAqL1xuICAgIEZvcm1hdHRlci5mb3JtID0gZnVuY3Rpb24gKHN0ciwgYXJyKSB7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGV4cCwgcDAsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxuICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgICAgICBpZiAoYXJyWysraV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZXhwID0gcDIgPyBwYXJzZUludChwMi5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgc3dpdGNoIChwNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9GaXhlZChleHApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9FeHBvbmVudGlhbChleHApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJyW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJyW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQocDEpOyAvKiBwYWRkaW5nIHNpemUgKi9cbiAgICAgICAgICAgIHZhciBjaCA9IHAxICYmIChwMVswXSArICcnKSA9PT0gJzAnID8gJzAnIDogJyAnOyAvKiBpc251bGw/ICovXG4gICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXG4gICAgICAgICAgICAgICAgdmFsID0gcDAgIT09IHVuZGVmaW5lZCA/IHZhbCArIGNoIDogY2ggKyB2YWw7IC8qIGlzbWludXM/ICovXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleCA9IC8lKC0pPygwP1swLTldKyk/KFsuXVswLTldKyk/KFsjXVswLTldKyk/KFtzY2ZwZXhkJV0pL2c7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC5cbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuXG4gICAgICovXG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoYXBwZW5kKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IEZvcm1hdHRlci5mb3JtKGFwcGVuZCwgYXJncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGb3JtYXR0ZXIgc3RyaW5nIHZhbHVlLlxuICAgICAqL1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9O1xuICAgIHJldHVybiBGb3JtYXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0dGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Formatter.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Ponyfill for Java's Integer class.\n */\nvar Integer = /** @class */ (function () {\n    function Integer() {\n    }\n    Integer.numberOfTrailingZeros = function (i) {\n        var y;\n        if (i === 0)\n            return 32;\n        var n = 31;\n        y = i << 16;\n        if (y !== 0) {\n            n -= 16;\n            i = y;\n        }\n        y = i << 8;\n        if (y !== 0) {\n            n -= 8;\n            i = y;\n        }\n        y = i << 4;\n        if (y !== 0) {\n            n -= 4;\n            i = y;\n        }\n        y = i << 2;\n        if (y !== 0) {\n            n -= 2;\n            i = y;\n        }\n        return n - ((i << 1) >>> 31);\n    };\n    Integer.numberOfLeadingZeros = function (i) {\n        // HD, Figure 5-6\n        if (i === 0) {\n            return 32;\n        }\n        var n = 1;\n        if (i >>> 16 === 0) {\n            n += 16;\n            i <<= 16;\n        }\n        if (i >>> 24 === 0) {\n            n += 8;\n            i <<= 8;\n        }\n        if (i >>> 28 === 0) {\n            n += 4;\n            i <<= 4;\n        }\n        if (i >>> 30 === 0) {\n            n += 2;\n            i <<= 2;\n        }\n        n -= i >>> 31;\n        return n;\n    };\n    Integer.toHexString = function (i) {\n        return i.toString(16);\n    };\n    Integer.toBinaryString = function (intNumber) {\n        return String(parseInt(String(intNumber), 2));\n    };\n    // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.\n    // Returns:\n    // the number of one-bits in the two's complement binary representation of the specified int value.\n    Integer.bitCount = function (i) {\n        // HD, Figure 5-2\n        i = i - ((i >>> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n        i = (i + (i >>> 4)) & 0x0f0f0f0f;\n        i = i + (i >>> 8);\n        i = i + (i >>> 16);\n        return i & 0x3f;\n    };\n    Integer.truncDivision = function (dividend, divisor) {\n        return Math.trunc(dividend / divisor);\n    };\n    /**\n     * Converts A string to an integer.\n     * @param s A string to convert into a number.\n     * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.\n     */\n    Integer.parseInt = function (num, radix) {\n        if (radix === void 0) { radix = undefined; }\n        return parseInt(num, radix);\n    };\n    Integer.MIN_VALUE_32_BITS = -2147483648;\n    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n    return Integer;\n}());\nexports[\"default\"] = Integer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0ludGVnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0ludGVnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgSW50ZWdlciBjbGFzcy5cbiAqL1xudmFyIEludGVnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZWdlcigpIHtcbiAgICB9XG4gICAgSW50ZWdlci5udW1iZXJPZlRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIHZhciBuID0gMzE7XG4gICAgICAgIHkgPSBpIDw8IDE2O1xuICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgbiAtPSAxNjtcbiAgICAgICAgICAgIGkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHkgPSBpIDw8IDg7XG4gICAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgICAgICBuIC09IDg7XG4gICAgICAgICAgICBpID0geTtcbiAgICAgICAgfVxuICAgICAgICB5ID0gaSA8PCA0O1xuICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgbiAtPSA0O1xuICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgeSA9IGkgPDwgMjtcbiAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgIGkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XG4gICAgfTtcbiAgICBJbnRlZ2VyLm51bWJlck9mTGVhZGluZ1plcm9zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTZcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IDE7XG4gICAgICAgIGlmIChpID4+PiAxNiA9PT0gMCkge1xuICAgICAgICAgICAgbiArPSAxNjtcbiAgICAgICAgICAgIGkgPDw9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4+PiAyNCA9PT0gMCkge1xuICAgICAgICAgICAgbiArPSA4O1xuICAgICAgICAgICAgaSA8PD0gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+Pj4gMjggPT09IDApIHtcbiAgICAgICAgICAgIG4gKz0gNDtcbiAgICAgICAgICAgIGkgPDw9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj4+IDMwID09PSAwKSB7XG4gICAgICAgICAgICBuICs9IDI7XG4gICAgICAgICAgICBpIDw8PSAyO1xuICAgICAgICB9XG4gICAgICAgIG4gLT0gaSA+Pj4gMzE7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgSW50ZWdlci50b0hleFN0cmluZyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpLnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuICAgIEludGVnZXIudG9CaW5hcnlTdHJpbmcgPSBmdW5jdGlvbiAoaW50TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocGFyc2VJbnQoU3RyaW5nKGludE51bWJlciksIDIpKTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBvbmUtYml0cyBpbiB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUuIFRoaXMgZnVuY3Rpb24gaXMgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIHRoZSBwb3B1bGF0aW9uIGNvdW50LlxuICAgIC8vIFJldHVybnM6XG4gICAgLy8gdGhlIG51bWJlciBvZiBvbmUtYml0cyBpbiB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUuXG4gICAgSW50ZWdlci5iaXRDb3VudCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIC8vIEhELCBGaWd1cmUgNS0yXG4gICAgICAgIGkgPSBpIC0gKChpID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgICAgICBpID0gKGkgJiAweDMzMzMzMzMzKSArICgoaSA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgICAgICAgaSA9IChpICsgKGkgPj4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGkgPSBpICsgKGkgPj4+IDgpO1xuICAgICAgICBpID0gaSArIChpID4+PiAxNik7XG4gICAgICAgIHJldHVybiBpICYgMHgzZjtcbiAgICB9O1xuICAgIEludGVnZXIudHJ1bmNEaXZpc2lvbiA9IGZ1bmN0aW9uIChkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhkaXZpZGVuZCAvIGRpdmlzb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgQSBzdHJpbmcgdG8gYW4gaW50ZWdlci5cbiAgICAgKiBAcGFyYW0gcyBBIHN0cmluZyB0byBjb252ZXJ0IGludG8gYSBudW1iZXIuXG4gICAgICogQHBhcmFtIHJhZGl4IEEgdmFsdWUgYmV0d2VlbiAyIGFuZCAzNiB0aGF0IHNwZWNpZmllcyB0aGUgYmFzZSBvZiB0aGUgbnVtYmVyIGluIG51bVN0cmluZy4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3VwcGxpZWQsIHN0cmluZ3Mgd2l0aCBhIHByZWZpeCBvZiAnMHgnIGFyZSBjb25zaWRlcmVkIGhleGFkZWNpbWFsLiBBbGwgb3RoZXIgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCBkZWNpbWFsLlxuICAgICAqL1xuICAgIEludGVnZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAobnVtLCByYWRpeCkge1xuICAgICAgICBpZiAocmFkaXggPT09IHZvaWQgMCkgeyByYWRpeCA9IHVuZGVmaW5lZDsgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCByYWRpeCk7XG4gICAgfTtcbiAgICBJbnRlZ2VyLk1JTl9WQUxVRV8zMl9CSVRTID0gLTIxNDc0ODM2NDg7XG4gICAgSW50ZWdlci5NQVhfVkFMVUUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICByZXR1cm4gSW50ZWdlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlZ2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Long.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Long.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Ponyfill for Java's Long class.\n */\nvar Long = /** @class */ (function () {\n    function Long() {\n    }\n    /**\n     * Parses a string to a number, since JS has no really Int64.\n     *\n     * @param num Numeric string.\n     * @param radix Destination radix.\n     */\n    Long.parseLong = function (num, radix) {\n        if (radix === void 0) { radix = undefined; }\n        return parseInt(num, radix);\n    };\n    return Long;\n}());\nexports[\"default\"] = Long;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL0xvbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvTG9uZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUG9ueWZpbGwgZm9yIEphdmEncyBMb25nIGNsYXNzLlxuICovXG52YXIgTG9uZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb25nKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgdG8gYSBudW1iZXIsIHNpbmNlIEpTIGhhcyBubyByZWFsbHkgSW50NjQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtIE51bWVyaWMgc3RyaW5nLlxuICAgICAqIEBwYXJhbSByYWRpeCBEZXN0aW5hdGlvbiByYWRpeC5cbiAgICAgKi9cbiAgICBMb25nLnBhcnNlTG9uZyA9IGZ1bmN0aW9uIChudW0sIHJhZGl4KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PT0gdm9pZCAwKSB7IHJhZGl4ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0sIHJhZGl4KTtcbiAgICB9O1xuICAgIHJldHVybiBMb25nO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvbmc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Long.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/OutputStream.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/OutputStream.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IndexOutOfBoundsException_1 = __webpack_require__(/*! ../IndexOutOfBoundsException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js\");\nvar NullPointerException_1 = __webpack_require__(/*! ../NullPointerException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NullPointerException.js\");\n/*\n * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n// package java.io;\n/**\n * This abstract class is the superclass of all classes representing\n * an output stream of bytes. An output stream accepts output bytes\n * and sends them to some sink.\n * <p>\n * Applications that need to define a subclass of\n * <code>OutputStream</code> must always provide at least a method\n * that writes one byte of output.\n *\n * @author  Arthur van Hoff\n * @see     java.io.BufferedOutputStream\n * @see     java.io.ByteArrayOutputStream\n * @see     java.io.DataOutputStream\n * @see     java.io.FilterOutputStream\n * @see     java.io.InputStream\n * @see     java.io.OutputStream#write(int)\n * @since   JDK1.0\n */\nvar OutputStream /*implements Closeable, Flushable*/ = /** @class */ (function () {\n    function OutputStream() {\n    }\n    /**\n     * Writes <code>b.length</code> bytes from the specified byte array\n     * to this output stream. The general contract for <code>write(b)</code>\n     * is that it should have exactly the same effect as the call\n     * <code>write(b, 0, b.length)</code>.\n     *\n     * @param      b   the data.\n     * @exception  IOException  if an I/O error occurs.\n     * @see        java.io.OutputStream#write(byte[], int, int)\n     */\n    OutputStream.prototype.writeBytes = function (b) {\n        this.writeBytesOffset(b, 0, b.length);\n    };\n    /**\n     * Writes <code>len</code> bytes from the specified byte array\n     * starting at offset <code>off</code> to this output stream.\n     * The general contract for <code>write(b, off, len)</code> is that\n     * some of the bytes in the array <code>b</code> are written to the\n     * output stream in order; element <code>b[off]</code> is the first\n     * byte written and <code>b[off+len-1]</code> is the last byte written\n     * by this operation.\n     * <p>\n     * The <code>write</code> method of <code>OutputStream</code> calls\n     * the write method of one argument on each of the bytes to be\n     * written out. Subclasses are encouraged to override this method and\n     * provide a more efficient implementation.\n     * <p>\n     * If <code>b</code> is <code>null</code>, a\n     * <code>NullPointerException</code> is thrown.\n     * <p>\n     * If <code>off</code> is negative, or <code>len</code> is negative, or\n     * <code>off+len</code> is greater than the length of the array\n     * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n     *\n     * @param      b     the data.\n     * @param      off   the start offset in the data.\n     * @param      len   the number of bytes to write.\n     * @exception  IOException  if an I/O error occurs. In particular,\n     *             an <code>IOException</code> is thrown if the output\n     *             stream is closed.\n     */\n    OutputStream.prototype.writeBytesOffset = function (b, off, len) {\n        if (b == null) {\n            throw new NullPointerException_1.default();\n        }\n        else if ((off < 0) || (off > b.length) || (len < 0) ||\n            ((off + len) > b.length) || ((off + len) < 0)) {\n            throw new IndexOutOfBoundsException_1.default();\n        }\n        else if (len === 0) {\n            return;\n        }\n        for (var i = 0; i < len; i++) {\n            this.write(b[off + i]);\n        }\n    };\n    /**\n     * Flushes this output stream and forces any buffered output bytes\n     * to be written out. The general contract of <code>flush</code> is\n     * that calling it is an indication that, if any bytes previously\n     * written have been buffered by the implementation of the output\n     * stream, such bytes should immediately be written to their\n     * intended destination.\n     * <p>\n     * If the intended destination of this stream is an abstraction provided by\n     * the underlying operating system, for example a file, then flushing the\n     * stream guarantees only that bytes previously written to the stream are\n     * passed to the operating system for writing; it does not guarantee that\n     * they are actually written to a physical device such as a disk drive.\n     * <p>\n     * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    OutputStream.prototype.flush = function () {\n    };\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with this stream. The general contract of <code>close</code>\n     * is that it closes the output stream. A closed stream cannot perform\n     * output operations and cannot be reopened.\n     * <p>\n     * The <code>close</code> method of <code>OutputStream</code> does nothing.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    OutputStream.prototype.close = function () {\n    };\n    return OutputStream;\n}());\nexports[\"default\"] = OutputStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL091dHB1dFN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQyxvS0FBOEI7QUFDeEUsNkJBQTZCLG1CQUFPLENBQUMsMEpBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvT3V0cHV0U3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIpO1xudmFyIE51bGxQb2ludGVyRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTnVsbFBvaW50ZXJFeGNlcHRpb25cIik7XG4vKlxuICogQ29weXJpZ2h0IChjKSAxOTk0LCAyMDA0LCBPcmFjbGUgYW5kL29yIGl0cyBhZmZpbGlhdGVzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRE8gTk9UIEFMVEVSIE9SIFJFTU9WRSBDT1BZUklHSFQgTk9USUNFUyBPUiBUSElTIEZJTEUgSEVBREVSLlxuICpcbiAqIFRoaXMgY29kZSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiBvbmx5LCBhc1xuICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24uICBPcmFjbGUgZGVzaWduYXRlcyB0aGlzXG4gKiBwYXJ0aWN1bGFyIGZpbGUgYXMgc3ViamVjdCB0byB0aGUgXCJDbGFzc3BhdGhcIiBleGNlcHRpb24gYXMgcHJvdmlkZWRcbiAqIGJ5IE9yYWNsZSBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQgYWNjb21wYW5pZWQgdGhpcyBjb2RlLlxuICpcbiAqIFRoaXMgY29kZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIHZlcnNpb24gMiBmb3IgbW9yZSBkZXRhaWxzIChhIGNvcHkgaXMgaW5jbHVkZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0XG4gKiBhY2NvbXBhbmllZCB0aGlzIGNvZGUpLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb25cbiAqIDIgYWxvbmcgd2l0aCB0aGlzIHdvcms7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbixcbiAqIEluYy4sIDUxIEZyYW5rbGluIFN0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQS5cbiAqXG4gKiBQbGVhc2UgY29udGFjdCBPcmFjbGUsIDUwMCBPcmFjbGUgUGFya3dheSwgUmVkd29vZCBTaG9yZXMsIENBIDk0MDY1IFVTQVxuICogb3IgdmlzaXQgd3d3Lm9yYWNsZS5jb20gaWYgeW91IG5lZWQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciBoYXZlIGFueVxuICogcXVlc3Rpb25zLlxuICovXG4vLyBwYWNrYWdlIGphdmEuaW87XG4vKipcbiAqIFRoaXMgYWJzdHJhY3QgY2xhc3MgaXMgdGhlIHN1cGVyY2xhc3Mgb2YgYWxsIGNsYXNzZXMgcmVwcmVzZW50aW5nXG4gKiBhbiBvdXRwdXQgc3RyZWFtIG9mIGJ5dGVzLiBBbiBvdXRwdXQgc3RyZWFtIGFjY2VwdHMgb3V0cHV0IGJ5dGVzXG4gKiBhbmQgc2VuZHMgdGhlbSB0byBzb21lIHNpbmsuXG4gKiA8cD5cbiAqIEFwcGxpY2F0aW9ucyB0aGF0IG5lZWQgdG8gZGVmaW5lIGEgc3ViY2xhc3Mgb2ZcbiAqIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gbXVzdCBhbHdheXMgcHJvdmlkZSBhdCBsZWFzdCBhIG1ldGhvZFxuICogdGhhdCB3cml0ZXMgb25lIGJ5dGUgb2Ygb3V0cHV0LlxuICpcbiAqIEBhdXRob3IgIEFydGh1ciB2YW4gSG9mZlxuICogQHNlZSAgICAgamF2YS5pby5CdWZmZXJlZE91dHB1dFN0cmVhbVxuICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW1cbiAqIEBzZWUgICAgIGphdmEuaW8uRGF0YU91dHB1dFN0cmVhbVxuICogQHNlZSAgICAgamF2YS5pby5GaWx0ZXJPdXRwdXRTdHJlYW1cbiAqIEBzZWUgICAgIGphdmEuaW8uSW5wdXRTdHJlYW1cbiAqIEBzZWUgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGludClcbiAqIEBzaW5jZSAgIEpESzEuMFxuICovXG52YXIgT3V0cHV0U3RyZWFtIC8qaW1wbGVtZW50cyBDbG9zZWFibGUsIEZsdXNoYWJsZSovID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dHB1dFN0cmVhbSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIDxjb2RlPmIubGVuZ3RoPC9jb2RlPiBieXRlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYnl0ZSBhcnJheVxuICAgICAqIHRvIHRoaXMgb3V0cHV0IHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIpPC9jb2RlPlxuICAgICAqIGlzIHRoYXQgaXQgc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlZmZlY3QgYXMgdGhlIGNhbGxcbiAgICAgKiA8Y29kZT53cml0ZShiLCAwLCBiLmxlbmd0aCk8L2NvZGU+LlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICAgYiAgIHRoZSBkYXRhLlxuICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGJ5dGVbXSwgaW50LCBpbnQpXG4gICAgICovXG4gICAgT3V0cHV0U3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGVzID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzT2Zmc2V0KGIsIDAsIGIubGVuZ3RoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICogc3RhcnRpbmcgYXQgb2Zmc2V0IDxjb2RlPm9mZjwvY29kZT4gdG8gdGhpcyBvdXRwdXQgc3RyZWFtLlxuICAgICAqIFRoZSBnZW5lcmFsIGNvbnRyYWN0IGZvciA8Y29kZT53cml0ZShiLCBvZmYsIGxlbik8L2NvZGU+IGlzIHRoYXRcbiAgICAgKiBzb21lIG9mIHRoZSBieXRlcyBpbiB0aGUgYXJyYXkgPGNvZGU+YjwvY29kZT4gYXJlIHdyaXR0ZW4gdG8gdGhlXG4gICAgICogb3V0cHV0IHN0cmVhbSBpbiBvcmRlcjsgZWxlbWVudCA8Y29kZT5iW29mZl08L2NvZGU+IGlzIHRoZSBmaXJzdFxuICAgICAqIGJ5dGUgd3JpdHRlbiBhbmQgPGNvZGU+YltvZmYrbGVuLTFdPC9jb2RlPiBpcyB0aGUgbGFzdCBieXRlIHdyaXR0ZW5cbiAgICAgKiBieSB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiA8cD5cbiAgICAgKiBUaGUgPGNvZGU+d3JpdGU8L2NvZGU+IG1ldGhvZCBvZiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IGNhbGxzXG4gICAgICogdGhlIHdyaXRlIG1ldGhvZCBvZiBvbmUgYXJndW1lbnQgb24gZWFjaCBvZiB0aGUgYnl0ZXMgdG8gYmVcbiAgICAgKiB3cml0dGVuIG91dC4gU3ViY2xhc3NlcyBhcmUgZW5jb3VyYWdlZCB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmRcbiAgICAgKiBwcm92aWRlIGEgbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICogPHA+XG4gICAgICogSWYgPGNvZGU+YjwvY29kZT4gaXMgPGNvZGU+bnVsbDwvY29kZT4sIGFcbiAgICAgKiA8Y29kZT5OdWxsUG9pbnRlckV4Y2VwdGlvbjwvY29kZT4gaXMgdGhyb3duLlxuICAgICAqIDxwPlxuICAgICAqIElmIDxjb2RlPm9mZjwvY29kZT4gaXMgbmVnYXRpdmUsIG9yIDxjb2RlPmxlbjwvY29kZT4gaXMgbmVnYXRpdmUsIG9yXG4gICAgICogPGNvZGU+b2ZmK2xlbjwvY29kZT4gaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAgICogPGNvZGU+YjwvY29kZT4sIHRoZW4gYW4gPHR0PkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb248L3R0PiBpcyB0aHJvd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgICBiICAgICB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gICAgICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSAgICAgIGxlbiAgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuIEluIHBhcnRpY3VsYXIsXG4gICAgICogICAgICAgICAgICAgYW4gPGNvZGU+SU9FeGNlcHRpb248L2NvZGU+IGlzIHRocm93biBpZiB0aGUgb3V0cHV0XG4gICAgICogICAgICAgICAgICAgc3RyZWFtIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBPdXRwdXRTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZXNPZmZzZXQgPSBmdW5jdGlvbiAoYiwgb2ZmLCBsZW4pIHtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bGxQb2ludGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvZmYgPCAwKSB8fCAob2ZmID4gYi5sZW5ndGgpIHx8IChsZW4gPCAwKSB8fFxuICAgICAgICAgICAgKChvZmYgKyBsZW4pID4gYi5sZW5ndGgpIHx8ICgob2ZmICsgbGVuKSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGJbb2ZmICsgaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgZm9yY2VzIGFueSBidWZmZXJlZCBvdXRwdXQgYnl0ZXNcbiAgICAgKiB0byBiZSB3cml0dGVuIG91dC4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Zmx1c2g8L2NvZGU+IGlzXG4gICAgICogdGhhdCBjYWxsaW5nIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCwgaWYgYW55IGJ5dGVzIHByZXZpb3VzbHlcbiAgICAgKiB3cml0dGVuIGhhdmUgYmVlbiBidWZmZXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIG91dHB1dFxuICAgICAqIHN0cmVhbSwgc3VjaCBieXRlcyBzaG91bGQgaW1tZWRpYXRlbHkgYmUgd3JpdHRlbiB0byB0aGVpclxuICAgICAqIGludGVuZGVkIGRlc3RpbmF0aW9uLlxuICAgICAqIDxwPlxuICAgICAqIElmIHRoZSBpbnRlbmRlZCBkZXN0aW5hdGlvbiBvZiB0aGlzIHN0cmVhbSBpcyBhbiBhYnN0cmFjdGlvbiBwcm92aWRlZCBieVxuICAgICAqIHRoZSB1bmRlcmx5aW5nIG9wZXJhdGluZyBzeXN0ZW0sIGZvciBleGFtcGxlIGEgZmlsZSwgdGhlbiBmbHVzaGluZyB0aGVcbiAgICAgKiBzdHJlYW0gZ3VhcmFudGVlcyBvbmx5IHRoYXQgYnl0ZXMgcHJldmlvdXNseSB3cml0dGVuIHRvIHRoZSBzdHJlYW0gYXJlXG4gICAgICogcGFzc2VkIHRvIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGZvciB3cml0aW5nOyBpdCBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdFxuICAgICAqIHRoZXkgYXJlIGFjdHVhbGx5IHdyaXR0ZW4gdG8gYSBwaHlzaWNhbCBkZXZpY2Ugc3VjaCBhcyBhIGRpc2sgZHJpdmUuXG4gICAgICogPHA+XG4gICAgICogVGhlIDxjb2RlPmZsdXNoPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgKi9cbiAgICBPdXRwdXRTdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgcmVsZWFzZXMgYW55IHN5c3RlbSByZXNvdXJjZXNcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdHJlYW0uIFRoZSBnZW5lcmFsIGNvbnRyYWN0IG9mIDxjb2RlPmNsb3NlPC9jb2RlPlxuICAgICAqIGlzIHRoYXQgaXQgY2xvc2VzIHRoZSBvdXRwdXQgc3RyZWFtLiBBIGNsb3NlZCBzdHJlYW0gY2Fubm90IHBlcmZvcm1cbiAgICAgKiBvdXRwdXQgb3BlcmF0aW9ucyBhbmQgY2Fubm90IGJlIHJlb3BlbmVkLlxuICAgICAqIDxwPlxuICAgICAqIFRoZSA8Y29kZT5jbG9zZTwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gZG9lcyBub3RoaW5nLlxuICAgICAqXG4gICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgT3V0cHV0U3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIHJldHVybiBPdXRwdXRTdHJlYW07XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0cHV0U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/OutputStream.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar CharacterSetECI_1 = __webpack_require__(/*! ../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\n/**\n * Just to make a shortcut between Java code and TS code.\n */\nvar StandardCharsets = /** @class */ (function () {\n    function StandardCharsets() {\n    }\n    StandardCharsets.ISO_8859_1 = CharacterSetECI_1.default.ISO8859_1;\n    return StandardCharsets;\n}());\nexports[\"default\"] = StandardCharsets;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL1N0YW5kYXJkQ2hhcnNldHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsOEpBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3N5c3RlbS9Eb2N1bWVudHMvUHJvamVjdHMvY3J5cHRleC12YXVsdC13ZWIvbm9kZV9tb2R1bGVzLy5wbnBtL0B6eGluZytsaWJyYXJ5QDAuMjEuMy9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvY2pzL2NvcmUvdXRpbC9TdGFuZGFyZENoYXJzZXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0lcIik7XG4vKipcbiAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICovXG52YXIgU3RhbmRhcmRDaGFyc2V0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZENoYXJzZXRzKCkge1xuICAgIH1cbiAgICBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzEgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LklTTzg4NTlfMTtcbiAgICByZXR1cm4gU3RhbmRhcmRDaGFyc2V0cztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZENoYXJzZXRzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar StringUtils_1 = __webpack_require__(/*! ../common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nvar StringBuilder = /** @class */ (function () {\n    function StringBuilder(value) {\n        if (value === void 0) { value = ''; }\n        this.value = value;\n    }\n    StringBuilder.prototype.enableDecoding = function (encoding) {\n        this.encoding = encoding;\n        return this;\n    };\n    StringBuilder.prototype.append = function (s) {\n        if (typeof s === 'string') {\n            this.value += s.toString();\n        }\n        else if (this.encoding) {\n            // use passed format (fromCharCode will return UTF8 encoding)\n            this.value += StringUtils_1.default.castAsNonUtf8Char(s, this.encoding);\n        }\n        else {\n            // correctly converts from UTF-8, but not other encodings\n            this.value += String.fromCharCode(s);\n        }\n        return this;\n    };\n    StringBuilder.prototype.appendChars = function (str, offset, len) {\n        for (var i = offset; offset < offset + len; i++) {\n            this.append(str[i]);\n        }\n        return this;\n    };\n    StringBuilder.prototype.length = function () {\n        return this.value.length;\n    };\n    StringBuilder.prototype.charAt = function (n) {\n        return this.value.charAt(n);\n    };\n    StringBuilder.prototype.deleteCharAt = function (n) {\n        this.value = this.value.substr(0, n) + this.value.substring(n + 1);\n    };\n    StringBuilder.prototype.setCharAt = function (n, c) {\n        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);\n    };\n    StringBuilder.prototype.substring = function (start, end) {\n        return this.value.substring(start, end);\n    };\n    /**\n     * @note helper method for RSS Expanded\n     */\n    StringBuilder.prototype.setLengthToZero = function () {\n        this.value = '';\n    };\n    StringBuilder.prototype.toString = function () {\n        return this.value;\n    };\n    StringBuilder.prototype.insert = function (n, c) {\n        this.value = this.value.substring(0, n) + c + this.value.substring(n);\n    };\n    return StringBuilder;\n}());\nexports[\"default\"] = StringBuilder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL1N0cmluZ0J1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMsc0pBQXVCO0FBQ25EO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvU3RyaW5nQnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9TdHJpbmdVdGlsc1wiKTtcbnZhciBTdHJpbmdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0J1aWxkZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmVuYWJsZURlY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlICs9IHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmVuY29kaW5nKSB7XG4gICAgICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXG4gICAgICAgICAgICB0aGlzLnZhbHVlICs9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5jYXN0QXNOb25VdGY4Q2hhcihzLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvcnJlY3RseSBjb252ZXJ0cyBmcm9tIFVURi04LCBidXQgbm90IG90aGVyIGVuY29kaW5nc1xuICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kQ2hhcnMgPSBmdW5jdGlvbiAoc3RyLCBvZmZzZXQsIGxlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBvZmZzZXQgPCBvZmZzZXQgKyBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoc3RyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuY2hhckF0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuY2hhckF0KG4pO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuZGVsZXRlQ2hhckF0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgdGhpcy52YWx1ZS5zdWJzdHJpbmcobiArIDEpO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuc2V0Q2hhckF0ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyKG4gKyAxKTtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnN1YnN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBub3RlIGhlbHBlciBtZXRob2QgZm9yIFJTUyBFeHBhbmRlZFxuICAgICAqL1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnNldExlbmd0aFRvWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyaW5nKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyaW5nKG4pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ0J1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyaW5nQnVpbGRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar UnsupportedOperationException_1 = __webpack_require__(/*! ../UnsupportedOperationException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js\");\nvar CharacterSetECI_1 = __webpack_require__(/*! ../common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\n/**\n * Responsible for en/decoding strings.\n */\nvar StringEncoding = /** @class */ (function () {\n    function StringEncoding() {\n    }\n    /**\n     * Decodes some Uint8Array to a string format.\n     */\n    StringEncoding.decode = function (bytes, encoding) {\n        var encodingName = this.encodingName(encoding);\n        if (this.customDecoder) {\n            return this.customDecoder(bytes, encodingName);\n        }\n        // Increases browser support.\n        if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {\n            return this.decodeFallback(bytes, encodingName);\n        }\n        return new TextDecoder(encodingName).decode(bytes);\n    };\n    /**\n     * Checks if the decoding method should use the fallback for decoding\n     * once Node TextDecoder doesn't support all encoding formats.\n     *\n     * @param encodingName\n     */\n    StringEncoding.shouldDecodeOnFallback = function (encodingName) {\n        return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';\n    };\n    /**\n     * Encodes some string into a Uint8Array.\n     */\n    StringEncoding.encode = function (s, encoding) {\n        var encodingName = this.encodingName(encoding);\n        if (this.customEncoder) {\n            return this.customEncoder(s, encodingName);\n        }\n        // Increases browser support.\n        if (typeof TextEncoder === 'undefined') {\n            return this.encodeFallback(s);\n        }\n        // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org\n        return new TextEncoder().encode(s);\n    };\n    StringEncoding.isBrowser = function () {\n        return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');\n    };\n    /**\n     * Returns the string value from some encoding character set.\n     */\n    StringEncoding.encodingName = function (encoding) {\n        return typeof encoding === 'string'\n            ? encoding\n            : encoding.getName();\n    };\n    /**\n     * Returns character set from some encoding character set.\n     */\n    StringEncoding.encodingCharacterSet = function (encoding) {\n        if (encoding instanceof CharacterSetECI_1.default) {\n            return encoding;\n        }\n        return CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n    };\n    /**\n     * Runs a fallback for the native decoding funcion.\n     */\n    StringEncoding.decodeFallback = function (bytes, encoding) {\n        var characterSet = this.encodingCharacterSet(encoding);\n        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {\n            var s = '';\n            for (var i = 0, length_1 = bytes.length; i < length_1; i++) {\n                var h = bytes[i].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                s += '%' + h;\n            }\n            return decodeURIComponent(s);\n        }\n        if (characterSet.equals(CharacterSetECI_1.default.UnicodeBigUnmarked)) {\n            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n        }\n        throw new UnsupportedOperationException_1.default(\"Encoding \" + this.encodingName(encoding) + \" not supported by fallback.\");\n    };\n    StringEncoding.isDecodeFallbackSupported = function (characterSet) {\n        return characterSet.equals(CharacterSetECI_1.default.UTF8) ||\n            characterSet.equals(CharacterSetECI_1.default.ISO8859_1) ||\n            characterSet.equals(CharacterSetECI_1.default.ASCII);\n    };\n    /**\n     * Runs a fallback for the native encoding funcion.\n     *\n     * @see https://stackoverflow.com/a/17192845/4367683\n     */\n    StringEncoding.encodeFallback = function (s) {\n        var encodedURIstring = btoa(unescape(encodeURIComponent(s)));\n        var charList = encodedURIstring.split('');\n        var uintArray = [];\n        for (var i = 0; i < charList.length; i++) {\n            uintArray.push(charList[i].charCodeAt(0));\n        }\n        return new Uint8Array(uintArray);\n    };\n    return StringEncoding;\n}());\nexports[\"default\"] = StringEncoding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL1N0cmluZ0VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxtQkFBTyxDQUFDLDRLQUFrQztBQUNoRix3QkFBd0IsbUJBQU8sQ0FBQyw4SkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvU3RyaW5nRW5jb2RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvblwiKTtcbnZhciBDaGFyYWN0ZXJTZXRFQ0lfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQ2hhcmFjdGVyU2V0RUNJXCIpO1xuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgZW4vZGVjb2Rpbmcgc3RyaW5ncy5cbiAqL1xudmFyIFN0cmluZ0VuY29kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0VuY29kaW5nKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIHNvbWUgVWludDhBcnJheSB0byBhIHN0cmluZyBmb3JtYXQuXG4gICAgICovXG4gICAgU3RyaW5nRW5jb2RpbmcuZGVjb2RlID0gZnVuY3Rpb24gKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICB2YXIgZW5jb2RpbmdOYW1lID0gdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy5jdXN0b21EZWNvZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EZWNvZGVyKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlYXNlcyBicm93c2VyIHN1cHBvcnQuXG4gICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2hvdWxkRGVjb2RlT25GYWxsYmFjayhlbmNvZGluZ05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGYWxsYmFjayhieXRlcywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nTmFtZSkuZGVjb2RlKGJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZGVjb2RpbmcgbWV0aG9kIHNob3VsZCB1c2UgdGhlIGZhbGxiYWNrIGZvciBkZWNvZGluZ1xuICAgICAqIG9uY2UgTm9kZSBUZXh0RGVjb2RlciBkb2Vzbid0IHN1cHBvcnQgYWxsIGVuY29kaW5nIGZvcm1hdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmdOYW1lXG4gICAgICovXG4gICAgU3RyaW5nRW5jb2Rpbmcuc2hvdWxkRGVjb2RlT25GYWxsYmFjayA9IGZ1bmN0aW9uIChlbmNvZGluZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuICFTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIoKSAmJiBlbmNvZGluZ05hbWUgPT09ICdJU08tODg1OS0xJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuY29kZXMgc29tZSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkuXG4gICAgICovXG4gICAgU3RyaW5nRW5jb2RpbmcuZW5jb2RlID0gZnVuY3Rpb24gKHMsIGVuY29kaW5nKSB7XG4gICAgICAgIHZhciBlbmNvZGluZ05hbWUgPSB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyk7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUVuY29kZXIocywgZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxuICAgICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRmFsbGJhY2socyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGV4dEVuY29kZXIgb25seSBlbmNvZGVzIHRvIFVURjggYnkgZGVmYXVsdCBhcyBzcGVjaWZpZWQgYnkgZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnXG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gICAgfTtcbiAgICBTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbCh3aW5kb3cpID09PSAnW29iamVjdCBXaW5kb3ddJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXG4gICAgICovXG4gICAgU3RyaW5nRW5jb2RpbmcuZW5jb2RpbmdOYW1lID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGVuY29kaW5nXG4gICAgICAgICAgICA6IGVuY29kaW5nLmdldE5hbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2hhcmFjdGVyIHNldCBmcm9tIHNvbWUgZW5jb2RpbmcgY2hhcmFjdGVyIHNldC5cbiAgICAgKi9cbiAgICBTdHJpbmdFbmNvZGluZy5lbmNvZGluZ0NoYXJhY3RlclNldCA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lKGVuY29kaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBkZWNvZGluZyBmdW5jaW9uLlxuICAgICAqL1xuICAgIFN0cmluZ0VuY29kaW5nLmRlY29kZUZhbGxiYWNrID0gZnVuY3Rpb24gKGJ5dGVzLCBlbmNvZGluZykge1xuICAgICAgICB2YXIgY2hhcmFjdGVyU2V0ID0gdGhpcy5lbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZyk7XG4gICAgICAgIGlmIChTdHJpbmdFbmNvZGluZy5pc0RlY29kZUZhbGxiYWNrU3VwcG9ydGVkKGNoYXJhY3RlclNldCkpIHtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBieXRlcy5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBieXRlc1tpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyArPSAnJScgKyBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlVuaWNvZGVCaWdVbm1hcmtlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0KFwiRW5jb2RpbmcgXCIgKyB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZykgKyBcIiBub3Qgc3VwcG9ydGVkIGJ5IGZhbGxiYWNrLlwiKTtcbiAgICB9O1xuICAgIFN0cmluZ0VuY29kaW5nLmlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuVVRGOCkgfHxcbiAgICAgICAgICAgIGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5JU084ODU5XzEpIHx8XG4gICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuQVNDSUkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUnVucyBhIGZhbGxiYWNrIGZvciB0aGUgbmF0aXZlIGVuY29kaW5nIGZ1bmNpb24uXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE5Mjg0NS80MzY3NjgzXG4gICAgICovXG4gICAgU3RyaW5nRW5jb2RpbmcuZW5jb2RlRmFsbGJhY2sgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgZW5jb2RlZFVSSXN0cmluZyA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSk7XG4gICAgICAgIHZhciBjaGFyTGlzdCA9IGVuY29kZWRVUklzdHJpbmcuc3BsaXQoJycpO1xuICAgICAgICB2YXIgdWludEFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVpbnRBcnJheS5wdXNoKGNoYXJMaXN0W2ldLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh1aW50QXJyYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ0VuY29kaW5nO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmluZ0VuY29kaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar System = /** @class */ (function () {\n    function System() {\n    }\n    // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n    /**\n     * Makes a copy of a array.\n     */\n    System.arraycopy = function (src, srcPos, dest, destPos, length) {\n        // TODO: better use split or set?\n        while (length--) {\n            dest[destPos++] = src[srcPos++];\n        }\n    };\n    /**\n     * Returns the current time in milliseconds.\n     */\n    System.currentTimeMillis = function () {\n        return Date.now();\n    };\n    return System;\n}());\nexports[\"default\"] = System;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvY29yZS91dGlsL1N5c3RlbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyIvaG9tZS9zeXN0ZW0vRG9jdW1lbnRzL1Byb2plY3RzL2NyeXB0ZXgtdmF1bHQtd2ViL25vZGVfbW9kdWxlcy8ucG5wbS9AenhpbmcrbGlicmFyeUAwLjIxLjMvbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2Nqcy9jb3JlL3V0aWwvU3lzdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN5c3RlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTeXN0ZW0oKSB7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBzdGF0aWMgdm9pZCBhcnJheWNvcHkoT2JqZWN0IHNyYywgaW50IHNyY1BvcywgT2JqZWN0IGRlc3QsIGludCBkZXN0UG9zLCBpbnQgbGVuZ3RoKVxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY29weSBvZiBhIGFycmF5LlxuICAgICAqL1xuICAgIFN5c3RlbS5hcnJheWNvcHkgPSBmdW5jdGlvbiAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgdXNlIHNwbGl0IG9yIHNldD9cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3lzdGVtO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN5c3RlbTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\n");

/***/ }),

/***/ "(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/index.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/index.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./browser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/browser.js\"), exports);\n// Exceptions\nvar ArgumentException_1 = __webpack_require__(/*! ./core/ArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArgumentException.js\");\nObject.defineProperty(exports, \"ArgumentException\", ({ enumerable: true, get: function () { return ArgumentException_1.default; } }));\nvar ArithmeticException_1 = __webpack_require__(/*! ./core/ArithmeticException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ArithmeticException.js\");\nObject.defineProperty(exports, \"ArithmeticException\", ({ enumerable: true, get: function () { return ArithmeticException_1.default; } }));\nvar ChecksumException_1 = __webpack_require__(/*! ./core/ChecksumException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ChecksumException.js\");\nObject.defineProperty(exports, \"ChecksumException\", ({ enumerable: true, get: function () { return ChecksumException_1.default; } }));\nvar Exception_1 = __webpack_require__(/*! ./core/Exception */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Exception.js\");\nObject.defineProperty(exports, \"Exception\", ({ enumerable: true, get: function () { return Exception_1.default; } }));\nvar FormatException_1 = __webpack_require__(/*! ./core/FormatException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/FormatException.js\");\nObject.defineProperty(exports, \"FormatException\", ({ enumerable: true, get: function () { return FormatException_1.default; } }));\nvar IllegalArgumentException_1 = __webpack_require__(/*! ./core/IllegalArgumentException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js\");\nObject.defineProperty(exports, \"IllegalArgumentException\", ({ enumerable: true, get: function () { return IllegalArgumentException_1.default; } }));\nvar IllegalStateException_1 = __webpack_require__(/*! ./core/IllegalStateException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/IllegalStateException.js\");\nObject.defineProperty(exports, \"IllegalStateException\", ({ enumerable: true, get: function () { return IllegalStateException_1.default; } }));\nvar NotFoundException_1 = __webpack_require__(/*! ./core/NotFoundException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/NotFoundException.js\");\nObject.defineProperty(exports, \"NotFoundException\", ({ enumerable: true, get: function () { return NotFoundException_1.default; } }));\nvar ReaderException_1 = __webpack_require__(/*! ./core/ReaderException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReaderException.js\");\nObject.defineProperty(exports, \"ReaderException\", ({ enumerable: true, get: function () { return ReaderException_1.default; } }));\nvar ReedSolomonException_1 = __webpack_require__(/*! ./core/ReedSolomonException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ReedSolomonException.js\");\nObject.defineProperty(exports, \"ReedSolomonException\", ({ enumerable: true, get: function () { return ReedSolomonException_1.default; } }));\nvar UnsupportedOperationException_1 = __webpack_require__(/*! ./core/UnsupportedOperationException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js\");\nObject.defineProperty(exports, \"UnsupportedOperationException\", ({ enumerable: true, get: function () { return UnsupportedOperationException_1.default; } }));\nvar WriterException_1 = __webpack_require__(/*! ./core/WriterException */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/WriterException.js\");\nObject.defineProperty(exports, \"WriterException\", ({ enumerable: true, get: function () { return WriterException_1.default; } }));\n// core\nvar BarcodeFormat_1 = __webpack_require__(/*! ./core/BarcodeFormat */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BarcodeFormat.js\");\nObject.defineProperty(exports, \"BarcodeFormat\", ({ enumerable: true, get: function () { return BarcodeFormat_1.default; } }));\nvar Binarizer_1 = __webpack_require__(/*! ./core/Binarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Binarizer.js\");\nObject.defineProperty(exports, \"Binarizer\", ({ enumerable: true, get: function () { return Binarizer_1.default; } }));\nvar BinaryBitmap_1 = __webpack_require__(/*! ./core/BinaryBitmap */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/BinaryBitmap.js\");\nObject.defineProperty(exports, \"BinaryBitmap\", ({ enumerable: true, get: function () { return BinaryBitmap_1.default; } }));\nvar DecodeHintType_1 = __webpack_require__(/*! ./core/DecodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/DecodeHintType.js\");\nObject.defineProperty(exports, \"DecodeHintType\", ({ enumerable: true, get: function () { return DecodeHintType_1.default; } }));\nvar InvertedLuminanceSource_1 = __webpack_require__(/*! ./core/InvertedLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js\");\nObject.defineProperty(exports, \"InvertedLuminanceSource\", ({ enumerable: true, get: function () { return InvertedLuminanceSource_1.default; } }));\nvar LuminanceSource_1 = __webpack_require__(/*! ./core/LuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/LuminanceSource.js\");\nObject.defineProperty(exports, \"LuminanceSource\", ({ enumerable: true, get: function () { return LuminanceSource_1.default; } }));\nvar MultiFormatReader_1 = __webpack_require__(/*! ./core/MultiFormatReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatReader.js\");\nObject.defineProperty(exports, \"MultiFormatReader\", ({ enumerable: true, get: function () { return MultiFormatReader_1.default; } }));\nvar MultiFormatWriter_1 = __webpack_require__(/*! ./core/MultiFormatWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js\");\nObject.defineProperty(exports, \"MultiFormatWriter\", ({ enumerable: true, get: function () { return MultiFormatWriter_1.default; } }));\nvar PlanarYUVLuminanceSource_1 = __webpack_require__(/*! ./core/PlanarYUVLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js\");\nObject.defineProperty(exports, \"PlanarYUVLuminanceSource\", ({ enumerable: true, get: function () { return PlanarYUVLuminanceSource_1.default; } }));\nvar Result_1 = __webpack_require__(/*! ./core/Result */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/Result.js\");\nObject.defineProperty(exports, \"Result\", ({ enumerable: true, get: function () { return Result_1.default; } }));\nvar ResultMetadataType_1 = __webpack_require__(/*! ./core/ResultMetadataType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultMetadataType.js\");\nObject.defineProperty(exports, \"ResultMetadataType\", ({ enumerable: true, get: function () { return ResultMetadataType_1.default; } }));\nvar RGBLuminanceSource_1 = __webpack_require__(/*! ./core/RGBLuminanceSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js\");\nObject.defineProperty(exports, \"RGBLuminanceSource\", ({ enumerable: true, get: function () { return RGBLuminanceSource_1.default; } }));\nvar ResultPoint_1 = __webpack_require__(/*! ./core/ResultPoint */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/ResultPoint.js\");\nObject.defineProperty(exports, \"ResultPoint\", ({ enumerable: true, get: function () { return ResultPoint_1.default; } }));\n// core/util\nvar System_1 = __webpack_require__(/*! ./core/util/System */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/System.js\");\nObject.defineProperty(exports, \"ZXingSystem\", ({ enumerable: true, get: function () { return System_1.default; } }));\nvar StringBuilder_1 = __webpack_require__(/*! ./core/util/StringBuilder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringBuilder.js\");\nObject.defineProperty(exports, \"ZXingStringBuilder\", ({ enumerable: true, get: function () { return StringBuilder_1.default; } }));\nvar StringEncoding_1 = __webpack_require__(/*! ./core/util/StringEncoding */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StringEncoding.js\");\nObject.defineProperty(exports, \"ZXingStringEncoding\", ({ enumerable: true, get: function () { return StringEncoding_1.default; } }));\nvar Charset_1 = __webpack_require__(/*! ./core/util/Charset */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Charset.js\");\nObject.defineProperty(exports, \"ZXingCharset\", ({ enumerable: true, get: function () { return Charset_1.default; } }));\nvar Arrays_1 = __webpack_require__(/*! ./core/util/Arrays */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Arrays.js\");\nObject.defineProperty(exports, \"ZXingArrays\", ({ enumerable: true, get: function () { return Arrays_1.default; } }));\nvar StandardCharsets_1 = __webpack_require__(/*! ./core/util/StandardCharsets */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/StandardCharsets.js\");\nObject.defineProperty(exports, \"ZXingStandardCharsets\", ({ enumerable: true, get: function () { return StandardCharsets_1.default; } }));\nvar Integer_1 = __webpack_require__(/*! ./core/util/Integer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/util/Integer.js\");\nObject.defineProperty(exports, \"ZXingInteger\", ({ enumerable: true, get: function () { return Integer_1.default; } }));\n// core/common\nvar BitArray_1 = __webpack_require__(/*! ./core/common/BitArray */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitArray.js\");\nObject.defineProperty(exports, \"BitArray\", ({ enumerable: true, get: function () { return BitArray_1.default; } }));\nvar BitMatrix_1 = __webpack_require__(/*! ./core/common/BitMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitMatrix.js\");\nObject.defineProperty(exports, \"BitMatrix\", ({ enumerable: true, get: function () { return BitMatrix_1.default; } }));\nvar BitSource_1 = __webpack_require__(/*! ./core/common/BitSource */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/BitSource.js\");\nObject.defineProperty(exports, \"BitSource\", ({ enumerable: true, get: function () { return BitSource_1.default; } }));\nvar CharacterSetECI_1 = __webpack_require__(/*! ./core/common/CharacterSetECI */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js\");\nObject.defineProperty(exports, \"CharacterSetECI\", ({ enumerable: true, get: function () { return CharacterSetECI_1.default; } }));\nvar DecoderResult_1 = __webpack_require__(/*! ./core/common/DecoderResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DecoderResult.js\");\nObject.defineProperty(exports, \"DecoderResult\", ({ enumerable: true, get: function () { return DecoderResult_1.default; } }));\nvar DefaultGridSampler_1 = __webpack_require__(/*! ./core/common/DefaultGridSampler */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js\");\nObject.defineProperty(exports, \"DefaultGridSampler\", ({ enumerable: true, get: function () { return DefaultGridSampler_1.default; } }));\nvar DetectorResult_1 = __webpack_require__(/*! ./core/common/DetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/DetectorResult.js\");\nObject.defineProperty(exports, \"DetectorResult\", ({ enumerable: true, get: function () { return DetectorResult_1.default; } }));\nvar EncodeHintType_1 = __webpack_require__(/*! ./core/EncodeHintType */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/EncodeHintType.js\");\nObject.defineProperty(exports, \"EncodeHintType\", ({ enumerable: true, get: function () { return EncodeHintType_1.default; } }));\nvar GlobalHistogramBinarizer_1 = __webpack_require__(/*! ./core/common/GlobalHistogramBinarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js\");\nObject.defineProperty(exports, \"GlobalHistogramBinarizer\", ({ enumerable: true, get: function () { return GlobalHistogramBinarizer_1.default; } }));\nvar GridSampler_1 = __webpack_require__(/*! ./core/common/GridSampler */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSampler.js\");\nObject.defineProperty(exports, \"GridSampler\", ({ enumerable: true, get: function () { return GridSampler_1.default; } }));\nvar GridSamplerInstance_1 = __webpack_require__(/*! ./core/common/GridSamplerInstance */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js\");\nObject.defineProperty(exports, \"GridSamplerInstance\", ({ enumerable: true, get: function () { return GridSamplerInstance_1.default; } }));\nvar HybridBinarizer_1 = __webpack_require__(/*! ./core/common/HybridBinarizer */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js\");\nObject.defineProperty(exports, \"HybridBinarizer\", ({ enumerable: true, get: function () { return HybridBinarizer_1.default; } }));\nvar PerspectiveTransform_1 = __webpack_require__(/*! ./core/common/PerspectiveTransform */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js\");\nObject.defineProperty(exports, \"PerspectiveTransform\", ({ enumerable: true, get: function () { return PerspectiveTransform_1.default; } }));\nvar StringUtils_1 = __webpack_require__(/*! ./core/common/StringUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/StringUtils.js\");\nObject.defineProperty(exports, \"StringUtils\", ({ enumerable: true, get: function () { return StringUtils_1.default; } }));\n// core/common/detector\nvar MathUtils_1 = __webpack_require__(/*! ./core/common/detector/MathUtils */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js\");\nObject.defineProperty(exports, \"MathUtils\", ({ enumerable: true, get: function () { return MathUtils_1.default; } }));\n// export { default as MonochromeRectangleDetector } from './core/common/detector/MonochromeRectangleDetector';\nvar WhiteRectangleDetector_1 = __webpack_require__(/*! ./core/common/detector/WhiteRectangleDetector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js\");\nObject.defineProperty(exports, \"WhiteRectangleDetector\", ({ enumerable: true, get: function () { return WhiteRectangleDetector_1.default; } }));\n// core/common/reedsolomon\nvar GenericGF_1 = __webpack_require__(/*! ./core/common/reedsolomon/GenericGF */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js\");\nObject.defineProperty(exports, \"GenericGF\", ({ enumerable: true, get: function () { return GenericGF_1.default; } }));\nvar GenericGFPoly_1 = __webpack_require__(/*! ./core/common/reedsolomon/GenericGFPoly */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js\");\nObject.defineProperty(exports, \"GenericGFPoly\", ({ enumerable: true, get: function () { return GenericGFPoly_1.default; } }));\nvar ReedSolomonDecoder_1 = __webpack_require__(/*! ./core/common/reedsolomon/ReedSolomonDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js\");\nObject.defineProperty(exports, \"ReedSolomonDecoder\", ({ enumerable: true, get: function () { return ReedSolomonDecoder_1.default; } }));\nvar ReedSolomonEncoder_1 = __webpack_require__(/*! ./core/common/reedsolomon/ReedSolomonEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js\");\nObject.defineProperty(exports, \"ReedSolomonEncoder\", ({ enumerable: true, get: function () { return ReedSolomonEncoder_1.default; } }));\n// core/datamatrix\nvar DataMatrixReader_1 = __webpack_require__(/*! ./core/datamatrix/DataMatrixReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js\");\nObject.defineProperty(exports, \"DataMatrixReader\", ({ enumerable: true, get: function () { return DataMatrixReader_1.default; } }));\nvar DecodedBitStreamParser_1 = __webpack_require__(/*! ./core/datamatrix/decoder/DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js\");\nObject.defineProperty(exports, \"DataMatrixDecodedBitStreamParser\", ({ enumerable: true, get: function () { return DecodedBitStreamParser_1.default; } }));\nvar DefaultPlacement_1 = __webpack_require__(/*! ./core/datamatrix/encoder/DefaultPlacement */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js\");\nObject.defineProperty(exports, \"DataMatrixDefaultPlacement\", ({ enumerable: true, get: function () { return DefaultPlacement_1.default; } }));\nvar ErrorCorrection_1 = __webpack_require__(/*! ./core/datamatrix/encoder/ErrorCorrection */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js\");\nObject.defineProperty(exports, \"DataMatrixErrorCorrection\", ({ enumerable: true, get: function () { return ErrorCorrection_1.default; } }));\nvar HighLevelEncoder_1 = __webpack_require__(/*! ./core/datamatrix/encoder/HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js\");\nObject.defineProperty(exports, \"DataMatrixHighLevelEncoder\", ({ enumerable: true, get: function () { return HighLevelEncoder_1.default; } }));\nvar SymbolInfo_1 = __webpack_require__(/*! ./core/datamatrix/encoder/SymbolInfo */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js\");\nObject.defineProperty(exports, \"DataMatrixSymbolInfo\", ({ enumerable: true, get: function () { return SymbolInfo_1.default; } }));\nvar constants_1 = __webpack_require__(/*! ./core/datamatrix/encoder/constants */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js\");\nObject.defineProperty(exports, \"DataMatrixSymbolShapeHint\", ({ enumerable: true, get: function () { return constants_1.SymbolShapeHint; } }));\nvar DataMatrixWriter_1 = __webpack_require__(/*! ./core/datamatrix/DataMatrixWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js\");\nObject.defineProperty(exports, \"DataMatrixWriter\", ({ enumerable: true, get: function () { return DataMatrixWriter_1.default; } }));\n// core/pdf417\nvar PDF417Reader_1 = __webpack_require__(/*! ./core/pdf417/PDF417Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js\");\nObject.defineProperty(exports, \"PDF417Reader\", ({ enumerable: true, get: function () { return PDF417Reader_1.default; } }));\nvar PDF417ResultMetadata_1 = __webpack_require__(/*! ./core/pdf417/PDF417ResultMetadata */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js\");\nObject.defineProperty(exports, \"PDF417ResultMetadata\", ({ enumerable: true, get: function () { return PDF417ResultMetadata_1.default; } }));\nvar DecodedBitStreamParser_2 = __webpack_require__(/*! ./core/pdf417/decoder/DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js\");\nObject.defineProperty(exports, \"PDF417DecodedBitStreamParser\", ({ enumerable: true, get: function () { return DecodedBitStreamParser_2.default; } }));\nvar ErrorCorrection_2 = __webpack_require__(/*! ./core/pdf417/decoder/ec/ErrorCorrection */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js\");\nObject.defineProperty(exports, \"PDF417DecoderErrorCorrection\", ({ enumerable: true, get: function () { return ErrorCorrection_2.default; } }));\n// core/twod/qrcode\nvar QRCodeReader_1 = __webpack_require__(/*! ./core/qrcode/QRCodeReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js\");\nObject.defineProperty(exports, \"QRCodeReader\", ({ enumerable: true, get: function () { return QRCodeReader_1.default; } }));\nvar QRCodeWriter_1 = __webpack_require__(/*! ./core/qrcode/QRCodeWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js\");\nObject.defineProperty(exports, \"QRCodeWriter\", ({ enumerable: true, get: function () { return QRCodeWriter_1.default; } }));\nvar ErrorCorrectionLevel_1 = __webpack_require__(/*! ./core/qrcode/decoder/ErrorCorrectionLevel */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js\");\nObject.defineProperty(exports, \"QRCodeDecoderErrorCorrectionLevel\", ({ enumerable: true, get: function () { return ErrorCorrectionLevel_1.default; } }));\nvar FormatInformation_1 = __webpack_require__(/*! ./core/qrcode/decoder/FormatInformation */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js\");\nObject.defineProperty(exports, \"QRCodeDecoderFormatInformation\", ({ enumerable: true, get: function () { return FormatInformation_1.default; } }));\nvar Version_1 = __webpack_require__(/*! ./core/qrcode/decoder/Version */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js\");\nObject.defineProperty(exports, \"QRCodeVersion\", ({ enumerable: true, get: function () { return Version_1.default; } }));\nvar Mode_1 = __webpack_require__(/*! ./core/qrcode/decoder/Mode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js\");\nObject.defineProperty(exports, \"QRCodeMode\", ({ enumerable: true, get: function () { return Mode_1.default; } }));\nvar DecodedBitStreamParser_3 = __webpack_require__(/*! ./core/qrcode/decoder/DecodedBitStreamParser */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js\");\nObject.defineProperty(exports, \"QRCodeDecodedBitStreamParser\", ({ enumerable: true, get: function () { return DecodedBitStreamParser_3.default; } }));\nvar DataMask_1 = __webpack_require__(/*! ./core/qrcode/decoder/DataMask */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js\");\nObject.defineProperty(exports, \"QRCodeDataMask\", ({ enumerable: true, get: function () { return DataMask_1.default; } }));\nvar Encoder_1 = __webpack_require__(/*! ./core/qrcode/encoder/Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js\");\nObject.defineProperty(exports, \"QRCodeEncoder\", ({ enumerable: true, get: function () { return Encoder_1.default; } }));\nvar QRCode_1 = __webpack_require__(/*! ./core/qrcode/encoder/QRCode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js\");\nObject.defineProperty(exports, \"QRCodeEncoderQRCode\", ({ enumerable: true, get: function () { return QRCode_1.default; } }));\nvar MatrixUtil_1 = __webpack_require__(/*! ./core/qrcode/encoder/MatrixUtil */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js\");\nObject.defineProperty(exports, \"QRCodeMatrixUtil\", ({ enumerable: true, get: function () { return MatrixUtil_1.default; } }));\nvar ByteMatrix_1 = __webpack_require__(/*! ./core/qrcode/encoder/ByteMatrix */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js\");\nObject.defineProperty(exports, \"QRCodeByteMatrix\", ({ enumerable: true, get: function () { return ByteMatrix_1.default; } }));\nvar MaskUtil_1 = __webpack_require__(/*! ./core/qrcode/encoder/MaskUtil */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js\");\nObject.defineProperty(exports, \"QRCodeMaskUtil\", ({ enumerable: true, get: function () { return MaskUtil_1.default; } }));\n// core/twod/aztec\nvar AztecReader_1 = __webpack_require__(/*! ./core/aztec/AztecReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js\");\nObject.defineProperty(exports, \"AztecCodeReader\", ({ enumerable: true, get: function () { return AztecReader_1.default; } }));\nvar AztecWriter_1 = __webpack_require__(/*! ./core/aztec/AztecWriter */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js\");\nObject.defineProperty(exports, \"AztecCodeWriter\", ({ enumerable: true, get: function () { return AztecWriter_1.default; } }));\nvar AztecDetectorResult_1 = __webpack_require__(/*! ./core/aztec/AztecDetectorResult */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js\");\nObject.defineProperty(exports, \"AztecDetectorResult\", ({ enumerable: true, get: function () { return AztecDetectorResult_1.default; } }));\nvar Encoder_2 = __webpack_require__(/*! ./core/aztec/encoder/Encoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js\");\nObject.defineProperty(exports, \"AztecEncoder\", ({ enumerable: true, get: function () { return Encoder_2.default; } }));\nvar HighLevelEncoder_2 = __webpack_require__(/*! ./core/aztec/encoder/HighLevelEncoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js\");\nObject.defineProperty(exports, \"AztecHighLevelEncoder\", ({ enumerable: true, get: function () { return HighLevelEncoder_2.default; } }));\nvar AztecCode_1 = __webpack_require__(/*! ./core/aztec/encoder/AztecCode */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js\");\nObject.defineProperty(exports, \"AztecCode\", ({ enumerable: true, get: function () { return AztecCode_1.default; } }));\nvar Decoder_1 = __webpack_require__(/*! ./core/aztec/decoder/Decoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js\");\nObject.defineProperty(exports, \"AztecDecoder\", ({ enumerable: true, get: function () { return Decoder_1.default; } }));\nvar Detector_1 = __webpack_require__(/*! ./core/aztec/detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js\");\nObject.defineProperty(exports, \"AztecDetector\", ({ enumerable: true, get: function () { return Detector_1.default; } }));\nvar Detector_2 = __webpack_require__(/*! ./core/aztec/detector/Detector */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js\");\nObject.defineProperty(exports, \"AztecPoint\", ({ enumerable: true, get: function () { return Detector_2.Point; } }));\n// core/oned\nvar OneDReader_1 = __webpack_require__(/*! ./core/oned/OneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/OneDReader.js\");\nObject.defineProperty(exports, \"OneDReader\", ({ enumerable: true, get: function () { return OneDReader_1.default; } }));\nvar EAN13Reader_1 = __webpack_require__(/*! ./core/oned/EAN13Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js\");\nObject.defineProperty(exports, \"EAN13Reader\", ({ enumerable: true, get: function () { return EAN13Reader_1.default; } }));\nvar Code128Reader_1 = __webpack_require__(/*! ./core/oned/Code128Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js\");\nObject.defineProperty(exports, \"Code128Reader\", ({ enumerable: true, get: function () { return Code128Reader_1.default; } }));\nvar ITFReader_1 = __webpack_require__(/*! ./core/oned/ITFReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/ITFReader.js\");\nObject.defineProperty(exports, \"ITFReader\", ({ enumerable: true, get: function () { return ITFReader_1.default; } }));\nvar Code39Reader_1 = __webpack_require__(/*! ./core/oned/Code39Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js\");\nObject.defineProperty(exports, \"Code39Reader\", ({ enumerable: true, get: function () { return Code39Reader_1.default; } }));\nvar Code93Reader_1 = __webpack_require__(/*! ./core/oned/Code93Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js\");\nObject.defineProperty(exports, \"Code93Reader\", ({ enumerable: true, get: function () { return Code93Reader_1.default; } }));\nvar RSS14Reader_1 = __webpack_require__(/*! ./core/oned/rss/RSS14Reader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js\");\nObject.defineProperty(exports, \"RSS14Reader\", ({ enumerable: true, get: function () { return RSS14Reader_1.default; } }));\nvar RSSExpandedReader_1 = __webpack_require__(/*! ./core/oned/rss/expanded/RSSExpandedReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js\");\nObject.defineProperty(exports, \"RSSExpandedReader\", ({ enumerable: true, get: function () { return RSSExpandedReader_1.default; } }));\nvar AbstractExpandedDecoder_1 = __webpack_require__(/*! ./core/oned/rss/expanded/decoders/AbstractExpandedDecoder */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js\");\nObject.defineProperty(exports, \"AbstractExpandedDecoder\", ({ enumerable: true, get: function () { return AbstractExpandedDecoder_1.default; } }));\nvar AbstractExpandedDecoderComplement_1 = __webpack_require__(/*! ./core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js\");\nObject.defineProperty(exports, \"createAbstractExpandedDecoder\", ({ enumerable: true, get: function () { return AbstractExpandedDecoderComplement_1.createDecoder; } }));\nvar MultiFormatOneDReader_1 = __webpack_require__(/*! ./core/oned/MultiFormatOneDReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js\");\nObject.defineProperty(exports, \"MultiFormatOneDReader\", ({ enumerable: true, get: function () { return MultiFormatOneDReader_1.default; } }));\nvar CodaBarReader_1 = __webpack_require__(/*! ./core/oned/CodaBarReader */ \"(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js\");\nObject.defineProperty(exports, \"CodaBarReader\", ({ enumerable: true, get: function () { return CodaBarReader_1.default; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywwSEFBVztBQUNoQztBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHdKQUEwQjtBQUM1RCxxREFBb0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbkksNEJBQTRCLG1CQUFPLENBQUMsNEpBQTRCO0FBQ2hFLHVEQUFzRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN2SSwwQkFBMEIsbUJBQU8sQ0FBQyx3SkFBMEI7QUFDNUQscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLGtCQUFrQixtQkFBTyxDQUFDLHdJQUFrQjtBQUM1Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsd0JBQXdCLG1CQUFPLENBQUMsb0pBQXdCO0FBQ3hELG1EQUFrRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMvSCxpQ0FBaUMsbUJBQU8sQ0FBQyxzS0FBaUM7QUFDMUUsNERBQTJELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ2pKLDhCQUE4QixtQkFBTyxDQUFDLGdLQUE4QjtBQUNwRSx5REFBd0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDM0ksMEJBQTBCLG1CQUFPLENBQUMsd0pBQTBCO0FBQzVELHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSSx3QkFBd0IsbUJBQU8sQ0FBQyxvSkFBd0I7QUFDeEQsbURBQWtELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQy9ILDZCQUE2QixtQkFBTyxDQUFDLDhKQUE2QjtBQUNsRSx3REFBdUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDekksc0NBQXNDLG1CQUFPLENBQUMsZ0xBQXNDO0FBQ3BGLGlFQUFnRSxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUMzSix3QkFBd0IsbUJBQU8sQ0FBQyxvSkFBd0I7QUFDeEQsbURBQWtELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQy9IO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsZ0pBQXNCO0FBQ3BELGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxrQkFBa0IsbUJBQU8sQ0FBQyx3SUFBa0I7QUFDNUMsNkNBQTRDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ25ILHFCQUFxQixtQkFBTyxDQUFDLDhJQUFxQjtBQUNsRCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsdUJBQXVCLG1CQUFPLENBQUMsa0pBQXVCO0FBQ3RELGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnQ0FBZ0MsbUJBQU8sQ0FBQyxvS0FBZ0M7QUFDeEUsMkRBQTBELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQy9JLHdCQUF3QixtQkFBTyxDQUFDLG9KQUF3QjtBQUN4RCxtREFBa0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDL0gsMEJBQTBCLG1CQUFPLENBQUMsd0pBQTBCO0FBQzVELHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSSwwQkFBMEIsbUJBQU8sQ0FBQyx3SkFBMEI7QUFDNUQscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLGlDQUFpQyxtQkFBTyxDQUFDLHNLQUFpQztBQUMxRSw0REFBMkQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDakosZUFBZSxtQkFBTyxDQUFDLGtJQUFlO0FBQ3RDLDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3RywyQkFBMkIsbUJBQU8sQ0FBQywwSkFBMkI7QUFDOUQsc0RBQXFELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3JJLDJCQUEyQixtQkFBTyxDQUFDLDBKQUEyQjtBQUM5RCxzREFBcUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDckksb0JBQW9CLG1CQUFPLENBQUMsNElBQW9CO0FBQ2hELCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0SUFBb0I7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2xILHNCQUFzQixtQkFBTyxDQUFDLDBKQUEyQjtBQUN6RCxzREFBcUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDaEksdUJBQXVCLG1CQUFPLENBQUMsNEpBQTRCO0FBQzNELHVEQUFzRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUNsSSxnQkFBZ0IsbUJBQU8sQ0FBQyw4SUFBcUI7QUFDN0MsZ0RBQStDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ3BILGVBQWUsbUJBQU8sQ0FBQyw0SUFBb0I7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2xILHlCQUF5QixtQkFBTyxDQUFDLGdLQUE4QjtBQUMvRCx5REFBd0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDdEksZ0JBQWdCLG1CQUFPLENBQUMsOElBQXFCO0FBQzdDLGdEQUErQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNwSDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLG9KQUF3QjtBQUNqRCw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDakgsa0JBQWtCLG1CQUFPLENBQUMsc0pBQXlCO0FBQ25ELDZDQUE0QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNuSCxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBeUI7QUFDbkQsNkNBQTRDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ25ILHdCQUF3QixtQkFBTyxDQUFDLGtLQUErQjtBQUMvRCxtREFBa0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDL0gsc0JBQXNCLG1CQUFPLENBQUMsOEpBQTZCO0FBQzNELGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCwyQkFBMkIsbUJBQU8sQ0FBQyx3S0FBa0M7QUFDckUsc0RBQXFELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3JJLHVCQUF1QixtQkFBTyxDQUFDLGdLQUE4QjtBQUM3RCxrREFBaUQsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDN0gsdUJBQXVCLG1CQUFPLENBQUMsa0pBQXVCO0FBQ3RELGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxpQ0FBaUMsbUJBQU8sQ0FBQyxvTEFBd0M7QUFDakYsNERBQTJELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ2pKLG9CQUFvQixtQkFBTyxDQUFDLDBKQUEyQjtBQUN2RCwrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsNEJBQTRCLG1CQUFPLENBQUMsMEtBQW1DO0FBQ3ZFLHVEQUFzRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN2SSx3QkFBd0IsbUJBQU8sQ0FBQyxrS0FBK0I7QUFDL0QsbURBQWtELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQy9ILDZCQUE2QixtQkFBTyxDQUFDLDRLQUFvQztBQUN6RSx3REFBdUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDekksb0JBQW9CLG1CQUFPLENBQUMsMEpBQTJCO0FBQ3ZELCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdLQUFrQztBQUM1RCw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsWUFBWSx5Q0FBeUM7QUFDckQsK0JBQStCLG1CQUFPLENBQUMsa01BQStDO0FBQ3RGLDBEQUF5RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUM3STtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhLQUFxQztBQUMvRCw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsc0JBQXNCLG1CQUFPLENBQUMsc0xBQXlDO0FBQ3ZFLGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCwyQkFBMkIsbUJBQU8sQ0FBQyxnTUFBOEM7QUFDakYsc0RBQXFELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3JJLDJCQUEyQixtQkFBTyxDQUFDLGdNQUE4QztBQUNqRixzREFBcUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDckk7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0S0FBb0M7QUFDckUsb0RBQW1ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2pJLCtCQUErQixtQkFBTyxDQUFDLHdNQUFrRDtBQUN6RixvRUFBbUUsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDdkoseUJBQXlCLG1CQUFPLENBQUMsNExBQTRDO0FBQzdFLDhEQUE2RCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSSx3QkFBd0IsbUJBQU8sQ0FBQywwTEFBMkM7QUFDM0UsNkRBQTRELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQ3pJLHlCQUF5QixtQkFBTyxDQUFDLDRMQUE0QztBQUM3RSw4REFBNkQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDM0ksbUJBQW1CLG1CQUFPLENBQUMsZ0xBQXNDO0FBQ2pFLHdEQUF1RCxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUMvSCxrQkFBa0IsbUJBQU8sQ0FBQyw4S0FBcUM7QUFDL0QsNkRBQTRELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzNJLHlCQUF5QixtQkFBTyxDQUFDLDRLQUFvQztBQUNyRSxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakk7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw0SkFBNEI7QUFDekQsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILDZCQUE2QixtQkFBTyxDQUFDLDRLQUFvQztBQUN6RSx3REFBdUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDekksK0JBQStCLG1CQUFPLENBQUMsZ01BQThDO0FBQ3JGLGdFQUErRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNuSix3QkFBd0IsbUJBQU8sQ0FBQyx3TEFBMEM7QUFDMUUsZ0VBQStELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzVJO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsNEpBQTRCO0FBQ3pELGdEQUErQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN6SCxxQkFBcUIsbUJBQU8sQ0FBQyw0SkFBNEI7QUFDekQsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILDZCQUE2QixtQkFBTyxDQUFDLDRMQUE0QztBQUNqRixxRUFBb0UsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDdEosMEJBQTBCLG1CQUFPLENBQUMsc0xBQXlDO0FBQzNFLGtFQUFpRSxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNoSixnQkFBZ0IsbUJBQU8sQ0FBQyxrS0FBK0I7QUFDdkQsaURBQWdELEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ3JILGFBQWEsbUJBQU8sQ0FBQyw0SkFBNEI7QUFDakQsOENBQTZDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQy9HLCtCQUErQixtQkFBTyxDQUFDLGdNQUE4QztBQUNyRixnRUFBK0QsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDbkosaUJBQWlCLG1CQUFPLENBQUMsb0tBQWdDO0FBQ3pELGtEQUFpRCxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUN2SCxnQkFBZ0IsbUJBQU8sQ0FBQyxrS0FBK0I7QUFDdkQsaURBQWdELEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ3JILGVBQWUsbUJBQU8sQ0FBQyxnS0FBOEI7QUFDckQsdURBQXNELEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzFILG1CQUFtQixtQkFBTyxDQUFDLHdLQUFrQztBQUM3RCxvREFBbUQsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDM0gsbUJBQW1CLG1CQUFPLENBQUMsd0tBQWtDO0FBQzdELG9EQUFtRCxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQyxvS0FBZ0M7QUFDekQsa0RBQWlELEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3ZIO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0pBQTBCO0FBQ3RELG1EQUFrRCxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUMzSCxvQkFBb0IsbUJBQU8sQ0FBQyx3SkFBMEI7QUFDdEQsbURBQWtELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQzNILDRCQUE0QixtQkFBTyxDQUFDLHdLQUFrQztBQUN0RSx1REFBc0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDdkksZ0JBQWdCLG1CQUFPLENBQUMsZ0tBQThCO0FBQ3RELGdEQUErQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNwSCx5QkFBeUIsbUJBQU8sQ0FBQyxrTEFBdUM7QUFDeEUseURBQXdELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ3RJLGtCQUFrQixtQkFBTyxDQUFDLG9LQUFnQztBQUMxRCw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsZ0JBQWdCLG1CQUFPLENBQUMsZ0tBQThCO0FBQ3RELGdEQUErQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNwSCxpQkFBaUIsbUJBQU8sQ0FBQyxvS0FBZ0M7QUFDekQsaURBQWdELEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3RILGlCQUFpQixtQkFBTyxDQUFDLG9LQUFnQztBQUN6RCw4Q0FBNkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDakg7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxvSkFBd0I7QUFDbkQsOENBQTZDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3JILG9CQUFvQixtQkFBTyxDQUFDLHNKQUF5QjtBQUNyRCwrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsc0JBQXNCLG1CQUFPLENBQUMsMEpBQTJCO0FBQ3pELGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxrQkFBa0IsbUJBQU8sQ0FBQyxrSkFBdUI7QUFDakQsNkNBQTRDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ25ILHFCQUFxQixtQkFBTyxDQUFDLHdKQUEwQjtBQUN2RCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgscUJBQXFCLG1CQUFPLENBQUMsd0pBQTBCO0FBQ3ZELGdEQUErQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN6SCxvQkFBb0IsbUJBQU8sQ0FBQyw4SkFBNkI7QUFDekQsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILDBCQUEwQixtQkFBTyxDQUFDLDRMQUE0QztBQUM5RSxxREFBb0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbkksZ0NBQWdDLG1CQUFPLENBQUMsME5BQTJEO0FBQ25HLDJEQUEwRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMvSSwwQ0FBMEMsbUJBQU8sQ0FBQyw4T0FBcUU7QUFDdkgsaUVBQWdFLEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQ3JLLDhCQUE4QixtQkFBTyxDQUFDLDBLQUFtQztBQUN6RSx5REFBd0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDM0ksc0JBQXNCLG1CQUFPLENBQUMsMEpBQTJCO0FBQ3pELGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvc3lzdGVtL0RvY3VtZW50cy9Qcm9qZWN0cy9jcnlwdGV4LXZhdWx0LXdlYi9ub2RlX21vZHVsZXMvLnBucG0vQHp4aW5nK2xpYnJhcnlAMC4yMS4zL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9janMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3NlclwiKSwgZXhwb3J0cyk7XG4vLyBFeGNlcHRpb25zXG52YXIgQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvQXJndW1lbnRFeGNlcHRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcmd1bWVudEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIEFyaXRobWV0aWNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvQXJpdGhtZXRpY0V4Y2VwdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyaXRobWV0aWNFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFyaXRobWV0aWNFeGNlcHRpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hlY2tzdW1FeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFeGNlcHRpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vY29yZS9Gb3JtYXRFeGNlcHRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXRFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90Rm91bmRFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBSZWFkZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvUmVhZGVyRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVhZGVyRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFkZXJFeGNlcHRpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJlZWRTb2xvbW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL1JlZWRTb2xvbW9uRXhjZXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVlZFNvbG9tb25FeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlZWRTb2xvbW9uRXhjZXB0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vY29yZS9VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgV3JpdGVyRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL1dyaXRlckV4Y2VwdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlckV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbi8vIGNvcmVcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi9jb3JlL0JhcmNvZGVGb3JtYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXJjb2RlRm9ybWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdDsgfSB9KTtcbnZhciBCaW5hcml6ZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvQmluYXJpemVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmluYXJpemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCaW5hcml6ZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEJpbmFyeUJpdG1hcF8xID0gcmVxdWlyZShcIi4vY29yZS9CaW5hcnlCaXRtYXBcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlCaXRtYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpbmFyeUJpdG1hcF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvcmUvRGVjb2RlSGludFR5cGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNvZGVIaW50VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEludmVydGVkTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL0ludmVydGVkTHVtaW5hbmNlU291cmNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvcmUvTHVtaW5hbmNlU291cmNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTHVtaW5hbmNlU291cmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0OyB9IH0pO1xudmFyIE11bHRpRm9ybWF0UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL011bHRpRm9ybWF0UmVhZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlGb3JtYXRSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE11bHRpRm9ybWF0UmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBNdWx0aUZvcm1hdFdyaXRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9NdWx0aUZvcm1hdFdyaXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpRm9ybWF0V3JpdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNdWx0aUZvcm1hdFdyaXRlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL1BsYW5hcllVVkx1bWluYW5jZVNvdXJjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvUmVzdWx0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZXN1bHRfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vY29yZS9SZXN1bHRNZXRhZGF0YVR5cGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXN1bHRNZXRhZGF0YVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUkdCTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL1JHQkx1bWluYW5jZVNvdXJjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJHQkx1bWluYW5jZVNvdXJjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUkdCTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4vY29yZS9SZXN1bHRQb2ludFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3VsdFBvaW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZXN1bHRQb2ludF8xLmRlZmF1bHQ7IH0gfSk7XG4vLyBjb3JlL3V0aWxcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9TeXN0ZW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaWGluZ1N5c3RlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3lzdGVtXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlpYaW5nU3RyaW5nQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgU3RyaW5nRW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlpYaW5nU3RyaW5nRW5jb2RpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBDaGFyc2V0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvQ2hhcnNldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlpYaW5nQ2hhcnNldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hhcnNldF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgQXJyYXlzXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvQXJyYXlzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWlhpbmdBcnJheXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5c18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgU3RhbmRhcmRDaGFyc2V0c18xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL1N0YW5kYXJkQ2hhcnNldHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaWGluZ1N0YW5kYXJkQ2hhcnNldHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0YW5kYXJkQ2hhcnNldHNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9JbnRlZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWlhpbmdJbnRlZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbnRlZ2VyXzEuZGVmYXVsdDsgfSB9KTtcbi8vIGNvcmUvY29tbW9uXG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0JpdEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQml0QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpdEFycmF5XzEuZGVmYXVsdDsgfSB9KTtcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0JpdE1hdHJpeFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpdE1hdHJpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQml0TWF0cml4XzEuZGVmYXVsdDsgfSB9KTtcbnZhciBCaXRTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0JpdFNvdXJjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpdFNvdXJjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQml0U291cmNlXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBDaGFyYWN0ZXJTZXRFQ0lfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0NoYXJhY3RlclNldEVDSVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYXJhY3RlclNldEVDSVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBEZWNvZGVyUmVzdWx0XzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9EZWNvZGVyUmVzdWx0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjb2RlclJlc3VsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVjb2RlclJlc3VsdF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRGVmYXVsdEdyaWRTYW1wbGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9EZWZhdWx0R3JpZFNhbXBsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0R3JpZFNhbXBsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlZmF1bHRHcmlkU2FtcGxlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRGV0ZWN0b3JSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0RldGVjdG9yUmVzdWx0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGV0ZWN0b3JSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERldGVjdG9yUmVzdWx0XzEuZGVmYXVsdDsgfSB9KTtcbnZhciBFbmNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4vY29yZS9FbmNvZGVIaW50VHlwZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuY29kZUhpbnRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgR3JpZFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0dyaWRTYW1wbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR3JpZFNhbXBsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdyaWRTYW1wbGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBHcmlkU2FtcGxlckluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9HcmlkU2FtcGxlckluc3RhbmNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR3JpZFNhbXBsZXJJbnN0YW5jZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZV8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgSHlicmlkQmluYXJpemVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9IeWJyaWRCaW5hcml6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIeWJyaWRCaW5hcml6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEh5YnJpZEJpbmFyaXplcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUGVyc3BlY3RpdmVUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL1BlcnNwZWN0aXZlVHJhbnNmb3JtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVyc3BlY3RpdmVUcmFuc2Zvcm1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vU3RyaW5nVXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJpbmdVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyaW5nVXRpbHNfMS5kZWZhdWx0OyB9IH0pO1xuLy8gY29yZS9jb21tb24vZGV0ZWN0b3JcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1hdGhVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aFV0aWxzXzEuZGVmYXVsdDsgfSB9KTtcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgTW9ub2Nocm9tZVJlY3RhbmdsZURldGVjdG9yIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9kZXRlY3Rvci9Nb25vY2hyb21lUmVjdGFuZ2xlRGV0ZWN0b3InO1xudmFyIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL2RldGVjdG9yL1doaXRlUmVjdGFuZ2xlRGV0ZWN0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaGl0ZVJlY3RhbmdsZURldGVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXaGl0ZVJlY3RhbmdsZURldGVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbi8vIGNvcmUvY29tbW9uL3JlZWRzb2xvbW9uXG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHZW5lcmljR0ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdlbmVyaWNHRl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgR2VuZXJpY0dGUG9seV8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGUG9seVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdlbmVyaWNHRlBvbHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJlZWRTb2xvbW9uRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVlZFNvbG9tb25EZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWVkU29sb21vbkRlY29kZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJlZWRTb2xvbW9uRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVlZFNvbG9tb25FbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWVkU29sb21vbkVuY29kZXJfMS5kZWZhdWx0OyB9IH0pO1xuLy8gY29yZS9kYXRhbWF0cml4XG52YXIgRGF0YU1hdHJpeFJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhSZWFkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhTWF0cml4UmVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhTWF0cml4UmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2RhdGFtYXRyaXgvZGVjb2Rlci9EZWNvZGVkQml0U3RyZWFtUGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YU1hdHJpeERlY29kZWRCaXRTdHJlYW1QYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIERlZmF1bHRQbGFjZW1lbnRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL0RlZmF1bHRQbGFjZW1lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhTWF0cml4RGVmYXVsdFBsYWNlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVmYXVsdFBsYWNlbWVudF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRXJyb3JDb3JyZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL2RhdGFtYXRyaXgvZW5jb2Rlci9FcnJvckNvcnJlY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhTWF0cml4RXJyb3JDb3JyZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFcnJvckNvcnJlY3Rpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIEhpZ2hMZXZlbEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL0hpZ2hMZXZlbEVuY29kZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhTWF0cml4SGlnaExldmVsRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSGlnaExldmVsRW5jb2Rlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgU3ltYm9sSW5mb18xID0gcmVxdWlyZShcIi4vY29yZS9kYXRhbWF0cml4L2VuY29kZXIvU3ltYm9sSW5mb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFNYXRyaXhTeW1ib2xJbmZvXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTeW1ib2xJbmZvXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvZGF0YW1hdHJpeC9lbmNvZGVyL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFNYXRyaXhTeW1ib2xTaGFwZUhpbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN5bWJvbFNoYXBlSGludDsgfSB9KTtcbnZhciBEYXRhTWF0cml4V3JpdGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2RhdGFtYXRyaXgvRGF0YU1hdHJpeFdyaXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFNYXRyaXhXcml0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFNYXRyaXhXcml0ZXJfMS5kZWZhdWx0OyB9IH0pO1xuLy8gY29yZS9wZGY0MTdcbnZhciBQREY0MTdSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcGRmNDE3L1BERjQxN1JlYWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERjQxN1JlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUERGNDE3UmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBQREY0MTdSZXN1bHRNZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vY29yZS9wZGY0MTcvUERGNDE3UmVzdWx0TWV0YWRhdGFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREY0MTdSZXN1bHRNZXRhZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUERGNDE3UmVzdWx0TWV0YWRhdGFfMS5kZWZhdWx0OyB9IH0pO1xudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMiA9IHJlcXVpcmUoXCIuL2NvcmUvcGRmNDE3L2RlY29kZXIvRGVjb2RlZEJpdFN0cmVhbVBhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERjQxN0RlY29kZWRCaXRTdHJlYW1QYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMi5kZWZhdWx0OyB9IH0pO1xudmFyIEVycm9yQ29ycmVjdGlvbl8yID0gcmVxdWlyZShcIi4vY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9FcnJvckNvcnJlY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREY0MTdEZWNvZGVyRXJyb3JDb3JyZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFcnJvckNvcnJlY3Rpb25fMi5kZWZhdWx0OyB9IH0pO1xuLy8gY29yZS90d29kL3FyY29kZVxudmFyIFFSQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvUVJDb2RlUmVhZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlUmVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBRUkNvZGVSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFFSQ29kZVdyaXRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvUVJDb2RlV3JpdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlV3JpdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBRUkNvZGVXcml0ZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9kZWNvZGVyL0Vycm9yQ29ycmVjdGlvbkxldmVsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlRGVjb2RlckVycm9yQ29ycmVjdGlvbkxldmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRm9ybWF0SW5mb3JtYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvcXJjb2RlL2RlY29kZXIvRm9ybWF0SW5mb3JtYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRUkNvZGVEZWNvZGVyRm9ybWF0SW5mb3JtYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1hdEluZm9ybWF0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9kZWNvZGVyL1ZlcnNpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRUkNvZGVWZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBWZXJzaW9uXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBNb2RlXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9kZWNvZGVyL01vZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRUkNvZGVNb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2RlXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzMgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9kZWNvZGVyL0RlY29kZWRCaXRTdHJlYW1QYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRUkNvZGVEZWNvZGVkQml0U3RyZWFtUGFyc2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzMuZGVmYXVsdDsgfSB9KTtcbnZhciBEYXRhTWFza18xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvZGVjb2Rlci9EYXRhTWFza1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlFSQ29kZURhdGFNYXNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhTWFza18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvZW5jb2Rlci9FbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW5jb2Rlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUVJDb2RlXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9lbmNvZGVyL1FSQ29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlFSQ29kZUVuY29kZXJRUkNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFFSQ29kZV8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgTWF0cml4VXRpbF8xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvZW5jb2Rlci9NYXRyaXhVdGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlTWF0cml4VXRpbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0cml4VXRpbF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgQnl0ZU1hdHJpeF8xID0gcmVxdWlyZShcIi4vY29yZS9xcmNvZGUvZW5jb2Rlci9CeXRlTWF0cml4XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUVJDb2RlQnl0ZU1hdHJpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQnl0ZU1hdHJpeF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgTWFza1V0aWxfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcXJjb2RlL2VuY29kZXIvTWFza1V0aWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRUkNvZGVNYXNrVXRpbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFza1V0aWxfMS5kZWZhdWx0OyB9IH0pO1xuLy8gY29yZS90d29kL2F6dGVjXG52YXIgQXp0ZWNSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYXp0ZWMvQXp0ZWNSZWFkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBenRlY0NvZGVSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEF6dGVjUmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBBenRlY1dyaXRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9henRlYy9BenRlY1dyaXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF6dGVjQ29kZVdyaXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXp0ZWNXcml0ZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEF6dGVjRGV0ZWN0b3JSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYXp0ZWMvQXp0ZWNEZXRlY3RvclJlc3VsdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF6dGVjRGV0ZWN0b3JSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEF6dGVjRGV0ZWN0b3JSZXN1bHRfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEVuY29kZXJfMiA9IHJlcXVpcmUoXCIuL2NvcmUvYXp0ZWMvZW5jb2Rlci9FbmNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXp0ZWNFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFbmNvZGVyXzIuZGVmYXVsdDsgfSB9KTtcbnZhciBIaWdoTGV2ZWxFbmNvZGVyXzIgPSByZXF1aXJlKFwiLi9jb3JlL2F6dGVjL2VuY29kZXIvSGlnaExldmVsRW5jb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF6dGVjSGlnaExldmVsRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSGlnaExldmVsRW5jb2Rlcl8yLmRlZmF1bHQ7IH0gfSk7XG52YXIgQXp0ZWNDb2RlXzEgPSByZXF1aXJlKFwiLi9jb3JlL2F6dGVjL2VuY29kZXIvQXp0ZWNDb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXp0ZWNDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBenRlY0NvZGVfMS5kZWZhdWx0OyB9IH0pO1xudmFyIERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYXp0ZWMvZGVjb2Rlci9EZWNvZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXp0ZWNEZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZWNvZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4vY29yZS9henRlYy9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF6dGVjRGV0ZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERldGVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBEZXRlY3Rvcl8yID0gcmVxdWlyZShcIi4vY29yZS9henRlYy9kZXRlY3Rvci9EZXRlY3RvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF6dGVjUG9pbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERldGVjdG9yXzIuUG9pbnQ7IH0gfSk7XG4vLyBjb3JlL29uZWRcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvT25lRFJlYWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9uZURSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9uZURSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIEVBTjEzUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvRUFOMTNSZWFkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFQU4xM1JlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRUFOMTNSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIENvZGUxMjhSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9Db2RlMTI4UmVhZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZTEyOFJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29kZTEyOFJlYWRlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgSVRGUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvSVRGUmVhZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSVRGUmVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJVEZSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIENvZGUzOVJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9vbmVkL0NvZGUzOVJlYWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGUzOVJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29kZTM5UmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBDb2RlOTNSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9Db2RlOTNSZWFkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlOTNSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvZGU5M1JlYWRlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUlNTMTRSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9yc3MvUlNTMTRSZWFkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSU1MxNFJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUlNTMTRSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIFJTU0V4cGFuZGVkUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL1JTU0V4cGFuZGVkUmVhZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUlNTRXhwYW5kZWRSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJTU0V4cGFuZGVkUmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BYnN0cmFjdEV4cGFuZGVkRGVjb2RlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0RXhwYW5kZWREZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBYnN0cmFjdEV4cGFuZGVkRGVjb2Rlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgQWJzdHJhY3RFeHBhbmRlZERlY29kZXJDb21wbGVtZW50XzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUFic3RyYWN0RXhwYW5kZWREZWNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlckNvbXBsZW1lbnRfMS5jcmVhdGVEZWNvZGVyOyB9IH0pO1xudmFyIE11bHRpRm9ybWF0T25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9vbmVkL011bHRpRm9ybWF0T25lRFJlYWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpRm9ybWF0T25lRFJlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBDb2RhQmFyUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvQ29kYUJhclJlYWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGFCYXJSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvZGFCYXJSZWFkZXJfMS5kZWZhdWx0OyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../node_modules/.pnpm/@zxing+library@0.21.3/node_modules/@zxing/library/cjs/index.js\n");

/***/ })

};
;